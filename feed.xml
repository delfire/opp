<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Menos é Mais</title>
        <description>&lt;p&gt;Já pensou qual seria a quantidade ideal para argumentos em um 
método? E a quantidade de métodos em uma Interface ou Classe?
E quantas Classes você codificaria dentro de uma única unidade?&lt;/p&gt;

&lt;p&gt;Vamos tentar obter alguns números.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-14541995559820-04de78c094e9.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O tamanho de uma Classe, ou seja, a quantidade de métodos que
ela implementa diz muito sobre ela. Uma Classe com muitos métodos
está fazendo coisas demais, possui
&lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/&quot;&gt;responsabilidades&lt;/a&gt;
demais.&lt;/p&gt;

&lt;p&gt;Podemos utilizar o mesmo princípio para argumentos de métodos. 
Mais argumentos, mais informação, mais comunicações com outros
Objetos. Então, teoricamente, o método está fazendo coisas demais.&lt;/p&gt;

&lt;p&gt;Nesse artigo vou lhe mostrar alguns números ideais.&lt;/p&gt;

&lt;p&gt;Não presumo que você irá concordar com tudo o que ler abaixo mas, 
concordando ou não, esses são &lt;em&gt;meus&lt;/em&gt; números.&lt;/p&gt;

&lt;h2 id=&quot;metodos&quot;&gt;Métodos&lt;/h2&gt;

&lt;p&gt;Interfaces devem ser pequenas, com poucos métodos.
Não é por que a Interface representa
um &lt;code&gt;Carro&lt;/code&gt; que ela deverá conter todos os métodos inimagináveis
para implementar o comportamento de um Carro.&lt;/p&gt;

&lt;p&gt;Cada Interface deve ter o número de métodos que represente uma
&lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;entidade&lt;/a&gt;
num contexto bem &lt;em&gt;delimitado&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O número de métodos ideal está entre &lt;strong&gt;1 e 5&lt;/strong&gt; para Interfaces e,
consequentemente, é o mesmo para Classes.&lt;/p&gt;

&lt;p&gt;No entanto eu não considero a sobrecarga de métodos nessa contagem, ou seja, se
a Classe possui 3 métodos &lt;code&gt;Save&lt;/code&gt; sobrecarregados, eu considero apenas
como 1 método. Mas, mesmo que possa haver muitos métodos sobrecarregados,
não quer dizer que a inteligência está dentro desses métodos. Não.
Quase tudo pode ser &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/&quot;&gt;delegado&lt;/a&gt;
à outros Objetos mais especialistas.&lt;/p&gt;

&lt;h2 id=&quot;construtores&quot;&gt;Construtores&lt;/h2&gt;

&lt;p&gt;Os construtores &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;primários e secundários&lt;/a&gt;
sempre serão sobrecargas. Então você poderá ter quantos quiser.&lt;/p&gt;

&lt;p&gt;Mas eu prefiro ter apenas 1 construtor e muitos
&lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Métodos &lt;em&gt;New&lt;/em&gt;&lt;/a&gt;. Assim eu me
beneficio de duas maneiras: a) A Classe só terá um meio para construir
Objetos e b) Os métodos &lt;em&gt;New&lt;/em&gt; obrigam outros desenvolvedores a utilizarem 
instâncias de Interfaces e não instâncias de Classe.&lt;/p&gt;

&lt;h2 id=&quot;argumentos&quot;&gt;Argumentos&lt;/h2&gt;

&lt;p&gt;Utilize a menor quantidade possível de argumentos nos métodos.
Um método com muitos argumentos é difícil de escrever, entender e ler.
Lembre-se que a maior parte do trabalho de um programador é &lt;em&gt;ler&lt;/em&gt; o código e não
escrevê-lo.&lt;/p&gt;

&lt;p&gt;O mesmo para argumentos dos &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt;
da Classe.&lt;/p&gt;

&lt;p&gt;O número ideal para os argumentos está entre &lt;strong&gt;0 e 5&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;variaveis-locais&quot;&gt;Variáveis locais&lt;/h2&gt;

&lt;p&gt;Antes de utilizar a técnica do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método &lt;em&gt;New&lt;/em&gt;&lt;/a&gt;,
eu precisava utilizar um número maior de variáveis, somente para
ter a &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Seattle/en/Using_Reference_Counting&quot;&gt;contagem de referência&lt;/a&gt;
funcionando sem vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Não mais.&lt;/p&gt;

&lt;p&gt;Agora eu utilizo cada vez menos variáveis locais e esse é um indício
de um código mais Orientado a Objetos. Variáveis locais são utilizados
em código &lt;em&gt;procedural&lt;/em&gt;. Você precisa de uma variável para &lt;em&gt;guardar&lt;/em&gt; algum
valor, enquanto executa outro processamento, e então utiliza a variável
que guardou em outro processamento… procedural.&lt;/p&gt;

&lt;p&gt;O número ideal para variáveis locais está entre &lt;strong&gt;0 e 3&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;atributos&quot;&gt;Atributos&lt;/h2&gt;

&lt;p&gt;Os atributos de um Objeto devem estar em conformidade com o que
ele representa. Se você tem um método que retorna o Objeto no formato
de XML, por exemplo, mas não utiliza esse formato em nenhum outro 
método, então você não deveria ter um atributo que representa um XML.
Em vez disso, crie o Objeto só quando ele for necessário, ou seja, 
quanto o método que retorna um XML for requisitado.&lt;/p&gt;

&lt;p&gt;O número ideal para atributos está entre &lt;strong&gt;1 e 7&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Aqui, no entanto, você pode quebrar essa regra &lt;em&gt;temporariamente&lt;/em&gt; se
necessário, devido a prazos, complexidade, etc. Você pode aumentar
o número de atributos e refatorar depois sem problemas, pois eles estarão 
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulados&lt;/a&gt;
dentro da Classe.&lt;/p&gt;

&lt;p&gt;Ninguém sabe o que acontece dentro de um Objeto, não é?&lt;/p&gt;

&lt;p&gt;O que não pode ocorrer é ter um Objeto que não encapsula &lt;em&gt;nenhum&lt;/em&gt; atributo.
Um Objeto &lt;em&gt;sempre&lt;/em&gt; deve encapsular alguma coisa, porque ele representa
algo. Ele deve ter algum &lt;a href=&quot;/posts/objetos-sem-estado/&quot;&gt;estado&lt;/a&gt;
que é implementado por seus atributos.&lt;/p&gt;

&lt;h2 id=&quot;classes&quot;&gt;Classes na Unidade&lt;/h2&gt;

&lt;p&gt;A linguagem Object Pascal foi uma das primeiras a implementar o conceito
de &lt;em&gt;packages&lt;/em&gt; ou &lt;em&gt;namespaces&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Sim, estou falando das &lt;em&gt;units&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Cada &lt;a href=&quot;/posts/unidades-limitrofes/&quot;&gt;Unidade&lt;/a&gt; pode conter Classes 
públicas ou privadas.&lt;/p&gt;

&lt;p&gt;O número ideal para Classes dentro da mesma Unidade está entre &lt;strong&gt;1 e 11&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Dificilmente eu utilizo Classes privadas, pois sempre acho que elas podem 
ser utilizadas em outros módulos. No entanto, se necessário, Classe privadas — 
não importa se é privado no nível de Classe ou de Unidade — podem ser implementadas 
seguindo as mesmas regras dos atributos. 
Como são privadas, podem ser alteradas sem problemas futuramente.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Definir números máximos de usabilidade, é o mesmo que &lt;em&gt;restringir&lt;/em&gt;.
E restrição pode ser uma coisa boa. Restrição nos faz pensar em como tornar as
coisas mais &lt;em&gt;eficazes&lt;/em&gt; e com menos &lt;em&gt;desperdícios&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Pense bem. Para fazer uma viagem para fora do seu país, por exemplo, você precisa 
planejar com cuidado o que levar na mochila.
Você deve escolher o que é mais &lt;em&gt;importante&lt;/em&gt; e &lt;em&gt;essencial&lt;/em&gt;, e nada a mais.
O motivo é viajar &lt;em&gt;leve&lt;/em&gt; e curtir ao máximo, sem se preocupar com inúmeros objetos
ou malas cheias de coisas que você estaria arrastando com você.&lt;/p&gt;

&lt;p&gt;É muito mais difícil &lt;em&gt;pensar&lt;/em&gt; no que é essencial ao invés de “por tudo na mala”,
mas é um exercício que vale a pena fazer. Você fica abismado ao saber que necessita
de tão pouco.&lt;/p&gt;

&lt;p&gt;O mesmo vale para o seu código. Mantenha tudo &lt;em&gt;leve&lt;/em&gt; e &lt;em&gt;simples&lt;/em&gt;.
Apenas com o essencial. Porque &lt;strong&gt;menos, é mais&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Nov 2016 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/posts/menos-e-mais/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/menos-e-mais/</guid>
      </item>
    
      <item>
        <title>Classes Adaptadoras</title>
        <description>&lt;p&gt;Os dados sempre deverão estar encapsulados em Objetos que conversam
entre si enviando mensagens uns aos outros. No entanto essas mensagens
podem conter dados no formato que só o Objeto emissor conhece.&lt;/p&gt;

&lt;p&gt;Como o Objeto receptor irá saber ler esses dados que, outrora, estavam
encapsulados no Objeto emissor?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1428954376791-d9ae785dfb2d.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Cada Objeto detém o conhecimento sobre seus próprios dados encapsulados.
Ninguém mais.&lt;/p&gt;

&lt;p&gt;Para um sistema funcionar esses Objetos devem conversar entre si, enviando
&lt;a href=&quot;/posts/diga-me-algo-sobre-voce/#mensagens&quot;&gt;mensagens&lt;/a&gt;
uns aos outros.&lt;/p&gt;

&lt;p&gt;Sabemos o que fazer quando queremos saber informações sobre um determinado
Objeto. Basta utilizar seu
&lt;a href=&quot;/posts/diga-me-algo-sobre-voce/#metodo-about&quot;&gt;Método &lt;em&gt;About&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Você, programador, sabe o que fazer com esses dados pois
você detém o conhecimento sobre todas as Classes e Objetos. No entanto são
os Objetos que devem &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;conversar&lt;/a&gt;
entre eles mesmos. Você está &lt;em&gt;fora&lt;/em&gt; dessa conversa. Você não pode ajudá-los.
Esse é o problema.&lt;/p&gt;

&lt;p&gt;Então deve haver uma maneira do Objeto emissor conversar com o Objeto receptor,
utilizando um mesmo dialeto, sem que &lt;em&gt;você&lt;/em&gt; faça conversões explícitas para que
essa conversa aconteça.&lt;/p&gt;

&lt;h2 id=&quot;dados-entre-formularios&quot;&gt;Dados entre Formulários&lt;/h2&gt;

&lt;p&gt;Sempre que utilizamos formulários — ou qualquer tipo de &lt;em&gt;view&lt;/em&gt; — é porque
queremos exibir alguma informação para que o usuário tome alguma decisão ou 
execute alguma tarefa.&lt;/p&gt;

&lt;p&gt;Esses formulários podem obter seus dados quando são criados ou posteriormente,
devido a alguma ação do usuário.&lt;/p&gt;

&lt;p&gt;Vamos nos concentrar nesses dados inicias.&lt;/p&gt;

&lt;p&gt;Imagine um sistema Financeiro. Há dois formulários:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Faturas a Pagar&lt;/li&gt;
  &lt;li&gt;Opções de Pagamento&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;No formulário de Faturas a Pagar o usuário irá selecionar as faturas, clicar
em algum botão para pagar e, nesse momento, um outro formulário com as Opções
de Pagamento será exibido.&lt;/p&gt;

&lt;p&gt;O que o formulário de Faturas a Pagar deveria enviar para o formulário de 
Opções de Pagamento no seu
&lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtor&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Bem, isso depende.&lt;/p&gt;

&lt;p&gt;Antes precisamos definir, nesse pequeno exemplo, o que é uma Fatura a Pagar,
assim como o que são Opções de Pagamento.&lt;/p&gt;

&lt;p&gt;Vamos nos concentrar nos dados:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Uma Fatura encapsula um número sequencial, um valor a pagar original, um valor
  a pagar atual (com multa e juros), uma data, uma descrição, itens…
  vamos parar aqui.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Uma Opção de Pagamento encapsula opções (dinheiro, cartão de crédito, etc),
  valor para cada opção, valor total a pagar e… tudo bem, já está bom.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;opcoes-de-implementacao&quot;&gt;Oções de Implementação&lt;/h2&gt;

&lt;p&gt;Agora que temos algumas definições, podemos pensar no modelo que iremos
seguir para determinar como será feita a implementação.&lt;/p&gt;

&lt;p&gt;Vamos ver as opções.&lt;/p&gt;

&lt;h3 id=&quot;banco-de-dados-e-registros&quot;&gt;1- Banco de dados e registros&lt;/h3&gt;

&lt;p&gt;Não pense em &lt;a href=&quot;/posts/pensando-em-dados/&quot;&gt;dados&lt;/a&gt; provenientes de
um banco de dados, &lt;em&gt;queries&lt;/em&gt; ou &lt;em&gt;DataSet&lt;/em&gt;. Os dados já estão no formulário, numa 
&lt;em&gt;grid&lt;/em&gt; listando todas as faturas.&lt;/p&gt;

&lt;p&gt;Você já tem tudo que precisa nos &lt;em&gt;widgets&lt;/em&gt; do formulário. Não há necessidade
de fazer uma nova requisição de dados.&lt;/p&gt;

&lt;p&gt;E agora, ficou mais fácil?&lt;/p&gt;

&lt;p&gt;Ainda não.&lt;/p&gt;

&lt;p&gt;Se toda Entidade deve ser
&lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;representada&lt;/a&gt;
por um Objeto, você já sabe que não são apenas 2 Objetos (formulários) que irão
fazer parte dessa conversa. Haverá outros Objetos.&lt;/p&gt;

&lt;p&gt;Mas lembre-se que ainda estamos falando de dados.&lt;/p&gt;

&lt;h3 id=&quot;objetos-anemicos-e-listas&quot;&gt;2- Objetos anêmicos e listas&lt;/h3&gt;

&lt;p&gt;Não pense em criar Classes Anêmicas
como &lt;code&gt;TInvoice&lt;/code&gt; com todos os campos acima, utilizando 
&lt;a href=&quot;/posts/getters-e-setters/&quot;&gt;Getters e Setters&lt;/a&gt;
e uma lista &lt;code&gt;TInvoices&lt;/code&gt; para passar ao formulário de Opções de Pagamento.&lt;/p&gt;

&lt;p&gt;Pensou nisso mesmo?&lt;/p&gt;

&lt;p&gt;Essa é uma opção de implementação que irá acoplar ambos os formulários
a essa lista de Faturas. E isso irá restringir o formulário de Opções de 
Pagamento.&lt;/p&gt;

&lt;p&gt;Então vamos adicionar um complicador:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;O formulário de Opções de Pagamento será utilizado
  para pagar &lt;em&gt;qualquer coisa&lt;/em&gt; dentro do sistema, ou seja, não &lt;em&gt;apenas&lt;/em&gt; Faturas.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nesse caso uma refatoração seria necessária.&lt;/p&gt;

&lt;p&gt;Ainda acha que criar uma lista de Faturas seria a melhor opção?&lt;/p&gt;

&lt;h3 id=&quot;heranca-e-esperanca&quot;&gt;3- Herança e esperança&lt;/h3&gt;

&lt;p&gt;Ora, vamos criar uma lista genérica ou Interface, utilizar herança para &lt;code&gt;TInvoices&lt;/code&gt;
e refatorar o formulário para receber essa lista.&lt;/p&gt;

&lt;p&gt;É claro que não.&lt;/p&gt;

&lt;p&gt;Já sabemos que
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;
não foi feita para compartilhar código e que ela pode piorar (e muito) a arquitetura do projeto.&lt;/p&gt;

&lt;p&gt;Essa seria uma das piores opções. Esqueça-a.&lt;/p&gt;

&lt;h3 id=&quot;manual&quot;&gt;4- Manualmente&lt;/h3&gt;

&lt;p&gt;Então você, o programador, manipula os dados do formulário de Faturas, criando 
um XML que você sabe que o formulário de Opções de Pagamento espera receber — 
porque você pode ver o código-fonte de todas as Classes — e então repassa esse XML
para o formulário de Opções de Pagamento.&lt;/p&gt;

&lt;p&gt;É, talvez irá funcionar… mas por quanto tempo?&lt;/p&gt;

&lt;p&gt;Sabendo que o formulário de Opções de Pagamento pode ser utilizado por outros módulos,
se houver alguma alteração nos dados que ele espera receber, será muito difícil
procurar em todos esses lugares para fazer alterações. Cada equipe que trabalha em 
módulos distintos — mas que utiliza esse mesmo formulário — pode ter criado suas próprias
versões do XML para enviar ao formulário. O código foi duplicado. Terrível.&lt;/p&gt;

&lt;h3 id=&quot;classes-adaptadoras&quot;&gt;5- Classes Adaptadoras&lt;/h3&gt;

&lt;p&gt;Minha sugestão é utilizarmos Classes Adaptadoras.&lt;/p&gt;

&lt;p&gt;Elas poderão ser muitas. Vai depender de quantos módulos/classes irão utilizar 
o formulário de Opções de Pagamentos.&lt;/p&gt;

&lt;p&gt;Classes Adaptadoras são &lt;strong&gt;conectores&lt;/strong&gt;. Elas adaptam as interfaces, adaptam os
&lt;a href=&quot;/posts/interfaces-em-todo-lugar/#interfaces-sao-contratos&quot;&gt;contratos&lt;/a&gt;
que cada Objeto tem para com o sistema.&lt;/p&gt;

&lt;p&gt;Elas tornam possível uma &lt;em&gt;Classe-A&lt;/em&gt; trabalhar em conjunto com a uma &lt;em&gt;Classe-B&lt;/em&gt;,
mesmo que ambas não se conheçam.&lt;/p&gt;

&lt;p&gt;Os programadores só precisam saber que essas Classes Adaptadoras existem e onde estão 
guardadas, quando eles precisarem delas.&lt;/p&gt;

&lt;h2 id=&quot;adaptando&quot;&gt;Adaptando&lt;/h2&gt;

&lt;p&gt;No formulário de Faturas a Pagar teremos, no mínimo, mais duas Classes que irão fazer
parte da conversa. São elas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A Classe &lt;code&gt;TGridSelectedRows&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A Classe &lt;code&gt;TInvoiceMedia&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A Classe &lt;code&gt;TGridSelectedRows&lt;/code&gt; é responsável por &lt;em&gt;adaptar&lt;/em&gt; as linhas selecionadas da &lt;em&gt;grid&lt;/em&gt; para o
formato XML — ou qualquer outro formato que lhe agrade — e seu resultado é utilizado ou
validado pela &lt;code&gt;TInvoiceMedia&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TInvoiceMedia.New(
  TGridSelectedRows.New(
    InvoiceGrid, &#39;invoices&#39;, &#39;invoice&#39;
  )
  .Stream
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A chamada a &lt;code&gt;TGridSelectedRows::Stream&lt;/code&gt; irá retorna uma instância de
&lt;code&gt;IDataStream&lt;/code&gt; (veja &lt;a href=&quot;http://objectpascalprogramming.com/posts/microservices-delphi-parte-1/#comment-2982613320&quot;&gt;aqui&lt;/a&gt;
a implementação). Os outros argumentos são utilizados para criar o XML dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;invoices&amp;gt;
  &amp;lt;invoice&amp;gt;
    &amp;lt;number...
    &amp;lt;value...
  &amp;lt;/invoice&amp;gt;
  &amp;lt;invoice&amp;gt;
    &amp;lt;number...
    &amp;lt;value...
  &amp;lt;/invoice&amp;gt;
&amp;lt;/invoices&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A implementação de &lt;code&gt;TGridSelectedRows&lt;/code&gt; não é relevante para o entendimento do problema.&lt;/p&gt;

&lt;p&gt;Nesse exemplo &lt;code&gt;TInvoiceMedia&lt;/code&gt; implementa &lt;code&gt;IDataStream&lt;/code&gt;. Mas essa classe também terá a
inteligência para validar o XML (stream) que foi lhe passado no construtor.&lt;/p&gt;

&lt;p&gt;Então temos o XML válido com todas as faturas encapsulado em &lt;code&gt;TInvoiceMedia&lt;/code&gt;. Precisamos
agora de uma Classe Adaptadora para transformar Faturas no formato que Opções de Pagamento
entenda.&lt;/p&gt;

&lt;p&gt;E aqui vai uma &lt;strong&gt;dica&lt;/strong&gt; importante: A Classes que adaptam um conceito devem estar “próximas”
umas das outras para que seja fácil para o programador achá-las e utilizá-las.&lt;/p&gt;

&lt;p&gt;Vamos dar nomes as outras Classes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Formulário Opções de Pagamento: &lt;code&gt;TPaymentOptionsForm&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Tipo do argumento no construtor do Formulário: &lt;code&gt;IPaymentOptionsMedia&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Classe Adaptadora de Faturas para Opções: &lt;code&gt;TPaymentOptionsForInvoices&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;O código do evento no botão para exibir as Opções de Pagamento, ou seja, a 
chamada do formulário, seria parecido com o código abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with
  TPaymentOptionsForm.Create(
    TPaymentOptionsForInvoices.New(
      TInvoiceMedia.New(
        TGridSelectedRows.New(
          InvoiceGrid, &#39;invoices&#39;, &#39;invoice&#39;
        )
        .Stream
      )
    )
  )
do
  try
    ShowModal;
  finally
    Free;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Classe &lt;code&gt;TPaymentOptionsForInvoices&lt;/code&gt; irá receber o XML de Faturas a Pagar
e irá &lt;em&gt;adaptar&lt;/em&gt; num XML de Opções de Pagamento (somar todos os valores das
faturas, verificar alguma insconcistência, etc).&lt;/p&gt;

&lt;p&gt;O formulário de Opções de Pagamento só &lt;em&gt;conhece&lt;/em&gt; implementações de &lt;em&gt;IPaymentOptionsMedia&lt;/em&gt;,
que é a Interface implementada por &lt;code&gt;TPaymentOptionsForInvoices&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para todos os outros casos de pagamentos, basta criar outra Classe Adaptadora especialista
com o mesmo prefixo &lt;code&gt;TPaymentOptionsFor...&lt;/code&gt; para facilitar o &lt;em&gt;code-completion&lt;/em&gt; quando
o programador estiver procurando um &lt;em&gt;conector&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Quando houver alguma alteração no XML que o formulário Opções de Pagamento
recebe, basta alterar as Classes Adaptadoras. Você saberá exatamente onde procurar. E,
tão importante quanto, é ter em mente que essas Classes poderão compartilhar código entre
elas bastando criar mais Classes especialistas — talvez privada na unidade.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Classes Adaptadoras e Interfaces é como plugamos as &lt;em&gt;peças&lt;/em&gt; dentro de um software Orientado
a Objetos.&lt;/p&gt;

&lt;p&gt;Em alguns casos pode ser bem difícil identificar essas Classes ou a melhor forma de
implementá-las. Mas, não desista, pois vale muito a pena. Seu código irá ficar mais 
desacoplado, sem duplicação e muito mais reutilizável.&lt;/p&gt;

&lt;p&gt;Dessa forma um Objeto receptor saberá ler os dados de Objetos emissores mesmo sem
conhecê-los intimamente.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Nov 2016 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/posts/classes-adaptadoras/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/classes-adaptadoras/</guid>
      </item>
    
      <item>
        <title>Diga-me algo Sobre você</title>
        <description>&lt;p&gt;Quando aprendemos sobre Orientação a Objetos, anos atrás,
ouvimos dizer que Objetos enviam &lt;em&gt;mensagens&lt;/em&gt; uns aos outros.
No entanto o que realmente vemos na maioria dos códigos de 
hoje não são verdadeiros Objetos, são apenas estrutura 
de dados com funções…&lt;/p&gt;

&lt;p&gt;Esquecemos o que significa enviar uma mensagem a um Objeto?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1453738773917-9c3eff1db985.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Fazendo a análise de um novo sistema, o arquiteto vê a 
necessidade de implementar uma Classe para representar um 
&lt;em&gt;Cliente&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O analista de negócio diz que um Cliente precisa ter 
&lt;em&gt;Login&lt;/em&gt;, Senha e seu Nome.&lt;/p&gt;

&lt;p&gt;Você começa a implementação da Classe.&lt;/p&gt;

&lt;p&gt;Após 2 horas o analista retorna e diz
que também precisa ter mais “alguns campos”. Então ele 
também acrescenta Endereço de correspondência; a Data de
Nascimento para dar descontos; separa o nome em 2 campos
(Nome e Sobrenome); e o Cartão de Crédito que
será a forma de pagamento ao comprar os produtos da empresa.&lt;/p&gt;

&lt;p&gt;Como implementamos a nova Classe &lt;code&gt;TCustomer&lt;/code&gt; que irá representar
um Cliente?&lt;/p&gt;

&lt;p&gt;Aqui está uma sugestão de implementação bastante utilizada
pelos desenvolvedores:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TCustomer = class
  private
    FLogin: string;
    FPassword: string;
    FFirstName: string;
    FLastName: string;
    FAddress: string;
    FBirthday: TDateTime;
    FCreditCard: string;
  public
    constructor Create;
    property Login: string read FLogin write FLogin;
    property Password: string read FPassword write FPassword;
    property FirstName: string read FFirstName write FFirstName;
    property LastName: string read FLastName write FLastName;
    property Address: string read FAddress write FAddress;
    property Birthday: TDateTime read FBirthday write FBirthday;
    property CreditCard: string read FCreditCard write FCreditCard;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Utilizei &lt;em&gt;properties&lt;/em&gt;. No &lt;em&gt;Object Pascal&lt;/em&gt;, assim como no C# fica até 
bonito e escrevemos menos. No Java seria o dobro de linhas, pois
teríamos 7 &lt;em&gt;Getters&lt;/em&gt; e 7 &lt;em&gt;Setters&lt;/em&gt; para cada atributo.&lt;/p&gt;

&lt;p&gt;Bem, tudo certo nessa implementação?&lt;/p&gt;

&lt;p&gt;Não.&lt;/p&gt;

&lt;p&gt;Infelizmente essa Classe não tem nada a ver com o real uso da 
&lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.
Essa Classe não está representando um Cliente, mas sim uma
tabela do Banco de Dados.&lt;/p&gt;

&lt;p&gt;Além disso, o uso de &lt;em&gt;properties&lt;/em&gt; não elimina o fato que, na verdade, 
essa Classe só possui
&lt;a href=&quot;/posts/getters-e-setters/&quot;&gt;&lt;em&gt;Getters&lt;/em&gt; e &lt;em&gt;Setters&lt;/em&gt;&lt;/a&gt;,
que é um anti-padrão.&lt;/p&gt;

&lt;h2 id=&quot;mensagens&quot;&gt;Mensagens&lt;/h2&gt;

&lt;p&gt;Uma Classe deve representar uma
&lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidade&lt;/a&gt;,
&lt;em&gt;nunca&lt;/em&gt; um registro de tabela no Banco de Dados.&lt;/p&gt;

&lt;p&gt;Se você tem uma Classe com &lt;em&gt;Getters&lt;/em&gt; e &lt;em&gt;Setters&lt;/em&gt;, seu pensamento não
está na Orientação a Objetos. Você está pensando em
&lt;a href=&quot;/posts/pensando-em-dados/&quot;&gt;Dados&lt;/a&gt;, em tabelas, em
persistência.&lt;/p&gt;

&lt;p&gt;Você não deveria &lt;em&gt;pegar&lt;/em&gt; e muito menos &lt;em&gt;alterar&lt;/em&gt; um dado de um Objeto
diretamente!&lt;/p&gt;

&lt;p&gt;Pense no mundo real. Quando você pergunta o nome de alguém,
ele/ela pode lhe responder de diversas maneiras:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Diz apenas o primeiro nome;&lt;/li&gt;
  &lt;li&gt;Diz apenas o sobrenome;&lt;/li&gt;
  &lt;li&gt;Diz o nome completo;&lt;/li&gt;
  &lt;li&gt;Diz o apelido;&lt;/li&gt;
  &lt;li&gt;Inventa um nome;&lt;/li&gt;
  &lt;li&gt;Não diz nada;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Veja que uma pergunta &lt;em&gt;simples&lt;/em&gt; pode ter inúmeras respostas.
Tudo irá depender do &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contexto&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Todo Objeto deve ser &lt;em&gt;respeitado&lt;/em&gt;. Então, o máximo que fazemos é enviar
uma &lt;strong&gt;mensagem&lt;/strong&gt; ao Objeto e aguardar uma resposta.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo.&lt;/p&gt;

&lt;p&gt;Compare os dois diálogos abaixo:&lt;/p&gt;

&lt;h3 id=&quot;dilogo-1&quot;&gt;Diálogo 1:&lt;/h3&gt;

&lt;p&gt;Carlos quer alugar um carro. Ele entra numa loja e vai falar com o vendedor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;— Bom dia. Gostaria de alugar um carro. — disse Carlos.
— Bom dia! Qual modelo o senhor está procurando?
— Procuro um de menor custo, bem simples.
— Ok. Temos esses 3 modelos...
— Legal. Quanto custa o hatch?
— Bem, o senhor está com sorte!
— Estou? — disse Carlos
— Sim, hoje é dia de promoção para esse modelo.
O vendedor vai buscar um catálogo e diz o preço.
— E vou lhe dar 20% de desconto!
Carlos fica feliz com a escolha do modelo e 
preço e resolve alugar.
— Ok! Vou levar esse!
— Certo. Preciso que o senhor preencha esse formulário.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;dilogo-2&quot;&gt;Diálogo 2:&lt;/h3&gt;

&lt;p&gt;Um &lt;em&gt;Registro&lt;/em&gt; quer um carro.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;O Controlador pega uma lista de carros;
O Controlador ordena a lista de forma crescente;
O Controlador pega o Carro com o menor valor;
O Controlador verifica a data atual e concede um desconto;
O Controlador altera o Registro, apontando o carro;
O Controlador pega os dados do Registro e salva 
em outra tabela;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No primeiro diálogo temos duas pessoas (Objetos no software)
conversando.&lt;/p&gt;

&lt;p&gt;No segundo… bem, na verdade não houve um segundo diálogo.
Havia apenas um Controlador (você) dando &lt;strong&gt;ordens&lt;/strong&gt; e alterando 
dados. Pegando o que quer, onde quer e alterando dados sempre
que queria.&lt;/p&gt;

&lt;p&gt;Para codificar o primeiro diálogo, precisaremos utilizar mensagens
entre os Objetos.&lt;/p&gt;

&lt;p&gt;Mensagens também são Métodos. Tecnicamente essa é a maneira que temos
para adicionar comportamento a uma Classe.&lt;/p&gt;

&lt;p&gt;Mas diferentemente de um Método &lt;code&gt;Get&lt;/code&gt;, onde o dado é &lt;em&gt;tomado a força&lt;/em&gt;
do Objeto, uma mensagem dá o controle ao Objeto para que ele retorne
as informações que ele desejar.&lt;/p&gt;

&lt;p&gt;Repare a diferença entre as 2 últimas linhas dos diálogos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;“Preciso que o senhor preencha esse formulário”&lt;/li&gt;
  &lt;li&gt;“O Controlador pega os dados do Registro e salva 
  em outra tabela”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Na mensagem #1 o vendedor solicita o preenchimento de um formulário
com os dados pessoais de Carlos.&lt;/p&gt;

&lt;p&gt;No procedimento #2 o Controlador apenas pega os dados do Registro.&lt;/p&gt;

&lt;p&gt;O correto é utilizarmos mensagens e dar o controle da resposta ao
Objeto.&lt;/p&gt;

&lt;h2 id=&quot;metodo-about&quot;&gt;O Método About&lt;/h2&gt;

&lt;p&gt;Todos os Objetos deveriam responder a uma mensagem padrão quando
outros Objetos quiserem saber sobre seus dados encapsulados.&lt;/p&gt;

&lt;p&gt;Eu nomeei esse Método de &lt;code&gt;About&lt;/code&gt;, ou seja, perguntamos ao Objeto
se ele tem &lt;strong&gt;algo a dizer sobre si mesmo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;O Método &lt;code&gt;About&lt;/code&gt; é utilizado em todos os Objetos que precisam
informar ao mundo as informações que eles encapsulam.&lt;/p&gt;

&lt;p&gt;Essa é uma alternativa viável para darmos o controle
de volta ao Objeto ao invés de tomar o dado dele.&lt;/p&gt;

&lt;p&gt;O Objeto tem o total controle sobre quais dados retornar. Dessa
forma não há uma quebra de
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;Encapsulamento&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Objetos devem ser capaz de apresentar a si mesmo.
De dar informações “pessoais” que só eles tem conhecimento.&lt;/p&gt;

&lt;p&gt;Essa ideia não é nova. No livro
&lt;a href=&quot;https://www.amazon.com/dp/0735619654/?tag=stackoverfl08-20&quot;&gt;Object Thinking&lt;/a&gt; o autor aborda esse assunto.&lt;/p&gt;

&lt;p&gt;Existem outros artigos na Internet que falam sobre esse tema.
Dentre esses artigos tem &lt;a href=&quot;http://www.yegor256.com/2016/04/05/printers-instead-of-getters.html&quot;&gt;esse&lt;/a&gt;
em particular que capta bem essa ideia. No entanto a abordagem do autor
para implementar esse conceito é diferente da minha abordagem.&lt;/p&gt;

&lt;p&gt;Então, o que retorna o Método &lt;code&gt;About&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Retorna um &lt;em&gt;Stream&lt;/em&gt; (&lt;code&gt;IDataStream&lt;/code&gt;). E, basicamente é isso.&lt;/p&gt;

&lt;p&gt;Para implementar o &lt;code&gt;About&lt;/code&gt; precisamos definir a Interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IDataStream = interface
    function Save(Stream: TStream): IDataStream;
    function Save(Strings: TStrings): IDataStream;
    function Save(const FileName: string): IDataStream;
    function AsString: string;
    function Size: Int64;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja &lt;a href=&quot;http://objectpascalprogramming.com/posts/microservices-delphi-parte-1/#comment-2982613320&quot;&gt;aqui&lt;/a&gt;
a implementação da Classe que implementa &lt;code&gt;IDataStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Aqui há uma grande diferença. Antes o Objeto era passivo. Ele
estava disponível para dar e receber dados através de seus Métodos,
o que é &lt;em&gt;extremamente&lt;/em&gt; errado se estivermos utilizando Orientação a Objetos.&lt;/p&gt;

&lt;p&gt;Agora, com a implementação do Método &lt;code&gt;About&lt;/code&gt;, os dados do Objeto continuam encapsulados.
O Objeto não é mais passivo. Ele não é mais um “balde de dados”. Ele está vivo
e tem seu próprio comportamento.&lt;/p&gt;

&lt;p&gt;Se Objetos externos querem obter os dados de outrem, deverão enviar uma mensagem
solicitando-os. Cabe ao receptor responder com os dados que &lt;em&gt;ele&lt;/em&gt; deseja
compartilhar.&lt;/p&gt;

&lt;h2 id=&quot;refatorando&quot;&gt;Refatorando&lt;/h2&gt;

&lt;p&gt;Nos diálogos acima, Carlos e o “Registro” obtém seus dados da mesma
tabela, chamada CUSTOMER. Seus campos são os mesmos definidos
na primeira versão da Classe &lt;code&gt;TCustomer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O que vamos fazer é refatorar &lt;code&gt;TCustomer&lt;/code&gt;, implementando seu Método
&lt;code&gt;About&lt;/code&gt; ao invés de ter todos os seus dados &lt;strong&gt;expostos&lt;/strong&gt; em &lt;em&gt;Getters&lt;/em&gt; e &lt;em&gt;Setters&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  ICustomer = interface
    function About: IDataStream;
  end;
  
  TCustomer = class(TInterfacedObject, ICustomer)
  private
    FId: IDataGuid;
  public
    constructor Create(Id: IDataGuid);
    class function New(Id: IDataGuid): ICustomer;
    function About: IDataStream;
  end;
  
  implementation
  
  constructor TCustomer.Create(Id: IDataGuid);
  begin
    inherited Create;
    FId := Id;
  end;
  
  class function TCustomer.New(Id: IDataGuid): ICustomer;
  begin
    Result := Create(Id);
  end;
  
  function TCustomer.About: IDataStream;
  begin
    // 1. get record from Database using Id
    // 2. choose data
    // 3. convert to XML
    Result := TDataStream.New({XML});
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando o vendedor diz &lt;em&gt;“Preciso que o senhor preencha esse formulário”&lt;/em&gt;
na verdade é o Formulário — &lt;code&gt;TRentACar&lt;/code&gt; — enviando uma mensagem ao Carlos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TRentACar.New(
  TCustomer.New(
    TDataGuid.New(&#39;{guid}&#39;) // Carlos&#39; guid
  ).About
).Rent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O Formulário necessita de alguns dados como Nome Completo,
Endereço e Cartão de Crédito. Esses dados são passados
no construtor de &lt;code&gt;TRentACar&lt;/code&gt;, provenientes da chamada
ao Método &lt;code&gt;About&lt;/code&gt; de &lt;code&gt;TCustomer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mas o retorno de &lt;code&gt;About&lt;/code&gt; será parecido com isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;customer&amp;gt;
  &amp;lt;Id&amp;gt;{guid}&amp;lt;/Id&amp;gt;
  &amp;lt;FirstName&amp;gt;Carlos&amp;lt;/FirstName&amp;gt;
  &amp;lt;LastName&amp;gt;Almeida&amp;lt;/LastName&amp;gt;
  &amp;lt;Address&amp;gt;Rua 1...&amp;lt;/Address&amp;gt;
&amp;lt;/customer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que &lt;em&gt;Login&lt;/em&gt; e &lt;em&gt;Password&lt;/em&gt; não foram retornados, assim como
a informação do &lt;em&gt;CreditCard&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;E aí temos um problema. Tudo bem que o Formulário não necessita
do &lt;em&gt;Login&lt;/em&gt; e &lt;em&gt;Password&lt;/em&gt; — essas informações serão salvas caso
o Cliente opte por fazer um registro online — mas o Cartão de Crédito
é necessário para concluir a operação.&lt;/p&gt;

&lt;p&gt;O que fazer?&lt;/p&gt;

&lt;p&gt;Temos 2 opções:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Retornar todos os dados no XML;&lt;/li&gt;
  &lt;li&gt;Criar Classes especialistas de &lt;code&gt;Customer&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nesse exemplo é mais fácil retornar todos os dados, é claro. Tudo
está numa única tabela, num único registro. Mas imagine um sistema
mais complexo onde um &lt;code&gt;Customer&lt;/code&gt; poderia ter várias tabelas (outros 
endereços, registros financeiros, histórico de aluguel, tickets de
reclamações…). É possível retornar tudo, num único XML, porém não 
é performático. Exigiria a consulta em muitas tabelas.&lt;/p&gt;

&lt;p&gt;Para esses casos, criamos Classes especialistas. Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TCustomerFinances = class(TInterfacedObject, ICustomer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essa Classe é especializada em Finanças. Ela pode retornar o Cartão
de Crédito e também todos os registros financeiros. O mais interessante,
no entanto, é que todas as Classes especialistas deverão implementar
&lt;code&gt;ICustomer&lt;/code&gt;, pois todas representam a mesma Entidade, porém cada uma
na sua especialidade e em contextos diferentes.&lt;/p&gt;

&lt;p&gt;Então, caso você opte por separar as responsabilidades, o registro
do aluguel do carro poderia ser feita dessa maneira:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TRentACar.New(
  TCustomerFinances.New(
    TCustomer.New(
      TDataGuid.New(&#39;{guid}&#39;) // Carlos&#39; guid
    )
  ).About
).Rent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Classe &lt;code&gt;TCustomerFinances&lt;/code&gt; deverá receber uma instância de
&lt;code&gt;TCustomer&lt;/code&gt; no construtor.
Na chamada ao &lt;code&gt;About&lt;/code&gt; ela irá chamar o &lt;code&gt;About&lt;/code&gt; padrão, incluir os 
dados financeiros e retornar a resposta.&lt;/p&gt;

&lt;p&gt;Isso é &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;decoração&lt;/a&gt; de Objetos.&lt;/p&gt;

&lt;p&gt;Para a Classe &lt;code&gt;TRentACar&lt;/code&gt; é transparente. Ela está conversando
com um único Objeto que retorna um &lt;code&gt;IDataStream&lt;/code&gt; quando enviar uma
mensagem &lt;code&gt;About&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Não podemos mais confundir Dados com Objetos.&lt;/p&gt;

&lt;p&gt;Vamos parar de criar Objetos anêmicos que mapeiam tabelas no 
Banco de Dados.&lt;/p&gt;

&lt;p&gt;Devemos dar o controle aos Objetos. Eles sabem o que devem ou não
responder quando estão se comunicando.&lt;/p&gt;

&lt;p&gt;Você é apenas o &lt;em&gt;diretor&lt;/em&gt; do teatro. Você pode até fazer o roteiro
e escolher quem irá atuar em cada cena. Mas você &lt;em&gt;não&lt;/em&gt; atua.&lt;/p&gt;

&lt;p&gt;Quando os &lt;em&gt;atores&lt;/em&gt; estiverem atuando, não tente controlá-los,
deixe-os trabalhar.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/posts/diga-me-algo-sobre-voce/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/diga-me-algo-sobre-voce/</guid>
      </item>
    
      <item>
        <title>Pensando em Dados</title>
        <description>&lt;p&gt;Você precisa fazer um relatório financeiro num sistema que 
possui o código Orientado a Objetos.&lt;/p&gt;

&lt;p&gt;Quais Classes e Objetos você precisa criar para representar os dados 
que serão exibidos no relatório?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1460925895917-afdab827c52f.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nenhuma!&lt;/p&gt;

&lt;p&gt;Nenhuma Classe que &lt;a href=&quot;/posts/classes-de-dados/&quot;&gt;representa dados&lt;/a&gt;
é necessária. Use apenas… &lt;em&gt;dados&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Muitos programadores (ainda) confundem conceitos tão distintos.
Dados e Objetos são coisas completamente diferentes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enquanto Objetos são criaturas vivas.&lt;/strong&gt; Dados são apenas registros do passado.&lt;/p&gt;

&lt;p&gt;Relatórios tabulares, por exemplo, consistem apenas de exibição e formatação de 
dados no formato de tabela.
Não precisamos de Objetos, comportamento ou
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt;
para fazer essa tarefa — a não ser para obter os dados no lugar onde estão armazenados.&lt;/p&gt;

&lt;p&gt;Objetos, no entanto, podem representar dados na forma de uma
&lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidade&lt;/a&gt;
que encapsula os dados. Poderíamos ter uma Classe &lt;code&gt;TFinanceReport&lt;/code&gt;, 
por exemplo, que representa um 
&lt;a href=&quot;/posts/datamodule-e-apenas-um-container/#implementao-de-um-relatrio&quot;&gt;relatório&lt;/a&gt;,
porém onde estariam os dados? Em atributos? Não, não especificamente.&lt;/p&gt;

&lt;p&gt;Imagine ter um atributo para cada coluna. Listas de objetos. Listas de
listas…&lt;/p&gt;

&lt;p&gt;No fim estaríamos trabalhando com &lt;em&gt;objetos anêmicos&lt;/em&gt; que só possuem 
&lt;a href=&quot;/posts/getters-e-setters/&quot;&gt;Métodos &lt;em&gt;Getters&lt;/em&gt; e &lt;em&gt;Setters&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Isso não seria nada eficaz devido ao grande trabalho que iria ser codificar
essas Classes — muitas delas — e fazer a manipulação de seus Objetos. A performance,
também, seria drasticamente afetada.&lt;/p&gt;

&lt;p&gt;Além disso essa abordagem é totalmente contra os princípios
da verdadeira &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mas não é assim que codificamos no &lt;em&gt;Object Pascal&lt;/em&gt;, certo?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Estou ciente de que utilizar Objetos e listas de Objetos para exibição de
relatórios não é um padrão muito utilizado no mundo &lt;em&gt;Object Pascal&lt;/em&gt;.
Vemos isso mais no mundo Java ou C#. Nesses ambientes muitos programadores acham
que por estarem utilizando Objetos, eles estariam programando Orientado a Objetos,
o que não é, necessariamente, uma verdade.&lt;/p&gt;

&lt;p&gt;Programadores &lt;em&gt;Object Pascal&lt;/em&gt; — maioria — são orientados a Dados e não a Objetos.
Utilizam a abordagem RAD. Dropam componentes nos formulários, fazem algumas
ligações e isso é o suficiente para a exibição dos dados em uma &lt;em&gt;Grid&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Eu sou contra a abordagem RAD para Regras de Negócio ou para qualquer módulo
que exija alguma inteligência, onde o encapsulamento e uso de Objetos iria me
proporcionar um maior &lt;em&gt;controle&lt;/em&gt; e &lt;em&gt;manutenibilidade&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Porém sou completamente a favor da abordagem RAD se estivermos falando sobre 
exibição de dados.&lt;/p&gt;

&lt;p&gt;Não tem nada de errado em utilizarmos &lt;em&gt;queries&lt;/em&gt; para obter os dados de um 
SGBD e exibir o resultado diretamente na tela ou relatório.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dados são apenas registros.&lt;/strong&gt; Estejam eles gravados em arquivos, Banco de Dados, em &lt;em&gt;streams&lt;/em&gt;
em memória ou provenientes de uma requisição HTTP via Web, não importa. São
dados, &lt;em&gt;não&lt;/em&gt; Objetos.&lt;/p&gt;

&lt;p&gt;Portanto não trate Objetos como um
&lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/#objeto-nao-e-um-balde-de-funcoes-e-dados&quot;&gt;balde de dados&lt;/a&gt;
e não trate os Dados como se fossem Objetos que
&lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;pensam&lt;/a&gt; e tomam decisões.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Nov 2016 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/posts/pensando-em-dados/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/pensando-em-dados/</guid>
      </item>
    
      <item>
        <title>Não Culpe o Código Alheio</title>
        <description>&lt;p&gt;Você fez entrevista numa grande empresa e foi contratado como
Desenvolvedor Senior.&lt;/p&gt;

&lt;p&gt;No primeiro dia que lhe dão acesso ao código para corrigir
uma pequena falha, você olha o código e pensa:&lt;/p&gt;

&lt;p&gt;Mas que P#$@[Piiiiii] é essa?!&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1466784828399-9a9921e8bdfd.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;O código é uma &lt;em&gt;bagunça&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Não há divisão lógica entre camadas.&lt;/p&gt;

&lt;p&gt;A equipe diz que o código é Orientado a Objetos, mas não há verdadeiros
&lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tudo parece ser global, pois não parece haver nenhum tipo de
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;Encapsulamento&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;e-agora&quot;&gt;E agora?&lt;/h2&gt;

&lt;p&gt;Normalmente, o primeiro sentimento é culpar o último
programador que trabalhou no código.&lt;/p&gt;

&lt;p&gt;Você pensa:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Eu não faria assim!”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“O que estavam pensando quando codificaram isso aqui?”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Será que alguém aqui sabe o que é normalização das tabelas,
padronização do código, separação de camadas, responsabilidade
única…?”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Culpar é &lt;em&gt;fácil&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Culpar sem nem ao menos saber o histórico do projeto, as 
motivações envolvidas e os responsáveis pelo projeto é ainda
mais fácil.&lt;/p&gt;

&lt;p&gt;Mas, não cometa essa &lt;em&gt;injustiça&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Não pense que somente o último programador é o &lt;em&gt;total&lt;/em&gt; responsável
por toda essa bagunça, pois tem grandes chances dele apenas 
ter seguindo ordens!&lt;/p&gt;

&lt;p&gt;Sim, é verdade.&lt;/p&gt;

&lt;p&gt;Claro que isso não exime os programadores da culpa.&lt;/p&gt;

&lt;h2 id=&quot;voce-tambem-e-culpado&quot;&gt;Você também é culpado&lt;/h2&gt;

&lt;p&gt;Se &lt;em&gt;você&lt;/em&gt; constrói algo, também é &lt;em&gt;responsabilidade&lt;/em&gt; sua que seja 
feito da forma &lt;em&gt;correta&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se você não concorda com a atitude de seus superiores, procure
outro emprego.&lt;/p&gt;

&lt;p&gt;É isso aí! Esse é o correto a se fazer.&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;pt&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;@ job interview:&lt;br /&gt;- We need responsible people. Are you of the kind?&lt;br /&gt;- Absolutely. At my last gig I was always responsible when shit happened&lt;/p&gt;&amp;mdash; Bruno Borges (@brunoborges) &lt;a href=&quot;https://twitter.com/brunoborges/status/792277126695096320&quot;&gt;29 de outubro de 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;Mas infelizmente a vida não é fácil.
E para a maioria das pessoas, a vida pode ser &lt;em&gt;extremamente&lt;/em&gt; difícil.&lt;/p&gt;

&lt;p&gt;Procurar outro emprego demanda tempo. Então a maioria “vai levando a vida”.
Vai “empurrando pra frente” até onde der pra chegar.
E essa atitude impacta diretamente nos projetos que essas 
pessoas estão envolvidas.&lt;/p&gt;

&lt;p&gt;Muitas vezes esses programadores até tentam fazer o certo,
mas gerentes de projetos inexperientes dizem para fazer de 
outra maneira:&lt;/p&gt;

&lt;p&gt;Mais &lt;em&gt;rápido&lt;/em&gt;, mais &lt;em&gt;barato&lt;/em&gt;, mais… sem lógica! Mais um projeto 
que irá &lt;em&gt;fracassar&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;E isso é extremamente desmotivamente.&lt;/p&gt;

&lt;p&gt;Então, quando tudo já está uma bagunça e você não tem voz
de decisão para fazer o certo… nada mais importa.&lt;/p&gt;

&lt;p&gt;E assim o código vira uma bagunça.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Quando chegar numa nova empresa, assuma o código.&lt;/p&gt;

&lt;p&gt;Diga que precisa de um tempo para entender tudo.&lt;/p&gt;

&lt;p&gt;Não aponte culpados. Ao invés disso, mostre à empresa algumas &lt;em&gt;soluções&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;E quando alguém apontar um erro no código, não diga que a culpa não é sua 
só porque o código já estava ali antes de você chegar.&lt;/p&gt;

&lt;p&gt;Se você &lt;em&gt;assumiu&lt;/em&gt; o código, agora ele é &lt;em&gt;seu&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/nao-culpe-o-codigo-alheio/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/nao-culpe-o-codigo-alheio/</guid>
      </item>
    
      <item>
        <title>Unidades Limítrofes</title>
        <description>&lt;p&gt;A maioria dos sistemas utilizam componentes ou &lt;em&gt;libraries&lt;/em&gt;
de terceiros. Seria perda de tempo codificar cada peça de 
código específica e necessária ao total funcionamento do 
sistema, já que existem ótimas opções mundo afora, que já fazem 
o trabalho específico que queremos implementar.&lt;/p&gt;

&lt;p&gt;Mas é prudente utilizar tais &lt;em&gt;peças de código&lt;/em&gt; sem nos 
preocuparmos sobre a manutenibilidade, dependências e 
encapsulamento?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1465447142348-e9952c393450.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Utilizar grupos de &lt;em&gt;componentes&lt;/em&gt; ou &lt;em&gt;libraries&lt;/em&gt; de terceiros 
com funcionalidades diversas é ótimo, pois nos fazem ganhar 
tempo na codificação.&lt;/p&gt;

&lt;p&gt;Vou me referir a ambos os grupos como &lt;strong&gt;peças de código&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Muitas peças já estão prontas para uso. Sejam elas &lt;em&gt;Open Source&lt;/em&gt;
ou comercial, não importa.&lt;/p&gt;

&lt;p&gt;Cada uma dessas peças foram projetadas e codificadas utilizando
estilos e paradigmas diferentes. Cada projeto utilizou um &lt;em&gt;caminho&lt;/em&gt;
diferente para implementar e resolver o problema que motivou o
desenvolvimento da peça.&lt;/p&gt;

&lt;p&gt;Não há um único caminho certo a percorrer, porém uns são menos 
difíceis que outros.&lt;/p&gt;

&lt;p&gt;Seu projeto tem seu próprio caminho e &lt;em&gt;estilo&lt;/em&gt; — ou o estilo da
empresa na qual você trabalha. Isso &lt;em&gt;precisa&lt;/em&gt; ser respeitado.&lt;/p&gt;

&lt;p&gt;Todas as peças intercambiáveis no seu projeto, que são utilizadas em 
muitas camadas comuns, devem seguir o mesmo estilo de codificação.&lt;/p&gt;

&lt;p&gt;Esse artigo irá ressaltar os &lt;em&gt;cuidados&lt;/em&gt; que devemos tomar ao utilizarmos
peças que não foram “feitas em casa” dentro dos nossos projetos.&lt;/p&gt;

&lt;h2 id=&quot;encapsulamento&quot;&gt;Encapsulamento&lt;/h2&gt;
&lt;p&gt;Um dos pilares da Orientação a Objetos é o
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;Encapsulamento&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Não estou me referindo apenas ao Encapsulamento que as Classes podem 
promover, mas sim a qualquer tipo de &lt;em&gt;cápsula&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Uma Função ou Método encapsula variáveis.&lt;/p&gt;

&lt;p&gt;Classes encasulam Estado e Comportamento.&lt;/p&gt;

&lt;p&gt;Unidades (módulos) encapsulam um conjunto de Classes que 
implementam as Regras de Negócio do nosso sistema.&lt;/p&gt;

&lt;p&gt;Unidades também podem encapsular todo um conjunto de peças de 
terceiros, para facilitar ou &lt;em&gt;adaptar&lt;/em&gt; o uso das mesmas dentro 
do nosso projeto.&lt;/p&gt;

&lt;p&gt;Essas Unidades são chamadas de &lt;em&gt;Unidades Limítrofes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo. Imagine um sistema para controlar um Hotel. Eu não conheço
tais Regras de Negócio, mas você pode imaginar cadastros, controle de
preços, quartos vagos, quartos ocupados e muitas outras.&lt;/p&gt;

&lt;p&gt;Nesse mesmo sistema, no entanto, você necessita de uma conexão HTTP, para
enviar arquivos, baixar uma nova versão do próprio sistema, atualizar
dados, etc.&lt;/p&gt;

&lt;p&gt;O protocolo HTTP não faz parte das Regras de Negócio, concorda?&lt;/p&gt;

&lt;p&gt;Não precisamos desenvolver Classes para fazer essa comunicação. Já temos
isso pronto na Internet, sendo a maioria &lt;em&gt;Open Source&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ótimo, vamos baixar um componente ou &lt;em&gt;library&lt;/em&gt; e pronto!&lt;/p&gt;

&lt;p&gt;Aqui eu alerto para um problema: &lt;strong&gt;Dependência&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Quando você adiciona um código de terceiro ao seu projeto, automaticamente
você fica &lt;em&gt;dependende&lt;/em&gt; desse código.&lt;/p&gt;

&lt;h2 id=&quot;componentes-de-terceiros&quot;&gt;Componentes de terceiros&lt;/h2&gt;

&lt;p&gt;Existem algumas ótimas opções de implementação do protocolo HTTP 
em Object Pascal. Mas, mesmo que a opção seja ótima e muitos usuários
já utilizam, não quer dizer que o componente terá um ótimo suporte, 
que sempre estará sendo atualizado ou que o mantenedor nunca irá desistir
do projeto.&lt;/p&gt;

&lt;p&gt;Pelo contrário. Você já deve ter visto componentes “morrerem” porque
o mantenedor não quer mais atualizar ou porque não faz mais sentido
em continuar o projeto, caso tenha outras opções melhores.&lt;/p&gt;

&lt;p&gt;E aí, o que fazer?&lt;/p&gt;

&lt;p&gt;Se o seu código utiliza tal componente em inúmeros lugares, você está 
com um grande problema nas mãos.&lt;/p&gt;

&lt;p&gt;Você não encapsulou essa tecnologia (HTTP) e agora há Unidades de
terceiros por todo o seu projeto, utilizando dezenas de Classes,
constantes e variáveis.&lt;/p&gt;

&lt;p&gt;Se você, no entanto, utilizasse apropriadamente as &lt;strong&gt;Unidades Limítrofes&lt;/strong&gt;,
encapsulando tudo relacionado a HTTP em Módulos a parte, não teria esse 
tipo de problema.&lt;/p&gt;

&lt;h2 id=&quot;unidades-limitrofes&quot;&gt;Unidades Limítrofes&lt;/h2&gt;

&lt;p&gt;Límitrofe &lt;a href=&quot;https://pt.wiktionary.org/wiki/lim%C3%ADtrofe&quot;&gt;significa&lt;/a&gt;
“&lt;em&gt;que se situa ou que vive nos limites de uma extensão, 
de uma região etc.; que tem limites comuns&lt;/em&gt;”.&lt;/p&gt;

&lt;p&gt;A fronteira entre dois sistemas ou módulos. O limite entre Contextos.&lt;/p&gt;

&lt;p&gt;Sempre que possível, temos que encapsular &lt;em&gt;todas&lt;/em&gt; as peças que
não tem relação &lt;em&gt;direta&lt;/em&gt; com as Regras de Negócio do seu sistema.&lt;/p&gt;

&lt;p&gt;A maneira de fazer isso é implementar novas Unidades no seu projeto
apenas para adaptar as peças de terceiros que serão utilizadas.&lt;/p&gt;

&lt;p&gt;Há duas opções quando você for implementar essas novas Unidades. Essas
opções também podem trabalhar em conjunto. São elas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Redefinição de tipos&lt;/li&gt;
  &lt;li&gt;Definição de novas Interfaces e Classes&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;redefinicao-de-tipos&quot;&gt;Redefinição de Tipos&lt;/h2&gt;

&lt;p&gt;Redefinir ou renomear um tipo é algo trivial no Object Pascal.&lt;/p&gt;

&lt;p&gt;Imagine que você baixou um componente para comunicação HTTP. 
A Unidade que contém a Classe que você quer utilizar chama-se
&lt;code&gt;FastHTTP.pas&lt;/code&gt; e a Classe foi implementada como &lt;code&gt;TftHttpClient&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Queremos encapsular essa Classe numa Unidade Limítrofe, para que 
nosso sistema só enxergue a nossa Unidade, que daremos o nome de &lt;code&gt;AcmeWebHttp.pas&lt;/code&gt;, 
e a nova Classe terá o nome &lt;code&gt;TWebHttp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então temos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit AcmeWebHttp;

interface

uses
  FastHTTP;
  
type
  TWebHttp = FastHTTP.TftHttpClient;
  
implementation

end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora &lt;code&gt;TWebHttp&lt;/code&gt; é apenas um atalho — &lt;em&gt;alias&lt;/em&gt; — para a verdadeira
Classe que implementa o protocolo HTTP.&lt;/p&gt;

&lt;p&gt;Todo o restante do sistema irá utilizar apenas &lt;code&gt;TWebHttp&lt;/code&gt; como se
essa Classe fosse a responsável por fazer o trabalho.&lt;/p&gt;

&lt;p&gt;Esse é um encapsulamento &lt;strong&gt;simples&lt;/strong&gt;. Ele só deve ser utilizado para 
coisas simples, pontuais, que não são utilizados em muitas partes do 
sistema.&lt;/p&gt;

&lt;p&gt;Essa técnica também pode ser utilizada para “concentrar” Classes e
constantes numa mesma Unidade. Mas, por algum motivo, não funciona
com tipos enumerados.&lt;/p&gt;

&lt;h2 id=&quot;novas-definicoes&quot;&gt;Definição de novas Interfaces e Classes&lt;/h2&gt;

&lt;p&gt;Para componentes mais complexos ou que são utilizados por todo o
sistema, o correto é implementarmos um encapsulamento através 
de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Componentes costumam ter &lt;em&gt;inúmeros&lt;/em&gt; Métodos e Propriedades mas, 
na maioria das vezes, você não necessita de todas essas opções.&lt;/p&gt;

&lt;p&gt;Implemente Interfaces apenas com os Métodos que fazem sentido
dentro do seu projeto e crie uma ou mais Classes que irão implementar
essa Interface.&lt;/p&gt;

&lt;p&gt;Pelo menos uma dessas novas Classes terá encapsulado
o componente real, ou seja, a Classe &lt;code&gt;TftHttpClient&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo. Se você só necessita de um Método para apontar para uma
URL e retornar seu conteúdo, você poderia implementar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit AcmeWebHttp;

interface

uses
  FastHTTP,
  AcmeData;
  
type
  IWebHttp = interface
    function Get(const URL: string): IDataStream;
  end;
  
  TWebHttp = class sealed(TInterfacedObject, IWebHttp)
  private
    FOrigin: TftHttpClient;
  public
    function Get(const URL: string): IDataStream;
  end;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por todo o sistema seu uso será simples, utilizando somente a Interface
&lt;code&gt;IWebHttp&lt;/code&gt; que, nesse exemplo, só tem um único Método.&lt;/p&gt;

&lt;p&gt;Essa é a forma que eu utilizo e que &lt;em&gt;recomendo&lt;/em&gt; que você faça.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A utilização de Unidades Limítrofes nos dá a capacidade de substituir
&lt;em&gt;todas&lt;/em&gt; as peças de terceiros em nosso sistema de forma simples, num &lt;em&gt;único
lugar&lt;/em&gt; e que irá refletir globalmente em todo o código. Isso facilita a
&lt;em&gt;manutenibilidade&lt;/em&gt; do código.&lt;/p&gt;

&lt;p&gt;Outro ganho com essa técnica é que mantemos o mesmo estilo de nomenclatura
de Classes e Unidades por todo o sistema, visto que podemos renomear ou
redefinir qualquer peça externa ao projeto.&lt;/p&gt;

&lt;p&gt;Não é algo difícil de se fazer. Dá trabalho, mas os &lt;em&gt;benefícios&lt;/em&gt; como diminuição
de dependências externas, encapsulamento e estilo de codificação, valem 
muito a pena no longo prazo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/unidades-limitrofes/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/unidades-limitrofes/</guid>
      </item>
    
      <item>
        <title>Funções Aninhadas</title>
        <description>&lt;p&gt;Se você tem um Método coeso, que trabalha em apenas uma única 
tarefa, mas mesmo assim o código parece complicado, dificultando
o entendimento e a manutenção… já pensou em refatorar o código
utilizando Funções Aninhadas?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1476411890462-80309823db3b.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Nested_function&quot;&gt;Funções Aninhadas&lt;/a&gt;
é algo que não existe em todas as linguagens.
A linguagem Pascal tem e acho que devemos aproveitar essa &lt;em&gt;feature&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Funções Aninhadas nada mais são do que funções declaradas dentro de
outras funções ou Métodos.&lt;/p&gt;

&lt;p&gt;Esse artigo irá mostrar os motivos e vantagens ao utilizarmos Funções 
Aninhadas, assim como algumas regras que devemos seguir ao utilizá-las.&lt;/p&gt;

&lt;h2 id=&quot;motivos&quot;&gt;Motivos&lt;/h2&gt;

&lt;p&gt;Funções Aninhadas é uma opção bem melhor do que 
&lt;a href=&quot;/posts/linhas-em-branco-no-metodo-e-mal-cheiro/&quot;&gt;pular linhas&lt;/a&gt;
dentro da implementação de um Método com o intuito de separar blocos
de código.&lt;/p&gt;

&lt;p&gt;Cada função já define um bloco, com a vantagem de ser &lt;strong&gt;reutilizável&lt;/strong&gt; em
outra parte do Método.&lt;/p&gt;

&lt;p&gt;Funções Aninhadas tem um conceito muito próximo da Programação Orientada a 
Objetos (leia esse 
&lt;a href=&quot;http://blog.synopse.info/post/2012/05/20/Recursive-calls-and-private-objects&quot;&gt;artigo&lt;/a&gt;
).
Um Método que contém Funções Aninhadas é como se fosse uma implementação
de uma &lt;em&gt;Classe Anônima&lt;/em&gt;. As variáveis locais serão como &lt;em&gt;atributos&lt;/em&gt; e as 
Funções Aninhadas serão como &lt;em&gt;Métodos privados&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Funções Aninhadas facilitam a correta utilização do
&lt;a href=&quot;/posts/a-declaracao-with-do-e-do-mal/&quot;&gt;&lt;em&gt;WITH&lt;/em&gt;&lt;/a&gt;
quando a implementação do Método é complexa ou quando o código utiliza
composição com muitos Objetos.
Dividir o código em pequenas funções, diminuirá as chances de haver &lt;strong&gt;conflitos&lt;/strong&gt;
entre identificadores que utilizam o &lt;em&gt;WITH&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Resumindo: Funções Aninhadas deixam o código melhor organizado, fácil de ler 
e alterar.&lt;/p&gt;

&lt;h2 id=&quot;regras&quot;&gt;Regras de Uso&lt;/h2&gt;

&lt;p&gt;Qualquer &lt;em&gt;feature&lt;/em&gt; utilizada de forma indiscriminada poderá ser um
potencial problema no futuro, ao invés de uma solução — o mesmo ocorre com 
o uso indiscriminado do &lt;em&gt;WITH&lt;/em&gt; por programadores que não sabem exatamente o
que estão fazendo.&lt;/p&gt;

&lt;p&gt;Precisamos de &lt;strong&gt;regras&lt;/strong&gt; e &lt;strong&gt;disciplina&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Abaixo algumas regras que você deve levar em conta.&lt;/p&gt;

&lt;h3 id=&quot;regra1&quot;&gt;Regra 1: Não utilize mais do que 3 Funções Aninhadas&lt;/h3&gt;

&lt;p&gt;É uma regra óbvia.
Se você tem muitas Funções Aninhadas dentro e um único Método, 
é bem provável que ele esteja fazendo &lt;strong&gt;coisas demais&lt;/strong&gt;.
Pense na refatoração e decomposição em outros Métodos ou mesmo
na criação de uma nova Classe.&lt;/p&gt;

&lt;p&gt;Existem pouquíssimas exceções a essa regra.&lt;/p&gt;

&lt;h3 id=&quot;regra2&quot;&gt;Regra 2: Evite compartilhar as Variáveis Locais&lt;/h3&gt;

&lt;p&gt;Falei acima que um Método com Funções Aninhadas é como uma Classe
Anônima, contendo Métodos privados e atributos. 
No entanto, sabemos que não são verdadeiras Classes.&lt;/p&gt;

&lt;p&gt;É melhor que você isole cada Função Aninhada com suas próprias 
variáveis e argumentos, ou seja, &lt;strong&gt;evite&lt;/strong&gt; compartilhar as variáveis
locais do Método com as Funções Aninhadas.&lt;/p&gt;

&lt;p&gt;Essa disciplina na codificação irá ajudá-lo na &lt;em&gt;extração&lt;/em&gt; e 
&lt;em&gt;refatoração&lt;/em&gt; das Funções Aninhadas, se for o caso, para criar outros 
Métodos com o mínimo de impacto possível.&lt;/p&gt;

&lt;p&gt;Ao invés de utilizar a variável local do Método, passe
a referência como argumento da função, mantendo-as &lt;strong&gt;isoladas&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Existem poucas exceções a esta regra. Por exemplo.
Se todas as Funções Aninhadas trabalham sempre com
os mesmos Objetos (variáveis locais) do Método, é mais fácil 
compartilhar as variáveis — ou refatorar criando uma nova Classe —
do que ficar repassando-as às funções. Utilize o bom senso.&lt;/p&gt;

&lt;h3 id=&quot;regra3&quot;&gt;Regra 3: Apenas 1 Nível de Funções&lt;/h3&gt;

&lt;p&gt;Não complique. Use &lt;em&gt;apenas&lt;/em&gt; um “nível” de Funções Aninhadas. Se
você tiver utilizando mais de um nível, é provável que a função
de “nível 2” deveria ser um Método.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Refatore&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Após a refatoração do código, o “nível 2” de Funções Aninhadas
passaria a ser o “nível 1” no novo Método criado.&lt;/p&gt;

&lt;p&gt;Sem exceções aqui!&lt;/p&gt;

&lt;h3 id=&quot;regra4&quot;&gt;Regra 4: Menos é Mais&lt;/h3&gt;

&lt;p&gt;Cada função deve implementar apenas uma &lt;strong&gt;única&lt;/strong&gt; responsabilidade.&lt;/p&gt;

&lt;p&gt;Essa é uma regra geral para codificar Métodos e Funções.&lt;/p&gt;

&lt;p&gt;Sem exceções.&lt;/p&gt;

&lt;h2 id=&quot;exemplos&quot;&gt;Exemplos&lt;/h2&gt;

&lt;p&gt;Funções Aninhadas podem ser utilizadas em qualquer tipo de Objeto.&lt;/p&gt;

&lt;p&gt;Objetos que lidam com XML, por exemplo, onde é necessário trabalhar
com recursividade e validações sempre são bons candidatos.&lt;/p&gt;

&lt;p&gt;Mas meu uso pessoal de Funções Aninhadas é, na maioria das vezes, 
utilizada no código de &lt;em&gt;Forms&lt;/em&gt;.
O motivo é simples: É natural para o usuário clicar em apenas um
botão e o sistema fazer &lt;em&gt;inúmeras&lt;/em&gt; tarefas. Para o usuário é
irrelevante se foi preciso 1 ou 20 Objetos para concluir a tarefa.
O usuário acha que apenas uma tarefa foi executada quando, na 
verdade, &lt;strong&gt;inúmeros Objetos&lt;/strong&gt; podem ter tido participação para executar
o serviço.&lt;/p&gt;

&lt;p&gt;Então, abaixo temos alguns exemplos do que eu considero um &lt;em&gt;bom&lt;/em&gt; uso
de Funções Aninhadas.&lt;/p&gt;

&lt;p&gt;Observação: Podem haver erros de sintaxe, visto que eu estou escrevendo
o código diretamente no editor do artigo sem compilar.&lt;/p&gt;

&lt;h3 id=&quot;exemplo1&quot;&gt;Exemplo 1: Pergunte, Faça o Serviço&lt;/h3&gt;

&lt;p&gt;Em alguns formulários temos que questionar o usuário sobre
qual caminho o sistema deve tomar.
Esses questionamentos, com mensagens &lt;em&gt;strings&lt;/em&gt;, podem 
diminuir a legibilidade do código.&lt;/p&gt;

&lt;p&gt;Somado isso com o uso &lt;em&gt;errado&lt;/em&gt; do &lt;em&gt;WITH&lt;/em&gt;, o código &lt;em&gt;não&lt;/em&gt; fica 
elegante. Veja:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TMainForm.DeleteButtonClick(Sender: TObject);
begin
  with TUserQuestion.New(
    Format(
      &#39;Você tem %d registros para excluir.&#39; + #13
      &#39;Esse processo pode demorar.&#39; + #13
      &#39;Confirma a execução?&#39;, [
        DataSet.RecordCount
      ]
    )
  ) do
  begin
    Show;
    if Confirmed then
    begin
      ExecuteProcessOne;
      ExecuteProcessTwo;
      TUserInformation.New(&#39;Processo concluído.&#39;).Show;
    end;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo eu utilizei Classes de Mensagens ao usuário.
Não precisamos de sua implementação para entender o que está 
ocorrendo aqui. No entanto o código pode parecer um pouco confuso
para alguns programadores “não iniciados” no uso do &lt;em&gt;WITH&lt;/em&gt;.
Por exemplo. O Método &lt;code&gt;Show&lt;/code&gt; após o primeiro &lt;code&gt;begin&lt;/code&gt;, pertence ao
Formulário ou a instância de &lt;code&gt;TUserQuestion&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Também temos a mensagem em texto com quebra de linha e parâmetros
concatenados. As vezes essas mensagens são maiores. O código fica 
uma bagunça.&lt;/p&gt;

&lt;p&gt;Vamos refatorar esse código utilizando Funções Aninhadas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TMainForm.DeleteButtonClick(Sender: TObject);

  function Question(Total: Integer): IUserQuestion;
  begin
    Result :=
      TUserQuestion.New(
        Format(
          &#39;Você tem %d registros para excluir.&#39; + #13
          &#39;Esse processo pode demorar.&#39; + #13
          &#39;Confirma a execução?&#39;, [
            Total
          ]
        )
      ).Show;
  end;

begin
  if Question(DataSet.RecordCount).Confirmed then
  begin
    ExecuteProcessOne;
    ExecuteProcessTwo;
    TUserInformation.New(&#39;Processo concluído.&#39;).Show;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mais simples?&lt;/p&gt;

&lt;p&gt;Sim, optei por retirar o &lt;em&gt;WITH&lt;/em&gt;, porque é mais simples dessa forma,
nesse exemplo.
Mas ele poderia ser utilizado caso o programador necessitasse de 
mais alguma informação da instância &lt;code&gt;IUserQuestion&lt;/code&gt;, criada e retornada
através da função &lt;code&gt;Question&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo. Você pode fazer uma pergunta ao usuário onde ele deve digitar 
um valor. Nesse caso você precisa validar o retorno (&lt;code&gt;Confirmed&lt;/code&gt;) e 
mostrar o valor digitado (&lt;code&gt;Value&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with TUserInput.New(&#39;Digite o valor&#39;) do
begin
  if Confirmed then
    TUserInformation.New(
      &#39;Valor digitado: &#39; + Value.AsString
    )
    .Show;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare, também, que a função &lt;code&gt;Question&lt;/code&gt; não tem mais dependência
com o Objeto que vem do Formulário, &lt;code&gt;DataSet.RecordCount&lt;/code&gt;. A função
agora está &lt;strong&gt;isolada&lt;/strong&gt;. Isso quer dizer que se você precisar dessa
função em mais de um lugar, pode extraí-la, criar um novo Método e 
passar o argumento na sua chamada.&lt;/p&gt;

&lt;h3 id=&quot;exemplo2&quot;&gt;Exemplo 2: Clicou no “Botão Mágico” que Faz tudo&lt;/h3&gt;

&lt;p&gt;Imagine um Formulário que, ao clique de um botão, o sistema:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Faz validações das informações desejadas&lt;/li&gt;
  &lt;li&gt;Pergunta ao usuário se deve continuar&lt;/li&gt;
  &lt;li&gt;Salva as informações no banco de dados&lt;/li&gt;
  &lt;li&gt;Envia um e-mail notificando alguém&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Claro que você terá uma Classe para cada uma dessas funções (certo?).
Você não deve implementar tudo isso dentro de um evento num botão.&lt;/p&gt;

&lt;p&gt;Por outro lado, a implementação mais &lt;strong&gt;correta&lt;/strong&gt; seria separar essas ações
em outras camadas, outras Classes, sem instanciar tais Classes específicas
dentro do Formulário.&lt;/p&gt;

&lt;p&gt;Infelizmente nem sempre temos tempo para fazer o 100% correto. Mas que 
tal fazer 80% correto para depois, quando tivermos mais tempo, refatorar
com tranquilidade o código?&lt;/p&gt;

&lt;p&gt;Aqui as Funções Aninhadas nos ajudam novamente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TMainForm.ConfirmButtonClick(Sender: TObject);

  function Checked: Boolean;
  begin
    Result := False;
    //if EmailEdit.Text &amp;lt;&amp;gt; &#39;&#39; then
    // Exit;
    //...
    Result := True;
  end;
  
  function Question: IUserQuestion;
  begin
    Result := 
      TUserQuestion.New(&#39;Confirma a operação?&#39;).Show;
  end;
  
  procedure Save;
  begin
    // persistência...
  end;
  
  procedure SendEmail;
  begin
    // envia um e-mail...
  end;

begin
  if Checked then
    if Question.Confirmed then
    begin
      Save;
      SendMail;
    end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tenha em mente que isso é apenas um exemplo.&lt;/p&gt;

&lt;p&gt;Todas as Funções Aninhadas devem seguir o bom senso e ter 
&lt;strong&gt;poucas linhas&lt;/strong&gt;. Caso contrário, &lt;em&gt;refatore&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Haverá muitas dependências entre o Formulário e todas essas Classes 
especialistas. Mas nem sempre
precisamos abstrair em camadas. Pode ser um pequeno Formulário de um
pequeno sistema, onde não haveria problemas em ter essas dependências.&lt;/p&gt;

&lt;p&gt;Mesmo assim o código está &lt;em&gt;limpo&lt;/em&gt; e &lt;em&gt;elegante&lt;/em&gt;, com fácil manutenção.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Funções Aninhadas nos ajudam a codificar de forma mais simples e elegante.&lt;/p&gt;

&lt;p&gt;É um dos caminhos para “seguir em frente” sem muitas preocupações com 
o &lt;strong&gt;purismo&lt;/strong&gt; da Orientação a Objetos — devido a falta de tempo — mas sem deixar
cair a qualidade do código no longo prazo.&lt;/p&gt;

&lt;p&gt;Utilize-as com sabedoria.&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/funcoes-aninhadas/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/funcoes-aninhadas/</guid>
      </item>
    
      <item>
        <title>Interfaces, Delegação, Problemas e Soluções</title>
        <description>&lt;p&gt;Delegação de Implementação através da composição de
Objetos é uma &lt;em&gt;feature&lt;/em&gt; incrível, só disponível na
Linguagem &lt;em&gt;Object Pascal&lt;/em&gt;, porém existem alguns 
problemas intrínsecos no uso dessa tecnologia.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1474406716381-8399fe67fbcf.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/&quot;&gt;artigo anterior&lt;/a&gt;
escrevi sobre a Delegação de Implementação de Interfaces, 
utilizando a Composição de Objetos.&lt;/p&gt;

&lt;p&gt;É uma &lt;em&gt;feature&lt;/em&gt; bem legal.&lt;/p&gt;

&lt;p&gt;Infelizmente existem algumas armadilhas quando trabalhamos
com Interfaces e sua liberação automática de memória.&lt;/p&gt;

&lt;p&gt;A Delegação utilizando Objetos também possui armadilhas que,
se não forem verificadas, podem arruinar seu projeto devido
aos vazamentos de memória que essa prática pode causar.&lt;/p&gt;

&lt;p&gt;Nesse artigo vou lhe mostrar os problemas e propor soluções.&lt;/p&gt;

&lt;h2 id=&quot;vazamentos-de-memoria&quot;&gt;Vazamentos de memória&lt;/h2&gt;

&lt;p&gt;A Linguagem Object Pascal nos dá a possibilidade de trabalharmos
utilizando variáveis do tipo Interface. Essas são liberadas
automaticamente, pelo compilador, quando saem do escopo de execução
na qual elas foram criadas.&lt;/p&gt;

&lt;p&gt;Essa facilidade nos traz alguns problemas ou cria 
condições para problemas como, por exemplo, a 
&lt;a href=&quot;/posts/interfaces-e-a-referencia-circular-entre-objetos/&quot;&gt;referência circular&lt;/a&gt;
e a &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;não existência de uma variável&lt;/a&gt;
na construção de um Objeto.&lt;/p&gt;

&lt;p&gt;Esse são alguns dos inúmeros equívocos na implementação que geram
os tão temidos vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Outro problema grave tem haver com a 
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;hierarquia de herança&lt;/a&gt; 
que você irá utilizar nas Classes que irão gerar Objetos que 
implementam Interfaces por delegação.&lt;/p&gt;

&lt;h2 id=&quot;contador-de-referencias&quot;&gt;Contador de Referências&lt;/h2&gt;

&lt;p&gt;Vou ser justo e dizer que o problema, em si, não é especificamente sobre
herança, mas como você implementa os Métodos especiais que são utilizados
pelo compilador para fazer a liberação da memória automaticamente.&lt;/p&gt;

&lt;p&gt;São eles: &lt;code&gt;QueryInterface&lt;/code&gt;, &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Esses são Métodos especiais que são utilizados para 
implementar um Contador de Referências. 
Eles servem para incrementar e decrementar um contador 
de referência da instância e, com isso, ter o controle para saber 
quando liberar o Objeto da memória.&lt;/p&gt;

&lt;p&gt;Ao utilizarmos Interfaces, somos obrigados a implementar esses 3 Métodos
— a não ser que utilizemos Interfaces CORBA, que não tem contagem de
referência e nem liberação automática da memória.&lt;/p&gt;

&lt;p&gt;Então utizamos a herança de alguma Classe que já implemente esses Métodos.&lt;/p&gt;

&lt;p&gt;E aqui começam os problemas.&lt;/p&gt;

&lt;h2 id=&quot;problemas&quot;&gt;Problemas&lt;/h2&gt;

&lt;p&gt;Como eu não utilizo mais herança de Classes eu não preciso pensar sobre
hierarquias de Classes e todas as suas complexidades. 
Todas as minhas Classes herdam de &lt;code&gt;TInterfacedObject&lt;/code&gt;, pois essa Classe
já implementa os 3 Métodos apropriadamente.&lt;/p&gt;

&lt;p&gt;Mas para programadores que ainda utilizam
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;
esse pode ser o primeiro problema a enfrentar.&lt;/p&gt;

&lt;p&gt;Exemplo. Você vai desenhando toda a sua hierarquia de Classes, “perfeitamente” e 
descobre que Cão não pode herdar de Mamífero porque você quer utilizar Interfaces
com contagem de referência… então Cão herda de &lt;code&gt;TInterfacedObject&lt;/code&gt; — 
quebrando a hierarquia — ou você é obrigado a copiar/colar o código 
de &lt;code&gt;TInterfacedObject&lt;/code&gt; dentro da sua Classe — o que também é abominável.&lt;/p&gt;

&lt;p&gt;Como eu dizia, todas as minhas Classes herdam de &lt;code&gt;TInterfacedObject&lt;/code&gt;.
Sendo assim, as Classes que serão utilizadas para delegar a implementação
das Interfaces, também serão filhas de &lt;code&gt;TInterfacedObject&lt;/code&gt; e… BUM! 
Temos vazamento de memória.&lt;/p&gt;

&lt;p&gt;Pois é. As Classes delegadas não podem herdar de &lt;code&gt;TInterfacedObject&lt;/code&gt;
se eu quiser instanciar a Classe principal como uma Interface.&lt;/p&gt;

&lt;p&gt;Confuso? Eu também fiquei.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h3&gt;

&lt;p&gt;Vamos utilizar o exemplo do
&lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/&quot;&gt;artigo anterior&lt;/a&gt;
para explicar onde iríamos ter problemas com vazamento de memória.&lt;/p&gt;

&lt;p&gt;A Classe final ficou assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  TTheClient = class(TInterfacedObject, IFinances, IAccess)
  private
    FFinances: IFinances;
    FAccess: IAccess;
    property Finances: IFinances read FFinances implements IFinances;
    property Access: IAccess read FAccess implements IAccess;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E os &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#como-utilizar-a-delegacao&quot;&gt;exemplos&lt;/a&gt;
de implementação utilizando delegação foram as Classes &lt;code&gt;TSimpleFinances&lt;/code&gt; 
e &lt;code&gt;TSimpleAccess&lt;/code&gt;. Ambas herdando de &lt;code&gt;TInterfacedObject&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  TSimpleFinances = class(TInterfacedObject, IFinances)
  public
    construtor ...
    function Current: Currency;
    function AsString: string;
  end;
  
  TSimpleAccess = class(TInterfacedObject, IAccess)
  public
    construtor ...
    function List: IDataList;
    function AsString: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Devido os atributos &lt;code&gt;FFinances&lt;/code&gt; e &lt;code&gt;FAccess&lt;/code&gt; forem do tipo Interface, haverá
vazamentos de memória se estanciarmos &lt;code&gt;TTheClient&lt;/code&gt; como sendo representante
de alguma das Interfaces que ele implementa (por delegação).&lt;/p&gt;

&lt;p&gt;Isso ocorre porque o compilador irá instanciar 2 Objetos — &lt;code&gt;TTheClient&lt;/code&gt;
e o Objeto delegado que implementa a Interface — mas no nosso código
só teremos a referência a um Objeto.
A princípio tudo deveria funcionar, já que também temos a referência ao
Objeto delegado através do atributo privado, mas não é assim que funciona.&lt;/p&gt;

&lt;p&gt;Há dois problemas no código acima, se considerarmos a utilização normal de 
instâncias com contagem de referência:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Propriedades e atributos delegados não podem ser Interfaces;&lt;/li&gt;
  &lt;li&gt;Objetos delegados não devem ter &lt;code&gt;TInterfacedObject&lt;/code&gt; como herança.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Então a Classe final &lt;code&gt;TTheClient&lt;/code&gt; tem um problema.&lt;/p&gt;

&lt;p&gt;Vamos ao um exemplo mais completo.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h3&gt;

&lt;p&gt;O exemplo abaixo foi submetido à lista de discussão oficial do FreePascal com
o título “&lt;em&gt;A serious Memleak using delegates/implements…&lt;/em&gt;” no dia 5 de Outubro, 
o que gerou alguma polêmica por lá.&lt;/p&gt;

&lt;p&gt;Se você não faz parte da lista, pode ler as mensagens dessa &lt;em&gt;thread&lt;/em&gt; 
&lt;a href=&quot;https://www.mail-archive.com/fpc-pascal@lists.freepascal.org/msg43835.html&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program Project1;

{$mode objfpc}{$H+}

uses
  Classes, SysUtils;

type
  IValue = interface
    function AsString: string;
  end;

  TIntegerValue = class(TInterfacedObject, IValue)
  private
    FValue: Integer;
  public
    constructor Create(Value: Integer);
    destructor Destroy; override;
    function AsString: string;
  end;

  TMyApp = class(TInterfacedObject, IValue)
  private
    FValue: IValue;
  public
    constructor Create(Value: Integer);
    destructor Destroy; override;
    property Value: IValue read FValue implements IValue;
  end;

{ TIntegerValue }

constructor TIntegerValue.Create(Value: Integer);
begin
  inherited Create;
  FValue := Value;
  WriteLn(&#39;TIntegerValue.Create&#39;);
end;

destructor TIntegerValue.Destroy;
begin
  WriteLn(&#39;TIntegerValue.Destroy&#39;);
  inherited Destroy;
end;

function TIntegerValue.AsString: string;
begin
  Result := &#39;Number is &#39; + IntToStr(FValue);
end;

{ TMyApp }

constructor TMyApp.Create(Value: Integer);
begin
  inherited Create;
  FValue := TIntegerValue.Create(Value);
  WriteLn(&#39;TMyApp.Create&#39;);
end;

destructor TMyApp.Destroy;
begin
  WriteLn(&#39;TMyApp.Destroy&#39;);
  inherited Destroy;
end;

// Program

procedure ExecuteIntegerValue;
var
  V: IValue;
begin
  WriteLn;
  WriteLn(&#39;IntegerValue:&#39;);
  V := TIntegerValue.Create(5);
  WriteLn(V.AsString);
end;

procedure ExecuteMyApp;
var
  App: TMyApp;
begin
  WriteLn;
  WriteLn(&#39;MyApp:&#39;);
  App := TMyApp.Create(10);
  try
    WriteLn(App.Value.AsString);
  finally
    App.Free;
  end;
end;

procedure ExecuteMyAppAsInterface;
var
  V: IValue;
begin
  WriteLn;
  WriteLn(&#39;MyAppAsInterface:&#39;);
  V := TMyApp.Create(20);
  WriteLn(V.AsString);
end;

begin
  ExecuteIntegerValue;
  ExecuteMyApp;
  ExecuteMyAppAsInterface;
  ReadLn;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O programa acima compila sem nenhum erro utilizando o FreePascal ou Delphi.
No entanto, se habilitarmos a saída de verificação de vazamentos
de memória (chama-se &lt;a href=&quot;http://www.freepascal.org/docs-html/rtl/heaptrc/usage.html&quot;&gt;Heaptrc&lt;/a&gt; no FreePascal)
podemos ver que o término do programa não foi elegante como deveria:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;W:\temp&amp;gt;project1.exe

IntegerValue:
TIntegerValue.Create
Number is 5
TIntegerValue.Destroy

MyApp:
TIntegerValue.Create
TMyApp.Create
Number is 10
TMyApp.Destroy
TIntegerValue.Destroy

MyAppAsInterface:
TIntegerValue.Create
TMyApp.Create
Number is 20

Heap dump by heaptrc unit
83 memory blocks allocated : 2017/2200
81 memory blocks freed     : 1981/2160
2 unfreed memory blocks : 36
True heap size : 229376 (80 used in System startup)
True free heap : 229104
Should be : 229128
Call trace for block $01812928 size 20
  $004017DA  TMYAPP__CREATE,  line 59 of W:/temp/project1.lpr
  $00401B82  EXECUTEMYAPPASINTERFACE,  line 101 of W:/temp/project1.lpr
  $00401C08  main,  line 108 of W:/temp/project1.lpr
Call trace for block $018128C8 size 16
  $00401B82  EXECUTEMYAPPASINTERFACE,  line 101 of W:/temp/project1.lpr
  $00401C08  main,  line 108 of W:/temp/project1.lpr

W:\temp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O problema de vazamento de memória ocorre somente na chamada à função &lt;code&gt;MyAppAsInterface&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ao vermos isso a primeira impressão é: Delegação de Implementação não funciona.&lt;/p&gt;

&lt;p&gt;Bem, funciona sim. Não é tão elegante como eu gostaria que fosse, mas ao
menos é contornável.&lt;/p&gt;

&lt;h2 id=&quot;solucoes&quot;&gt;Soluções&lt;/h2&gt;

&lt;p&gt;A partir de agora, a Classe que você sempre deverá se lembrar, depois da 
&lt;code&gt;TInterfacedObject&lt;/code&gt;, será a Classe &lt;code&gt;TAggregatedObject&lt;/code&gt;. 
Ambas existem no FreePascal e também no Delphi.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TAggregatedObject&lt;/code&gt; também implementa os 3 métodos especiais, mas
é uma implementação diferente da utilizada em &lt;code&gt;TInterfacedObject&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Essa Classe deverá ser utilizada para implementar Objetos que são utilizados
na Delegação de Implementação utilizando a sintaxe “&lt;em&gt;implements&lt;/em&gt;”.&lt;/p&gt;

&lt;p&gt;Em &lt;a href=&quot;http://www.freepascal.org/docs-html/rtl/system/taggregatedobject.html&quot;&gt;poucas palavras&lt;/a&gt;, 
os Objetos de &lt;code&gt;TAggregatedObject&lt;/code&gt; delegam a contagem de 
referência ao “Objeto controlador”, ou seja, delegam seus próprios “tempos de vida”
ao Objeto externo que implementa as Interfaces.&lt;/p&gt;

&lt;p&gt;Primeiro vamos implementar uma nova Classe que herda de &lt;code&gt;TAggregatedObject&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TDelegatedIntegerValue = class(TAggregatedObject, IValue)
private
  FValue: Integer;
public
  constructor Create(AController: IInterface; Value: Integer);
  destructor Destroy; override;
  function AsString: string;
end;

{ TDelegatedIntegerValue }

constructor TDelegatedIntegerValue.Create(AController: IInterface;
  Value: Integer);
begin
  inherited Create(AController);
  FValue := Value;
  WriteLn(&#39;TDelegatedIntegerValue.Create&#39;);
end;

destructor TDelegatedIntegerValue.Destroy;
begin
  WriteLn(&#39;TDelegatedIntegerValue.Destroy&#39;);
  inherited Destroy;
end;

function TDelegatedIntegerValue.AsString: string;
begin
  Result := &#39;Number is &#39; + IntToStr(FValue);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Infelizmente também teremos que alterar a definição da Classe &lt;code&gt;TMyApp&lt;/code&gt;,
redefinindo a propriedade e atributo para um tipo concreto de Classe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TMyApp = class(TInterfacedObject, IValue)
private
  FValue: TDelegatedIntegerValue;
public
  constructor Create(Value: Integer);
  destructor Destroy; override;
  property Value: TDelegatedIntegerValue read FValue implements IValue;
end;

{ TMyApp }

constructor TMyApp.Create(Value: Integer);
begin
  inherited Create;
  FValue := TDelegatedIntegerValue.Create(Self, Value);
  WriteLn(&#39;TMyApp.Create&#39;);
end;

destructor TMyApp.Destroy;
begin
  FValue.Free;
  WriteLn(&#39;TMyApp.Destroy&#39;);
  inherited Destroy;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ao criamos a instância &lt;code&gt;FValue&lt;/code&gt;, um dos argumentos do construtor
da Classe &lt;code&gt;TDelegatedIntegerValue&lt;/code&gt; é o &lt;em&gt;Controller&lt;/em&gt; que irá controlar
o tempo de vida da instância que, nesse caso, é a instância (&lt;em&gt;Self&lt;/em&gt;)
de &lt;code&gt;TMyApp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Após compilar e executar novamente a aplicação, podemos ver um novo resultado:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe

IntegerValue:
TIntegerValue.Create
Number is 5
TIntegerValue.Destroy

MyApp:
TDelegatedIntegerValue.Create
TMyApp.Create
Number is 10
TDelegatedIntegerValue.Destroy
TMyApp.Destroy

MyAppAsInterface:
TDelegatedIntegerValue.Create
TMyApp.Create
Number is 20
TDelegatedIntegerValue.Destroy
TMyApp.Destroy

Heap dump by heaptrc unit
83 memory blocks allocated : 2009/2184
83 memory blocks freed     : 2009/2184
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528

c:\temp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Os &lt;em&gt;designers&lt;/em&gt; da linguagem foram muito infelizes ao criarem “métodos especiais”
para liberação de memória. Isso é algo difícil de explicar para programadores
não-Pascal. É até um pouco vergonhoso…&lt;/p&gt;

&lt;p&gt;Poderiam ter criado uma Interface especial que só pelo fato de dizer que sua
a Classe à implementa, o compilador poderia fazer sua mágica.&lt;/p&gt;

&lt;p&gt;Felizmente há possíveis soluções para contornar esse erro no &lt;em&gt;design&lt;/em&gt;, mas se 
pudessemos utilizar propriedades de Objetos delegados como sendo do 
tipo Interface, como sugeri no artigo anterior, seria quase perfeito. Poderíamos
utilizar Injeção de Dependência através dos construtores dos Objetos, inicializando
as instâncias delegadas, que seriam do tipo Interface.&lt;/p&gt;

&lt;p&gt;Com a implementação atual, até podemos utilizar a Injeção de Dependência, 
mas os argumentos deverão ser do tipo Classe e não Interface — isso na maioria dos
casos normais onde queremos utilizar a contagem de referência — 
então o polimorfismo iria ficar por conta da herança de Classes, o que não é muito bem
vindo devido aos problemas já relatados em artigos anteriores.&lt;/p&gt;

&lt;p&gt;O jeito é instanciar as Classes delegadas internamente. O que não é um real problema.&lt;/p&gt;

&lt;p&gt;Se formos pensar bem, todos os métodos de Implementação das Interfaces deveriam ser 
implementas dentro do Objeto, quando não utilizamos Delegação. Então não estaríamos 
perdendo muito, apenas estamos deixando de ganhar mais.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/interfaces-delegacao-problemas-solucoes/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/interfaces-delegacao-problemas-solucoes/</guid>
      </item>
    
      <item>
        <title>Delegação de Implementação de Interfaces</title>
        <description>&lt;p&gt;Existe uma bela &lt;em&gt;feature&lt;/em&gt; na linguagem &lt;em&gt;Object Pascal&lt;/em&gt;
que nem todos sabem que existem. Aqueles que sabem pouco
utilizam e, talvez, não tenham percebido o potencial dessa 
&lt;em&gt;feature&lt;/em&gt; para a implementação da Orientação a Objetos
numa linguagem de programação.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1451650645557-62193a7bed6a.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A bela &lt;em&gt;feature&lt;/em&gt; que existe no &lt;em&gt;Object Pascal&lt;/em&gt; e que — até onde
eu sei — não existe em nenhuma outra linguagem de programação chama-se
&lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Seattle/en/Using_Implements_for_Delegation&quot;&gt;Delegation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Java não tem.&lt;/p&gt;

&lt;p&gt;Ruby não tem.&lt;/p&gt;

&lt;p&gt;C# não tem.&lt;/p&gt;

&lt;p&gt;Os engenheiros da linguagem C# utilizaram a mesma nomenclatura 
para implementar o que nós — Programadores &lt;em&gt;Object Pascal&lt;/em&gt; — 
damos o nome de Eventos. 
Um ponteiro para um Método é uma implementação para um Evento, 
mas em C# eles deram o nome de
&lt;a href=&quot;https://msdn.microsoft.com/library/900fyy8e.aspx&quot;&gt;&lt;em&gt;delegates&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Você verá porque essa &lt;em&gt;feature&lt;/em&gt; é tão importante para implementarmos
um Objeto da forma mais fiel possível a 
&lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidade real&lt;/a&gt;
que ele representa.&lt;/p&gt;

&lt;p&gt;Verá que é possível escrever menos e ainda deixar o código mais 
flexível para implementações de &lt;strong&gt;comportamentos dinâmicos&lt;/strong&gt;, 
utilizando a composição de Objetos.&lt;/p&gt;

&lt;h2 id=&quot;delegation--implements&quot;&gt;Delegation / Implements&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Delegation&lt;/em&gt; no &lt;em&gt;Object Pascal&lt;/em&gt; também pode ser conhecido pela
palavra &lt;em&gt;Implements&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ambas as nomenclaturas estão corretas.
Sendo &lt;em&gt;delegation&lt;/em&gt; a técnica e &lt;em&gt;implements&lt;/em&gt; a palavra-reservada
que a implementa.&lt;/p&gt;

&lt;p&gt;Essa &lt;em&gt;feature&lt;/em&gt; existe na linguagem &lt;em&gt;Object Pascal&lt;/em&gt; desde sempre e
seu objetivo é a &lt;strong&gt;delegação de implementação de Interfaces, 
utilizando Composição de Objetos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A anos atrás eu só codificava utilizando o 
&lt;a href=&quot;/posts/procedural-e-facil-orientado-a-objetos-e-dificil/&quot;&gt;paradigma Procedural&lt;/a&gt;
então eu apenas ignorava essa &lt;em&gt;feature&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas antes de começarmos a utilizar &lt;em&gt;Delegation&lt;/em&gt;, precisamos pensar
em Contextos.&lt;/p&gt;

&lt;h2 id=&quot;contextos&quot;&gt;Contextos&lt;/h2&gt;

&lt;p&gt;Já falei muito sobre Contextos em &lt;a href=&quot;/archive/&quot;&gt;artigos anteriores&lt;/a&gt;.
Um &lt;em&gt;software&lt;/em&gt; deve ser codificado utilizando Contextos. Cada Contexto
é um agrupamento de ideias, Classes, Objetos, Regras de Negócio, etc.&lt;/p&gt;

&lt;p&gt;No &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-driven_design&quot;&gt;DDD&lt;/a&gt; 
dá-se o nome de 
&lt;a href=&quot;http://martinfowler.com/bliki/BoundedContext.html&quot;&gt;Bounded Context&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bounded Context é um conceito muito importante do DDD e pode ser a 
solução para a boa modelagem do seu domínio. Bounded Context é um 
conceito tão importante quanto o entendimento da separação de 
responsabilidades das camadas do DDD. — Google search&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em termos práticos, isso quer dizer o seguinte:&lt;/p&gt;

&lt;p&gt;Imagine que você tem uma Entidade &lt;code&gt;Client&lt;/code&gt;. Um &lt;code&gt;Client&lt;/code&gt; teria Regras de
Negócio de acessos mas também teria Regras de Negócio sobre suas Finanças,
considerando um sistema hipotético.&lt;/p&gt;

&lt;p&gt;Se cada Classe deve
&lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/&quot;&gt;representar apenas uma responsabilidade&lt;/a&gt;,
como construir um Objeto que A) tenha Regras de Acesso e B) tenha Regras de Finanças ao mesmo tempo?&lt;/p&gt;

&lt;p&gt;Por agora, a resposta é: Você &lt;strong&gt;não&lt;/strong&gt; deve fazer isso.&lt;/p&gt;

&lt;p&gt;Por quê não?&lt;/p&gt;

&lt;p&gt;Bem, se você tem uma Interface &lt;code&gt;IFinances&lt;/code&gt; e outra &lt;code&gt;IAccess&lt;/code&gt;, por exemplo,
e tivesse que implementar os métodos de ambas numa única Classe, você 
estaria quebrando a regra de &lt;strong&gt;Implementar apenas uma Responsabilidade&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A Classe ficaria “inchada”. Métodos demais. Responsabilidades demais.&lt;/p&gt;

&lt;p&gt;Se daqui a algumas semanas tivesse que acrescentar outras regras, ou seja,
implementar outra Interface… imagine onde isso iria parar! 
A manutenção ficaria extremamente comprometida.&lt;/p&gt;

&lt;p&gt;A maneira mais eficaz e segura é implementar Classes diferentes para
cada Contexto, mas que representem a mesma Entidade.&lt;/p&gt;

&lt;p&gt;Utilizando o exemplo acima teríamos que implementar as Classes:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;TClientFinances (IFinances)&lt;/li&gt;
  &lt;li&gt;TClientAccess (IAccess)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ambas as Classes representam um &lt;code&gt;Client&lt;/code&gt;, porém em Contextos diferentes,
com Métodos diferentes.&lt;/p&gt;

&lt;p&gt;E esse tipo de implementação funciona em qualquer linguagem com suporte a
Orientação a Objetos.&lt;/p&gt;

&lt;p&gt;Eu gosto disso. Gosto de ter soluções simples que funcionam em (quase)
qualquer linguagem, sem precisar utilizar &lt;em&gt;features&lt;/em&gt; específicas de
cada linguagem.&lt;/p&gt;

&lt;p&gt;No entanto…&lt;/p&gt;

&lt;p&gt;Nem todo Objeto é tão simples. Há casos em que Objetos mais complexos
podem simplificar o código, pois se a complexidade está dentro do Objeto
mas seu uso é simples, então vale a pena, certo?&lt;/p&gt;

&lt;p&gt;Então digamos que gostaríamos de ter um Objeto que representasse
&lt;code&gt;Finances&lt;/code&gt; mas também &lt;code&gt;Access&lt;/code&gt;, por algum motivo, mas sem quebrar a 
regra da responsabilidade única.&lt;/p&gt;

&lt;h2 id=&quot;o-problema&quot;&gt;O Problema&lt;/h2&gt;

&lt;p&gt;Vou definir alguns Métodos simples para ambas as Interfaces.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IFinances = interface
    function Current: Currency; // total no banco
    function AsString: string;
  end;
  
  IAccess = interface
    function List: IDataList; // lista de acessos
    function AsString: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se tivéssemos uma Classe que implementa ambas as Interfaces, 
teríamos algo como:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  TSuperClient = class(TInterfacedObject, IFinances, IAccess)
  public
    function Current: Currency;
    function List: IDataList;
    function IFinances.AsString: string;
    function IAccess.AsString: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que com apenas duas Interfaces simples já temos 4 métodos
que não são nada coesos numa única Classe. Ainda tem o fato de 
ambas as Classes possuirem Métodos iguais, então, se for preciso
representar as Interfaces como &lt;code&gt;String&lt;/code&gt;, é necessário definir um
prefixo com o nome da Interface.&lt;/p&gt;

&lt;h2 id=&quot;como-utilizar-a-delegacao&quot;&gt;Como utilizar a Delegação&lt;/h2&gt;

&lt;p&gt;Para utilizarmos &lt;em&gt;Delegation&lt;/em&gt;, primeiro precisamos definir os
reais Objetos que representam as Interfaces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TSimpleFinances = class(TInterfacedObject, IFinances)
  public
    construtor ...
    function Current: Currency;
    function AsString: string;
  end;
  
  TSimpleAccess = class(TInterfacedObject, IAccess)
  public
    construtor ...
    function List: IDataList;
    function AsString: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essas são Classes que implementam, de forma genérica, as Interfaces 
acima.&lt;/p&gt;

&lt;p&gt;Agora podemos implementar uma Classe que represente um &lt;code&gt;Client&lt;/code&gt;
dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  TTheClient = class(TInterfacedObject, IFinances, IAccess)
  private
    FFinances: IFinances;
    FAccess: IAccess;
    property Finances: IFinances read FFinances implements IFinances;
    property Access: IAccess read FAccess implements IAccess;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja agora que &lt;code&gt;TTheClient&lt;/code&gt; não implementa mais os Métodos de ambas as
Interfaces, ele &lt;strong&gt;delega&lt;/strong&gt; para outras Classes, especialistas no assunto!&lt;/p&gt;

&lt;p&gt;No entanto &lt;code&gt;TTheClient&lt;/code&gt; pode ser 
&lt;a href=&quot;/posts/interfaces-em-todo-lugar/#interfaces-sao-contratos&quot;&gt;contratado&lt;/a&gt;
para trabalhar em qualquer especialidade definida pelas Interfaces que ele 
implementa (por delegação).&lt;/p&gt;

&lt;p&gt;Veja que ambas as propriedades são privadas. Sim. Você irá trabalhar com 
&lt;code&gt;TTheClient&lt;/code&gt; instanciando um tipo de Interface. Você não deve trabalhar com 
a Classe diretamente. Sempre trabalhe com o(s) tipo(s) da(s) Interface(s) 
que a Classe representa.&lt;/p&gt;

&lt;p&gt;As possibilidades de evolução do código com essa técnica são muitas. Por exemplo.
Agora que temos a Classe genérica (simples) &lt;code&gt;TSimpleFinances&lt;/code&gt;, ela pode ser 
reutilizada por outras Classes, similares a &lt;code&gt;TTheClient&lt;/code&gt;, apenas definindo 
uma propriedade. Essas Classes deverão possuir construtores que as inicialize
de acordo com as Classes que as consome. Por exemplo, &lt;code&gt;TSimpleFinances&lt;/code&gt; poderia
ser inicializa com o &lt;code&gt;ID&lt;/code&gt; do Client ou algum outro identificador.&lt;/p&gt;

&lt;p&gt;Outra possibilidade: A Classe &lt;code&gt;TTheClient&lt;/code&gt; pode ter em seu construtor um argumento do
tipo &lt;code&gt;IFinances&lt;/code&gt;, indicando que ela pode ser inicializada com qualquer tipo de
Classe que implemente &lt;code&gt;IFinances&lt;/code&gt;, inicializando, assim, o atributo &lt;code&gt;FFinances&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Conseguimos fazer isso em &lt;em&gt;Object Pascal&lt;/em&gt;, mas parece que a maioria prefere
definir Classes com 30 métodos do tipo Getter/Setter ou adicionam 40 Métodos numa
Classe do tipo &lt;code&gt;TDataModule&lt;/code&gt; e acham que estão programando Orientado a Objetos e
reutilizando código.&lt;/p&gt;

&lt;p&gt;Temos as ferramentas para programar melhor, mas é preciso olhar “fora da caixa”.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/delegacao-de-implementacao-de-interfaces/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/delegacao-de-implementacao-de-interfaces/</guid>
      </item>
    
      <item>
        <title>Linhas em Branco no Método é um Mal Cheiro no Código</title>
        <description>&lt;p&gt;Pular linhas dentro de um Método é um “mal cheiro”
no código. Significa que você está fazendo coisas 
demais num único Método.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1417309807426-472e833fa5d0.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O que significa mal cheiro no código?&lt;/p&gt;

&lt;p&gt;Um &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_smell&quot;&gt;mal cheiro&lt;/a&gt;,
se refere a qualquer sintoma no código-fonte 
de um programa que possivelmente indica um problema 
mais profundo.&lt;/p&gt;

&lt;p&gt;Eu já falei sobre isso
&lt;a href=&quot;/posts/pensando-em-objetos/#exemplo-1&quot;&gt;aqui&lt;/a&gt;
e nesse artigo vou abordar melhor esse assunto.&lt;/p&gt;

&lt;p&gt;Você irá entender porque não devemos utilizar 
linhas em branco dentro de Métodos.&lt;/p&gt;

&lt;h2 id=&quot;blocos-de-cdigo&quot;&gt;Blocos de Código&lt;/h2&gt;

&lt;p&gt;Por que muitos programadores ainda utilizam linhas em
branco dentro de Métodos?&lt;/p&gt;

&lt;p&gt;Simples. Eles estão separando o código de um Método
em blocos. E isso é, errado.&lt;/p&gt;

&lt;p&gt;Eu mesmo fiz isso por anos.&lt;/p&gt;

&lt;p&gt;Algumas vezes eu conseguia enxergar esse mal cheiro, então 
refatorava — criando outros Métodos — e seguia a vida.&lt;/p&gt;

&lt;p&gt;Mas na maioria das vezes eu pensava que estava “organizando o código”.
Tornando mais legível, mas “limpo”… não era verdade.&lt;/p&gt;

&lt;p&gt;Quando li esse
&lt;a href=&quot;http://www.yegor256.com/2014/11/03/empty-line-code-smell.html&quot;&gt;artigo&lt;/a&gt;
eu percebi que sempre houve algo de errado quando eu
utiliza linhas em branco.&lt;/p&gt;

&lt;p&gt;Quando existem linhas em branco dentro do Método,
significa que &lt;strong&gt;o Método está fazendo coisas demais&lt;/strong&gt;.
Um único grande procedimento, separado por com blocos 
de código…&lt;/p&gt;

&lt;p&gt;Desde então eu não codifico mais dessa forma.&lt;/p&gt;

&lt;h2 id=&quot;nao-seja-leviano&quot;&gt;Não basta retirar as Linhas em Branco&lt;/h2&gt;

&lt;p&gt;Você entendeu o problema e agora quer abrir seu editor
e começar a remover as linhas em branco… apenas remover
as linhas.&lt;/p&gt;

&lt;p&gt;Não seja leviano.&lt;/p&gt;

&lt;p&gt;Não basta abrir seu editor e começar a remover toda
linha em branco que encontrar dentro dos Métodos.&lt;/p&gt;

&lt;p&gt;Não!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A linha em branco não é o problema em si. 
Ela só indica que há um problema&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Apenas retirar essas linhas não vai sanar o problema.&lt;/p&gt;

&lt;p&gt;O que temos que fazer é &lt;strong&gt;refatorar&lt;/strong&gt; o código,
para depois removê-las.&lt;/p&gt;

&lt;h2 id=&quot;refatorando&quot;&gt;Refatorando&lt;/h2&gt;

&lt;p&gt;Se você realmente entendeu o conceito, não irá mais utilizar
linhas em branco dentro de Métodos de agora em diante.&lt;/p&gt;

&lt;p&gt;Certo?&lt;/p&gt;

&lt;p&gt;Mas você pode ir além. Você pode querer refatorar todo tipo
de código antigo ou fazer uma refatoração &lt;em&gt;on demand&lt;/em&gt;:
Refatorar apenas se encontrar Métodos com linhas em branco.&lt;/p&gt;

&lt;p&gt;Você pode seguir esses passos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Encontre um Método;&lt;/li&gt;
  &lt;li&gt;Verifique se há linhas em branco separando blocos;&lt;/li&gt;
  &lt;li&gt;Para cada bloco, extrair o código criando um novo Método;&lt;/li&gt;
  &lt;li&gt;Faça a chamada do novo Método no mesmo lugar que extraiu
  o código;&lt;/li&gt;
  &lt;li&gt;Repita o processo enquanto for necessário.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Parece besteira, mas não é.&lt;/p&gt;

&lt;p&gt;Escrever código qualquer um faz. Mas escrever um &lt;strong&gt;bom&lt;/strong&gt; código, 
no entanto, não é pra qualquer um. É necessário pensar no
longo prazo, no acoplamento, na coesão, no &lt;em&gt;design&lt;/em&gt;, deixar 
as coisas simples… é Engenharia, mas também Arte.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E a verdadeira Arte está nos detalhes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Sep 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/linhas-em-branco-no-metodo-e-mal-cheiro/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/linhas-em-branco-no-metodo-e-mal-cheiro/</guid>
      </item>
    
  </channel>
</rss>
