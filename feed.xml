<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Records - Antiga Nova Tecnologia</title>
        <description>&lt;p&gt;O tipo Record pode ter métodos e até mesmo campos privados. Seria isso considerado uma abominação para um código Orientado a Objetos?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/alvaro-reyes-517391-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Alvaro Reyes on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Na programação Orientada a Objetos, utilizamos objetos.&lt;/p&gt;

&lt;p&gt;Se você precisasse de um objeto para representar os &lt;em&gt;dados&lt;/em&gt; de um usuário, apenas login, password e nome, como seria a definição da classe?&lt;/p&gt;

&lt;p&gt;Vamos tentar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TUserData = class
private
  fLogin: string;
  fPassword: string;
  fName: string;
public
  property Login: string read fLogin write fLogin;
  property Password: string read fPassword write fPassword;
  property Name: string read fName write fName;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse seria um estilo de implementação que podemos ver em muitos sistemas que se dizem ser Orientados a Objetos.&lt;/p&gt;

&lt;p&gt;No entanto, essa classe irá gerar “objetos” que são mais conhecidos como DTO (Data Transfer Object) o que, por definição, é um conceito errado.&lt;/p&gt;

&lt;p&gt;Objetos não são &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/#objeto-nao-e-um-balde-de-funcoes-e-dados&quot;&gt;“baldes de dados”&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Objetos verdadeiros possuem comportamento e &lt;a href=&quot;/encapsulamento&quot;&gt;encapsulam&lt;/a&gt; dados e/ou outros objetos em seu interior. O que está encapsulado não deveria ser visível ou acessado diretamente por outro objeto externo.&lt;/p&gt;

&lt;p&gt;Essa é a &lt;em&gt;teoria&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas, e se no contexto do seu sistema você realmente não necessitasse de nenhum método para representar os dados de um usuário?&lt;/p&gt;

&lt;p&gt;Por muito tempo eu tenho utilizado objetos para tudo, até mesmo para representar dados, mas sem utilizar objetos anêmicos como esse, no entanto.&lt;/p&gt;

&lt;p&gt;Para representar os dados acima, eu utilizaria a técnica do &lt;a href=&quot;/posts/diga-me-algo-sobre-voce/#metodo-about&quot;&gt;Método About()&lt;/a&gt;, que iria retornar um XML ou JSON, conforme explicado em 2016…&lt;/p&gt;

&lt;p&gt;Há vantagens nessa técnica como ter uma única interface que qualquer classe possa implementar para retornar um XML/JSON. Mas também há desvantagens, como não haver checagem estática do compilador e o &lt;em&gt;overhead&lt;/em&gt; em “montar/desmontar” o &lt;em&gt;stream&lt;/em&gt; se houver a necessidade de repassar a informação por uma cadeia de objetos.&lt;/p&gt;

&lt;p&gt;Nesses ~2 anos, eu diria que muita coisa mudou.&lt;/p&gt;

&lt;p&gt;Estou trabalhando em alguns projetos que necessitam de extrema velocidade de processamento, mas nem por isso eles são menos Orientados a Objetos.&lt;/p&gt;

&lt;p&gt;Como?&lt;/p&gt;

&lt;p&gt;Redescobrindo o tipo Record.&lt;/p&gt;

&lt;p&gt;Mas antes eu quero lhe contar por quê eu neglicenciei os Records por muito tempo.&lt;/p&gt;

&lt;p&gt;Bem, Records existem desde o Turbo Pascal. Eles representam uma estrutura de dados. Você define uma estrutura e depois define &lt;em&gt;procedures&lt;/em&gt; e &lt;em&gt;functions&lt;/em&gt; para trabalhar com as estruturas — como ainda fazemos na linguagem C.&lt;/p&gt;

&lt;p&gt;Na Orientação a Objetos, nós unimos comportamento aos dados num único artefato chamado objeto.&lt;/p&gt;

&lt;p&gt;Então, a ideia de ter um Record com todos os seus dados públicos e funções “soltas” que o utilizam, implementadas muitas vezes em Unidades diferentes, me soa muito “anti-objeto”, muito anti-encapsulamento.&lt;/p&gt;

&lt;p&gt;Records, dessa forma, são estruturas para programas procedurais.&lt;/p&gt;

&lt;p&gt;Mas, já faz uns anos que os arquitetos da linguagem Object Pascal introduziram métodos em Records.&lt;/p&gt;

&lt;p&gt;Sim, métodos, em Records.&lt;/p&gt;

&lt;p&gt;Quando eu li isso pela primeira vez, achei que os arquitetos tinham ficado loucos. Métodos em Records? Qual o sentido? Já temos objetos, não precisamos de Records com métodos. Isso não faz o menor sentido! — eu pensava.&lt;/p&gt;

&lt;p&gt;Entretanto, hoje em dia, Records podem ter métodos e eles podem ser até mesmo privados, assim como ter &lt;em&gt;fields&lt;/em&gt; privados!&lt;/p&gt;

&lt;p&gt;Ora, não é isso um objeto?&lt;/p&gt;

&lt;p&gt;Não.&lt;/p&gt;

&lt;p&gt;Então, não seria melhor utilizar um objeto?&lt;/p&gt;

&lt;p&gt;Depende.&lt;/p&gt;

&lt;p&gt;Records são estruturas de dados — mesmo que eles tenham métodos — e deveria ser utilizados como tal.&lt;/p&gt;

&lt;p&gt;Records são alocados automaticamente pelo compilador na área de memória &lt;em&gt;stack&lt;/em&gt;, ao invés da área de memória &lt;em&gt;heap&lt;/em&gt;, como fazem os objetos. Utilizar o &lt;em&gt;stack&lt;/em&gt; é mais rápido e mais simples para o compilador gerenciar a memória.&lt;/p&gt;

&lt;p&gt;Então, se você necessita representar &lt;em&gt;apenas&lt;/em&gt; dados, Record é a melhor opção.&lt;/p&gt;

&lt;p&gt;Records não podem utilizar herança e muito menos implementar uma interface, então não há polimorfismo — lembre-se, são apenas dados.&lt;/p&gt;

&lt;p&gt;Então, se você necessita de polimorfismo e comportamento, objeto é a melhor opção.&lt;/p&gt;

&lt;p&gt;Dito isso, por quê métodos em Records pode mudar a maneira em como utilizamos Records em programas Orientados a Objetos?&lt;/p&gt;

&lt;p&gt;Quando declaramos um Record, seus campos não são inicializados, como acontece com os atributos de um objeto. Então, podemos definir um método para iniciá-lo, sem ter que fazer isso externamente — mesmo que seus campos sejam públicos — encapsulando a inicialização dos campos na própria estrutura de dados:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TUserData = record
  login: string;
  password: string;
  name: string;
  procedure Init;
end;

procedure TUserData.Init;
begin
  login := &#39;&#39;;
  password := &#39;&#39;;
  name := &#39;&#39;;
end;

var
  u: TUserData;
begin
  u.Init;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outra opção é utilizar a função &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/default.html&quot;&gt;Default()&lt;/a&gt; mas o importante é que você tem a opção de fazer o que quiser no procedimento que será como um construtor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TUserData.Init;
begin
  Default(self);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se o &lt;em&gt;password&lt;/em&gt; precisar ser criptografado/descriptografado, você não precisa de funções externas para isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TUserData.EncryptedPassword: string;
begin
  result := &#39;&amp;lt;using some algorithm to encrypt&amp;gt;&#39;;
end;

function TUserData.DecryptedPassword: string;
begin
  result := &#39;&amp;lt;using some algorithm to decrypt&amp;gt;&#39;;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Existem algumas regras a seguir:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Não implemente métodos que se comportem como objetos, ou seja, trabalhe &lt;em&gt;apenas&lt;/em&gt; com os dados do Record, transformando-os;&lt;/li&gt;
  &lt;li&gt;Não retorne instâncias de objetos em seus métodos, com exceção de instâncias de interfaces, mas evite a todo custo;&lt;/li&gt;
  &lt;li&gt;Só utilize campos com tipos primitivos ou gerenciados (ex: strings, Variant, etc), nunca instâncias de objetos;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Faça isso e você estará seguro.&lt;/p&gt;

&lt;p&gt;Seu código não será considerado menos Orientado a Objetos por estar utilizando estruturas de dados que representam dados. Records foram criados exatamente para isso e a implementação de métodos apenas facilitaram seu uso.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Oct 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/records-antiga-nova-tecnologia</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/records-antiga-nova-tecnologia</guid>
      </item>
    
      <item>
        <title>Builder Classes Simplificado</title>
        <description>&lt;p&gt;O padrão Builder utiliza no mínimo 2 classes: 1 classe para instância a ser construída e 1 classe para a instância construtora.&lt;/p&gt;

&lt;p&gt;Nesse artigo irei utilizar um Builder simplificado, que irá utilizar a mesma classe tanto para construir como para representar a instância final.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/christopher-burns-360244-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Christopher Burns on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;O padrão &lt;a href=&quot;https://en.wikipedia.org/wiki/Builder_pattern&quot;&gt;Builder&lt;/a&gt; já é muito conhecido e utilizado mundo afora.&lt;/p&gt;

&lt;p&gt;Esse artigo não tem a pretensão de ensiná-lo para que serve esse padrão — há milhares de artigos sobre isso na Internet, com implementação em várias linguagens diferentes.&lt;/p&gt;

&lt;p&gt;No entanto, um bom resumo é encontrado na Wikipedia:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Separar a construção de um objeto complexo da sua representação de modo que o mesmo processo de construção possa criar diferentes representações.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Como podemos ver nos exemplos em C# da Wikipedia, foi utilizado uma classe &lt;code&gt;Car&lt;/code&gt; e uma interface &lt;code&gt;ICarBuilder&lt;/code&gt;. Depois, temos uma implementação dessa interface com a definição da classe &lt;code&gt;FerrariBuilder&lt;/code&gt; e, finalmente, outra classe para customizar a Ferrari chamada &lt;code&gt;SportsCarBuildDirector&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Podemos simplificar esse exemplo?&lt;/p&gt;

&lt;p&gt;Primeiramente, &lt;code&gt;Car&lt;/code&gt; poderia ser uma interface &lt;code&gt;ICar&lt;/code&gt; e não uma classe. Então, poderíamos ter a classe &lt;code&gt;TFerrari&lt;/code&gt; que implementa &lt;code&gt;ICar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Na minha opinião, o único &lt;code&gt;Builder&lt;/code&gt; do exemplo é a classe &lt;code&gt;TSportsCarBuildDirector&lt;/code&gt; que customiza uma Ferrari para diretores. No entanto, eu também não concordo com sua existência e acho que podemos simplificar ainda mais esse exemplo — veja mais abaixo.&lt;/p&gt;

&lt;p&gt;Vamos começar pela primeira interface, mantendo-a &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, retornando tipos primitivos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ICar = interface
  function Model: string;
  function NumDoors: Integer;
  function Color: TColor;
  procedure Run;
end;      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depois, codificamos a classe &lt;code&gt;TFerrari&lt;/code&gt;, que implementa &lt;code&gt;ICar&lt;/code&gt;. Veja que essa classe não é um Builder, mas sim apenas uma classe comum.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TFerrari = class(TInterfacedObject, ICar)
private
  fModel: string;
  fNumDoors: Integer;
  fColor: TColor;
public
  constructor Create(const aModel: string;
    aNumDoors: Integer; aColor: TColor);
  function Model: string;
  function NumDoors: Integer;
  function Color: TColor;
  procedure Run;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como disse acima, não acho necessidade de haver um &lt;code&gt;Builder&lt;/code&gt; chamado &lt;code&gt;TSportsCarBuildDirector&lt;/code&gt;. Para implementar essa classe seria necessário implementar uma nova interface &lt;code&gt;ICarBuilder&lt;/code&gt; além da própria classe, o que seria desnecessário.&lt;/p&gt;

&lt;p&gt;Podemos simplificar esse exemplo utilizando &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/&quot;&gt;herança&lt;/a&gt; dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TDirectorSportCar = class(TFerrari)
public
  constructor Create(aColor: TColor); reintroduce;
end;

constructor TDirectorSportCar.Create(aColor: TColor);
begin
  inherited Create(&#39;488 Spider&#39;, 2, aColor);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Acabamos de criar um Builder mas utilizando a própria classe que irá representar um &lt;code&gt;ICar&lt;/code&gt;, ou seja, a &lt;code&gt;TDirectorSportCar&lt;/code&gt;. Não precisamos de mais uma interface abstrata como &lt;code&gt;ICarBuilder&lt;/code&gt; ou sua implementação.&lt;/p&gt;

&lt;p&gt;Para demonstrar o código, poderíamos ter algo assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure DoSomethingWithCars;
var
  car: ICar;
begin
  car := TDirectorSportCar.Create(clRed);
  car.Run;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sem Builders (aparentes), sem o método “Construct”, sem o método “GetResult”, e utilizando objetos &lt;a href=&quot;/posts/objetos-imutaveis/&quot;&gt;imutáveis&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/builder-classes-simplificado</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/builder-classes-simplificado</guid>
      </item>
    
      <item>
        <title>Como Transformar uma Instância de Classe em Instância de Interface</title>
        <description>&lt;p&gt;E se a linguagem Object Pascal nos permitisse codificar uma instância de classe que se auto destrói quando não mais precisamos dela?&lt;/p&gt;

&lt;p&gt;É possível transformar uma instância de classe para se comportar como uma instância de interface?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/julie-north-720719-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Julie North on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Há alguns dias eu acompanhei alguns desenvolvedores solicitarem algumas “novas features” para o compilador Free Pascal..&lt;/p&gt;

&lt;p&gt;Uma dessas features é a possibilidade de fazer um &lt;em&gt;“auto free”&lt;/em&gt; de uma instância de classe. Sim, como no Java ou C#, onde um objeto do tipo de uma classe é liberado automaticamente quando a VM acha que deve fazê-lo.&lt;/p&gt;

&lt;p&gt;No entanto, devemos lembrar dos princípios da linguagem Object Pascal antes de solicitar tais mudanças. A linguagem Object Pascal não possui uma VM, portanto não temos um “robozinho” para ficar monitorando nossos objetos. Devemos liberar nossos objetos “manualmente” chamando &lt;code&gt;obj.Free&lt;/code&gt; na maioria dos casos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/simplicidade/&quot;&gt;Simples&lt;/a&gt; e eficiente.&lt;/p&gt;

&lt;p&gt;Mas eu posso entender o motivo de tal solicitação: É muito cômodo declarar objetos sem se preocupar em liberá-los da memória… e eu tenho feito isso há anos utilizando a “técnica” do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt; em conjunto com instâncias de interfaces.&lt;/p&gt;

&lt;p&gt;O tipo de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;interface&lt;/a&gt; é liberado automaticamente pelo compilador quando a variável sai do escopo. Mas isso não existe para instâncias de classe, proposto no pedido da nova feature.&lt;/p&gt;

&lt;p&gt;Então, se houvesse um jeito de liberar automaticamente as instâncias de classes, “convertendo-as” em instâncias de interfaces, sem utilizar nenhum tipo de &lt;a href=&quot;/posts/nao-utilize-casting/&quot;&gt;casting&lt;/a&gt;, teríamos a liberação automática sem que fosse necessária alterações no compilador.&lt;/p&gt;

&lt;p&gt;Bem, o que vou lhe apresentar agora pode já estar sendo utilizando por muitos desenvolvedores ao redor do mundo, e é algo tão simples que podemos até mesmo substituir o &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt; — tão difundido na comunidade brasileira e mundo afora — por essa simples “técnica” que mostrarei mais abaixo.&lt;/p&gt;

&lt;p&gt;Mas antes, o que há de errado com o &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Esse método foi criado com o intuito de implementar a liberação automática da instância, sem haver a necessidade de declarar uma variável local para incrementar a contagem de referência.&lt;/p&gt;

&lt;p&gt;Funciona.&lt;/p&gt;

&lt;p&gt;No entanto, há alguns problemas com essa abordagem.&lt;/p&gt;

&lt;p&gt;Primeiro, ele é um método estático da classe. Deveríamos &lt;del&gt;não utilizar&lt;/del&gt; evitar métodos de classe a todo custo, dando [preferência] em utilizar instâncias de interfaces, onde não existem métodos estáticos.&lt;/p&gt;

&lt;p&gt;Segundo, é redundante ter que codificar sempre os mesmos parâmetros da(s) mesma(s) assinatura do(s) construtor(es). Isso, além de ser no mínimo chato, é um pouco custoso para a manutenção pois (quase sempre) haverá 2 lugares para alterar os argumentos.&lt;/p&gt;

&lt;p&gt;Terceiro, o método não impede que um programador que não conheça a técnica, chame diretamente o construtor da classe, &lt;em&gt;by passing&lt;/em&gt; o método estático. Isso pode gerar &lt;em&gt;memory leaks&lt;/em&gt;, como já foi explicado em alguns outros artigos aqui do blog.&lt;/p&gt;

&lt;p&gt;Embora haja todos esses problemas, a utilização do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt; se mostrou eficiente, melhorando e simplificando a base de código em muitos projetos.&lt;/p&gt;

&lt;p&gt;Entretanto, a técnica a seguir traz todas as vantagens do &lt;code&gt;New&lt;/code&gt; porém sem as desvantagens.&lt;/p&gt;

&lt;p&gt;Você pode fazer essa “mágica” adicionando mais um método na classe.&lt;/p&gt;

&lt;p&gt;Eu o chamo de Método &lt;code&gt;Ref&lt;/code&gt;, que significa &lt;em&gt;reference for&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TFoo.Ref: ISomething;
begin
  result := self;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sim, é só isso.&lt;/p&gt;

&lt;p&gt;Um método que retorna &lt;code&gt;self&lt;/code&gt;, sendo o tipo do retorno a interface que a classe implementa.&lt;/p&gt;

&lt;p&gt;Diferentemente do &lt;code&gt;New&lt;/code&gt;, o método &lt;code&gt;Ref&lt;/code&gt; não é estático e não duplica a assinatura do(s) construtor(s), eliminando as primeiras duas desvantagens.&lt;/p&gt;

&lt;p&gt;Sim, há a possibilidade do desenvolvedor esquecer de utilizá-lo ao chamar o construtor da classe diretamente ao invés do &lt;code&gt;New&lt;/code&gt;e isso poderia ocasionar &lt;em&gt;memory leaks&lt;/em&gt;. Mas sua vantagem é que você tem a &lt;em&gt;opção&lt;/em&gt; em não utilizá-lo para aumentar a performance na criação dos objetos &lt;em&gt;by passing&lt;/em&gt; um método de classe (o método &lt;code&gt;New&lt;/code&gt;) antes de chegar ao construtor, ganhando, talvez, alguns milionésimos de segundos.&lt;/p&gt;

&lt;p&gt;Veja um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure DoIt;
begin
  TFoo.Create(TBar.Create).Ref.Execute;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se ambas as classes implementam interfaces, temos a possibilidade de não utilizar &lt;code&gt;Ref&lt;/code&gt; no argumento do construtor de &lt;code&gt;TFoo&lt;/code&gt;, chamando apenas o construtor de &lt;code&gt;TBar&lt;/code&gt;. Mas, somos “obrigados” a utilizar &lt;code&gt;Ref&lt;/code&gt; na chamada mais externa para executar algum método da interface que &lt;code&gt;TFoo&lt;/code&gt; implementa, afim de evitar &lt;em&gt;memory leaks&lt;/em&gt;, pois não há nenhuma variável (local) para receber a instância da interface.&lt;/p&gt;

&lt;p&gt;Agora você deve estar se perguntando, o que isso tem have com o título do artigo?&lt;/p&gt;

&lt;p&gt;Tudo.&lt;/p&gt;

&lt;p&gt;É padrão da linguagem que, ao trabalharmos com instâncias de interfaces, o compilador utilize um contador de referências para saber quando destruir um objeto, liberando a memória alocada.&lt;/p&gt;

&lt;p&gt;Então, se você criar um objeto do tipo de classe e depois utilizar o método &lt;code&gt;Ref&lt;/code&gt; ou apenas atribuir a instância a uma variável do tipo interface, você irá “transformar” sua instância de classe em instância de interface, ganhando a contagem de referência e a auto destruição do objeto… de graça.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo completo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program Project1;

{$mode delphi}

uses
  SysUtils,
  Classes;

type
  IFoo = interface
  [&#39;{1D26066C-984B-4632-95B2-B25253AF149E}&#39;]
    procedure ShowMsg;
  end;

type
  TFoo = class(TInterfacedObject, IFoo)
  private
    fText: string;
  public
    constructor Create(const aText: string);
    destructor Destroy; override;
    function Ref: IFoo;
    procedure ShowMsg;
  end;

{ TFoo }

constructor TFoo.Create(const aText: string);
begin
  inherited Create;
  fText := aText;
  writeln(&#39;Creating &#39;+ FRefCount.ToString);
end;

destructor TFoo.Destroy;
begin
  writeln(&#39;Destroing &#39; + FRefCount.ToString);
  inherited Destroy;
end;

function TFoo.Ref: IFoo;
begin
  result := self;
end;

procedure TFoo.ShowMsg;
begin
  writeln(fText);
end;

var
  f: TFoo; // class, not an interface
begin
  f := TFoo.Create(&#39;teste&#39;);
  f.Ref.ShowMsg;
  // f.Free; &amp;lt;&amp;lt; you don&#39;t need it
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute o código acima e verá que não existe nenhum &lt;em&gt;memory leak&lt;/em&gt;, mesmo &lt;code&gt;f&lt;/code&gt; sendo do tipo &lt;code&gt;TFoo&lt;/code&gt;, uma classe.&lt;/p&gt;

&lt;p&gt;A mágica acontece quando chamamos &lt;code&gt;Ref&lt;/code&gt;. Ele retorna um tipo de interface que é o próprio objeto &lt;code&gt;self&lt;/code&gt;. Assim, a “nova” instância passa a ter uma contagem de referência e será destruída automaticamente.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
Creating 1
teste
Destroing 0
Heap dump by heaptrc unit of c:\temp\project1.exe
76 memory blocks allocated : 1967/2120
76 memory blocks freed     : 1967/2120
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A linguagem Object Pascal pode parecer simples demais para alguns desenvolvedores (que não conhecem bem a linguagem).&lt;/p&gt;

&lt;p&gt;Alguns dizem que é “apenas uma linguagem para aprendizado” ou que não acompanhou as “novas features” das linguagens mais “modernas”.&lt;/p&gt;

&lt;p&gt;Me diga então, qual linguagem você conhece que nos dá a eficiência em poder liberar nossos objetos no melhor momento que quisermos, mas também ter objetos que se “auto destroem” e ainda conseguir fazer a transição de um tipo para o outro?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Aug 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/metodo-ref</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/metodo-ref</guid>
      </item>
    
      <item>
        <title>Interfaces e Casting</title>
        <description>&lt;p&gt;Seria um anti-padrão verificar se um objeto implementa determinada(s) interface(s)? Seria essa prática considerada o mesmo que &lt;em&gt;casting&lt;/em&gt;?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/stefan-stefancik-257625-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Štefan Štefančík on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Já faz mais de 2 anos que &lt;a href=&quot;/posts/nao-utilize-casting/&quot;&gt;escrevi&lt;/a&gt; que não devemos utilizar casting.&lt;/p&gt;

&lt;p&gt;Essa pode ser uma afirmação difícil de acreditar, se você não por sua mente no contexto certo antes.&lt;/p&gt;

&lt;p&gt;Alguns desenvolvedores tem me perguntado, como é possível fazer uma aplicação sem haver &lt;em&gt;casting&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Bem, em uma aplicação de médio tamanho eu diria que pode ser até difícil, mas não impossível. Entretanto, irá depender do &lt;em&gt;tipo&lt;/em&gt; de casting que estamos tratando.&lt;/p&gt;

&lt;p&gt;Na programação orientada a objetos só haverá objetos. Então vamos esquecer os tipos primitivos. Um cast de uma &lt;em&gt;string&lt;/em&gt; em um &lt;em&gt;Integer&lt;/em&gt;, por exemplo, é algo &lt;em&gt;necessário&lt;/em&gt; em linguagens que possuem tipos primitivos.&lt;/p&gt;

&lt;p&gt;Esse não é o problema.&lt;/p&gt;

&lt;p&gt;O casting a que me refiro é sobre &lt;em&gt;objetos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Passar um parâmetro para um método com o tipo &lt;code&gt;TObject&lt;/code&gt; para, então, fazer um casting interno para outro objeto é como ter um “pré-conceito” sobre o objeto que irá fazer o trabalho.&lt;/p&gt;

&lt;p&gt;O objeto em si não é suficiente?&lt;/p&gt;

&lt;p&gt;Se você está verificando o &lt;em&gt;tipo&lt;/em&gt; do objeto para fazer o trabalho, é pré-conceito.&lt;/p&gt;

&lt;p&gt;Você não confia nele. Você tem sempre que &lt;em&gt;gerenciá-lo&lt;/em&gt;, dizendo quem ele deve &lt;em&gt;representar&lt;/em&gt; em cada parte do código.&lt;/p&gt;

&lt;p&gt;Mas, há alguma maneira de trabalhar com objetos sem utilizar casting?&lt;/p&gt;

&lt;p&gt;O “segredo” está nas &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;. Uma interface é um contrato entre o cliente (sistema) e o trabalhador (objeto).&lt;/p&gt;

&lt;p&gt;No entanto, um objeto pode implementar mais de uma interface, tendo muitas &lt;em&gt;especialidades&lt;/em&gt; por assim dizer.&lt;/p&gt;

&lt;p&gt;Então, é possível que um mesmo objeto possa trabalhar em muitas especialidades diferentes. Mas a única maneira de saber isso é &lt;em&gt;perguntar&lt;/em&gt; ao próprio objeto se ele &lt;em&gt;sabe&lt;/em&gt; fazer o serviço especializado.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/e8312b8e539ac0e1b1baac28be18efe3.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O mesmo empregado pode ser um analista e/ou programador.&lt;/p&gt;

&lt;p&gt;A função &lt;a href=&quot;/supports-traicoeira&quot;&gt;Supports&lt;/a&gt; “pergunta” ao objeto se ele também sabe fazer um “outro trabalho”, determinado pelo “contrato” no segundo parâmetro da função.&lt;/p&gt;

&lt;p&gt;A diferença é sutil, mas importante: Tentar transformar um objeto em outro é equivocado, mas perguntar à ele se tem uma determinada especialidade, não.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 23 Jul 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/interfaces-e-casting</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/interfaces-e-casting</guid>
      </item>
    
      <item>
        <title>Como Trabalhar com Libraries sem Pacotes</title>
        <description>&lt;p&gt;Como seria trabalhar em um projeto que utiliza libraries que não possuem pacotes? Se cada desenvolvedor tiver cópias das libraries em paths diferentes, as configurações do projeto não devem utilizar paths pré-determinados.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/aditya-romansa-117300-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Aditya Romansa on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Pacotes facilitam muito o desenvolvimento, pois eles registram na IDE onde estão o código-fonte de suas libraries. Assim, cada desenvolvedor pode ter suas próprias cópias de libraries salvos em quaisquer pastas em seus computadores.&lt;/p&gt;

&lt;p&gt;Um projeto que utiliza pacotes apenas irá fazer referência à eles e deixará a IDE o trabalho de localizá-los para informar ao compilador os códigos-fontes referentes aos pacotes.&lt;/p&gt;

&lt;p&gt;Mas, e se uma library não possuir pacotes?&lt;/p&gt;

&lt;p&gt;Nesse caso basta adicionarmos o path da library no &lt;em&gt;search path&lt;/em&gt; do projeto. Ao compilarmos, os fontes serão localizados pela IDE.&lt;/p&gt;

&lt;p&gt;Funciona. Porém, se o projeto tiver muitos desenvolvedores, como garantir que todos irão utilizar o mesmo path? Há uma grande possibilidade de haver divergências de paths em projetos colaborativos com mais de um desenvolvedor.&lt;/p&gt;

&lt;p&gt;Desenvolvedores podem utilizar diferentes paths para projetos, componentes e libraries. Cada um organiza seus projetos da forma que achar melhor em seus próprios computadores.&lt;/p&gt;

&lt;p&gt;Um projeto sem pacotes não tem a ajuda da IDE para localizar os fontes. O desenvolvedor deve informar onde eles estão.  Como cada desenvolvedor “gosta” de ter sua própria hierarquia de pastas, como configurar o &lt;em&gt;search path&lt;/em&gt; do projeto?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Macros.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;No Lazarus há &lt;a href=&quot;http://wiki.lazarus.freepascal.org/IDE_Macros_in_paths_and_filenames&quot;&gt;macros&lt;/a&gt; que podem ser interpretadas em &lt;em&gt;run-time&lt;/em&gt; pela IDE.&lt;/p&gt;

&lt;p&gt;A macro que precisamos para resolver o problema de paths é a &lt;code&gt;$Env(name)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Agora, imagine um library chamada &lt;code&gt;DBFast&lt;/code&gt;, &lt;em&gt;sem&lt;/em&gt; pacotes.&lt;/p&gt;

&lt;p&gt;O desenvolvedor José tem a cópia da library em &lt;code&gt;c:\dev\libs\dbfast&lt;/code&gt; enquanto o Márcio tem a mesma library em &lt;code&gt;d:\pascal\components\dbfast&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dois paths bem diferentes para um mesmo projeto.&lt;/p&gt;

&lt;p&gt;Felizmente, utilizando macros a configuração é simplificada.&lt;/p&gt;

&lt;p&gt;José e Márcio devem criar uma variável de ambiente em seus computadores apontando para esses paths. A variável de ambiente deve ter o &lt;em&gt;mesmo&lt;/em&gt; nome, por exemplo, &lt;code&gt;DBFastSource&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finalmente, basta adicionarmos a macro &lt;code&gt;$Env(DBFastSource)&lt;/code&gt; no &lt;a href=&quot;http://wiki.freepascal.org/IDE_Window:_Compiler_Options#Paths&quot;&gt;search path&lt;/a&gt; do projeto para que tudo funcione com paths diferentes para cada desenvolvedor.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jul 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/libraries-sem-pacotes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/libraries-sem-pacotes</guid>
      </item>
    
      <item>
        <title>Quem é o Responsável por Liberar os Objetos?</title>
        <description>&lt;p&gt;Você consideraria um bom design para seu projeto, ter métodos ou funções que criam objetos que serão liberados em outro local, por outro objeto ou função?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/w-a-t-a-r-i-535375-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by W A T A R I on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Em linguagens onde a liberação de memória e recursos é algo manual que depende do desenvolvedor, ter funções ou métodos (vamos nos referir apenas a métodos de agora em diante) que criam novos objetos para que “alguém”, em algum lugar, faça a limpeza da memória é uma má ideia.&lt;/p&gt;

&lt;p&gt;Ao longo dos anos tenho visto código como esse:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TFoo.Build(const Name: string; Value: Integer): TBar;
begin
  Result := TBar.Create;
  Result.Name := Name;
  Result.Value := Value;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uma classe &lt;code&gt;TFoo&lt;/code&gt; que, através do método &lt;code&gt;Build&lt;/code&gt;, retorna uma nova instância de &lt;code&gt;TBar&lt;/code&gt; sem manter uma referência para o objeto criado.&lt;/p&gt;

&lt;p&gt;Acredito que esses tipos de métodos são criados com a intenção de “facilitar” a codificação. Ao invés de criar um objeto &lt;code&gt;TBar&lt;/code&gt; e ter que iniciar suas propriedades em muitos lugares no código, cria-se um método que &lt;a href=&quot;/encapsulamento&quot;&gt;encapsula&lt;/a&gt; a criação do objeto sem ter que &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/&quot;&gt;duplicar o código&lt;/a&gt; em outros lugares.&lt;/p&gt;

&lt;p&gt;Parece bom?&lt;/p&gt;

&lt;p&gt;Eu considero essa abordagem &lt;em&gt;péssima&lt;/em&gt;, pois é o início para ocorrer eventuais vazamentos de memória.&lt;/p&gt;

&lt;p&gt;A linguagem Object Pascal não obriga o desenvolvedor a armazenar o retorno de um método em alguma variável — assim como Java e C#. Então, se não tivermos uma referência através de um variável, o objeto não seria liberado, gerando um vazamento de memória.&lt;/p&gt;

&lt;p&gt;Mas você poderia dizer que não há sentido em criar um objeto e não fazer nada com ele, então o desenvolvedor iria ter uma variável… bem, nem sempre. Mas no caso acima, eu concordo.&lt;/p&gt;

&lt;p&gt;Então, digamos que o desenvolvedor armazena o objeto em uma variável.&lt;/p&gt;

&lt;p&gt;Infelizmente, isso também não garante que ele irá liberar a memória após seu uso.&lt;/p&gt;

&lt;p&gt;OK. Esse não é um problema. Sei que isso é intrínseco ao design da linguagem: O desenvolvedor deve liberar os objetos chamando os destrutores.&lt;/p&gt;

&lt;p&gt;No entanto, há uma grande diferença.&lt;/p&gt;

&lt;p&gt;Por exemplo: Quando temos objetos que possuem objetos, naturalmente não nos preocupamos quem irá liberar a memória alocada. Sabemos que alguém irá liberá-los. O motivo é simples: &lt;em&gt;não fomos nós que os criamos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Então, temos uma regra aqui:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aquele que cria é também o responsável por destruir a instância e/ou liberar o recurso.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mas, quando utilizamos métodos que retornam objetos, como saber se devemos ou não liberar os recursos manualmente?&lt;/p&gt;

&lt;p&gt;Será que o próprio objeto irá fazer o trabalho?&lt;/p&gt;

&lt;p&gt;Como o desenvolvedor iria saber?&lt;/p&gt;

&lt;p&gt;Só lendo a documentação ou código da classe, o que é um péssimo design de projeto.&lt;/p&gt;

&lt;p&gt;Ao voltarmos para o nosso primeiro exemplo, a instância da classe &lt;code&gt;TFoo&lt;/code&gt; seria, então, responsável por liberar quaisquer objetos que porventura tenha criado para estar de acordo com a regra acima. O que não é o caso.&lt;/p&gt;

&lt;p&gt;O que fazer?&lt;/p&gt;

&lt;p&gt;Existe alguma técnica que nos permite criar e retornar novos objetos sem ter de nos preocupar (muito) quem irá liberar a memória?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Sim&lt;/em&gt;, contanto que você utilize &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;interfaces&lt;/a&gt; ao invés de instâncias de classes. Para esses casos eu proponho a técnica do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;método estático New&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Jul 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/quem-libera-os-objetos</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/quem-libera-os-objetos</guid>
      </item>
    
      <item>
        <title>Free Pascal Macros</title>
        <description>&lt;p&gt;Uma linguagem simples e com um design elegante como Object Pascal não necessitaria de suporte a macros como existem em C/C++. No entanto, Free Pascal as tem. Devemos utilizá-las?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/remi-jacquaint-441559-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Rémi Jacquaint on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O uso de &lt;a href=&quot;https://en.wikipedia.org/wiki/Macro_(computer_science)&quot;&gt;macros&lt;/a&gt; já existe no Free Pascal faz tempo, porém nunca havia pensando utilizar tal feature.&lt;/p&gt;

&lt;p&gt;Se você é leitor assíduo do blog já deve ter percebido que eu prefiro ter um bom design e consistência no código do que utilizar “hacks” para escrever menos, porém com a perda da legibilidade e da manutenibilidade.&lt;/p&gt;

&lt;p&gt;Na minha opinião, macros são &lt;em&gt;hacks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bem, talvez a maioria…&lt;/p&gt;

&lt;p&gt;Não acho que o suporte a macros não tenha sido implementado com o objetivo de melhorar o design e legibilidade do código.&lt;/p&gt;

&lt;p&gt;No entanto, acredito que podemos tirar proveito dessa feature.&lt;/p&gt;

&lt;h2 id=&quot;macros&quot;&gt;Macros&lt;/h2&gt;

&lt;p&gt;No código Pascal podemos definir macros que serão pré-processadas pelo compilador. Esse processamento irá gerar um resultado, que será como uma constante. Mas, essa constante pode representar uma expressão, um algorítimo, uma unidade, etc.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{$macro on}
{$define VALUE := A+B}

function Sum(A, B: Integer): Integer;
begin
  Result := VALUE;
end;

function Concat(const A, B: string): string;
begin
  Result := VALUE;
end;
{ TForm1 }

procedure TForm1.Button1Click(Sender: TObject);
begin
  ShowMessage(Sum(1,2).ToString); // 3
  ShowMessage(Concat(&#39;A&#39;,&#39;B&#39;));   // &#39;AB&#39;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A primeira coisa a se fazer é ativar o uso de macros utilizando a diretiva &lt;code&gt;{$macro on}&lt;/code&gt;, pois macros não são ativadas por padrão. Outra maneira de ativá-as para todas as unidades é passando o argumento &lt;code&gt;-Sm&lt;/code&gt; para o compilador.&lt;/p&gt;

&lt;p&gt;O exemplo acima não faz muito sentido, pois para se fazer uma soma não é necessário o uso de macros. No entanto, serviu para lhe mostrar o que é possível fazer com elas.&lt;/p&gt;

&lt;p&gt;Repare que &lt;code&gt;A&lt;/code&gt; e &lt;code&gt;B&lt;/code&gt; são definidos na macro como 2 identificadores que ainda não existem. Esses identificadores virão do contexto onde as macros serão chamadas, ou seja, as funções &lt;code&gt;Sum&lt;/code&gt; e &lt;code&gt;Concat&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para a macro, não importa o tipo de &lt;code&gt;A&lt;/code&gt; e &lt;code&gt;B&lt;/code&gt;. Então, elas funcionam como &lt;em&gt;Generics&lt;/em&gt;, o que já é bem legal.&lt;/p&gt;

&lt;p&gt;Mas &lt;em&gt;Generics&lt;/em&gt; são muito mais poderosos do que isso, então não pense em macros como substitutos aos Generics.&lt;/p&gt;

&lt;p&gt;Vamos a outro exemplo onde Generics não ajudam em nada:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{$macro on}
{$ifdef debug}
  {$define foo := foo.debug}
{$else}
  {$define foo := foo.run}
{$endif}

uses
  foo;
begin
  foo.SomeFunc;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo acima, há um teste se a diretiva &lt;code&gt;debug&lt;/code&gt; foi definida. Se for verdadeiro, definimos uma macro &lt;code&gt;foo&lt;/code&gt; com o nome da unidade &lt;code&gt;foo.debug&lt;/code&gt;, senão definimos &lt;code&gt;foo&lt;/code&gt; como &lt;code&gt;foo.run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Repare que na cláusula &lt;code&gt;uses&lt;/code&gt; há somente &lt;code&gt;foo&lt;/code&gt;. Imagine agora por as diretivas em outro lugar, talvez arquivos &lt;code&gt;.inc&lt;/code&gt;, e teremos uma unidade com o código limpo que irá utilizar as classes corretas dependendo da diretiva escolhida.&lt;/p&gt;

&lt;p&gt;Bem legal, não é?&lt;/p&gt;

&lt;p&gt;Entretanto, isso também não foi o que mais me chamou atenção no uso das macros. Pois, para fazer o mesmo que no exemplo acima, não é preciso macros. Basta você ter unidades como o mesmo nome, porém em diretórios diferentes, e passar o path correspondente ao compilador dependendo se há ou não a diretiva &lt;code&gt;debug&lt;/code&gt;. O Lazarus IDE lhe dá essa opção.&lt;/p&gt;

&lt;p&gt;Se há outras alternativas na própria linguagem para o uso de macros, por quê então utilizá-las?&lt;/p&gt;

&lt;h2 id=&quot;alias&quot;&gt;Unit Alias&lt;/h2&gt;

&lt;p&gt;Faz muito tempo que solicitei a implementação de uma nova sintaxe à equipe Free Pascal para ser possível &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclarar&lt;/a&gt; uma unidade diretamente no código. A linguagem C# tem isso, assim como Python.&lt;/p&gt;

&lt;p&gt;A razão para esse pedido é poder declarar unidades com nomes longos no código, mas dar-lhes um apelido curto para servir de prefixo a algumas classes que tem nomes iguais em unidades diferentes.&lt;/p&gt;

&lt;p&gt;Então pensei numa alternativa que chamei de &lt;a href=&quot;/api-unit&quot;&gt;API Unit&lt;/a&gt;. As vantagens e desvantagens estão no artigo.&lt;/p&gt;

&lt;p&gt;Infelizmente essa ideia não se mostrou muito eficaz para projetos com muitas unidades, já que é necessário redeclarar todas as unidades, suas classes e interfaces em um único arquivo.&lt;/p&gt;

&lt;p&gt;Mas com macros, tudo muda.&lt;/p&gt;

&lt;p&gt;Hipoteticamente, vamos supor que as unidades &lt;code&gt;Windows&lt;/code&gt; e &lt;code&gt;Graphics&lt;/code&gt; pertencem ao namespace &lt;code&gt;FPC.RTL.&lt;/code&gt;, ou seja, um “nome longo”.&lt;/p&gt;

&lt;p&gt;Então, minha proposta (antiga) seria utilizar essa sintaxe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  FPC.RTL.Windows as Win,
  FPC.RTL.Graphics as Graph;
var
  B1: Win.TBitmap;
  B2: Graph.TBitmap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eu não estou me referindo aqui o uso de namespaces do Delphi — que já foi implementado no Free Pascal — onde poderíamos definir um &lt;code&gt;NS=&quot;FPC.RTL&quot;&lt;/code&gt; e declarar apenas &lt;code&gt;Windows&lt;/code&gt; e &lt;code&gt;Graphics&lt;/code&gt; respectivamente.&lt;/p&gt;

&lt;p&gt;Não é isso.&lt;/p&gt;

&lt;p&gt;Utilizando essa sintaxe, teríamos o &lt;em&gt;controle local&lt;/em&gt; sobre a nomenclatura das unidades.&lt;/p&gt;

&lt;p&gt;Quando solicitei isso na época, eu pensava que iria exigir mudanças no parser da linguagem, que daria muito trabalho, etc.&lt;/p&gt;

&lt;p&gt;Não era prioridade.&lt;/p&gt;

&lt;p&gt;Porém, veja que com o uso de macros, bastaria o compilador substituir os &lt;code&gt;uses&lt;/code&gt; acima, que utiliza a palavra reservada &lt;code&gt;as&lt;/code&gt;, pelo código abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  {$macro on}
  FPC.RTL.Windows,
  {$define Win := FPC.RTL.Windows}
  FPC.RTL.Graphics;
  {$define Graph := FPC.RTL.Graphics}
var
  B1: Win.TBitmap;
  B2: Graph.TBitmap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E então eu poderia “renomear” as unidades com nomes longos como &lt;code&gt;Acme.SysFoo.Finances.Billing.Utils.Classes&lt;/code&gt; para apenas &lt;code&gt;Billing&lt;/code&gt;. Porém, em outra unidade, eu poderia renomear para &lt;code&gt;Utils&lt;/code&gt; se assim o desejasse.&lt;/p&gt;

&lt;p&gt;Teríamos a possibilidade de definir um apelido local (por unidade) a cada unidade. Perfeito.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A resposta a pergunta inicial é, sim. O uso de macros, quando bem utilizado, pode melhorar muito a legibilidade e design do código.&lt;/p&gt;

&lt;p&gt;Não temos (ainda?) a sintaxe com o uso de &lt;code&gt;as&lt;/code&gt;, que seria apenas uma &lt;em&gt;syntax sugar&lt;/em&gt; para o uso de macros, porém já podemos renomear unidades localmente. O que é um grande avanço, na minha opinião.&lt;/p&gt;

&lt;p&gt;O único contra que eu vejo é que, infelizmente, essa feature não existe no Delphi… por enquanto?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jun 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpc-macros</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpc-macros</guid>
      </item>
    
      <item>
        <title>fpWeb: Verificando Vazamentos de Memória</title>
        <description>&lt;p&gt;A linguagem Object Pascal, assim como C ou C++, não possui &lt;em&gt;Garbage Collector&lt;/em&gt; para liberar os objetos e recursos da memória automaticamente. Pode ser difícil ter 100% de certeza que todos os objetos estão sendo liberados (manualmente) pelo código. Mas, se algum objeto não for liberado, ocorrerá um vazamento de memória.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-steve-johnson-548294-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Steve Johnson on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Quando utilizamos a linguagem Object Pascal precisamos nos preocupar com &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#vazamentos-de-memoria&quot;&gt;vazamentos de memória&lt;/a&gt;, até mesmo nos sistemas mais simples.&lt;/p&gt;

&lt;p&gt;Vazamentos de memória podem ser ainda mais prejudiciais em sistemas Web comparado com sistemas Desktop. Se uma aplicação Desktop tem vazamentos de memória, em algum momento o usuário poderá fechar a aplicação e todo o vazamento será recuperado pelo Sistema Operacional. Mas em aplicações Web, onde podem haver múltiplas requisições por segundo enquanto o servidor mantém em memória cópias do executável (FastCGI), tais vazamentos poderiam diminuir drasticamente com os recursos do servidor.&lt;/p&gt;

&lt;p&gt;No &lt;a href=&quot;/fpweb-hello&quot;&gt;artigo anterior&lt;/a&gt; fizemos um programa simples que responde “Hello!” quando uma determinada URL  acessada.&lt;/p&gt;

&lt;p&gt;Como não há vazamentos de memória nesse programa, teremos que simulá-lo, alterando o método &lt;code&gt;HandleRequest&lt;/code&gt; conforme abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure THelloRoute.HandleRequest(
  ARequest: TRequest; AResponse: TResponse);
begin
  TStringList.Create;
  AResponse.Content := &#39;Hello!&#39;;
  AResponse.SendResponse;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mesmo após compilar o programa com o &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/heaptrc/usage.html&quot;&gt;HeapTrc&lt;/a&gt; habilitado, iniciá-lo e executá-lo utilizando o browser, não será possível ver o vazamento — diferentemente de aplicações Desktop que, ao término do programa, mostra um “relatório” sobre a memória &lt;em&gt;utilizada vs. liberada&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para ser possível ver o relatório, você tem que finalizar a aplicação apropriadamente. O problema é que, mesmo após finalizada a requisição pelo browser, ela continua em execução aguardando mais e mais requisições.&lt;/p&gt;

&lt;p&gt;Felizmente, há uma maneira de ver o relatório do HeapTrc, alterando o código conforme a seguir:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/90b319e7bcf5d37383c1083179b69546.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, foi introduzido um procedimento &lt;code&gt;TerminateCall&lt;/code&gt;, algumas configurações do &lt;code&gt;heaptrc&lt;/code&gt; e a inclusão de uma nova rota &lt;code&gt;/quit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compile e execute a aplicação novamente. Depois, faça uma requisição a URL &lt;code&gt;/hello&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, aponte seu browser para fazer uma requisição a URL &lt;code&gt;/quit&lt;/code&gt;. Nesse momento você verá que a janela da aplicação foi finalizada.&lt;/p&gt;

&lt;p&gt;Finalmente, abra o arquivo &lt;code&gt;log.txt&lt;/code&gt;, localizado no mesmo diretório do executável, para visualizar todos os vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Jun 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpweb-memleak</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpweb-memleak</guid>
      </item>
    
      <item>
        <title>Construindo uma Aplicação Básica com fpWeb</title>
        <description>&lt;p&gt;As vezes, tudo que precisamos é uma aplicação “Alô Mundo”.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-rawpixel-296622-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by rawpixel on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Neste artigo você verá como preparar seu ambiente Lazarus para o desenvolvimento Web com fpWeb.&lt;/p&gt;

&lt;p&gt;Eu estou utilizando a versão mais atual e revisada do Lazarus 1.8.5,  &lt;a href=&quot;https://svn.freepascal.org/svn/lazarus/branches/fixes_1_8&quot;&gt;fixes_1_8&lt;/a&gt;, revisão 58049.&lt;/p&gt;

&lt;p&gt;Para o compilador, também estou utilizando a versão mais atual e revisada do FPC 3.0.5, &lt;a href=&quot;https://svn.freepascal.org/svn/fpc/branches/fixes_3_0&quot;&gt;fixes_3_0&lt;/a&gt;, revisão 38970.&lt;/p&gt;

&lt;p&gt;O artigo presume que você já tem o FPC e Lazarus instalados e funcionando no seu computador.&lt;/p&gt;

&lt;h2 id=&quot;instalando&quot;&gt;Instalando fpWeb&lt;/h2&gt;

&lt;p&gt;A primeira instalação a ser realizada será a do pacote &lt;code&gt;lazwebextra&lt;/code&gt;. Esse pacote adiciona opções para a criação de novos projetos do tipo Web como CGI Application, FastCGI Application e outros.&lt;/p&gt;

&lt;p&gt;Esse pacote não é obrigatório, mas facilita a criação de novos projetos. No entanto, se você não quiser instalá-lo, ainda poderá criar uma aplicação console simples e ir alterando manualmente o código conforme for lendo o artigo.&lt;/p&gt;

&lt;p&gt;Para prosseguir com a instalação, abra o menu &lt;code&gt;Package&amp;gt;Install/Uninstall Packages&lt;/code&gt; e localize o pacote &lt;code&gt;lazwebextra&lt;/code&gt; no box “Available for installation”.&lt;/p&gt;

&lt;p&gt;Na figura abaixo, o pacote é mostrado no box esquerdo, pois já foi instalado no meu computador.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/laz-install-lazwebextra.jpg&quot; alt=&quot;Install/Uninstall Packages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Clique em “Save e Rebuild IDE”.&lt;/p&gt;

&lt;p&gt;Se tudo deu certo, você poderá seguir para o próximo passo, ou seja, o início da construção de um sistema Web simples.&lt;/p&gt;

&lt;h2 id=&quot;desenvolvimento&quot;&gt;Desenvolvimento&lt;/h2&gt;

&lt;p&gt;Após a instalação do pacote de integração com a IDE, você estará habilitado a construir aplicativos Web utilizando o fpWeb framework.&lt;/p&gt;

&lt;p&gt;Abra o menu &lt;code&gt;File&amp;gt;New&lt;/code&gt; e escolha a opção “FastCGI Application”.&lt;/p&gt;

&lt;p&gt;Apesar de escolhermos essa opção, não iremos criar uma aplicação FastCGI que precisará ser executada em algum servidor Web como Apache ou Microsoft IIS. Ao invés disso, iremos criar um executável Standalone que irá responder as requisições do browser sem a necessidade de existir um servidor.&lt;/p&gt;

&lt;p&gt;Após clicar nessa opção, um novo projeto será criado.&lt;/p&gt;

&lt;p&gt;Infelizmente, nessa versão do Lazarus eles ainda mantém a versão antiga do fpWeb como padrão, ou seja, aquela baseada no modelo Web Broker. No entanto, queremos utilizar a &lt;a href=&quot;/fpweb&quot;&gt;nova&lt;/a&gt; versão e para isso precisaremos fazer algumas modificações manuais.&lt;/p&gt;

&lt;p&gt;Feche a &lt;code&gt;Unit1&lt;/code&gt; sem salvar e remova-a do projeto (&lt;code&gt;lpr&lt;/code&gt;). Salve o projeto, escolhendo um nome — eu digitei &lt;code&gt;hello.lpr&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program hello;

{$mode objfpc}{$H+}

uses
 fpFCGI;

begin
  Application.Title := &#39;Hello World&#39;;
  { Uncomment the port setting here if you want to run the
    FastCGI application stand-alone (e.g. for NGINX) }
  // Application.Port:=2015; // For example
  Application.Initialize;
  Application.Run;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por enquanto esse é todo o projeto. Ele ainda não faz nada de útil. É necessário criar alguma rota que execute alguma ação.&lt;/p&gt;

&lt;p&gt;Como iremos criar uma aplicação Standalone, precisaremos substituir a seção &lt;code&gt;uses&lt;/code&gt; com outras unidades e também definir a porta de acesso que estará em execução quando acessarmos &lt;code&gt;localhost&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program hello;

{$mode objfpc}{$H+}

uses
  SysUtils, httpdefs, httproute, fphttpapp;

begin
  Application.Title := &#39;Hello World&#39;;
  Application.Port := 8080;
  Application.Initialize;
  Application.Run;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As duas unidades mais importantes são &lt;code&gt;httproute&lt;/code&gt;, que define os objetos relacionados às rotas e &lt;code&gt;fphttpapp&lt;/code&gt;, que substitui o tipo de projeto de FastCGI para Standalone.&lt;/p&gt;

&lt;p&gt;Feito isso é necessário definir ao menos uma rota para executar alguma ação.&lt;/p&gt;

&lt;p&gt;A maneira mais fácil é implementar uma nova classe, tendo como base a &lt;code&gt;TRouteObject&lt;/code&gt;, padrão do fpWeb. Essa nova classe deverá sobrescrever o método &lt;code&gt;HandleRequest&lt;/code&gt; e retornar algo como resposta.&lt;/p&gt;

&lt;p&gt;Vamos criar uma nova classe chamada &lt;code&gt;THelloRoute&lt;/code&gt;, implementando o método &lt;code&gt;HandleRequest&lt;/code&gt; da forma mais simples possível. Depois, é necessário registrar essa rota em algum lugar, antes da aplicação realmente iniciar — você poderá utilizar as seções &lt;code&gt;initialization&lt;/code&gt; de cada nova unidade que você criar, porém aqui, para manter simples, basta registrar a rota antes de &lt;code&gt;Application.Run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Abaixo pode-se ver o programa completo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program hello;

{$mode objfpc}{$H+}

uses
  SysUtils, httpdefs, httproute, fphttpapp;

type
  THelloRoute = class(TRouteObject)
  public
    procedure HandleRequest(
      ARequest: TRequest; AResponse: TResponse); override;
  end;

{ THelloRoute }

procedure THelloRoute.HandleRequest(
  ARequest: TRequest; AResponse: TResponse);
begin
  AResponse.Content := &#39;Hello!&#39;;
  AResponse.SendResponse;
end;

begin
  HTTPRouter.RegisterRoute(&#39;/hello&#39;, rmAll, THelloRoute);
  Application.Title := &#39;Hello World&#39;;
  Application.Port := 8080;
  Application.Initialize;
  Application.Run;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora execute a aplicação diretamente pela IDE.&lt;/p&gt;

&lt;p&gt;Depois, abra algum browser se sua preferência e digite: &lt;a href=&quot;http://localhost:8080/hello&quot;&gt;http://localhost:8080/hello&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Se tudo deu certo, você estará vendo “Hello!” como resposta.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Esse artigo mostrou como criar uma aplicação Web simples que pode ser executada e testada sem a necessidade de um servidor Web.&lt;/p&gt;

&lt;p&gt;Tenha em mente que “todo esse trabalho” só será feito uma vez. Após criar um projeto de “template”, bastará copiar/colar e renomear o projeto. Todo o restante do trabalho será criando novas unidades e rotas relacionadas às suas regras de negócio.&lt;/p&gt;

&lt;p&gt;Até a data de publicação desse artigo não havia documentação sobre esse novo estilo de desenvolvimento utilizando o fpWeb framework. Então, talvez esse seja um dos primeiros artigos a explicar essa nova tecnologia.&lt;/p&gt;

&lt;p&gt;Espero que você tenha ficado motivado a pesquisar mais a respeito sobre desenvolvimento Web com Free Pascal e Lazarus.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Jun 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpweb-hello</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpweb-hello</guid>
      </item>
    
      <item>
        <title>Desenvolvimento Web com fpWeb Framework</title>
        <description>&lt;p&gt;Durante anos, o desenvolvimento Web no Delphi e Lazarus sempre seguiram o antigo padrão Web Broker.
Felizmente, estamos vivendo uma nova fase no ambiente Object Pascal.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-maik-jonietz-535261-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Maik Jonietz on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A tecnologia Web Broker foi apresentada no &lt;a href=&quot;https://en.wikipedia.org/wiki/Delphi_(IDE)#Borland_Delphi_3&quot;&gt;Delphi 3&lt;/a&gt; em 1997 e desde esse tempo não houve muitas melhorias. Pelo menos, não na parte do &lt;em&gt;arquitetura&lt;/em&gt; das aplicações.&lt;/p&gt;

&lt;p&gt;O Web Broker é um sistema baseado em Web Modules. Cada Web Module pode ter uma lista de Actions, e cada Action corresponde a uma URL onde você define um &lt;em&gt;evento&lt;/em&gt; que será executado.&lt;/p&gt;

&lt;p&gt;Eu venho construindo aplicações Web em Object Pascal desde os tempos do Delphi 4~5. Essas aplicações sempre tiveram uma boa performance quando utilizávamos o padrão &lt;a href=&quot;https://pt.wikipedia.org/wiki/ISAPI&quot;&gt;ISAPI&lt;/a&gt;. Entretanto, a arquitetura estava longe de ser a ideal. Na minha opinião, tentaram utilizar a abordagem RAD em um contexto não-RAD. Funcionava, e ainda funciona, mas não era “empolgante” desenvolver tais aplicações.&lt;/p&gt;

&lt;h2 id=&quot;fpweb&quot;&gt;fpWeb Framework&lt;/h2&gt;

&lt;p&gt;A implementação atual do fpWeb — framework Web disponível no Free Pascal 3.0.4 — é bem diferente. Eles mantiveram a compatibilidade com o estilo Web Broker antigo, caso você ainda precise dele para sistemas legados, mas nos deram a possibilidade de utilizar um sistema de &lt;em&gt;rotas&lt;/em&gt; muito melhor além de podermos compilar nossas aplicações utilizando diferentes tipos de modelos como Standalone, CGI ou FastCGI.&lt;/p&gt;

&lt;h2 id=&quot;rotas&quot;&gt;Rotas&lt;/h2&gt;

&lt;p&gt;Com o novo sistema de rotas não é mais necessário utilizar Web Modules e eventos, basta registrar uma classe ou mesmo uma simples procedure para representar uma ação quando uma determinada URL for acessada.&lt;/p&gt;

&lt;p&gt;Além disso, não estamos mais presos às URLs com o padrão &lt;code&gt;/module/action&lt;/code&gt; utilizados no padrão Web Broker. No novo sistema, você pode definir e registrar suas URLs do jeito que quiser.&lt;/p&gt;

&lt;p&gt;Exemplo. Através da &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;, você pode definir uma classe que irá responder a uma determinada URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TMyHandler = Class(TRouteObject)
public
  procedure HandleRequest(
    ARequest: TRequest; AResponse: TResponse); override;
end;

initialization
  HTTPRouter.RegisterRoute(
    &#39;/my/route/in/action&#39;, rmAll, TMyHandler
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A classe &lt;code&gt;TRouteObject&lt;/code&gt; faz parte da fpWeb. Utilize essa classe como base para suas classes. É possível utilizar desde uma simples procedure ou até mesmo uma classe que implemente &lt;code&gt;IRouteInterface&lt;/code&gt;. Mas, na minha opinião, a melhor opção é utilizar apenas classes por ser o método mais simples e organizado para codificar as rotas.&lt;/p&gt;

&lt;h2 id=&quot;padroes&quot;&gt;Standalone, CGI ou FastCGI&lt;/h2&gt;

&lt;p&gt;A depuração de aplicações Web nunca foi fácil. Uma aplicação ISAPI, por exemplo, é executada no formato multi thread e depurar uma aplicação nesse formato é um desafio.&lt;/p&gt;

&lt;p&gt;A fpWeb facilita o desenvolvimento e depuração. Através de &lt;a href=&quot;/diretivas-de-compilacao&quot;&gt;diretivas de compilação&lt;/a&gt;, você pode determinar o tipo de modelo a ser desenvolvido. Por exemplo, você poderia determinar que o modelo Standalone será escolhido se o depurador estiver ativado.&lt;/p&gt;

&lt;p&gt;Exemplo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{$ifdef STANDALONE}
  fphttpapp,
{$endif}
{$ifdef FCGI}
  fpfcgi,
{$endif}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Standalone é uma aplicação que não precisa de um serviço Apache ou IIS. O próprio executável se registra numa porta (escolhida pelo desenvolvedor) para responder a requisições HTTP. É possível utilizar esse modelo até mesmo em produção — pense em vários serviços sendo executados localmente numa única máquina se comunicando entre si, mas que também podem responder a requisições na rede.&lt;/p&gt;

&lt;p&gt;Sendo uma aplicação que não necessita de um servidor Web, é possível depurar facilmente utilizando &lt;em&gt;breakpoints&lt;/em&gt; da mesma forma que fazemos em aplicações Desktop.&lt;/p&gt;

&lt;p&gt;No entanto, se você tem um servidor Web, a forma mais simples de fazer o deploy para um Apache ou IIS é o formato CGI. Nesse formato o servidor Web irá executar e instanciar sua aplicação a cada requisição feita pelo usuário de forma isolada e segura. É um ótimo modelo para aplicações simples, no entanto não é o mais performático.&lt;/p&gt;

&lt;p&gt;Finalmente, o padrão FastCGI une o que há de melhor do modelo ISAPI (multi thread, cache, inicialização rápida) com a segurança do CGI (processos isolados). Para aplicações que realmente necessitam de performance, esse deve ser o padrão a ser escolhido.&lt;/p&gt;

&lt;p&gt;Servidores Web permitem muitas configurações para o modelo FastCGI como o número de instâncias que ficarão ativas, quando elas serão desativadas por falta de requisições, etc.&lt;/p&gt;

&lt;p&gt;E não pense em apenas servidores Linux. Eu mesmo mantenho algumas aplicações FastCGI em servidores Windows funcionando 24h/dia, sem parar.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O framework fpWeb vem facilitando muito o desenvolvimento Web em aplicações Object Pascal com Free Pascal e Lazarus.&lt;/p&gt;

&lt;p&gt;É um framework simples, bem testado e utilizado em produção a muitos anos pela comunidade.&lt;/p&gt;

&lt;p&gt;Com o uso de diretivas de compilação fica fácil alternar entre modelos de aplicações, facilitando muito o desenvolvimento e depuração do código.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 May 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpweb</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpweb</guid>
      </item>
    
  </channel>
</rss>
