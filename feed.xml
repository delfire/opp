<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Inter-process Communication</title>
        <description>&lt;p&gt;Gostaria de modularizar seus sistemas &lt;em&gt;Object Pascal&lt;/em&gt; em pequenos executáveis mas não sabe como?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-climate-kic-350836.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Climate KIC on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Muitos sistemas começam simples. Uma dúzia de tabelas, alguns cadastros, um formulário de &lt;em&gt;login&lt;/em&gt; e poucas &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#regras-de-negocio&quot;&gt;Regras de Negócio&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Com o tempo é necessário ter alguns relatórios, mais cadastros, mais tabelas e muito mais Regras de Negócio.&lt;/p&gt;

&lt;p&gt;A complexidade vai aumentando cada vez mais. O que antes era simples, agora é um “monstro” monolítico.&lt;/p&gt;

&lt;p&gt;Essa história parece familiar?&lt;/p&gt;

&lt;p&gt;Isso já aconteceu comigo — mais de uma vez — e talvez esteja acontecendo com você agora mesmo.&lt;/p&gt;

&lt;p&gt;Hoje vou lhe apresentar uma técnica (antiga) para modularizar seus sistemas, facilitando a manutenção e, possivelmente, diminuir a complexidade do código.&lt;/p&gt;

&lt;p&gt;Esse artigo irá focar numa dessas técnicas chamada &lt;a href=&quot;https://en.wikipedia.org/wiki/Inter-process_communication&quot;&gt;Inter-process Communication&lt;/a&gt; ou IPC.&lt;/p&gt;

&lt;h2 id=&quot;ipc&quot;&gt;IPC&lt;/h2&gt;

&lt;p&gt;Um sistema pode ser modularizado de várias maneiras. Podemos utilizar algumas técnicas como DLL’s, &lt;a href=&quot;/posts/pacotes-e-versoes-no-lazarus/&quot;&gt;&lt;em&gt;Packages&lt;/em&gt;&lt;/a&gt;, WebServices, &lt;a href=&quot;/posts/microservices-delphi-parte-1/&quot;&gt;Microservices&lt;/a&gt; e algumas outras.&lt;/p&gt;

&lt;p&gt;O IPC permite que dois processos (executáveis) distintos se comuniquem entre si através de mensagens que são gerenciadas pelo sistema operacional.&lt;/p&gt;

&lt;p&gt;Essa técnica é muito utilizada por sistemas operacionais de microkernel como, por exemplo, o sistema operacional &lt;a href=&quot;http://www.minix3.org/&quot;&gt;MINIX3&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O objetivo principal é diminuir o número de funcionalidades de um executável monolítico, utilizando um &lt;em&gt;design&lt;/em&gt; mas modular, onde haverá uma comunicação entre processos colaborativos ao invés de haver um único processo que faz tudo.&lt;/p&gt;

&lt;p&gt;A comunicação por IPC é do tipo cliente/servidor, sendo que cada processo pode ser tanto um como outro ao mesmo tempo.&lt;/p&gt;

&lt;p&gt;Então, imagine projetar um sistema onde seus módulos seriam divididos em vários executáveis. Um módulo com as Regras de Negócio, outro de Relatórios para disponibilizá-los tanto na Web quanto no Desktop, outro para &lt;em&gt;login&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Alguns destes módulos seriam executados na mesma máquina e, portanto, seria mais vantajoso se esses executáveis se comunicassem através de mensagens gerenciadas pelo Sistema Operacional ao invés de utilizar uma nova camada de protocolos (REST, SOAP, etc). Para esses casos, podemos utilizar o IPC.&lt;/p&gt;

&lt;p&gt;Mas como implementá-lo?&lt;/p&gt;

&lt;h2 id=&quot;simpleipc&quot;&gt;SimpleIPC&lt;/h2&gt;

&lt;p&gt;No compilador &lt;a href=&quot;https://freepascal.org/&quot;&gt;&lt;em&gt;Free Pascal&lt;/em&gt;&lt;/a&gt; existe um &lt;em&gt;package&lt;/em&gt; chamado &lt;a href=&quot;https://svn.freepascal.org/svn/fpc/branches/fixes_3_0/packages/fcl-process/&quot;&gt;fcl-process&lt;/a&gt; que implementa o IPC.&lt;/p&gt;

&lt;p&gt;Essa implementação foi codificada numa única Unidade chamada &lt;code&gt;simpleipc.pp&lt;/code&gt; e é &lt;em&gt;cross-platform&lt;/em&gt;, ou seja, um único código que funciona em sistemas &lt;em&gt;Unix-like&lt;/em&gt; e &lt;em&gt;Windows&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O próprio &lt;a href=&quot;http://www.lazarus-ide.org/&quot;&gt;&lt;em&gt;Lazarus&lt;/em&gt;&lt;/a&gt; utiliza o &lt;em&gt;SimpleIPC&lt;/em&gt; para fazer a &lt;a href=&quot;http://wiki.freepascal.org/Help_protocol&quot;&gt;comunicação&lt;/a&gt; entre a IDE e o &lt;em&gt;Help Viewer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Basicamente são duas classes principais a saber:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A classe &lt;a href=&quot;http://lazarus-ccr.sourceforge.net/docs/fcl/simpleipc/tsimpleipcclient.html&quot;&gt;&lt;code&gt;TSimpleIPCClient&lt;/code&gt;&lt;/a&gt; implementa o envio das mensagens&lt;/li&gt;
  &lt;li&gt;A classe &lt;a href=&quot;http://lazarus-ccr.sourceforge.net/docs/fcl/simpleipc/tsimpleipcserver.html&quot;&gt;&lt;code&gt;TSimpleIPCServer&lt;/code&gt;&lt;/a&gt; implementa o recebimento das mensagens&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Exemplos de uso de ambas as Classes podem ser visto nos &lt;em&gt;demos&lt;/em&gt; disponibilizados no próprio &lt;em&gt;package&lt;/em&gt;, &lt;a href=&quot;https://svn.freepascal.org/svn/fpc/branches/fixes_3_0/packages/fcl-process/examples/&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;alternativas&quot;&gt;Alternativas&lt;/h2&gt;

&lt;p&gt;Para aqueles que não utilizam &lt;em&gt;Free Pascal&lt;/em&gt;, existe a opção de utilizar a implementação do &lt;em&gt;SimpleIPC&lt;/em&gt; no formato de DLL.&lt;/p&gt;

&lt;p&gt;O projeto &lt;a href=&quot;http://wiki.lazarus.freepascal.org/SimpleIPC_Library&quot;&gt;&lt;em&gt;SimpleIPC Library&lt;/em&gt;&lt;/a&gt; encapsula a implementação do &lt;em&gt;Free Pascal&lt;/em&gt; numa DLL que pode ser utilizada por praticamente qualquer linguagem.&lt;/p&gt;

&lt;p&gt;O código é bastante procedural — padrão em DLL’s — porém pode ser uma alternativa rápida para começar a utilizar essa técnica ao invés de implentá-la do zero.&lt;/p&gt;

&lt;p&gt;Considere que mesmo que sua linguagem já implemente tal padrão, talvez ele não seja compatível com outras linguagens. Nesses casos o uso de uma DLL padrão pode fazer sentido.&lt;/p&gt;

&lt;p&gt;No Windows o IPC pode ser “traduzido” como uma &lt;em&gt;Windows Message&lt;/em&gt; do tipo &lt;code&gt;WM_COPYDATA&lt;/code&gt;. Sabemos que é relativamente fácil trabalhar com mensagens do Windows no &lt;em&gt;Object Pascal&lt;/em&gt;  então, se o desenvolvimento for apenas para a plataforma Windows, talvez seja mais simples utilizar mensagens do tipo &lt;code&gt;WM_COPYDATA&lt;/code&gt;. Esses links &lt;a href=&quot;https://www.thoughtco.com/send-information-between-applications-1058476&quot;&gt;aqui&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/7257719/wm-copydata-string-not-appearing-in-target-application&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;https://stackoverflow.com/questions/7540706/wm-copydata-with-and-without-quotes-yields-different-results&quot;&gt;aqui&lt;/a&gt;, podem ajudar.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Nos anos 60 já existiam tais técnicas de modularização. No entanto, ainda hoje, continuamos a desenvolver softwares monolíticos, pesados e de difícil manutenção.&lt;/p&gt;

&lt;p&gt;Como visto nesse artigo, utilizar o IPC pode facilitar a manutenção do código, pois cada subprojeto (executável) iria lidar apenas com poucos &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contextos&lt;/a&gt;, possivelmente diminuindo a complexidade.&lt;/p&gt;

&lt;p&gt;Cada subprojeto poderia evoluir e ser utilizado independentemente.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Sep 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/ipc</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/ipc</guid>
      </item>
    
      <item>
        <title>Porquê eu escolhi Delphi e então, Object Pascal</title>
        <description>&lt;p&gt;Essa é minha contribuição aos artigos na Internet com a &lt;em&gt;hastag&lt;/em&gt; &lt;a href=&quot;https://www.google.com.br/search?q=%23WhyIChooseDelphi&quot;&gt;#WhyIChooseDelphi&lt;/a&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-kace-rodriguez-75513.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Kace Rodriguez on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;inicio&quot;&gt;Quando tudo começou&lt;/h2&gt;

&lt;p&gt;Minha história com &lt;em&gt;Object Pascal&lt;/em&gt; começa em 1999 quando comecei a estudar programação de computadores.&lt;/p&gt;

&lt;p&gt;Havia um curso chamado Programação de Computadores com “Novas” Tecnologias ministrado na PUC-RJ.&lt;/p&gt;

&lt;p&gt;Lá eu aprendi bastante sobre algoritmos, SGBD’s e linguagens de programação como COBOL, C/C++, Pascal, Java, Visual Basic e &lt;a href=&quot;https://www.embarcadero.com/products/delphi&quot;&gt;Delphi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Através dos convênios da PUC com outras empresas, consegui meu primeiro emprego como estagiário numa &lt;em&gt;software house&lt;/em&gt; chamada &lt;em&gt;Fuzion Engenharia de Software&lt;/em&gt; em meados do ano 2000.&lt;/p&gt;

&lt;h2 id=&quot;delphi&quot;&gt;Um caminho diferente&lt;/h2&gt;

&lt;p&gt;Na &lt;em&gt;Fuzion&lt;/em&gt; utilizáva-mos Delphi, Visual Basic e pouca coisa em Java. No entanto, a maioria dos projetos eram desenvolvidos em Delphi.&lt;/p&gt;

&lt;p&gt;Na PUC éramos referência no desenvolvimento &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt;. Veja, em Delphi, não em Java.&lt;/p&gt;

&lt;p&gt;Quando eu entrei na empresa a versão era Delphi 4. Alguns bugs, alguns problemas… mas então veio a tão aclamada versão 5 e a produtividade era sem igual.&lt;/p&gt;

&lt;p&gt;Tínhamos desenvolvido nossa própria metodologia e ferramentas que geravam código automaticamente e eu já tinha um cargo de Desenvolvedor Pleno.&lt;/p&gt;

&lt;p&gt;Nunca utilizamos &lt;em&gt;DB-aware components&lt;/em&gt;, pois tudo era feito através de camadas e Objetos. Esse era um dos motivos para ser tão difícil contratar mais desenvolvedores, pois aqueles que vinham fazer uma prova depois da entrevista, não sabiam como mostrar informações num &lt;em&gt;Form&lt;/em&gt; com “Mestre/Detalhe” e outros &lt;em&gt;widgets&lt;/em&gt;, sem utizar componentes &lt;em&gt;DB-aware&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Essa sempre foi a beleza do Delphi: Você pode utilizar o paradigma que quiser e conseguir um excelente resultado no final.&lt;/p&gt;

&lt;p&gt;Na Fuzion trilhávamos um caminho diferente. Delphi era um dos nossos segredos de performance e eficácia. E tivemos sucesso… enquanto durou.&lt;/p&gt;

&lt;h2 id=&quot;mudando&quot;&gt;A mudança de ambiente&lt;/h2&gt;

&lt;p&gt;Eu abri minha própria empresa em 2003 para trabalhar como consultor alocado em outras empresas.&lt;/p&gt;

&lt;p&gt;Eu já havia mudado de empresa umas duas vezes até estar na atual, onde já trabalho por quase 13 anos.&lt;/p&gt;

&lt;p&gt;Lá também utilizamos Delphi, a versão 7. Na época que entrei nesta empresa, o Delphi ainda dominava o mercado quando se tratava de aplicações Desktop.&lt;/p&gt;

&lt;p&gt;Por volta de 2006 (se não me engano) a Borland estava vendendo o Delphi. Eu acompanhei, com tristeza, o Delphi ser vendido entre as empresas.&lt;/p&gt;

&lt;p&gt;Eu adorava a Borland, a ponto de querer trabalhar pra ela, e Delphi sempre foi a minha escolha, mas eu achava que tinha que seguir em frente, já que agora o caminho parecia incerto.&lt;/p&gt;

&lt;p&gt;Apesar de na época estar num emprego relativamente estável, eu tinha meus próprios clientes. Eu utilizei Delphi para fazer todos os seus &lt;em&gt;softwares&lt;/em&gt; e, como não tinha certeza se o Delphi iria sobreviver, comecei a pensar em migrar para outra linguagem, outro ambiente.&lt;/p&gt;

&lt;p&gt;Apenas em 2010 eu comecei a pensar em outras possibilidades, quando soube um um projeto que “voltou das cinzas”, hoje conhecido como Lazarus.&lt;/p&gt;

&lt;h2 id=&quot;lazarus&quot;&gt;Migrando para Lazarus&lt;/h2&gt;

&lt;p&gt;Eu comecei a utilizar &lt;a href=&quot;http://www.lazarus-ide.org/&quot;&gt;Lazarus&lt;/a&gt; e quase desisti. Comparado com o Delphi, na época, Lazarus era muito inferior.&lt;/p&gt;

&lt;p&gt;Muitos bugs, pouca produtividade e muita diferença entre ambientes. Apesar de ambos utilizarem a mesma linguagem.&lt;/p&gt;

&lt;p&gt;Felizmente eu consegui superar os problemas. Hoje o ambiente Lazarus é bem estável e completo e me sinto “em casa” como eu me sentia na época do Delphi 5~7.&lt;/p&gt;

&lt;p&gt;Então consegui migrar muitos projetos de Delphi para Lazarus e outros parmaneceram nas versões antigas de Delphi — e vão muito bem, obrigado.&lt;/p&gt;

&lt;p&gt;Apesar de ainda haver problemas, hoje em dia a história parece ser outra. Cada vez mais vejo pessoas reclamando de &lt;em&gt;bugs&lt;/em&gt; no Delphi e, em comparação, vejo cada vez mais elogios ao Lazarus e ao compilador &lt;a href=&quot;https://freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hoje em dia tenho aplicações Desktop e Web, construídas em Free Pascal e Lazarus, rodando em servidores Windows IIS utilizando &lt;a href=&quot;https://www.iis.net/downloads/microsoft/fastcgi-for-iis&quot;&gt;FastCGI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nada mal, considerando que tais &lt;em&gt;softwares&lt;/em&gt; foram desenvolvidos utilizando ferramentas gratuitas e livres, não é?&lt;/p&gt;

&lt;p&gt;Free Pascal e Lazarus são ferramentas desenvolvidas apenas nas horas vagas por alguns programadores motivados e apaixonados por &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;motivos&quot;&gt;Simplicidade, Performance e Lucro&lt;/h2&gt;

&lt;p&gt;Hoje em dia existem tantas linguagens e ambientes que alguns programadores continuam querendo saber meus motivos em continuar utilizando &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bem, eu publiquei um vídeo que explica meus principais motivos.&lt;/p&gt;

&lt;div style=&quot;position:relative;height:0;padding-bottom:56.25%&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/iayMGRIRwjY?ecver=2&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; style=&quot;position:absolute;width:100%;height:100%;left:0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;p&gt;E enquanto esses motivos forem válidos, irei continuar utilizando a linguagem &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;hoje&quot;&gt;Object Pascal hoje em dia&lt;/h2&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; é relevante hoje em dia? Bem, depende de como você vê o mundo.&lt;/p&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt;, pra mim, é como um carro esportivo antigo, como essa imagem do &lt;em&gt;Porsche&lt;/em&gt; aí em cima.&lt;/p&gt;

&lt;p&gt;Esse &lt;em&gt;Porsche&lt;/em&gt; — ou quase qualquer outro esportivo antigo —  é simples, manual e puro. Você precisa saber o que está fazendo a todo momento. Não há computadores e sensores para lhe ajudar. Não há muita segurança como &lt;em&gt;airbags&lt;/em&gt;. Você tem que fazer mais força para “domá-lo”. Quase tudo é manual e “barulhento”. Você precisa entender de subesterço e sobre-esterço, se quiser dirigir de forma mais agressiva ao entrar numa curva. Enfim, você precisa saber muita coisa se quiser ter a verdadeira experiência de dirigir.&lt;/p&gt;

&lt;p&gt;Mas no fim do dia, após passar algumas horas atrás do volante, você se sente realizado. Você sabe exatamente o que fez. Você entende como as coisas funcionam nos seus mínimos detalhes. Você estava integrado ao ambiente. Você era apenas um com seu &lt;em&gt;Porsche&lt;/em&gt;. Homem e máquina.&lt;/p&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; é como um clássico esportivo que nunca sai de moda.&lt;/p&gt;

&lt;p&gt;Hoje temos cada vez mais IDE’s e linguagens “inteligentes” que podem mudar a cada nova versão. Esquecem do passado e “inventam” novas maneiras de fazer a mesma coisa que já fazíamos antes. Essas IDE’s nos dão &lt;em&gt;“airbags”&lt;/em&gt;, “segurança” e todo tipo de “artefato” para ajudar no desenvolvimento, mas no fim o desenvolvedor não sabe exatamente o que está fazendo. Ele apenas memorizou quais “botões apertar no painel” e se algo não sai conforme o esperado, sempre haverá a Internet para responder suas dúvidas, certo?&lt;/p&gt;

&lt;p&gt;Vejo desenvolvedores correndo atrás do último lançamento da IDE, &lt;em&gt;Lib&lt;/em&gt; ou compilador, apenas para constatarem que deverão modificar seu código que antes funcionava.&lt;/p&gt;

&lt;p&gt;A última versão do compilador adiciou tais e tais &lt;em&gt;features&lt;/em&gt; e todos querem utilizar, no entanto a maioria não sabe separar um &lt;em&gt;software&lt;/em&gt; em módulos reutilizáveis!&lt;/p&gt;

&lt;p&gt;Então, pra mim, &lt;em&gt;Object Pascal&lt;/em&gt; continua muito relevante. Gosto de “ter trabalho” ao construir meus &lt;em&gt;softwares&lt;/em&gt;, pois gosto do sentimento de ter construído algo por minhas próprias mãos sem ser obrigado a seguir as “regras de desenvolvimento” que algumas empresas consideram ideal.&lt;/p&gt;

&lt;p&gt;Não quero depender de outras empresas e de seus produtos privados, que podem mudar a qualquer momento, para que eu possa entregar valor aos meus clientes. A confiança que eu tinha na antiga Borland se foi… até que me provem o contrário. Hoje eu quero ser livre.&lt;/p&gt;

&lt;p&gt;Liberdade, é disso que se trata.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Eu gosto de imaginar um mundo onde o Delphi fosse disponibilizado de graça, doado ao time do Free Pascal e Lazarus.&lt;/p&gt;

&lt;p&gt;Gosto de pensar numa união de forças entre o &lt;em&gt;Open Source&lt;/em&gt; e a magnífica IDE, Delphi, que sempre ajudou o desenvolvedor (experiente ou não) da melhor forma possível.&lt;/p&gt;

&lt;p&gt;Gosto de pensar num mundo onde iríamos dar um passo pra trás e ver a beleza e a simplicidade da linguagem &lt;em&gt;Object Pascal&lt;/em&gt;, linguagem essa que foi e ainda é inspiração para várias outras.&lt;/p&gt;

&lt;p&gt;Eu &lt;em&gt;escolhi&lt;/em&gt; Delphi no passado e construí minha carreira com a ajuda dele.&lt;/p&gt;

&lt;p&gt;Delphi continua sendo uma ótima escolha para aqueles que sabem aproveitá-lo.&lt;/p&gt;

&lt;p&gt;Eu não o abandonei. Tiraram ele de mim devido a burocracia e altos custos. Mas ele continua no meu coração.&lt;/p&gt;

&lt;p&gt;Minha &lt;em&gt;hastag&lt;/em&gt; hoje — infelizmente ou não — não é mais &lt;strong&gt;#WhyIChooseDelphi&lt;/strong&gt;, mas sim &lt;strong&gt;#WhyIChoseDelphi&lt;/strong&gt; (uma letra faz diferença).&lt;/p&gt;

&lt;p&gt;Felizmente tem algo que nunca mudou: A linguagem &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/porque-eu-escolhi-delphi-e-object-pascal</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/porque-eu-escolhi-delphi-e-object-pascal</guid>
      </item>
    
      <item>
        <title>Redefinindo Classes</title>
        <description>&lt;p&gt;A redeclaração de Classes é um método prático para minimizar a colisão de nomes entre Classes, mesmo utilizando identificadores curtos.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-mpumelelo-macu-283883.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Mpumelelo Macu on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; tem uma &lt;em&gt;feature&lt;/em&gt; muito útil que, acredito, não é muito utilizada pelos desenvolvedores.&lt;/p&gt;

&lt;p&gt;Não sei se há um nome específico pra isso, mas eu a chamo de &lt;em&gt;Redefinição de Classes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Na verdade essa &lt;em&gt;feature&lt;/em&gt; pode ser utilizada para redeclarar Classes, Constantes e até mesmo Funções.&lt;/p&gt;

&lt;p&gt;Porém, na Orientação a Objetos, basicamente só utilizamos Classes. Então esqueça o resto e vamos nos concentrar nelas.&lt;/p&gt;

&lt;p&gt;Vamos ver algumas técnicas que podem ser aplicadas utilizando tal conceito.&lt;/p&gt;

&lt;h2 id=&quot;renomeando&quot;&gt;Renomeando&lt;/h2&gt;

&lt;p&gt;Imagine que você quer utilizar uma classe de alguma &lt;em&gt;Lib&lt;/em&gt;, mas essa Classe tem o mesmo nome — exemplo &lt;code&gt;TSmartMemory&lt;/code&gt;— de uma de suas Classes que você já utiliza por todo o seu código. O que fazer?&lt;/p&gt;

&lt;p&gt;A primeira opção é nunca utilizar ambas as Classes numa mesma Unidade. Mas talvez você não tenha essa sorte.&lt;/p&gt;

&lt;p&gt;A segunda opção é prefixar uma das Classes com o nome da Unidade — muito comum ver isso em projetos Java — por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  LibMemory,
  MyMemory;

begin
  M := TSmartMemory.New;  // your class
  L := LibMemory.TSmartMemory.Create;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A terceira opção, que eu utilizo na maioria das vezes, é &lt;em&gt;“renomear”&lt;/em&gt; a Classe da &lt;em&gt;Lib&lt;/em&gt; para uma nomenclatura que não colide com a nomenclatura já utilizada no meu projeto. Vejamos um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyMemory;

uses
  LibMemory;

type
  // TSmartMemory from LibMemory
  TLibStartMemory = TSmartMemory; 

  // my new class
  TSmartMemory = class
    // ...
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo ambas as Classes estão declaradas na mesma Unidade existente no projeto — a &lt;code&gt;MyMemory&lt;/code&gt; — e o projeto poderá utilizar ambas as Classes sem colisão de nomenclatura.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
  M := TSmartMemory.New;
  L := TLibSmartMemory.Create;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Utilizando essa técnica evitamos o conflito de nomes, o que é muito útil.&lt;/p&gt;

&lt;p&gt;Ao invés de utilizarmos o nome real da Classe, podemos lhe dar um &lt;em&gt;apelido&lt;/em&gt;. O código fica mais limpo, simples e com identificadores curtos, pois não temos a necessidade de utilizar a Unidade como prefixo.&lt;/p&gt;

&lt;p&gt;A linguagem C# &lt;a href=&quot;https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/using-directive&quot;&gt;tem algo muito parecido&lt;/a&gt; o que me faz pensar de onde será que o principal arquiteto da linguagem C# tirou essa ideia.&lt;/p&gt;

&lt;h2 id=&quot;visibilidade&quot;&gt;Visibilidade&lt;/h2&gt;

&lt;p&gt;Muitas vezes precisamos utilizar uma composição de diferentes Classes para resolver um problema.&lt;/p&gt;

&lt;p&gt;Mas se cada uma dessas Classes tiver sido declarada numa Unidade diferente, precisaremos declarar todas essas Unidades, para ter acesso a cada uma dessas Classes.&lt;/p&gt;

&lt;p&gt;Por exemplo. Precisamos da &lt;code&gt;TClass1&lt;/code&gt;, &lt;code&gt;TClass2&lt;/code&gt; e &lt;code&gt;TClass3&lt;/code&gt;. Cada uma delas em Unidades diferentes, &lt;code&gt;Unit1&lt;/code&gt;, &lt;code&gt;Unit2&lt;/code&gt; e &lt;code&gt;Unit3&lt;/code&gt;, respectivamente.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyUnit;

uses
  Unit1, Unit2, Unit3;  
  
begin
  TClass3.New(
    TClass2.New(
      TClass1.New
    )
  )
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se precisarmos utilizar essa composição em muitos lugares do código, teremos sempre que lembrar em quais Unidades essas Classes estão.&lt;/p&gt;

&lt;p&gt;Outra opção é dar visibilidade às Classes, redeclarando todas elas numa única Unidade, por exemplo &lt;code&gt;Unit123&lt;/code&gt;, para que possamos utilizá-las de forma mais simples, porém ainda mantendo cada implementação em Unidades diferentes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit Unit123;

uses
  Unit1, Unit2, Unit3;

type
  TClass1 = Unit1.TClass1;
  TClass2 = Unit2.TClass2;
  TClass3 = Unit3.TClass3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora, basta utilizarmos a &lt;code&gt;Unit123&lt;/code&gt; no código para ter acesso a todas as 3 Classes que anteriormente só poderiam ser acessadas em Unidades distintas.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit UnitTest;

uses
  Unit123;  
  
begin
  TClass3.New(
    TClass2.New(
      TClass1.New
    )
  )
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta técnica é bastante útil para simplificar uma API, fornecendo aos desenvolvedores somente algumas poucas Classes para uso em contextos bem específicos.&lt;/p&gt;

&lt;h2 id=&quot;heranca&quot;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Há momentos que queremos utilizar &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/&quot;&gt;Herança de Classes&lt;/a&gt; — mesmo sendo a Composição de Objetos a melhor escolha — porém gostaríamos de utilizar o mesmo nome da Classe ancestral.&lt;/p&gt;

&lt;p&gt;Vamos imaginar que estamos desenvolvendo um software e que em uma de suas Unidades tem uma Classe que &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;representa&lt;/a&gt; um arquivo PDF. Nomeamos essa Classe como &lt;code&gt;TPDFFile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;No entanto sabemos que poderá haver dezenas ou centenas de &lt;em&gt;Libs&lt;/em&gt; que já trabalham com PDF. Então vamos chamar uma dessas &lt;em&gt;Libs&lt;/em&gt; de &lt;em&gt;“PDFLib”&lt;/em&gt;, apenas como exemplo.&lt;/p&gt;

&lt;p&gt;Na &lt;em&gt;PDFLib&lt;/em&gt; temos uma Classe chamada &lt;code&gt;TPDFFile&lt;/code&gt; que é exatamente o mesmo nome que já decidimos que será utilizada no nosso software, mas o arquiteto do projeto diz que nossa Classe deve herdar de &lt;code&gt;PDFLib.TPDFFile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Acho que você já sabe a resposta:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyPDFUnit;

uses
  PDFLib;

type
  TPDFFile = class(PDFLib.TPDFFile)
    // more methods
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prefixando a Classe da &lt;em&gt;Lib&lt;/em&gt; podemos identificá-la de forma diferente da nossa Classe declarada na mesma Unidade.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TPDFFile&lt;/code&gt; é agora uma extensão de &lt;code&gt;PDFLib.TPDFFile&lt;/code&gt; que pertence a uma &lt;em&gt;Lib&lt;/em&gt; externa. Mas para todo o restante do código no projeto, só existirá a Classe &lt;code&gt;MyPDFUnit.TPDFFile&lt;/code&gt; que representa um PDF.&lt;/p&gt;

&lt;h2 id=&quot;estendendo&quot;&gt;Estendendo&lt;/h2&gt;

&lt;p&gt;A técnica que vou mostrar agora já era utilizada antes mesmo de haver a sintaxe para &lt;em&gt;Classes Helpers&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por exemplo, imagine que você queira incluir novas propriedades ou métodos na Classe &lt;code&gt;TEdit&lt;/code&gt;. O primeiro pensamento é utilizar herança para criar um novo componente. No entanto você não quer substituir cada &lt;code&gt;TEdit&lt;/code&gt; em todos os &lt;code&gt;TForm&lt;/code&gt; já existentes no projeto. Então, o que fazer?&lt;/p&gt;

&lt;p&gt;A resposta continua sendo utilizar Herança. Mas há um truque ou &lt;em&gt;hack&lt;/em&gt; que irei mostrar na técnica a seguir. Mas gostaria de lembrar que isso deve ser utilizado com muita parcimônia. Eu só utilizei essa técnica pouquíssimas vezes e somente para Classes que representam &lt;em&gt;widgets&lt;/em&gt;, ou seja, Classes de componentes que são utilizadas em Formulários.&lt;/p&gt;

&lt;p&gt;Para extender um &lt;code&gt;TEdit&lt;/code&gt; sem criar uma nova Classe e sem ter que alterar os Formulários, basta utilizar a mesma técnica acima:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyStdCtrls;

type
  TEdit = class(StdCtrls.TEdit) // or Vcl.StdCtrls.TEdit
    // more methods and properties
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Você não precisa alterar os &lt;em&gt;widgets&lt;/em&gt; nos Formulários. A renderização do &lt;em&gt;design&lt;/em&gt; do Formulário irá funcionar utilizando os recursos (*.lfm | *.dfm) corretamente.&lt;/p&gt;

&lt;p&gt;Porém há um truque que você não pode esquecer: Em cada um desses Formulários você precisará &lt;a href=&quot;/declarando-unidades&quot;&gt;declarar&lt;/a&gt; sua Unidade &lt;strong&gt;depois&lt;/strong&gt; da Unidade &lt;code&gt;StdCtrls&lt;/code&gt; real.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyForm1;

uses
  StdCtrls, MyStdCtrls;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse &lt;em&gt;hack&lt;/em&gt; é necessário para que o compilador ache a declaração da sua Unidade antes de encontrá-la na &lt;code&gt;StdCtrls&lt;/code&gt; padrão.&lt;/p&gt;

&lt;p&gt;Por isso é tão importante ter uma &lt;a href=&quot;/declarando-unidades&quot;&gt;ordem&lt;/a&gt; na declaração das Unidades.&lt;/p&gt;

&lt;h2 id=&quot;opcional&quot;&gt;Nomenclatura Opcional&lt;/h2&gt;

&lt;p&gt;Essa técnica pode ser considerada o oposto da primeira mostrada nesse artigo, ou seja, ao invés de você “renomear” uma Classe pertencente a outra &lt;em&gt;Lib&lt;/em&gt;, você irá dar ao desenvolvedor opções de nomenclatura para o uso das suas Classes.&lt;/p&gt;

&lt;p&gt;Imagine que você codificou um &lt;em&gt;package&lt;/em&gt; com algumas Classes. Nesse &lt;em&gt;package&lt;/em&gt; você gosta de utilizar nomes simples como &lt;code&gt;TStream&lt;/code&gt;, &lt;code&gt;TMemoryStream&lt;/code&gt;, &lt;code&gt;TString&lt;/code&gt;, &lt;code&gt;TInteger&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;Veja que já temos alguns possíveis “problemas” aqui. Vejamos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;As Classes &lt;code&gt;TStream&lt;/code&gt; e &lt;code&gt;TMemoryStream&lt;/code&gt; já existem no FPC|Delphi e por isso poderá haver colisão de nomes quando os desenvolvedores forem utilizar seu &lt;em&gt;package&lt;/em&gt;, pois é bem provável que eles já estejam utilizando tais Classes padrão em seus projetos;&lt;/li&gt;
  &lt;li&gt;As Classes &lt;code&gt;TString&lt;/code&gt; e &lt;code&gt;TInteger&lt;/code&gt; são Classes com nomes muito simples ou genéricos e, novamente, é provável que alguma outra &lt;em&gt;Lib&lt;/em&gt; ou mesmo os próprios projetos desses desenvolvedores já utilizem tais nomes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O problema aqui é o nome &lt;em&gt;limpo&lt;/em&gt; e &lt;em&gt;curto&lt;/em&gt;. Ao mesmo tempo que esses nomes são &lt;em&gt;perfeitos&lt;/em&gt;, eles tem o grande potencial de gerar o problema da colisão de nomenclatura.&lt;/p&gt;

&lt;p&gt;Mas quando você está criando seu &lt;em&gt;package&lt;/em&gt;, você tem que abstrair o mundo externo. O &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contexto&lt;/a&gt; do &lt;em&gt;package&lt;/em&gt; que deve influenciar a nomenclatura das Classes e não o mundo externo que, talvez, irá utilizá-lo!&lt;/p&gt;

&lt;p&gt;Eu “lutei” contra esse problema por muito anos. Antes de “descobrir” essa técnica, eu prefixava minhas Classes com 1, 2 ou 3 letras — esse parece ser o padrão utilizado por todos os desenvolvedores de componentes do mercado — porém você pode descobrir com o tempo que “seu prefixo” escolhido para suas Classes já foi utilizado em outra &lt;em&gt;Lib&lt;/em&gt; de terceiros.&lt;/p&gt;

&lt;p&gt;Imagine você ter que utilizar nomes verbosos como &lt;code&gt;TXyzMemoryStream&lt;/code&gt; por todo o seu código para, então, descobrir que &lt;code&gt;Xyz&lt;/code&gt; já é o prefixo utilizado por uma grande “fazedora de componentes” do mercado.&lt;/p&gt;

&lt;p&gt;Então eu descobri que a linguagem &lt;em&gt;Object Pascal&lt;/em&gt; já tinha uma resposta e eu poderia ter o melhor dos dois mundos. Eu poderia utilizar nomes simples, compactos e limpos dentro do meu contexto (&lt;em&gt;package&lt;/em&gt;, projeto, &lt;em&gt;lib&lt;/em&gt;) mas dar aos potenciais usuários|desenvolvedores um nome mais verboso, porém com menor possibilidade de haver colisão de nomes, se assim eu desejasse.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo. Uma das Classes do &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.data.clss.pas&quot;&gt;James&lt;/a&gt; tem o nome &lt;code&gt;TDataStream&lt;/code&gt;. Esse nome já evita a colisão com &lt;code&gt;TStream&lt;/code&gt; que é basicamente o que essa Classe representa, porém o “prefixo” &lt;code&gt;Data&lt;/code&gt; não foi utilizado para minimizar a colisão de nomenclatura, mas sim devido a sua semântica.&lt;/p&gt;

&lt;p&gt;Mas digamos que agora o Lazarus e/ou Delphi implementaram uma Classe de uso geral chamada… &lt;code&gt;TDataStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Eu deveria mudar o nome dessa Classe no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt; e em todos os meus projetos que já utilizam essa nomenclatura? É claro que não!&lt;/p&gt;

&lt;p&gt;Eu só iria dar a opção para os (novos) desenvolvedores utizarem outra nomenclatura para a mesma Classe, desse jeito:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TDataStream = class sealed(TInterfacedObject, IDataStream)
  // some methods
  end;
  
  TJamesDataStream = TDataStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código agora tem 2 possibilidades de uso de nomenclatura para a mesma Classe!&lt;/p&gt;

&lt;p&gt;Você pode continuar utilizando &lt;code&gt;TDataStream&lt;/code&gt; por todo o seu código, desde que mantenha a &lt;a href=&quot;/declarando-unidades&quot;&gt;ordem de declaração&lt;/a&gt; das Unidades, ou pode utilizar a nova opção &lt;code&gt;TJamesDataStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;E se mesmo assim ainda houver colisão de nomenclatura, aí caberá ao desenvolvedor utilizar a primeira técnica desse artigo.&lt;/p&gt;

&lt;p&gt;Dessa forma ambos os lados (desenvolvedores de &lt;em&gt;packages&lt;/em&gt; e usuários de &lt;em&gt;packages&lt;/em&gt;) estão &lt;em&gt;livres&lt;/em&gt; para utilizarem os nomes que quiserem em suas Classes.&lt;/p&gt;

&lt;p&gt;A única exceção, até onde eu sei, são os componentes que são instalados na IDE. Ambas as IDE’s (Lazarus e Delphi) não deixam instalar componentes com o mesmo nome, mesmo estando em &lt;em&gt;packages&lt;/em&gt; distintos. No entanto, na minha opinião, isso é um erro de &lt;em&gt;design&lt;/em&gt; das IDE’s. Ambas deveriam permitir a instalação e, ao utilizarmos tais componentes, bastaria a IDE declarar os &lt;em&gt;fields&lt;/em&gt; no Formulário utilizando a nomenclatura totalmente qualificada, como &lt;code&gt;Edit1: StdCtrls.TEdit;&lt;/code&gt; e tudo iria funcionar.&lt;/p&gt;

&lt;p&gt;Eu fiz essa &lt;a href=&quot;http://lists.lazarus-ide.org/pipermail/lazarus/2011-January/123929.html&quot;&gt;proposta&lt;/a&gt; na lista oficial do Lazarus em Janeiro/2011, porém ainda sem previsão, prioridade ou interesse.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A redeclaração ou renomeação de Classes (e constantes, funções, etc) é uma técnica que existe quase desde os primórdios da linguagem, mas que a grande maioria dos desenvolvedores não utiliza, seja por desconhecimento, inabilidade ou mesmo falta de interesse.&lt;/p&gt;

&lt;p&gt;É um conceito &lt;em&gt;antigo&lt;/em&gt;, mas que nos proporciona várias técnicas e possibilidades para codificar melhor &lt;em&gt;hoje&lt;/em&gt;, conforme demonstrado nesse artigo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/redeclarando-classes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/redeclarando-classes</guid>
      </item>
    
      <item>
        <title>Git-work Project</title>
        <description>&lt;p&gt;Git-work são extensões minimalistas para Git, fornecendo operações de repositório de alto nível.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-zachary-nelson-192289.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Zachary Nelson on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Git&lt;/em&gt;&lt;/strong&gt;, segundo a &lt;a href=&quot;https://pt.wikipedia.org/wiki/Git&quot;&gt;Wikipedia&lt;/a&gt;,
é um sistema de controle de versão distribuído e um sistema de gerenciamento de código fonte, com ênfase em velocidade. O Git foi inicialmente projetado e desenvolvido por Linus Torvalds para o desenvolvimento do kernel Linux, mas foi adotado por muitos outros projetos.&lt;/p&gt;

&lt;p&gt;Ele é o padrão atual para o controle de versão de softwares. Não há nenhum outro concorrente que seja tão simples e eficaz.&lt;/p&gt;

&lt;p&gt;Apesar de ser um magnífico sistema, por muito tempo não havia um padrão definido em como trabalhar em equipe ou mesmo sozinho, ou seja, como enviar de forma eficiente uma alteração feita por você; como ser eficaz ao trabalhar com &lt;em&gt;branches&lt;/em&gt;; se devemos trabalhar diretamente no &lt;code&gt;master&lt;/code&gt; ou em &lt;em&gt;branches&lt;/em&gt; secundários; como iniciar uma alteração quando o projeto recebe uma &lt;em&gt;issue&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Hoje em dia temos um padrão chamado &lt;code&gt;git flow&lt;/code&gt;. Ele vem instalado nas últimas versões do Git e você pode configurá-lo digitando &lt;code&gt;git flow&lt;/code&gt; na linha-de-comando.&lt;/p&gt;

&lt;p&gt;No entanto, ainda que o &lt;code&gt;git flow&lt;/code&gt; não seja um padrão complicado de se utilizar, ele não nos deixa customizá-lo de forma simples num único lugar (são alguns arquivos &lt;em&gt;bash&lt;/em&gt; que devem ser editados), é verboso e não define um padrão para as mensagens dos &lt;em&gt;commits&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nesse artigo eu irei lhe apresentar o meu mais novo “&lt;em&gt;pet project&lt;/em&gt;” chamado &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt;, que é uma alternativa minimalista ao &lt;code&gt;git flow&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;git-work&quot;&gt;O que é Git-work&lt;/h2&gt;

&lt;p&gt;Assim como o &lt;code&gt;git flow&lt;/code&gt;, o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; é uma coleção de extensões para a linha-de-comando do Git.&lt;/p&gt;

&lt;p&gt;O nome escolhido é devido a semântica ao digitar os comandos como, por exemplo, &lt;code&gt;git work done&lt;/code&gt; para concluir uma &lt;code&gt;issue&lt;/code&gt;. Legal, não?&lt;/p&gt;

&lt;p&gt;É um projeto extremamente novo (apenas alguns dias) porém com um grande potencial, na minha humilde opinião.&lt;/p&gt;

&lt;p&gt;São extensões minimalistas para Git, fornecendo operações de repositório de alto nível além de padronizar, um &lt;em&gt;fluxo de trabalho&lt;/em&gt; com os &lt;em&gt;branches&lt;/em&gt;, que poderá ser totalmente customizável.&lt;/p&gt;

&lt;h2 id=&quot;motivacao&quot;&gt;Motivação&lt;/h2&gt;

&lt;p&gt;Eu tentei (tento) utilizar alguns &lt;em&gt;clients&lt;/em&gt; para Git como &lt;a href=&quot;https://desktop.github.com/&quot;&gt;Github Desktop&lt;/a&gt;, &lt;a href=&quot;http://www.syntevo.com/smartgit/&quot;&gt;SmartGit&lt;/a&gt; ou &lt;a href=&quot;https://www.gitkraken.com/&quot;&gt;GitKraken&lt;/a&gt;. Apesar desses e dezenas de outras IDE’s serem ótimos produtos, podem ter restrições de uso, além da curva de aprendizado para utilizá-los.&lt;/p&gt;

&lt;p&gt;Além disso, no meu caso, eu utilizo Git em alguns computadores e não posso me dar ao luxo de ter que ficar atualizando e reconfigurando IDE’s em todos esses computadores caso eu queria mudar meu modo de trabalho.&lt;/p&gt;

&lt;p&gt;Eu sou um cara &lt;em&gt;“old-school”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Gosto das coisas mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e manuais. Gosto de saber o que está acontecendo nos “bastidores” quando clico num botão. Gosto de aprender a utilizar algo reduzindo-o à sua interface mais básica.&lt;/p&gt;

&lt;p&gt;Então voltei para a linha-de-commando, onde posso fazer literalmente tudo com o Git. &lt;a href=&quot;/posts/menos-e-mais/&quot;&gt;Menos é mais&lt;/a&gt;, certo?&lt;/p&gt;

&lt;p&gt;Mas a linha-de-comando pode ser assutadora quando você não conhece os comandos. E, mesmo depois de aprendê-los, pode ser ineficaz se você tiver que fazer &lt;em&gt;tudo&lt;/em&gt; de forma manual.&lt;/p&gt;

&lt;p&gt;Então como eu poderia utilizar a linha-de-comando, mas automatizar os comandos mais utilizados e, ao mesmo tempo, definir um fluxo de trabalho padronizado?&lt;/p&gt;

&lt;p&gt;A ideia de construir o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; me ocorreu após uma tarde de intenso trabalho e uso do Git em um projeto particular.&lt;/p&gt;

&lt;p&gt;Trabalhei em algumas &lt;em&gt;issues&lt;/em&gt; e foi bastante ineficaz ter que ficar indo e vindo entre os &lt;em&gt;branches&lt;/em&gt; para fazer a mesclagem além de ter que ficar digitando comandos que poderiam ser automatizados.&lt;/p&gt;

&lt;p&gt;Além disso, não ter um fluxo de trabalho pré-determinado me fazia perder tempo para identificar o próximo passo.&lt;/p&gt;

&lt;p&gt;Então nasceu o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;features&quot;&gt;Características&lt;/h2&gt;

&lt;p&gt;Inicialmente eu pensei em codificar o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; em &lt;em&gt;Object Pascal&lt;/em&gt;. Sério. Porém vi que o mais simples a fazer seria utilizar &lt;em&gt;Bash scripts&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O Git é bem integrado com &lt;em&gt;Bash&lt;/em&gt; então… Por quê não?&lt;/p&gt;

&lt;p&gt;Criei o projeto no Github, codifiquei as primeiras características e subi os fontes.&lt;/p&gt;

&lt;p&gt;Então meu amigo &lt;a href=&quot;https://github.com/fabriciofx/&quot;&gt;Fabrício Cabral&lt;/a&gt; se interessou pelo projeto e começou a trabalhar e melhorar o código.&lt;/p&gt;

&lt;p&gt;No momento da escrita desse artigo já temos algumas funcionalidades.&lt;/p&gt;

&lt;p&gt;Após “instalar”, digite &lt;code&gt;git work&lt;/code&gt; para ver os comandos:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/git-work-1.jpg&quot; alt=&quot;git-work&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Esses comandos ainda serão aperfeiçoados, pois estão em constante desenvolvimento.&lt;/p&gt;

&lt;h3 id=&quot;flow&quot;&gt;Fluxo de Trabalho&lt;/h3&gt;

&lt;p&gt;Após um usuário registrar a &lt;em&gt;issue&lt;/em&gt; #41 no seu sistema de &lt;em&gt;tickets&lt;/em&gt;, você inicia um fluxo:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Digite &lt;code&gt;git work issue 41&lt;/code&gt; para criar uma nova &lt;em&gt;branch&lt;/em&gt; com o nome &lt;code&gt;41&lt;/code&gt; a partir da &lt;code&gt;master&lt;/code&gt;, já com &lt;em&gt;checkout&lt;/em&gt; automático para o &lt;code&gt;41&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Enquanto você vai alterando os fontes, poderá digitar &lt;code&gt;git work commit &quot;mensagem&quot;&lt;/code&gt; para ir comitando seu trabalho;&lt;/li&gt;
  &lt;li&gt;Quando você tiver terminado o trabalho, digite &lt;code&gt;git work done&lt;/code&gt; para ir para o &lt;code&gt;master&lt;/code&gt; enquanto o sistema faz o &lt;em&gt;merge&lt;/em&gt; com a atual &lt;em&gt;branch&lt;/em&gt; &lt;code&gt;41&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Então você pode enviar suas alterações para o servidor digitando &lt;code&gt;git work push&lt;/code&gt; para enviar a &lt;em&gt;branch&lt;/em&gt; atual, que é a &lt;code&gt;master&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Quando tiver uma versão de &lt;em&gt;release&lt;/em&gt;, o comando &lt;code&gt;git work release 1.0&lt;/code&gt; poderá ser utilizado. O git-work irá criar uma nova &lt;em&gt;tag&lt;/em&gt; a partir da &lt;code&gt;master&lt;/code&gt; e enviar ao servidor.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pode não parecer muito agora. Os comandos são muito similares aos comandos do próprio Git, porém tudo ainda está em desenvolvimento.&lt;/p&gt;

&lt;p&gt;Os scripts irão verificar, na medida do possível, se você está utilizando os comandos certos, nos &lt;em&gt;branches&lt;/em&gt; corretos.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;branch&lt;/em&gt; padrão poderá ser &lt;a href=&quot;https://github.com/mdbs99/git-work/issues/9&quot;&gt;configurado&lt;/a&gt; (padrão &lt;code&gt;master&lt;/code&gt;) para que os comandos &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt; e &lt;code&gt;release&lt;/code&gt; saibam onde pegar os fontes atuais.&lt;/p&gt;

&lt;p&gt;As mensagens do &lt;code&gt;commit&lt;/code&gt; poderão ser &lt;a href=&quot;https://github.com/mdbs99/git-work/issues/8&quot;&gt;padronizadas&lt;/a&gt; com o número da &lt;em&gt;issue&lt;/em&gt; no início. Exemplo: &lt;em&gt;“#41 this fix…”.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;E se todos os (futuros) parâmetros customizáveis ainda não sejam suficientes para suas customizações, bastará você alterar apenas o &lt;a href=&quot;https://github.com/mdbs99/git-work/blob/master/git-work.sh&quot;&gt;único arquivo&lt;/a&gt; nesse projeto.&lt;/p&gt;

&lt;p&gt;Ainda há um grande caminho a percorrer.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Essa é apenas a versão &lt;code&gt;0.1&lt;/code&gt; desse projeto que só tem poucos dias de vida.&lt;/p&gt;

&lt;p&gt;Padronização, eficiência e simplicidade. Essa é a proposta desse projeto.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;https://github.com/mdbs99/git-work&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/git-work-project</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/git-work-project</guid>
      </item>
    
      <item>
        <title>Imutabilidade do Estado</title>
        <description>&lt;p&gt;Na Orientação a Objetos, um Objeto pode ser considerável Imutável mesmo que ele… mude.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-morgan-harper-nichols-157838.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Morgan Harper Nichols on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O aprendizado de um conceito complexo, tende a ser melhor absorvido se dividirmos o conceito em pequenas partes.&lt;/p&gt;

&lt;p&gt;Por exemplo, quando começamos a aprender Inglês, nos é ensinado que, para nos referirmos a algo que ocorreu no passado, devemos utilizar os verbos no passado para fazer afirmações ou utilizamos o verbo modal &lt;em&gt;did&lt;/em&gt; ou &lt;em&gt;did not&lt;/em&gt; para fazermos perguntas ou negações. Esse é o tempo verbal &lt;em&gt;Simple Past&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo: &lt;em&gt;I saw this movie&lt;/em&gt; (tradução: eu vi esse filme).&lt;/p&gt;

&lt;p&gt;Então, quando você começa a estudar mais a língua, descobre que existe muitas outras maneiras de expressar algo que ocorreu no passado. Por exemplo, o uso do tempo verbal &lt;em&gt;Present Perfect&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo: &lt;em&gt;I have seen this movie&lt;/em&gt; (tradução: eu vi esse filme).&lt;/p&gt;

&lt;p&gt;Aqui vemos o uso do verbo modal &lt;em&gt;have&lt;/em&gt; e o uso do &lt;em&gt;Past Participle&lt;/em&gt; do verbo &lt;em&gt;to see&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ambas as frases dizem o mesmo quando traduzimos para o Português, porém a segunda frase pode ser considerada mais &lt;em&gt;correta&lt;/em&gt; do que a primeira — você só descobre isso depois que aprende o &lt;em&gt;Present Perfect&lt;/em&gt;.
Mas isso não é um blog de Inglês, vamos voltar para a Orientação a Objetos.&lt;/p&gt;

&lt;p&gt;Essa introdução é para lhe mostrar que primeiro devemos aprender um conceito na sua forma mais simples; depois aprimoramos.&lt;/p&gt;

&lt;h2 id=&quot;conceitos&quot;&gt;Conceitos da Imutabilidade&lt;/h2&gt;

&lt;p&gt;Quando você aprendeu sobre &lt;a href=&quot;/posts/objetos-imutaveis/&quot;&gt;Imutabilidade&lt;/a&gt; pode ter pensado que um Objeto é imutável se, depois de criado, nada é alterado dentro dele ou que o Objeto retorna sempre a mesma informação quando um método é chamado.&lt;/p&gt;

&lt;p&gt;Bem, não é tão simples assim.&lt;/p&gt;

&lt;p&gt;Diferentemente das linguagens funcionais, onde tudo é imutável por padrão, na Orientação a Objetos esse conceito pode ser mais amplo.&lt;/p&gt;

&lt;p&gt;Vamos ver alguns conceitos.&lt;/p&gt;

&lt;h3 id=&quot;ex1&quot;&gt;Conteúdo Externo&lt;/h3&gt;

&lt;p&gt;Uma classe que representa um arquivo pode ser imútável de duas maneiras:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/48237c902271b6f2c3a314d3b6f5b8c0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, o método &lt;code&gt;TFile.Stream: IDataStream&lt;/code&gt; sempre irá retornar o mesmo valor lido na primeira execução.&lt;/p&gt;

&lt;p&gt;O Objeto é imutável e &lt;em&gt;constante&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas, e se alterarmos o método confome abaixo, a classe continuaria sendo imutável?&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/0aea75fefaf8612d0bc84d5fc9ce85a0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Sim, com certeza.&lt;/p&gt;

&lt;p&gt;Apesar do retorno do método poder ser diferente em cada chamada — o conteúdo do arquivo pode ser alterado por outro processo — o Objeto continuaria sendo imutável pois seu &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado&lt;/a&gt; (&lt;code&gt;FFilePath&lt;/code&gt;) não foi alterado.&lt;/p&gt;

&lt;p&gt;Ele é imutável, porém &lt;em&gt;não&lt;/em&gt; é constante.&lt;/p&gt;

&lt;p&gt;O mesmo conceito se aplica para um conteúdo vindo de um Banco de Dados, site na Web, etc.&lt;/p&gt;

&lt;h3 id=&quot;ex2&quot;&gt;Conteúdo em Memória&lt;/h3&gt;

&lt;p&gt;Uma lista de Objetos é considerada mutável se adicionarmos itens após ela ter sido criada?&lt;/p&gt;

&lt;p&gt;Vejamos no código:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/af8769161d1b111128349b05b74bccb9.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Copyright (c) &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James Project&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TDataParams&lt;/code&gt; encapsula uma lista do tipo &lt;code&gt;TInterfaceList&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A cada inclusão de um novo item, é delegada à essa lista interna, a persistência em memória dos Objetos.&lt;/p&gt;

&lt;p&gt;Você acha que, assim, estamos alterando o Estado (&lt;code&gt;FList&lt;/code&gt;) do Objeto?&lt;/p&gt;

&lt;p&gt;Não estamos.&lt;/p&gt;

&lt;p&gt;O motivo é que não estamos redefinindo &lt;code&gt;FList&lt;/code&gt;. Não estamos recriando uma nova lista.&lt;/p&gt;

&lt;p&gt;Uma lista de itens está sendo criada em memória — blocos de memória — mas o endereço inicial de &lt;code&gt;FList&lt;/code&gt; continua intacto.&lt;/p&gt;

&lt;p&gt;Além disso, &lt;code&gt;FList&lt;/code&gt; é um &lt;a href=&quot;/atributos-primarios-secundarios#secundarios&quot;&gt;Atributo Secundário&lt;/a&gt;, então nós até poderíamos redefinir esse atributo sem estar em desacordo com o princípio. Mas, se a instância da lista fosse passada no construtor, então não poderíamos redefinir o Objeto, pois esse seria considerado como um &lt;a href=&quot;/atributos-primarios-secundarios#primarios&quot;&gt;Atributo Primário&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;estado&quot;&gt;Imutabilidade do Estado&lt;/h2&gt;

&lt;p&gt;Se mesmo após algumas mudanças internas ou externas ao Objeto, ele continua sendo considerado imutável, como saber se não estamos violando o princípio da Imutabilidade?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Simples&lt;/strong&gt;: Se o &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado do Objeto&lt;/a&gt;, ou seja, seus &lt;a href=&quot;/atributos-primarios-secundarios#primarios&quot;&gt;Atributos Primários&lt;/a&gt;, não for alterado/redefinindo, então ele é imutável.&lt;/p&gt;

&lt;p&gt;Uma vez que um atributo é instânciado, ele não poderá ter seu &lt;em&gt;endereço de memória&lt;/em&gt; alterado. Esses atributos serão inicializados no &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtor&lt;/a&gt; da classe e jamais poderão ser reinicializados.&lt;/p&gt;

&lt;p&gt;Seu Objeto deve ser &lt;em&gt;fiél&lt;/em&gt; aos argumentos passados no construtor da Classe, no entanto ele é &lt;em&gt;livre&lt;/em&gt; para trabalhar e responder o que quiser em seus métodos.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Imutabilidade, na Orientação a Objetos, não é só sobre as não-mudanças internas ou externas ao Objeto, mas sim sobre não alterar o Estado Primário do Objeto.&lt;/p&gt;

&lt;p&gt;Não confunda &lt;a href=&quot;/posts/classes-de-dados/&quot;&gt;dados&lt;/a&gt; com o Estado do Objeto.&lt;/p&gt;

&lt;p&gt;Infelizmente nenhum compilador &lt;em&gt;Object Pascal&lt;/em&gt; que eu conheça possui uma sintaxe para que essas regras não sejam quebradas. Java, por exemplo, tem atributos &lt;em&gt;final&lt;/em&gt; onde, uma vez inicializados, não podem ter seu endereço de memória substituído.&lt;/p&gt;

&lt;p&gt;Sven Barth, um integrante do FPC team, &lt;a href=&quot;http://lists.freepascal.org/pipermail/fpc-pascal/2017-July/051941.html&quot;&gt;me falou&lt;/a&gt; sobre um &lt;code&gt;{$modeswitch
finalfields}&lt;/code&gt; que foi implementado para a interoperabilidade do FPC para a JVM plataforma, porém ainda não disponível.&lt;/p&gt;

&lt;p&gt;Então temos que trabalhar apenas com o conceito ou utilizar ferramentas de verificação de código para que essa regra não seja quebrada.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/imutabilidade-do-estado</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/imutabilidade-do-estado</guid>
      </item>
    
      <item>
        <title>Diretivas de Compilação</title>
        <description>&lt;p&gt;Diretivas de Compilação podem lhe ajudar a tornar seu código &lt;em&gt;multi-plataform&lt;/em&gt; ou até mesmo &lt;em&gt;cross-compiled&lt;/em&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-mathyas-kurmann-102977.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Mathyas Kurmann on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freepascal.org/docs-html/prog/progch1.html&quot;&gt;Diretivas de Compilação&lt;/a&gt; são comandos poderosos que o desenvolvedor pode utilizar para customizar a compilação.&lt;/p&gt;

&lt;p&gt;Essas Diretivas passam parâmetros para o compilador, informando os &lt;em&gt;argumentos&lt;/em&gt; da compilação, &lt;em&gt;como&lt;/em&gt; deve ser compilado e &lt;em&gt;o que&lt;/em&gt; deve ser compilado.&lt;/p&gt;

&lt;p&gt;Existem basicamente &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Delphi_compiler_directives&quot;&gt;3 tipos&lt;/a&gt; de Diretivas de Compilação:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Switch directive&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Parameter directive&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Conditional compilation directive&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Os dois primeiros tipos alteram os parâmetros de compilação, enquanto o último altera o que o compilador irá executar.&lt;/p&gt;

&lt;p&gt;Nesse artigo iremos tratar do último tipo: &lt;em&gt;Condicionais&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;condicionais&quot;&gt;Condicionais&lt;/h2&gt;

&lt;p&gt;Apesar de serem comandos poderosos, &lt;em&gt;não&lt;/em&gt; devem ser utilizados levianamente.&lt;/p&gt;

&lt;p&gt;Com apenas alguns comandos condicionais, seu código &lt;a href=&quot;https://freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt; ou &lt;a href=&quot;https://www.embarcadero.com/products/delphi&quot;&gt;Delphi&lt;/a&gt; pode ser compilável em várias plataformas.&lt;/p&gt;

&lt;p&gt;Entretanto, a medida que vamos adicionando mais e mais diretivas, o código irá ficar mais complexo.&lt;/p&gt;

&lt;p&gt;Vejamos o exemplo abaixo:
&lt;script src=&quot;https://gist.github.com/mdbs99/dffca8326e924f4e036485a5674ea147.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;No código acima apenas a 1º e 3º chamada da função &lt;em&gt;Writeln&lt;/em&gt; serão executadas.&lt;/p&gt;

&lt;p&gt;Todas as diretivas e também a 2º chamada de &lt;em&gt;Writeln&lt;/em&gt; não irão fazer parte do executável final.&lt;/p&gt;

&lt;p&gt;Bem legal.&lt;/p&gt;

&lt;p&gt;Entretanto, veja que o código ficou bem “poluído” e também temos um &lt;a href=&quot;/posts/objetos-imutaveis/#acoplamento-temporal&quot;&gt;acoplamento temporal&lt;/a&gt;, pois as  constantes precisam ser definidas numa ordem específica.&lt;/p&gt;

&lt;p&gt;Diretivas e Definições de constantes que serão utilizadas em apenas numa única &lt;a href=&quot;/declarando-unidades&quot;&gt;Unidade&lt;/a&gt; pode até ser gerenciável, mas e se tivermos trabalhando com dezenas ou até centenas de Unidades que irão utilizar as mesmas diretivas e definições, ainda acha que essa abordagem é a melhor escolha para a arquitetura do seu projeto com a finalidade de construí-lo como &lt;em&gt;multi-plataform&lt;/em&gt; ou &lt;em&gt;cross-compiled&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Eu acho que &lt;em&gt;não&lt;/em&gt; e é por isso que no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt; estamos utilizando uma abordagem diferente.&lt;/p&gt;

&lt;h2 id=&quot;encapsulando&quot;&gt;Encapsulando Diretivas&lt;/h2&gt;

&lt;p&gt;No James estamos codificando num estilo que chamo de &lt;em&gt;Encapsulamento de Diretivas&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Um dos objetivos desse projeto é ser &lt;em&gt;cross-compiled&lt;/em&gt;, ou seja, ele irá compilar em Free Pascal e Delphi. No entanto não queremos que nem os usuários (desenvolvedores) ou os autores desse projeto se preocupem com diretivas de compilação.&lt;/p&gt;

&lt;p&gt;Atualmente não há diretivas condicionais no código de implementação dos métodos — com exceção da classe &lt;code&gt;TXMLComponent&lt;/code&gt; que deverá ser &lt;a href=&quot;https://github.com/mdbs99/james/issues/65&quot;&gt;refatorada&lt;/a&gt; em breve.&lt;/p&gt;

&lt;p&gt;O motivo dessa abordagem é que não queremos nos preocupar em  quebrar um código que é utilizado por 2 compiladores diferentes.&lt;/p&gt;

&lt;p&gt;Não utilizamos arquivos &lt;em&gt;“include”&lt;/em&gt; com pedaços de código.&lt;/p&gt;

&lt;p&gt;Não utilizamos definições globais de condicionais.&lt;/p&gt;

&lt;p&gt;Diretiva condicional é uma técnica &lt;em&gt;procedural&lt;/em&gt;. Não gostamos.&lt;/p&gt;

&lt;p&gt;Ao invés disso, utilizamos apenas &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;implementacao&quot;&gt;Implementação&lt;/h2&gt;

&lt;p&gt;Imagine uma Unidade que contenha classes para &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;representar&lt;/a&gt; a criptografia &lt;a href=&quot;https://en.wikipedia.org/wiki/MD5&quot;&gt;MD5&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No Free Pascal já temos uma Unidade &lt;code&gt;md5&lt;/code&gt; que tem funções que fazem esse trabalho — e é claro que temos que fazer Objetos para encapsular essas funções.&lt;/p&gt;

&lt;p&gt;No Delphi a Unidade que faz o mesmo trabalho é denominada &lt;code&gt;hash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Não queremos “reinventar a roda”. Queremos utilizar o que já está pronto em ambas as plataformas.&lt;/p&gt;

&lt;p&gt;Então, como fazer essa implementação sem utilizar diretivas condicionais no código de implementação ou arquivos de inclusão?&lt;/p&gt;

&lt;p&gt;Bem, no James temos a Unidade &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.crypto.md5.clss.pas&quot;&gt;James.Crypto.MD5.Clss&lt;/a&gt; com algumas classes que representam MD5.&lt;/p&gt;

&lt;p&gt;Essa é a única Unidade (até a data desse artigo) que os usuários devem utilizar para trabalhar com MD5.&lt;/p&gt;

&lt;p&gt;Nós, autores do projeto, poderíamos separar alguns desenvolvedores para trabalhar na implementação Free Pascal e outros para trabalhar na implementação Delphi, se assim o desejarmos, pois as implementações estão separadas em Unidades distintas.&lt;/p&gt;

&lt;p&gt;Primeiro criamos mais duas Unidades que serão utilizadas pela &lt;code&gt;James.Crypto.MD5.Clss&lt;/code&gt;:
Uma para Free Pascal e outra para o Delphi.&lt;/p&gt;

&lt;p&gt;São elas &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.crypto.md5.fpc.pas&quot;&gt;James.Crypto.MD5.FPC&lt;/a&gt; e &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.crypto.md5.delphi.pas&quot;&gt;James.Crypto.MD5.Delphi&lt;/a&gt;, respectivamente.&lt;/p&gt;

&lt;p&gt;Veja abaixo como implementamos isso:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/1bc867bb6303223496c44d221eae9044.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Ambas as Unidades possuem a definição da Classe &lt;code&gt;TMD5Hash&lt;/code&gt; (sim, mesmo nome em ambas). Então bastou criar um &lt;em&gt;alias&lt;/em&gt; (novamente, com o mesmo nome) direcionando &lt;code&gt;TMD5Hash&lt;/code&gt; para a classe correta (dependente da plataforma) e, &lt;em&gt;voilá!&lt;/em&gt;, temos uma Unidade “limpa” e sem condicionais na implementação dos métodos.&lt;/p&gt;

&lt;p&gt;Agora temos duas Classes distintas, em Unidades diferentes, que podem evoluir independentemente sem receio de quebrar o código entre plataformas.&lt;/p&gt;

&lt;p&gt;A clase &lt;code&gt;TMD5Stream&lt;/code&gt; não tem nenhuma diferença entre os compiladores, então é implementada diretamente na Unidade &lt;code&gt;James.Crypto.MD5.Clss&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Diretiva de Compilação é uma boa ferramenta para customização do código, porém deve ser utilizada com parcimônia.&lt;/p&gt;

&lt;p&gt;No código &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;Orientado a Objetos&lt;/a&gt;, dê preferência aos Objetos para resolver seus problemas.&lt;/p&gt;

&lt;p&gt;Para cada diretiva condicional que você queira adicionar no código de implementação, sugiro implementar um novo Objeto que encapsule a diretiva.&lt;/p&gt;

&lt;p&gt;Seu código ficará mais limpo e sustentável.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/diretivas-de-compilacao</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/diretivas-de-compilacao</guid>
      </item>
    
      <item>
        <title>Declarando Unidades</title>
        <description>&lt;p&gt;Determinar uma ordem para declarar as Unidades no código poderá facilitar a manutenção do código no futuro.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-annie-spratt-303942.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Quando você organiza suas coisas, tem a tendência de manter mais perto, mais fácil de utilizar ou pegar, todos os objetos que são mais utilizados no dia-a-dia, certo?&lt;/p&gt;

&lt;p&gt;Assim também deveria ser com as &lt;a href=&quot;http://castle-engine.io/modern_pascal_introduction.html#_units&quot;&gt;Unidades&lt;/a&gt; de um Projeto.&lt;/p&gt;

&lt;p&gt;A ordem em que aparecem as Unidades no código pode facilitar ou dificultar a manutenção.&lt;/p&gt;

&lt;p&gt;Nesse artigo irei lhe mostrar qual a ordem que utilizo ao declarar as Unidades no meus projetos.&lt;/p&gt;

&lt;h2 id=&quot;compilador&quot;&gt;Compilador&lt;/h2&gt;

&lt;p&gt;As Unidades, também conhecidas como módulos, compõe os projetos.&lt;/p&gt;

&lt;p&gt;Todo projeto deve ser dividido em Unidades lógicas e fazer essa divisão nem sempre é fácil, pois envolve um nível de pensamento abstrato e lógico.&lt;/p&gt;

&lt;p&gt;Após dividir as Unidades do projeto, também temos que nos preocupar com as Unidades de terceiros.&lt;/p&gt;

&lt;p&gt;Hoje em dia é quase mandatório utilizarmos &lt;em&gt;libs&lt;/em&gt; e &lt;em&gt;frameworks&lt;/em&gt; de terceiros. Na maioria das vezes são projetos &lt;em&gt;OpenSource&lt;/em&gt; como, por exemplo, o &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tais Unidades facilitam o nosso trabalho, pois já possuem artefatos prontos que agilizam muito a conclusão do projeto.&lt;/p&gt;

&lt;p&gt;Além dessas Unidades de terceiros, também temos as Unidades padrão da linguagem localizadas na &lt;em&gt;Run-time Library&lt;/em&gt; (RTL) ou VCL/LCL, possuindo muitas interfaces, classes, funções e artefatos prontos para uso.&lt;/p&gt;

&lt;p&gt;Então, qual ordem devemos declarar essas Unidades quando utilizamos em uma das nossas próprias Unidades?&lt;/p&gt;

&lt;p&gt;Aqui está a ordem que eu proponho:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyUnit;
uses
  // 1. fpc/lazarus/delphi units,
  // 2. 3rd units,
  // 3. my open source units,
  // 4. project units
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando o compilador começa a fazer o &lt;em&gt;parser&lt;/em&gt; do código do seu projeto e ele chega na &lt;code&gt;MyUnit&lt;/code&gt;, ele irá ler as Unidades na sequência na qual elas foram declaradas — pode haver alguma otimização, como leitura paralela, porém o que importa é o resultado final, no qual depende da ordem acima — e os identificadores (classes, interfaces, funções/procedimentos, variáveis e constantes) serão “armazenados em ordem” na qual eles foram declarados.&lt;/p&gt;

&lt;p&gt;Por isso eu proponho declarar, inicialmente, todas as Unidades que são padrão ao ambiente. Depois, todas as Unidades de terceiros como &lt;em&gt;libs&lt;/em&gt; e &lt;em&gt;frameworks&lt;/em&gt;. Então, todas as Unidades referentes a seus projetos públicos, sejam eles &lt;em&gt;OpenSource&lt;/em&gt; ou compartilhados dentro de setores de uma empresa. Finalmente, declaramos as Unidades do projeto em si, ou seja, no projeto no qual estamos trabalhando no momento.&lt;/p&gt;

&lt;p&gt;E por quê isso é importante?&lt;/p&gt;

&lt;p&gt;O motivo é porque o compilador precisa saber em qual Unidade um determinado artefato (classe, função, etc) está localizado.&lt;/p&gt;

&lt;p&gt;A regra é a seguinte:&lt;/p&gt;

&lt;p&gt;Se você tem 3 Unidades (&lt;code&gt;Unit1&lt;/code&gt;, &lt;code&gt;Unit2&lt;/code&gt; e &lt;code&gt;Unit3&lt;/code&gt;) e, em cada uma delas, tem uma classe com o nome &lt;code&gt;TFoo&lt;/code&gt;, o compilador irá “informar” ao seu código que &lt;code&gt;TFoo&lt;/code&gt; está localizada na última Unidade declarada.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  Unit1, Unit3, Unit2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reparem que eu inverti a ordem numérica. Primeiro é a 1, depois 3 e por último a 2.&lt;/p&gt;

&lt;p&gt;Onde está localizada a classe &lt;code&gt;TFoo&lt;/code&gt; quando você utilizá-la na sua Unidade, a &lt;code&gt;MyUnit&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;A resposta é: Na &lt;code&gt;Unit2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Motivo: Ela foi declarada por &lt;em&gt;último&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Imagine que o compilador vai montando, em memória, uma tabela de referência para todos os identificadores que ele encontra. Primeiro ele encontra &lt;code&gt;TFoo&lt;/code&gt; quando lê a &lt;code&gt;Unit1&lt;/code&gt;, depois encontra novamente quando lê a &lt;code&gt;Unit3&lt;/code&gt;. Nesse momento ele &lt;em&gt;substitui&lt;/em&gt; a referência que dizia que &lt;code&gt;TFoo&lt;/code&gt; está na &lt;code&gt;Unit1&lt;/code&gt;, pois agora está na &lt;code&gt;Unit3&lt;/code&gt;. Por fim, quando ele lê a &lt;code&gt;Unit2&lt;/code&gt; o identificador é reposicionado novamente.&lt;/p&gt;

&lt;p&gt;Se nessa mesma &lt;code&gt;MyUnit&lt;/code&gt; eu precisar utilizar &lt;code&gt;TFoo&lt;/code&gt; da &lt;code&gt;Unit1&lt;/code&gt;, eu sou obrigado a qualificar a classe com o nome da Unidade ao invés de apenas utilizar o identificador:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Foo := Unit1.TFoo.Create...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vocês podem ver outro exemplo &lt;a href=&quot;http://castle-engine.io/modern_pascal_introduction.html#_qualifying_identifiers_with_unit_name&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;secoes&quot;&gt;Seções&lt;/h2&gt;

&lt;p&gt;Na linguagem &lt;em&gt;Object Pascal&lt;/em&gt; temos dois lugares (seções) onde podemos declarar as Unidades que serão utilizadas.&lt;/p&gt;

&lt;p&gt;Podemos declarar na seção de interface ou na seção de implementação.&lt;/p&gt;

&lt;p&gt;Vale a pena declarar Unidades na seção de implementação?&lt;/p&gt;

&lt;p&gt;Na minha opinião sincera, não.&lt;/p&gt;

&lt;p&gt;Ao fazer isso, você terá 2 lugares para organizar a precedência da Unidades, ou seja, terá mais trabalho.&lt;/p&gt;

&lt;p&gt;Como a linguagem &lt;em&gt;Object Pascal&lt;/em&gt; não aceita &lt;a href=&quot;/posts/interfaces-e-a-referencia-circular-entre-objetos/&quot;&gt;referência circular&lt;/a&gt; entre Unidades, o motivo de haver opção para declarar Unidades na implementação é para permitir essa referência bi-direcional entre elas. No entanto, isso também indica um mal &lt;em&gt;design&lt;/em&gt; na divisão das Unidades do projeto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Definir a ordem de declaração das Unidades em cada Unidade de seu projeto pode ser de extrema importância para facilitar a manutenção e organização.&lt;/p&gt;

&lt;p&gt;Conforme você for adicionando novos identificadores, você terá a certeza que o compilador dará “prioridade” para uso dos identificadores do seu projeto, sem precisar prefixar com o nome da Unidade.&lt;/p&gt;

&lt;p&gt;Caso você adicione algum identificador e este entre em conflito com outra Unidade que possui o mesmo nome, basta prefixar esse identificador com o nome da Unidade, seja ela de terceiros ou do próprio ambiente. Entretando esse conflito não existirá nos identificadores das Unidades do seu projeto.&lt;/p&gt;

&lt;p&gt;Portanto deixe mais “próximo” do código as Unidades que pertencem ao projeto, ou seja, as Unidades que são mais utilizadas e mais “distantes” as Unidades auxiliares.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/declarando-unidades</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/declarando-unidades</guid>
      </item>
    
      <item>
        <title>James 2017-07</title>
        <description>&lt;p&gt;James é um projeto Open Source que será a base de todos os meus projetos Orientados a Objetos codificados em Object Pascal.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-hope-house-press-127593.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;james&quot;&gt;James&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;O que é?&lt;/strong&gt; &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James&lt;/a&gt; é uma coleção de classes e interfaces para projetos verdadeiramente orientados a objetos escritos em Object Pascal. Esta API está sendo escrita em Free Pascal e Lazarus. No entanto, torná-lo compatível com Delphi pode ser possível ou mesmo pode ser um objetivo (estamos dependendo de mais contribuidores para torná-lo possível).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Por quê?&lt;/strong&gt; Nós não queremos mais escrever o código procedural, nunca mais. Queremos escrever código elegante, limpo e sustentável usando a OOP.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Princípios&lt;/strong&gt;. O código possui alguns princípios de &lt;em&gt;design&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Totalmente baseado em interface&lt;/li&gt;
  &lt;li&gt;A memória é liberada automaticamente&lt;/li&gt;
  &lt;li&gt;Todos os métodos públicos são implementações de métodos de interface&lt;/li&gt;
  &lt;li&gt;Todos os métodos públicos retornam uma instância de interface ou tipo primitivo&lt;/li&gt;
  &lt;li&gt;Nenhum uso de NULL em argumentos ou retornos de métodos&lt;/li&gt;
  &lt;li&gt;Sem algoritmos nos construtores&lt;/li&gt;
  &lt;li&gt;Não há getters e setters&lt;/li&gt;
  &lt;li&gt;Sem &lt;em&gt;casting&lt;/em&gt; ou reflexão utilizando RTTI&lt;/li&gt;
  &lt;li&gt;Sem procedimentos e funções, apenas Objetos&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Mais informações&lt;/strong&gt;. Leia mais sobre o James &lt;a href=&quot;/posts/james/&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;/posts/james-e-testes-de-unidade/&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;como-contribuir&quot;&gt;Como contribuir?&lt;/h3&gt;

&lt;p&gt;Apenas faça um &lt;em&gt;fork&lt;/em&gt; do &lt;a href=&quot;https://github.com/mdbs99/james#fork-destination-box&quot;&gt;repositório&lt;/a&gt; e envie-nos um &lt;em&gt;Pull Request&lt;/em&gt; (PR).&lt;/p&gt;

&lt;p&gt;Cada PR precisa trabalhar apenas sobre uma única &lt;em&gt;issue&lt;/em&gt; ou em uma &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;única responsabilidade&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Por favor, nomeie seu PR usando o mesmo estilo de outros PR já &lt;a href=&quot;https://github.com/mdbs99/james/pulls?q=is%3Apr+is%3Aclosed&quot;&gt;finalizados&lt;/a&gt; neste projeto.&lt;/p&gt;

&lt;p&gt;Certifique-se de que o seu ramo seja construído sem quaisquer &lt;em&gt;warnings&lt;/em&gt;/problemas.&lt;/p&gt;

&lt;p&gt;Se você tiver dúvidas ou sugestões gerais, não hesite em enviar uma nova &lt;a href=&quot;https://github.com/mdbs99/james/issues/new&quot;&gt;Github issue&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;atualizacoes&quot;&gt;Atualizações&lt;/h3&gt;

&lt;p&gt;Ainda estamos em uma versão alfa muito precoce, a API pode e vai mudar com freqüência. Por favor, use isso por sua conta e risco, até liberarmos a versão 1.0.&lt;/p&gt;

&lt;p&gt;Algumas &lt;em&gt;unidades&lt;/em&gt; foram excluídas e outras foram criadas. Classes foram movidas e renomeadas.&lt;/p&gt;

&lt;p&gt;Vejamos abaixo as modificações mais recentes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/18&quot;&gt;PR #18&lt;/a&gt;: Só vamos utilizar caracteres ASCII para facilitar o uso no Delphi sem haver problemas de UNICODE (&lt;a href=&quot;https://www.mail-archive.com/lazarus@lists.lazarus-ide.org/msg02754.html&quot;&gt;veja mais&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/19&quot;&gt;PR #19&lt;/a&gt;: A classe &lt;code&gt;TStreamBase64&lt;/code&gt; não apenas foi renomeada para &lt;code&gt;TBase64Stream&lt;/code&gt;, como também está numa nova unidade chamada &lt;code&gt;james.format.base64.clss&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/20&quot;&gt;PR #20&lt;/a&gt;: A unidade &lt;code&gt;james.data.xml.clss&lt;/code&gt; foi renomeada para &lt;code&gt;james.format.xml.clss&lt;/code&gt; adicionando um novo prefixo &lt;code&gt;format&lt;/code&gt; que poderá ser utilizado por outros “formatos” como JSON, INI, etc.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/21&quot;&gt;PR #21&lt;/a&gt;: As unidades &lt;code&gt;james.files.*&lt;/code&gt; foram renomeadas para &lt;code&gt;james.io.*&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/23&quot;&gt;PR #23&lt;/a&gt;: Criada uma nova unidade &lt;code&gt;james.crypto.md5.clss&lt;/code&gt; que, além de adicionar um novo prefixo &lt;code&gt;crypto&lt;/code&gt; para outros tipos de criptografia, também contém classes relacionadas ao MD5.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/30&quot;&gt;PR #30&lt;/a&gt;: Adicionado as classes que implementam &lt;a href=&quot;/objetos-validadores#constraints&quot;&gt;Constraints&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A maioria das modificações são apenas estéticas ou apenas para melhorar a organização. No entanto são modificações necessárias para fazer o projeto crescer com saúde.&lt;/p&gt;

&lt;p&gt;Por enquanto é isso. Aguardo seus comentários aqui embaixo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/james-2017-07</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/james-2017-07</guid>
      </item>
    
      <item>
        <title>Objetos Validadores</title>
        <description>&lt;p&gt;Veja como fazer validações utilizando Objetos ao invés de utilizar programação procedural.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-scott-webb-59043.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Na Orientação a Objetos a codificação deve ser declarativa. Isso quer dizer que, num mundo ideal, iríamos criar os Objetos agrupando-os entre si e, com uma única &lt;a href=&quot;/posts/diga-me-algo-sobre-voce/#mensagens&quot;&gt;mensagem&lt;/a&gt;, o trabalho a ser realizado seria iniciado e cada Objeto iria realizar parte desse trabalho. Tudo em perfeita harmonia.&lt;/p&gt;

&lt;p&gt;No entanto, não vivemos num mundo ideal e problemas podem ocorrer.&lt;/p&gt;

&lt;p&gt;Se pudermos validar o &lt;em&gt;input&lt;/em&gt; dos dados no nosso sistema antes de iniciar um processo mais elaborado, isso tornaria o processamento menos custoso, menos demorado e menos propenso a erros.&lt;/p&gt;

&lt;p&gt;No entanto, se devemos codificar de forma declarativa, ou seja, sem condicionais que validem passo-a-passo o que está sendo processado — o &lt;em&gt;modus operandis&lt;/em&gt; da programação procedural — como seria possível fazer isso utilizando Objetos para deixar o código mais seguro e fazer um tratamento mais adequado para cada problema ou decisão, antes que uma exceção possa ocorrer?&lt;/p&gt;

&lt;h2 id=&quot;validacoes&quot;&gt;Validações&lt;/h2&gt;

&lt;p&gt;Imagine um Formulário onde há diversos campos para o usuário preencher antes de clicar em algum botão que irá fazer algo com os dados preenchidos nos &lt;em&gt;widgets&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Sempre temos que validar o &lt;em&gt;input&lt;/em&gt; antes de processá-lo, certo?&lt;/p&gt;

&lt;p&gt;Tenho trabalhado com desenvolvimento de &lt;em&gt;software&lt;/em&gt; a muitos anos. Grande parte desse tempo eu codifiquei a validação de campos utilizando o mesmo “padrão” que até hoje é utilizado, independentemente da linguagem utilizada.&lt;/p&gt;

&lt;p&gt;Vejamos como é esse padrão:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/1d990d474d0a15a7543c54c5c02b370a.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O exemplo acima é sobre um Formulário que contém alguns campos, dentre esses campos temos &lt;code&gt;Name&lt;/code&gt; e &lt;code&gt;Birthday&lt;/code&gt;. O primeiro é &lt;em&gt;string&lt;/em&gt; e não pode estar em branco. Já o segundo deveria ser uma data válida, então o código utiliza a função padrão &lt;code&gt;SysUtils.TryStrToDate&lt;/code&gt; que verifica se é uma data válida e retorna o valor na variável &lt;code&gt;MyDate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Quem nunca fez isso?&lt;/p&gt;

&lt;p&gt;Pois é.&lt;/p&gt;

&lt;p&gt;Há problemas demais com essa abordagem:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Não podemos reutilizar as validações. Em cada Formulário haverá uma possível cópia do mesmo código;&lt;/li&gt;
  &lt;li&gt;As variáveis locais podem aumentar consideravelmente caso haja mais testes que necessitem de variáveis;&lt;/li&gt;
  &lt;li&gt;O código é totalmente procedural;&lt;/li&gt;
  &lt;li&gt;Não posso utilizar as informações de aviso ao usuário em outra aplicação Web, por exemplo, visto que as &lt;em&gt;strings&lt;/em&gt; estão codificadas dentro de funções &lt;code&gt;ShowMessage&lt;/code&gt; (ou qualquer outra função de mensagem para Desktop);&lt;/li&gt;
  &lt;li&gt;O Formulário ficou complexo, visto que há muito código num único evento — e não adianta apenas criar vários métodos privados para cada teste, pois o Formulário irá continuar fazendo coisas demais.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Há variantes dessa abordagem acima, porém acredito que todos nós já vimos algo assim ou mesmo estamos codificando dessa maneira ainda hoje.&lt;/p&gt;

&lt;p&gt;O que podemos fazer para simplificar o código, obter a reutilização das validações e ainda codificar utilizando Orientação a Objetos?&lt;/p&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Constraints&lt;/em&gt; são Objetos que tem por função a validação de algum dado ou mesmo a validação de outro Objeto.&lt;/p&gt;

&lt;p&gt;Cada &lt;em&gt;constraint&lt;/em&gt; valida apenas 1 artefato. Assim podemos reutilizar a validação em muitos outros lugares.&lt;/p&gt;

&lt;p&gt;Vamos definir algumas &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/c668747123d651298e9f40d0e10af5b4.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Vamos entender cada Interface:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;[guids]&lt;/code&gt;: São necessários para &lt;em&gt;casting&lt;/em&gt; de Interfaces.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataInformation&lt;/code&gt;: Representa uma infomação.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataInformations&lt;/code&gt;: Representa uma lista de informações.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataResult&lt;/code&gt;: Representa um resultado de uma restrição.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataConstraint&lt;/code&gt;: Representa uma restrição.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataConstraints&lt;/code&gt;: Representa uma lista de restrições.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Não estou utilizando &lt;em&gt;Generics&lt;/em&gt;. Apenas Classes que podem ser reescritas em praticamente qualquer versão do Lazarus ou Delphi.&lt;/p&gt;

&lt;p&gt;Bem simples.&lt;/p&gt;

&lt;p&gt;Agora veremos a implementação das Interfaces — por questões de breviedade, vou apresentar somente as assinaturas das Classes:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/b254ff882ce27ce9fa4e8219c63e3e96.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Essas são Classes utilizadas em projetos reais. &lt;del&gt;Em breve&lt;/del&gt; todo o código &lt;del&gt;estará&lt;/del&gt; já está disponível no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt;. Você poderá obter esse código acompanhando a &lt;a href=&quot;https://github.com/mdbs99/james/issues/17&quot;&gt;Issue #17&lt;/a&gt; do mesmo projeto.&lt;/p&gt;

&lt;p&gt;Na implementação acima não tem nenhuma Classe que implemente a Interface &lt;code&gt;IDataConstraint&lt;/code&gt;. O motivo disso é que você, programador, irá criar suas próprias &lt;em&gt;constraints&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo de como reescrever o código procedural do primeiro exemplo.&lt;/p&gt;

&lt;p&gt;Precisamos criar duas Classes que implementam &lt;code&gt;IDataConstraint&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Como só há apenas 1 método nessa Interface, e para não deixar esse artigo ainda maior, vou mostrar o código de apenas uma implementação:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/62040307d41fbc45c0f15605acc541b5.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O código acima mostra como seria a implementação para a &lt;em&gt;constraint&lt;/em&gt; &lt;code&gt;TNameConstraint&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O código está &lt;em&gt;procedural&lt;/em&gt; e ainda pode &lt;em&gt;melhorar&lt;/em&gt; muito. As variáveis locais poderiam ser retiradas, bastando adicionar mais um &lt;em&gt;overload&lt;/em&gt; do método &lt;code&gt;New&lt;/code&gt; na Classe &lt;code&gt;TDataResult&lt;/code&gt; — você consegue ver essa possibilidade? Conseguiria implementá-la?&lt;/p&gt;

&lt;p&gt;Abaixo o código de como utilizar todos esses Objetos em conjunto:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/5dc64c57916d86d01de561077d831aaf.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Se nas validações acima o nome estivesse &lt;em&gt;em branco&lt;/em&gt; mas a data de aniverário tivesse sido digitada &lt;em&gt;corretamente&lt;/em&gt; — o resultado do método &lt;code&gt;OK&lt;/code&gt; será verdadeiro se apenas todas as validações passarem no teste — o resultado do &lt;code&gt;ShowMessage&lt;/code&gt; poderia ser:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- Name: Name is empty
- Birthday: OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essa seria apenas uma versão da implementação de como mostrar as informações. Poderia haver muitos outros &lt;em&gt;decoradores&lt;/em&gt; para mostrar a informação em outros formatos como, por exemplo, HTML numa aplicação Web.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O código não está completo, mas acredito que posso ter aberto sua mente a novas possibilidades quando se trata de validações.&lt;/p&gt;

&lt;p&gt;O resultado final de &lt;code&gt;SaveButtonClick&lt;/code&gt;, mesmo utilizando a Classe &lt;code&gt;TDataConstraints&lt;/code&gt;, também não foi implementada complemente seguindo o paradigma da Orientação a Objetos — para deixar o código mais sucinto — pois tem um &lt;code&gt;IF&lt;/code&gt; lá que não deixa o código tão elegante quanto deveria, mas eu acho que dá para você visualizar as possibilidades de uso.&lt;/p&gt;

&lt;p&gt;A instância de &lt;code&gt;TDataConstraints&lt;/code&gt; e seus itens poderia ser utilizada em muitos outros lugares do código.&lt;/p&gt;

&lt;p&gt;A combinação de tais Objetos é virtualmente infinita e seu será o mesmo em &lt;em&gt;todo&lt;/em&gt; código.&lt;/p&gt;

&lt;p&gt;O código é &lt;em&gt;reutilizável&lt;/em&gt; em qualquer tipo de aplicação.&lt;/p&gt;

&lt;p&gt;Nenhuma informação ou mensagem ao usuário seria duplicada no código. Haverá apenas um &lt;em&gt;único&lt;/em&gt; lugar, uma única Classe, para fazer a manutenção de cada validação.&lt;/p&gt;

&lt;p&gt;E a exibição da mensagem poderia ser em qualquer formato, bastando utilizar outros Objetos &lt;em&gt;decoradores&lt;/em&gt; para ler as &lt;em&gt;informations&lt;/em&gt;, formatando como quiser.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/objetos-validadores</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/objetos-validadores</guid>
      </item>
    
      <item>
        <title>Atributos Não Existem</title>
        <description>&lt;p&gt;E se eu lhe dissesse que Atributos não existem realmente?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-guillaume-bolduc-259596.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tive um &lt;em&gt;insight&lt;/em&gt; um dia desses:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Não existem Atributos, apenas Composição e Comportamento”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;O que chamamos de &lt;a href=&quot;/posts/menos-e-mais/#atributos&quot;&gt;Atributo&lt;/a&gt; é, na verdade, Composição de Objetos e &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;Comportamento&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Atributos &lt;em&gt;não&lt;/em&gt; existem. São virtuais, produtos de nossa imaginação ou apenas uma abstração da realidade.&lt;/p&gt;

&lt;p&gt;Veja as Cores, por exemplo.&lt;/p&gt;

&lt;p&gt;Não existe atributos de cor Amarelo, Vermelho ou Azul. São todos Objetos!&lt;/p&gt;

&lt;p&gt;O Amarelo é um Objeto numa composição &lt;em&gt;RGB&lt;/em&gt; e nosso olho processa essa composição interagindo com outro Objeto, a &lt;em&gt;Luz&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Assim “vemos” as cores.&lt;/p&gt;

&lt;p&gt;Quer outros exemplos?&lt;/p&gt;

&lt;p&gt;A quantidade de itens numa lista é determinada pelo comportamento do Objeto ao contar os itens da lista.&lt;/p&gt;

&lt;p&gt;A idade de uma pessoa é determinada pelo comportamento do Objeto ao contar o tempo.&lt;/p&gt;

&lt;p&gt;Não há nada de errado em continuarmos utilizando a palavra Atributo, mas não se esqueça que eles não existem. São apenas abstrações da realidade.&lt;/p&gt;

&lt;p&gt;Faz sentido?&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Jun 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/atributos-nao-existem</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/atributos-nao-existem</guid>
      </item>
    
  </channel>
</rss>
