<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Como Dividir e Organizar o Código em Formulários com Muitos Widgets</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/robert-bye-200739-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Robert Bye on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Em um formulário com muitos widgets, haveria dezenas de métodos para controlá-los. Esses métodos lidariam com o estado visual (visível, checado, cores,…); com os dados (texto, grids, labels,…); mensagens (dialogs, popups,…) e todo tipo de interação entre os componentes visuais e não-visuais.&lt;/p&gt;

&lt;p&gt;Definir dezenas de métodos em formulários e DataModules parece ser comum. O programador cria um DataModule com queries e componentes relacionados, acrescenta 50 métodos e considera ter feito um ótimo trabalho na reutilização e organização do código — no entanto ele só criou mais uma classe inchada, seguindo o anti-padrão conhecido como a &lt;a href=&quot;http://wiki.c2.com/?GodClass&quot;&gt;síndrome da classe Deus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nesse artigo você poderá aprender algumas técnicas para se livrar dessas classes com dezenas de métodos, difíceis de entender e gerenciar.&lt;/p&gt;

&lt;h2 id=&quot;rad&quot;&gt;A culpa é do RAD?&lt;/h2&gt;

&lt;p&gt;Na minha opinião, Delphi sempre foi a melhor IDE para desenvolvimento de aplicações Desktop — até surgirem opções como Lazarus — e grande parte desse sucesso é devido ao conceito e uso do RAD (Rapid Application Development).&lt;/p&gt;

&lt;p&gt;Largue um componente no formulário, defina algumas propriedades, implemente alguns eventos e pronto. Fácil. Rápido. Mas talvez, sujo.&lt;/p&gt;

&lt;p&gt;Para prototipagem é ótimo. Você consegue mostrar ao cliente algo funcionando em minutos. Mas para código real, para a manutenção, esse tipo de design pode se tornar um pesadelo no médio prazo.&lt;/p&gt;

&lt;p&gt;Mas a culpa não é do RAD. Ele é apenas uma ferramenta. Ferramentas sozinhas não fazem mal projetos. Os desenvolvedores fazem.&lt;/p&gt;

&lt;p&gt;RAD foi feito para agilizar o desenvolvimento, especialmente no design de formulários. Mas levaram esse conceito tão longe que muitos desenvolvedores só conhecem esse caminho para o desenvolvimento, desde formulários, regras de negócio, até a persistência.&lt;/p&gt;

&lt;p&gt;RAD significou o sucesso mas também a “desgraça” do Delphi. É por causa do RAD que o Delphi (até hoje) não é bem visto em círculos de desenvolvimento mais voltados a regras de negócio, padrões de projetos, aplicações em camadas, etc.&lt;/p&gt;

&lt;p&gt;Mas, novamente, não é culpa do RAD. Não há nada de errado com RAD. O errado e tentar implementar tudo no modelo RAD, na minha opinião.&lt;/p&gt;

&lt;p&gt;É mais fácil largar componentes no formulário e setar propriedades e eventos, do que pensar em padrões de projeto, orientação a objetos e desenvolvimento em camadas.&lt;/p&gt;

&lt;p&gt;RAD funciona, mas não é sustentável no longo prazo.&lt;/p&gt;

&lt;h2 id=&quot;forms&quot;&gt;Formulários sem Métodos&lt;/h2&gt;

&lt;p&gt;O uso indiscriminado do RAD pode deixar a aplicação tão acoplada que seria muito difícil ter camadas separadas entre GUI, regras de negócio e persistência.&lt;/p&gt;

&lt;p&gt;Acredito que para remover o conceito de “RAD para tudo”, temos que começar com o básico, por exemplo, como desenvolver formulários com uma quantidade mínima de métodos.&lt;/p&gt;

&lt;p&gt;A quantidade de métodos não está relacionado diretamente ao RAD — você pode ter uma classe com 100 métodos em qualquer linguagem, utilizando RAD ou não — no entanto, eu acredito que o RAD “estimula” essa prática, pois se todos os widgets e eventos estão declarados no formulário, onde mais eu iria implementar os métodos para lidar com esses componentes, certo?&lt;/p&gt;

&lt;p&gt;Essa prática e muito comum, porém equivocada. Uma classe deveria ser pequena — menor quantidade de métodos possível — e coesa — todos os seus atributos são utilizados na maior quantidade de métodos possível. E fazer isso em um formulário e praticamente impossível.&lt;/p&gt;

&lt;p&gt;A tendência é que cada novo método trabalhe com poucos widgets; os métodos terão uma nomenclatura tão verbosa quanto uma frase, pois todos irão fazer parte de uma mesma classe e não pode haver ambiguidade ou colisão de nomes.&lt;/p&gt;

&lt;p&gt;Quantas vezes isso já aconteceu com você?&lt;/p&gt;

&lt;p&gt;Seria possível termos formulários com o &lt;a href=&quot;https://objectpascalprogramming.com/posts/menos-e-mais/#metodos&quot;&gt;mínimo de métodos&lt;/a&gt; ou até nenhum e, mesmo assim, capazes de controlar as interações entre todos os widgets e componentes visuais e não-visuais?&lt;/p&gt;

&lt;p&gt;A primeira prática que eu recomendo é separar widgets em frames — disponíveis no Delphi desde as primeiras versões através da classe &lt;code&gt;TFrame&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Muitos formulários possuem &lt;em&gt;tabs&lt;/em&gt; e cada tab pode ser um frame que desconhece completamente o formulário onde ele está contido.&lt;/p&gt;

&lt;p&gt;Cada frame irá ter seu próprio conjunto de widgets, com nomenclatura simplificada, visto que não há colisões de nomes entre outros widgets se tudo estivesse em um mesmo formulário.&lt;/p&gt;

&lt;p&gt;Esse é o &lt;em&gt;primeiro&lt;/em&gt; nível da refatoração.&lt;/p&gt;

&lt;p&gt;Mas isso não elimina a quantidade enorme de métodos que poderão existir, pois o desenvolvedor precisa por ação nos formulários e frames.&lt;/p&gt;

&lt;p&gt;O segundo nível consiste em dividir para conquistar, eliminando quase que totalmente os métodos de um formulário.&lt;/p&gt;

&lt;h2 id=&quot;dividir&quot;&gt;Dividir para Conquistar&lt;/h2&gt;

&lt;p&gt;Independente de ser um formulário, frame ou DataModule, considere todos como sendo &lt;a href=&quot;2016-02-22-datamodule-e-apenas-um-container&quot;&gt;containers&lt;/a&gt; de componentes (visuais ou não).&lt;/p&gt;

&lt;p&gt;O objetivo é dividir os métodos em pequenos objetos que irão fazer uso dos componentes do container.&lt;/p&gt;

&lt;p&gt;Mesmo que esse artigo se refira a formulários complexos, vou lhe dar um exemplo simples, mostrando que com apenas 1 widget, poderíamos adicionar vários métodos ao formulário, erroneamente.&lt;/p&gt;

&lt;p&gt;Considere uma instância de um &lt;code&gt;TStatusBar&lt;/code&gt; para exibir informações da aplicação.&lt;/p&gt;

&lt;p&gt;O usuário precisaria ver a versão da aplicação; o database em uso; o status atual de algum processamento.&lt;/p&gt;

&lt;p&gt;Um StatusBar possui a propriedade &lt;code&gt;Panels[]&lt;/code&gt;que é como um array de objetos de texto — dado um índice, você altera o texto naquela posição.&lt;/p&gt;

&lt;p&gt;Um programador iniciante talvez iria utilizá-lo dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;StatusBar1.Panels[0].Text := version;
StatusBar1.Panels[1].Text := database;
StatusBar1.Panels[2].Text := &#39;Loading...&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Um programador mais experiente saberia que não se deve utilizar índices arbitrários pelo código — se quisermos mudar a posição de alguma informação, teríamos que percorrer todo o código para mudar os índices para novas posições. Esse programador provavelmente iria criar constantes para cada índice, o que resolveria a manutenção futura, no entanto teríamos constantes (verbosas) no código que estão “desacopladas” do objeto no qual elas atuam, ou seja, o StatusBar.&lt;/p&gt;

&lt;p&gt;O código ficaria dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const
  STATUSBAR_VERSION = 0;
  STATUSBAR_DATABASE = 1;
  STATUSBAR_STATUS = 2;

StatusBar1.Panels[STATUSBAR_VERSION].Text := version;
StatusBar1.Panels[STATUSBAR_DATABASE].Text := database;
StatusBar1.Panels[STATUSBAR_STATUS].Text := &#39;Loading...&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja o quão é verboso cada constante, pois é (quase) obrigatório utilizar prefixos para deixar claro em qual componente(s) esse  “grupo de constantes” trabalham.&lt;/p&gt;

&lt;p&gt;Outro tipo de desenvolvedor iria utilizar métodos no formulário. O exemplo abaixo pode ser meio extremo, mas considere que eu não poderia dar um exemplo real pois não caberia nesse artigo. Portanto, utilizar tais métodos não estaria tão longe da realidade:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  procedure SetStatusBarVersion(const aValue: string);
  procedure SetStatusBarDatabase(const aValue: string);
  procedure SetStatusBarStatus(const aValue: string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Criando métodos no formulário elimina as constantes e índices, porém incha a classe do formulário.&lt;/p&gt;

&lt;p&gt;Veja, também, o quão é verboso cada método, novamente utilizando prefixos longos e entediantes — nomes longos em métodos e variáveis são sinais de que eles podem não fazer parte da classe onde estão.&lt;/p&gt;

&lt;p&gt;Foram adicionados 3 métodos para lidar com apenas 1 componente que exibe texto.&lt;/p&gt;

&lt;p&gt;Finalmente, um arquiteto de software teria objetivos maiores como: reutilizar os métodos em outro formulário ou projeto; simplificar o formulário, removendo métodos que lidam apenas com poucos componentes; retirar índices e constantes arbitrárias; trabalhar com o StatusBar sem pensar que ele é um StatusBar, abstraindo-o.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TStatusBarWidget = class
private
  fOrigin: TStatusBar;
  fVersion: string;
  fDatabase: string;
  fStatus: string;
public
  constructor Create(aOrigin: TStatusBar); reintroduce;
  property Version: string read fVersion;
  property Database: string read fDatabase;
  property Status: string read fStatus write fStatus;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essa classe iria receber a instância do StatusBar real no construtor, inicializada no construtor do formulário; iria obter os dados da versão e database automaticamente, disponibilizando propriedades somente leitura; o status poderia ser atualizado e lido dentro dos eventos do formulário.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
   fStatusBar.Status := &#39;Loading...&#39;;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toda a lógica referente ao StatusBar estaria encapsulada dentro da classe &lt;code&gt;TStatusBarWidget&lt;/code&gt;, podendo ser reutilizada em outro lugar.&lt;/p&gt;

&lt;p&gt;Outros programadores que porventura trabalhem no código, não iriam precisar lembrar de índices ou constantes arbitrárias. Eles iriam utilizar apenas um único objeto com métodos bem definidos para cada atividade, abstraindo sobre o que esta acontecendo internamente ao objeto — a atualização do StatusBar.&lt;/p&gt;

&lt;p&gt;O formulário não teria nenhum método (relacionado a StatusBar), contendo apenas um atributo privado do tipo &lt;code&gt;TStatusBarWidget&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O exemplo é simples, porém acredito que você tenha visualizado que poderá utilizar essa técnica não apenas para encapsular um componente, mas também para todo um conjunto deles, implementando toda a interação entre eles num único objeto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Toda vez que você nomear um método com nomenclatura composta, pare e pense se esse método deveria estar em outra classe.&lt;/p&gt;

&lt;p&gt;Não implemente vários métodos numa única classe. Separe-os em objetos menores e coesos, mesmo que esses objetos trabalhem diretamente com os componentes do container.&lt;/p&gt;

&lt;p&gt;É melhor ter vários objetos pequenos, mesmo que fortemente acoplados, do que por tudo num único objeto onde a manutenção irá se tornar um caos em pouco tempo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/formularios-e-widgets</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/formularios-e-widgets</guid>
      </item>
    
      <item>
        <title>Pascal Deveria ser Modernizado?</title>
        <description>&lt;p&gt;Ao longo dos anos, desde Turbo Pascal até as versões mais atuais do Delphi e Lazarus, temos visto muitas mudanças na linguagem.&lt;/p&gt;

&lt;p&gt;Você acha que estamos modernizando a linguagem Object Pascal?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/hayes-potter-1054894-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Hayes Potter on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;É incrível como até hoje eu ainda tenho que responder perguntas sobre os motivos de continuar utilizando a linguagem Object Pascal.&lt;/p&gt;

&lt;p&gt;Vou desenvolver utilizando Object Pascal — eu digo a um possível cliente.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Object Pas… Ah, aquela linguagem da Apple? (Objective C)&lt;/li&gt;
  &lt;li&gt;Acho que você quer dizer Delphi, não é?&lt;/li&gt;
  &lt;li&gt;Por quê você continua utilizando “isso”?&lt;/li&gt;
  &lt;li&gt;Por quê não utilizar C# ou Java?&lt;/li&gt;
  &lt;li&gt;Você ainda consegue achar emprego?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Eu já escrevi meus &lt;a href=&quot;/porque-eu-escolhi-delphi-e-object-pascal#motivos&quot;&gt;motivos&lt;/a&gt; mas entendo como pode ser difícil para a maioria das pessoas acreditarem.&lt;/p&gt;

&lt;p&gt;Talvez eles pensem que Object Pascal não é tão &lt;a href=&quot;https://castle-engine.io/modern_pascal_introduction.html&quot;&gt;moderno&lt;/a&gt; quanto as linguagens &lt;em&gt;mainstream&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;prioridade&quot;&gt;Quando o Concorrente é Prioridade&lt;/h2&gt;

&lt;p&gt;Existem linguagens muito mais “modernas” hoje em dia e escolher uma que “está morta” não parece uma opção razoável &lt;del&gt;para aqueles que só sabem seguir cegamente o que a maioria diz&lt;/del&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Se você quer chegar onde a maioria não chega, faça o que a maioria não faz — Bill Gates&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Talvez esse sentimento de modernização está abalando até mesmo os diretores e desenvolvedores do atual Delphi.&lt;/p&gt;

&lt;p&gt;A “modernização” a que me refiro pode ser simplificada dessa forma:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Se meu concorrente tem tal feature, eu preciso ter também.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;E isso pode matar a linguagem.&lt;/p&gt;

&lt;h3 id=&quot;inline&quot;&gt;Inline Variable Declarations&lt;/h3&gt;

&lt;p&gt;A alguns dias recebemos a notícia que a linguagem Delphi irá ter &lt;em&gt;Inline Variables&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Marco Cantu — respeitado e conceituado no mundo Delphi — já começou a “matar” a sintaxe Pascal clássica de declaração de variáveis quando inicia seu &lt;a href=&quot;http://blog.marcocantu.com/blog/2018-october-inline-variables-delphi.html&quot;&gt;artigo&lt;/a&gt; escrevendo “Old Style Var Blocks”.&lt;/p&gt;

&lt;p&gt;Então é oficial, estamos &lt;em&gt;defasados&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Na linguagem Object Pascal, declaramos as variáveis em blocos bem definidos e organizados, diferentemente de outras linguagens onde pode-se declarar onde quiser. Entretanto, agora isso parece ser ruim, já que a maioria faz diferente.&lt;/p&gt;

&lt;p&gt;Solução? Ora, vamos copiar o concorrente!&lt;/p&gt;

&lt;p&gt;O foco parece ser mais no que o concorrente anda fazendo nos compiladores deles do que nos seus fieis usuários e desenvolvedores Pascal.&lt;/p&gt;

&lt;h3 id=&quot;inference&quot;&gt;Type Inference for Inline Variables&lt;/h3&gt;

&lt;p&gt;Na linguagem Pascal, tudo deve ser previamente declarado.&lt;/p&gt;

&lt;p&gt;Tudo.&lt;/p&gt;

&lt;p&gt;Isso é algo intrínseco a linguagem desde o seu nascimento e é um dos pontos fortes dela, pois minimiza qualquer ambiguidade na declaração de tipos.&lt;/p&gt;

&lt;p&gt;Tem quem goste, tem quem odeie. Não importa. Ela foi feita dessa forma e deve ser respeitada.&lt;/p&gt;

&lt;p&gt;Mas, agora temos a &lt;em&gt;inferência de tipo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Isso existe em outras linguagens mas é provável que você conheça através do C#.&lt;/p&gt;

&lt;p&gt;E as pessoas “aplaudiram”…&lt;/p&gt;

&lt;p&gt;Sim, pode ser considerada uma facilidade. Você irá escrever menos. E 99% dos programadores Object Pascal — especialmente Delphi — adoram uma facilidade sem se preocupar com o custo. Sim, o custo, por quê na engenharia nada vem de graça.&lt;/p&gt;

&lt;p&gt;A compilação pode ficar mais lenta; pode haver erros de conversão obscuros; o código pode ficar menos legível… além de ir contra a própria filosofia da linguagem, que é declarar tudo antes.&lt;/p&gt;

&lt;p&gt;Mesmo assim, se é fácil para escrever e o concorrente tem… por quê não?&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Não há problemas com a declaração de variáveis atual. Esse é o estilo Pascal. Entretanto, parecem que estão mais preocupados em adicionar mais features a linguagem do que corrigir &lt;em&gt;bugs&lt;/em&gt;. Bem, cada um sabe o que é melhor para sua empresa.&lt;/p&gt;

&lt;p&gt;Trabalho com sistemas de alta performance que ainda utilizam a sintaxe clássica do Delphi 7. Então, posso afirmar que não é isso que irá deixar a linguagem melhor que seus concorrentes.&lt;/p&gt;

&lt;p&gt;Não me entenda mal. Não estou dizendo que não podemos alterar a linguagem. Existem algumas features ou acertos que que seriam muito bem vindos como, por exemplo, a correção da sintaxe &lt;a href=&quot;/a-declaracao-with-do-perfeita&quot;&gt;WITH-DO&lt;/a&gt; ou uma nova sintaxe para para determinar um &lt;a href=&quot;/fpc-macros#alias&quot;&gt;alias para uma Unit&lt;/a&gt;. Esses seriam melhorias que iriam corrigir problemas no design da linguagem, melhorando a leitura do código e tudo de acordo com a filosofia e estilo Pascal.&lt;/p&gt;

&lt;p&gt;Não quero um &lt;a href=&quot;https://en.wikipedia.org/wiki/Frankenstein&quot;&gt;Frankenstein&lt;/a&gt; de várias linguagens. Quero um design limpo, &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e eficiente.&lt;/p&gt;

&lt;p&gt;Não quero copiar o concorrente. Quero escrever código Object Pascal.&lt;/p&gt;

&lt;p&gt;Não faz sentido levar seu BMW clássico ao mecânico dizendo para deixá-lo mais parecido com uma Mercedes-Benz mais moderna. Você acabará ficando com  &lt;em&gt;nenhum&lt;/em&gt; dos dois, apenas sucata.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/pascal-deveria-ser-modernizado-Copy</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/pascal-deveria-ser-modernizado-Copy</guid>
      </item>
    
      <item>
        <title>Records - Antiga Nova Tecnologia</title>
        <description>&lt;p&gt;O tipo Record pode ter métodos e até mesmo campos privados. Seria isso considerado uma abominação para um código Orientado a Objetos?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/alvaro-reyes-517391-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Alvaro Reyes on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Na programação Orientada a Objetos, utilizamos objetos.&lt;/p&gt;

&lt;p&gt;Se você precisasse de um objeto para representar os &lt;em&gt;dados&lt;/em&gt; de um usuário, apenas login, password e nome, como seria a definição da classe?&lt;/p&gt;

&lt;p&gt;Vamos tentar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TUserData = class
private
  fLogin: string;
  fPassword: string;
  fName: string;
public
  property Login: string read fLogin write fLogin;
  property Password: string read fPassword write fPassword;
  property Name: string read fName write fName;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse seria um estilo de implementação que podemos ver em muitos sistemas que se dizem ser Orientados a Objetos.&lt;/p&gt;

&lt;p&gt;No entanto, essa classe irá gerar “objetos” que são mais conhecidos como DTO (Data Transfer Object) o que, por definição, é um conceito errado.&lt;/p&gt;

&lt;p&gt;Objetos não são &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/#objeto-nao-e-um-balde-de-funcoes-e-dados&quot;&gt;“baldes de dados”&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Objetos verdadeiros possuem comportamento e &lt;a href=&quot;/encapsulamento&quot;&gt;encapsulam&lt;/a&gt; dados e/ou outros objetos em seu interior. O que está encapsulado não deveria ser visível ou acessado diretamente por outro objeto externo.&lt;/p&gt;

&lt;p&gt;Essa é a &lt;em&gt;teoria&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas, e se no contexto do seu sistema você realmente não necessitasse de nenhum método para representar os dados de um usuário?&lt;/p&gt;

&lt;p&gt;Por muito tempo eu tenho utilizado objetos para tudo, até mesmo para representar dados, mas sem utilizar objetos anêmicos como esse, no entanto.&lt;/p&gt;

&lt;p&gt;Para representar os dados acima, eu utilizaria a técnica do &lt;a href=&quot;/posts/diga-me-algo-sobre-voce/#metodo-about&quot;&gt;Método About()&lt;/a&gt;, que iria retornar um XML ou JSON, conforme explicado em 2016…&lt;/p&gt;

&lt;p&gt;Há vantagens nessa técnica como ter uma única interface que qualquer classe possa implementar para retornar um XML/JSON. Mas também há desvantagens, como não haver checagem estática do compilador e o &lt;em&gt;overhead&lt;/em&gt; em “montar/desmontar” o &lt;em&gt;stream&lt;/em&gt; se houver a necessidade de repassar a informação por uma cadeia de objetos.&lt;/p&gt;

&lt;p&gt;Nesses ~2 anos, eu diria que muita coisa mudou.&lt;/p&gt;

&lt;p&gt;Estou trabalhando em alguns projetos que necessitam de extrema velocidade de processamento, mas nem por isso eles são menos Orientados a Objetos.&lt;/p&gt;

&lt;p&gt;Como?&lt;/p&gt;

&lt;p&gt;Redescobrindo o tipo Record.&lt;/p&gt;

&lt;p&gt;Mas antes eu quero lhe contar por quê eu neglicenciei os Records por muito tempo.&lt;/p&gt;

&lt;p&gt;Bem, Records existem desde o Turbo Pascal. Eles representam uma estrutura de dados. Você define uma estrutura e depois define &lt;em&gt;procedures&lt;/em&gt; e &lt;em&gt;functions&lt;/em&gt; para trabalhar com as estruturas — como ainda fazemos na linguagem C.&lt;/p&gt;

&lt;p&gt;Na Orientação a Objetos, nós unimos comportamento aos dados num único artefato chamado objeto.&lt;/p&gt;

&lt;p&gt;Então, a ideia de ter um Record com todos os seus dados públicos e funções “soltas” que o utilizam, implementadas muitas vezes em Unidades diferentes, me soa muito “anti-objeto”, muito anti-encapsulamento.&lt;/p&gt;

&lt;p&gt;Records, dessa forma, são estruturas para programas procedurais.&lt;/p&gt;

&lt;p&gt;Mas, já faz uns anos que os arquitetos da linguagem Object Pascal introduziram métodos em Records.&lt;/p&gt;

&lt;p&gt;Sim, métodos, em Records.&lt;/p&gt;

&lt;p&gt;Quando eu li isso pela primeira vez, achei que os arquitetos tinham ficado loucos. Métodos em Records? Qual o sentido? Já temos objetos, não precisamos de Records com métodos. Isso não faz o menor sentido! — eu pensava.&lt;/p&gt;

&lt;p&gt;Entretanto, hoje em dia, Records podem ter métodos e eles podem ser até mesmo privados, assim como ter &lt;em&gt;fields&lt;/em&gt; privados!&lt;/p&gt;

&lt;p&gt;Ora, não é isso um objeto?&lt;/p&gt;

&lt;p&gt;Não.&lt;/p&gt;

&lt;p&gt;Então, não seria melhor utilizar um objeto?&lt;/p&gt;

&lt;p&gt;Depende.&lt;/p&gt;

&lt;p&gt;Records são estruturas de dados — mesmo que eles tenham métodos — e deveria ser utilizados como tal.&lt;/p&gt;

&lt;p&gt;Records são alocados automaticamente pelo compilador na área de memória &lt;em&gt;stack&lt;/em&gt;, ao invés da área de memória &lt;em&gt;heap&lt;/em&gt;, como fazem os objetos. Utilizar o &lt;em&gt;stack&lt;/em&gt; é mais rápido e mais simples para o compilador gerenciar a memória.&lt;/p&gt;

&lt;p&gt;Então, se você necessita representar &lt;em&gt;apenas&lt;/em&gt; dados, Record é a melhor opção.&lt;/p&gt;

&lt;p&gt;Records não podem utilizar herança e muito menos implementar uma interface, então não há polimorfismo — lembre-se, são apenas dados.&lt;/p&gt;

&lt;p&gt;Então, se você necessita de polimorfismo e comportamento, objeto é a melhor opção.&lt;/p&gt;

&lt;p&gt;Dito isso, por quê métodos em Records pode mudar a maneira em como utilizamos Records em programas Orientados a Objetos?&lt;/p&gt;

&lt;p&gt;Quando declaramos um Record, seus campos não são inicializados, como acontece com os atributos de um objeto. Então, podemos definir um método para iniciá-lo, sem ter que fazer isso externamente — mesmo que seus campos sejam públicos — encapsulando a inicialização dos campos na própria estrutura de dados:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TUserData = record
  login: string;
  password: string;
  name: string;
  procedure Init;
end;

procedure TUserData.Init;
begin
  login := &#39;&#39;;
  password := &#39;&#39;;
  name := &#39;&#39;;
end;

var
  u: TUserData;
begin
  u.Init;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outra opção é utilizar a função &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/default.html&quot;&gt;Default()&lt;/a&gt; mas o importante é que você tem a opção de fazer o que quiser no procedimento que será como um construtor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TUserData.Init;
begin
  Default(self);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se o &lt;em&gt;password&lt;/em&gt; precisar ser criptografado/descriptografado, você não precisa de funções externas para isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TUserData.EncryptedPassword: string;
begin
  result := &#39;&amp;lt;using some algorithm to encrypt&amp;gt;&#39;;
end;

function TUserData.DecryptedPassword: string;
begin
  result := &#39;&amp;lt;using some algorithm to decrypt&amp;gt;&#39;;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Existem algumas regras a seguir:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Não implemente métodos que se comportem como objetos, ou seja, trabalhe &lt;em&gt;apenas&lt;/em&gt; com os dados do Record, transformando-os;&lt;/li&gt;
  &lt;li&gt;Não retorne instâncias de objetos em seus métodos, com exceção de instâncias de interfaces, mas evite a todo custo;&lt;/li&gt;
  &lt;li&gt;Só utilize campos com tipos primitivos ou gerenciados (ex: strings, Variant, etc), nunca instâncias de objetos;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Faça isso e você estará seguro.&lt;/p&gt;

&lt;p&gt;Seu código não será considerado menos Orientado a Objetos por estar utilizando estruturas de dados que representam dados. Records foram criados exatamente para isso e a implementação de métodos apenas facilitaram seu uso.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Oct 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/records-antiga-nova-tecnologia</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/records-antiga-nova-tecnologia</guid>
      </item>
    
      <item>
        <title>Builder Classes Simplificado</title>
        <description>&lt;p&gt;O padrão Builder utiliza no mínimo 2 classes: 1 classe para instância a ser construída e 1 classe para a instância construtora.&lt;/p&gt;

&lt;p&gt;Nesse artigo irei utilizar um Builder simplificado, que irá utilizar a mesma classe tanto para construir como para representar a instância final.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/christopher-burns-360244-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Christopher Burns on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;O padrão &lt;a href=&quot;https://en.wikipedia.org/wiki/Builder_pattern&quot;&gt;Builder&lt;/a&gt; já é muito conhecido e utilizado mundo afora.&lt;/p&gt;

&lt;p&gt;Esse artigo não tem a pretensão de ensiná-lo para que serve esse padrão — há milhares de artigos sobre isso na Internet, com implementação em várias linguagens diferentes.&lt;/p&gt;

&lt;p&gt;No entanto, um bom resumo é encontrado na Wikipedia:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Separar a construção de um objeto complexo da sua representação de modo que o mesmo processo de construção possa criar diferentes representações.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Como podemos ver nos exemplos em C# da Wikipedia, foi utilizado uma classe &lt;code&gt;Car&lt;/code&gt; e uma interface &lt;code&gt;ICarBuilder&lt;/code&gt;. Depois, temos uma implementação dessa interface com a definição da classe &lt;code&gt;FerrariBuilder&lt;/code&gt; e, finalmente, outra classe para customizar a Ferrari chamada &lt;code&gt;SportsCarBuildDirector&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Podemos simplificar esse exemplo?&lt;/p&gt;

&lt;p&gt;Primeiramente, &lt;code&gt;Car&lt;/code&gt; poderia ser uma interface &lt;code&gt;ICar&lt;/code&gt; e não uma classe. Então, poderíamos ter a classe &lt;code&gt;TFerrari&lt;/code&gt; que implementa &lt;code&gt;ICar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Na minha opinião, o único &lt;code&gt;Builder&lt;/code&gt; do exemplo é a classe &lt;code&gt;TSportsCarBuildDirector&lt;/code&gt; que customiza uma Ferrari para diretores. No entanto, eu também não concordo com sua existência e acho que podemos simplificar ainda mais esse exemplo — veja mais abaixo.&lt;/p&gt;

&lt;p&gt;Vamos começar pela primeira interface, mantendo-a &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, retornando tipos primitivos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ICar = interface
  function Model: string;
  function NumDoors: Integer;
  function Color: TColor;
  procedure Run;
end;      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depois, codificamos a classe &lt;code&gt;TFerrari&lt;/code&gt;, que implementa &lt;code&gt;ICar&lt;/code&gt;. Veja que essa classe não é um Builder, mas sim apenas uma classe comum.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TFerrari = class(TInterfacedObject, ICar)
private
  fModel: string;
  fNumDoors: Integer;
  fColor: TColor;
public
  constructor Create(const aModel: string;
    aNumDoors: Integer; aColor: TColor);
  function Model: string;
  function NumDoors: Integer;
  function Color: TColor;
  procedure Run;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como disse acima, não acho necessidade de haver um &lt;code&gt;Builder&lt;/code&gt; chamado &lt;code&gt;TSportsCarBuildDirector&lt;/code&gt;. Para implementar essa classe seria necessário implementar uma nova interface &lt;code&gt;ICarBuilder&lt;/code&gt; além da própria classe, o que seria desnecessário.&lt;/p&gt;

&lt;p&gt;Podemos simplificar esse exemplo utilizando &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/&quot;&gt;herança&lt;/a&gt; dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TDirectorSportCar = class(TFerrari)
public
  constructor Create(aColor: TColor); reintroduce;
end;

constructor TDirectorSportCar.Create(aColor: TColor);
begin
  inherited Create(&#39;488 Spider&#39;, 2, aColor);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Acabamos de criar um Builder mas utilizando a própria classe que irá representar um &lt;code&gt;ICar&lt;/code&gt;, ou seja, a &lt;code&gt;TDirectorSportCar&lt;/code&gt;. Não precisamos de mais uma interface abstrata como &lt;code&gt;ICarBuilder&lt;/code&gt; ou sua implementação.&lt;/p&gt;

&lt;p&gt;Para demonstrar o código, poderíamos ter algo assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure DoSomethingWithCars;
var
  car: ICar;
begin
  car := TDirectorSportCar.Create(clRed);
  car.Run;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sem Builders (aparentes), sem o método “Construct”, sem o método “GetResult”, e utilizando objetos &lt;a href=&quot;/posts/objetos-imutaveis/&quot;&gt;imutáveis&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/builder-classes-simplificado</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/builder-classes-simplificado</guid>
      </item>
    
      <item>
        <title>Como Transformar uma Instância de Classe em Instância de Interface</title>
        <description>&lt;p&gt;E se a linguagem Object Pascal nos permitisse codificar uma instância de classe que se auto destrói quando não mais precisamos dela?&lt;/p&gt;

&lt;p&gt;É possível transformar uma instância de classe para se comportar como uma instância de interface?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/julie-north-720719-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Julie North on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Há alguns dias eu acompanhei alguns desenvolvedores solicitarem algumas “novas features” para o compilador Free Pascal..&lt;/p&gt;

&lt;p&gt;Uma dessas features é a possibilidade de fazer um &lt;em&gt;“auto free”&lt;/em&gt; de uma instância de classe. Sim, como no Java ou C#, onde um objeto do tipo de uma classe é liberado automaticamente quando a VM acha que deve fazê-lo.&lt;/p&gt;

&lt;p&gt;No entanto, devemos lembrar dos princípios da linguagem Object Pascal antes de solicitar tais mudanças. A linguagem Object Pascal não possui uma VM, portanto não temos um “robozinho” para ficar monitorando nossos objetos. Devemos liberar nossos objetos “manualmente” chamando &lt;code&gt;obj.Free&lt;/code&gt; na maioria dos casos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/simplicidade/&quot;&gt;Simples&lt;/a&gt; e eficiente.&lt;/p&gt;

&lt;p&gt;Mas eu posso entender o motivo de tal solicitação: É muito cômodo declarar objetos sem se preocupar em liberá-los da memória… e eu tenho feito isso há anos utilizando a “técnica” do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt; em conjunto com instâncias de interfaces.&lt;/p&gt;

&lt;p&gt;O tipo de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;interface&lt;/a&gt; é liberado automaticamente pelo compilador quando a variável sai do escopo. Mas isso não existe para instâncias de classe, proposto no pedido da nova feature.&lt;/p&gt;

&lt;p&gt;Então, se houvesse um jeito de liberar automaticamente as instâncias de classes, “convertendo-as” em instâncias de interfaces, sem utilizar nenhum tipo de &lt;a href=&quot;/posts/nao-utilize-casting/&quot;&gt;casting&lt;/a&gt;, teríamos a liberação automática sem que fosse necessária alterações no compilador.&lt;/p&gt;

&lt;p&gt;Bem, o que vou lhe apresentar agora pode já estar sendo utilizando por muitos desenvolvedores ao redor do mundo, e é algo tão simples que podemos até mesmo substituir o &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt; — tão difundido na comunidade brasileira e mundo afora — por essa simples “técnica” que mostrarei mais abaixo.&lt;/p&gt;

&lt;p&gt;Mas antes, o que há de errado com o &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Esse método foi criado com o intuito de implementar a liberação automática da instância, sem haver a necessidade de declarar uma variável local para incrementar a contagem de referência.&lt;/p&gt;

&lt;p&gt;Funciona.&lt;/p&gt;

&lt;p&gt;No entanto, há alguns problemas com essa abordagem.&lt;/p&gt;

&lt;p&gt;Primeiro, ele é um método estático da classe. Deveríamos &lt;del&gt;não utilizar&lt;/del&gt; evitar métodos de classe a todo custo, dando [preferência] em utilizar instâncias de interfaces, onde não existem métodos estáticos.&lt;/p&gt;

&lt;p&gt;Segundo, é redundante ter que codificar sempre os mesmos parâmetros da(s) mesma(s) assinatura do(s) construtor(es). Isso, além de ser no mínimo chato, é um pouco custoso para a manutenção pois (quase sempre) haverá 2 lugares para alterar os argumentos.&lt;/p&gt;

&lt;p&gt;Terceiro, o método não impede que um programador que não conheça a técnica, chame diretamente o construtor da classe, &lt;em&gt;by passing&lt;/em&gt; o método estático. Isso pode gerar &lt;em&gt;memory leaks&lt;/em&gt;, como já foi explicado em alguns outros artigos aqui do blog.&lt;/p&gt;

&lt;p&gt;Embora haja todos esses problemas, a utilização do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt; se mostrou eficiente, melhorando e simplificando a base de código em muitos projetos.&lt;/p&gt;

&lt;p&gt;Entretanto, a técnica a seguir traz todas as vantagens do &lt;code&gt;New&lt;/code&gt; porém sem as desvantagens.&lt;/p&gt;

&lt;p&gt;Você pode fazer essa “mágica” adicionando mais um método na classe.&lt;/p&gt;

&lt;p&gt;Eu o chamo de Método &lt;code&gt;Ref&lt;/code&gt;, que significa &lt;em&gt;reference for&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TFoo.Ref: ISomething;
begin
  result := self;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sim, é só isso.&lt;/p&gt;

&lt;p&gt;Um método que retorna &lt;code&gt;self&lt;/code&gt;, sendo o tipo do retorno a interface que a classe implementa.&lt;/p&gt;

&lt;p&gt;Diferentemente do &lt;code&gt;New&lt;/code&gt;, o método &lt;code&gt;Ref&lt;/code&gt; não é estático e não duplica a assinatura do(s) construtor(s), eliminando as primeiras duas desvantagens.&lt;/p&gt;

&lt;p&gt;Sim, há a possibilidade do desenvolvedor esquecer de utilizá-lo ao chamar o construtor da classe diretamente ao invés do &lt;code&gt;New&lt;/code&gt;e isso poderia ocasionar &lt;em&gt;memory leaks&lt;/em&gt;. Mas sua vantagem é que você tem a &lt;em&gt;opção&lt;/em&gt; em não utilizá-lo para aumentar a performance na criação dos objetos &lt;em&gt;by passing&lt;/em&gt; um método de classe (o método &lt;code&gt;New&lt;/code&gt;) antes de chegar ao construtor, ganhando, talvez, alguns milionésimos de segundos.&lt;/p&gt;

&lt;p&gt;Veja um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure DoIt;
begin
  TFoo.Create(TBar.Create).Ref.Execute;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se ambas as classes implementam interfaces, temos a possibilidade de não utilizar &lt;code&gt;Ref&lt;/code&gt; no argumento do construtor de &lt;code&gt;TFoo&lt;/code&gt;, chamando apenas o construtor de &lt;code&gt;TBar&lt;/code&gt;. Mas, somos “obrigados” a utilizar &lt;code&gt;Ref&lt;/code&gt; na chamada mais externa para executar algum método da interface que &lt;code&gt;TFoo&lt;/code&gt; implementa, afim de evitar &lt;em&gt;memory leaks&lt;/em&gt;, pois não há nenhuma variável (local) para receber a instância da interface.&lt;/p&gt;

&lt;p&gt;Agora você deve estar se perguntando, o que isso tem have com o título do artigo?&lt;/p&gt;

&lt;p&gt;Tudo.&lt;/p&gt;

&lt;p&gt;É padrão da linguagem que, ao trabalharmos com instâncias de interfaces, o compilador utilize um contador de referências para saber quando destruir um objeto, liberando a memória alocada.&lt;/p&gt;

&lt;p&gt;Então, se você criar um objeto do tipo de classe e depois utilizar o método &lt;code&gt;Ref&lt;/code&gt; ou apenas atribuir a instância a uma variável do tipo interface, você irá “transformar” sua instância de classe em instância de interface, ganhando a contagem de referência e a auto destruição do objeto… de graça.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo completo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program Project1;

{$mode delphi}

uses
  SysUtils,
  Classes;

type
  IFoo = interface
  [&#39;{1D26066C-984B-4632-95B2-B25253AF149E}&#39;]
    procedure ShowMsg;
  end;

type
  TFoo = class(TInterfacedObject, IFoo)
  private
    fText: string;
  public
    constructor Create(const aText: string);
    destructor Destroy; override;
    function Ref: IFoo;
    procedure ShowMsg;
  end;

{ TFoo }

constructor TFoo.Create(const aText: string);
begin
  inherited Create;
  fText := aText;
  writeln(&#39;Creating &#39;+ FRefCount.ToString);
end;

destructor TFoo.Destroy;
begin
  writeln(&#39;Destroing &#39; + FRefCount.ToString);
  inherited Destroy;
end;

function TFoo.Ref: IFoo;
begin
  result := self;
end;

procedure TFoo.ShowMsg;
begin
  writeln(fText);
end;

var
  f: TFoo; // class, not an interface
begin
  f := TFoo.Create(&#39;teste&#39;);
  f.Ref.ShowMsg;
  // f.Free; &amp;lt;&amp;lt; you don&#39;t need it
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute o código acima e verá que não existe nenhum &lt;em&gt;memory leak&lt;/em&gt;, mesmo &lt;code&gt;f&lt;/code&gt; sendo do tipo &lt;code&gt;TFoo&lt;/code&gt;, uma classe.&lt;/p&gt;

&lt;p&gt;A mágica acontece quando chamamos &lt;code&gt;Ref&lt;/code&gt;. Ele retorna um tipo de interface que é o próprio objeto &lt;code&gt;self&lt;/code&gt;. Assim, a “nova” instância passa a ter uma contagem de referência e será destruída automaticamente.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
Creating 1
teste
Destroing 0
Heap dump by heaptrc unit of c:\temp\project1.exe
76 memory blocks allocated : 1967/2120
76 memory blocks freed     : 1967/2120
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A linguagem Object Pascal pode parecer simples demais para alguns desenvolvedores (que não conhecem bem a linguagem).&lt;/p&gt;

&lt;p&gt;Alguns dizem que é “apenas uma linguagem para aprendizado” ou que não acompanhou as “novas features” das linguagens mais “modernas”.&lt;/p&gt;

&lt;p&gt;Me diga então, qual linguagem você conhece que nos dá a eficiência em poder liberar nossos objetos no melhor momento que quisermos, mas também ter objetos que se “auto destroem” e ainda conseguir fazer a transição de um tipo para o outro?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Aug 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/metodo-ref</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/metodo-ref</guid>
      </item>
    
      <item>
        <title>Interfaces e Casting</title>
        <description>&lt;p&gt;Seria um anti-padrão verificar se um objeto implementa determinada(s) interface(s)? Seria essa prática considerada o mesmo que &lt;em&gt;casting&lt;/em&gt;?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/stefan-stefancik-257625-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Štefan Štefančík on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Já faz mais de 2 anos que &lt;a href=&quot;/posts/nao-utilize-casting/&quot;&gt;escrevi&lt;/a&gt; que não devemos utilizar casting.&lt;/p&gt;

&lt;p&gt;Essa pode ser uma afirmação difícil de acreditar, se você não por sua mente no contexto certo antes.&lt;/p&gt;

&lt;p&gt;Alguns desenvolvedores tem me perguntado, como é possível fazer uma aplicação sem haver &lt;em&gt;casting&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Bem, em uma aplicação de médio tamanho eu diria que pode ser até difícil, mas não impossível. Entretanto, irá depender do &lt;em&gt;tipo&lt;/em&gt; de casting que estamos tratando.&lt;/p&gt;

&lt;p&gt;Na programação orientada a objetos só haverá objetos. Então vamos esquecer os tipos primitivos. Um cast de uma &lt;em&gt;string&lt;/em&gt; em um &lt;em&gt;Integer&lt;/em&gt;, por exemplo, é algo &lt;em&gt;necessário&lt;/em&gt; em linguagens que possuem tipos primitivos.&lt;/p&gt;

&lt;p&gt;Esse não é o problema.&lt;/p&gt;

&lt;p&gt;O casting a que me refiro é sobre &lt;em&gt;objetos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Passar um parâmetro para um método com o tipo &lt;code&gt;TObject&lt;/code&gt; para, então, fazer um casting interno para outro objeto é como ter um “pré-conceito” sobre o objeto que irá fazer o trabalho.&lt;/p&gt;

&lt;p&gt;O objeto em si não é suficiente?&lt;/p&gt;

&lt;p&gt;Se você está verificando o &lt;em&gt;tipo&lt;/em&gt; do objeto para fazer o trabalho, é pré-conceito.&lt;/p&gt;

&lt;p&gt;Você não confia nele. Você tem sempre que &lt;em&gt;gerenciá-lo&lt;/em&gt;, dizendo quem ele deve &lt;em&gt;representar&lt;/em&gt; em cada parte do código.&lt;/p&gt;

&lt;p&gt;Mas, há alguma maneira de trabalhar com objetos sem utilizar casting?&lt;/p&gt;

&lt;p&gt;O “segredo” está nas &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;. Uma interface é um contrato entre o cliente (sistema) e o trabalhador (objeto).&lt;/p&gt;

&lt;p&gt;No entanto, um objeto pode implementar mais de uma interface, tendo muitas &lt;em&gt;especialidades&lt;/em&gt; por assim dizer.&lt;/p&gt;

&lt;p&gt;Então, é possível que um mesmo objeto possa trabalhar em muitas especialidades diferentes. Mas a única maneira de saber isso é &lt;em&gt;perguntar&lt;/em&gt; ao próprio objeto se ele &lt;em&gt;sabe&lt;/em&gt; fazer o serviço especializado.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/e8312b8e539ac0e1b1baac28be18efe3.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O mesmo empregado pode ser um analista e/ou programador.&lt;/p&gt;

&lt;p&gt;A função &lt;a href=&quot;/supports-traicoeira&quot;&gt;Supports&lt;/a&gt; “pergunta” ao objeto se ele também sabe fazer um “outro trabalho”, determinado pelo “contrato” no segundo parâmetro da função.&lt;/p&gt;

&lt;p&gt;A diferença é sutil, mas importante: Tentar transformar um objeto em outro é equivocado, mas perguntar à ele se tem uma determinada especialidade, não.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 23 Jul 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/interfaces-e-casting</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/interfaces-e-casting</guid>
      </item>
    
      <item>
        <title>Como Trabalhar com Libraries sem Pacotes</title>
        <description>&lt;p&gt;Como seria trabalhar em um projeto que utiliza libraries que não possuem pacotes? Se cada desenvolvedor tiver cópias das libraries em paths diferentes, as configurações do projeto não devem utilizar paths pré-determinados.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/aditya-romansa-117300-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Aditya Romansa on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Pacotes facilitam muito o desenvolvimento, pois eles registram na IDE onde estão o código-fonte de suas libraries. Assim, cada desenvolvedor pode ter suas próprias cópias de libraries salvos em quaisquer pastas em seus computadores.&lt;/p&gt;

&lt;p&gt;Um projeto que utiliza pacotes apenas irá fazer referência à eles e deixará a IDE o trabalho de localizá-los para informar ao compilador os códigos-fontes referentes aos pacotes.&lt;/p&gt;

&lt;p&gt;Mas, e se uma library não possuir pacotes?&lt;/p&gt;

&lt;p&gt;Nesse caso basta adicionarmos o path da library no &lt;em&gt;search path&lt;/em&gt; do projeto. Ao compilarmos, os fontes serão localizados pela IDE.&lt;/p&gt;

&lt;p&gt;Funciona. Porém, se o projeto tiver muitos desenvolvedores, como garantir que todos irão utilizar o mesmo path? Há uma grande possibilidade de haver divergências de paths em projetos colaborativos com mais de um desenvolvedor.&lt;/p&gt;

&lt;p&gt;Desenvolvedores podem utilizar diferentes paths para projetos, componentes e libraries. Cada um organiza seus projetos da forma que achar melhor em seus próprios computadores.&lt;/p&gt;

&lt;p&gt;Um projeto sem pacotes não tem a ajuda da IDE para localizar os fontes. O desenvolvedor deve informar onde eles estão.  Como cada desenvolvedor “gosta” de ter sua própria hierarquia de pastas, como configurar o &lt;em&gt;search path&lt;/em&gt; do projeto?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Macros.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;No Lazarus há &lt;a href=&quot;http://wiki.lazarus.freepascal.org/IDE_Macros_in_paths_and_filenames&quot;&gt;macros&lt;/a&gt; que podem ser interpretadas em &lt;em&gt;run-time&lt;/em&gt; pela IDE.&lt;/p&gt;

&lt;p&gt;A macro que precisamos para resolver o problema de paths é a &lt;code&gt;$Env(name)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Agora, imagine um library chamada &lt;code&gt;DBFast&lt;/code&gt;, &lt;em&gt;sem&lt;/em&gt; pacotes.&lt;/p&gt;

&lt;p&gt;O desenvolvedor José tem a cópia da library em &lt;code&gt;c:\dev\libs\dbfast&lt;/code&gt; enquanto o Márcio tem a mesma library em &lt;code&gt;d:\pascal\components\dbfast&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dois paths bem diferentes para um mesmo projeto.&lt;/p&gt;

&lt;p&gt;Felizmente, utilizando macros a configuração é simplificada.&lt;/p&gt;

&lt;p&gt;José e Márcio devem criar uma variável de ambiente em seus computadores apontando para esses paths. A variável de ambiente deve ter o &lt;em&gt;mesmo&lt;/em&gt; nome, por exemplo, &lt;code&gt;DBFastSource&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finalmente, basta adicionarmos a macro &lt;code&gt;$Env(DBFastSource)&lt;/code&gt; no &lt;a href=&quot;http://wiki.freepascal.org/IDE_Window:_Compiler_Options#Paths&quot;&gt;search path&lt;/a&gt; do projeto para que tudo funcione com paths diferentes para cada desenvolvedor.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jul 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/libraries-sem-pacotes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/libraries-sem-pacotes</guid>
      </item>
    
      <item>
        <title>Quem é o Responsável por Liberar os Objetos?</title>
        <description>&lt;p&gt;Você consideraria um bom design para seu projeto, ter métodos ou funções que criam objetos que serão liberados em outro local, por outro objeto ou função?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/w-a-t-a-r-i-535375-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by W A T A R I on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Em linguagens onde a liberação de memória e recursos é algo manual que depende do desenvolvedor, ter funções ou métodos (vamos nos referir apenas a métodos de agora em diante) que criam novos objetos para que “alguém”, em algum lugar, faça a limpeza da memória é uma má ideia.&lt;/p&gt;

&lt;p&gt;Ao longo dos anos tenho visto código como esse:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TFoo.Build(const Name: string; Value: Integer): TBar;
begin
  Result := TBar.Create;
  Result.Name := Name;
  Result.Value := Value;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uma classe &lt;code&gt;TFoo&lt;/code&gt; que, através do método &lt;code&gt;Build&lt;/code&gt;, retorna uma nova instância de &lt;code&gt;TBar&lt;/code&gt; sem manter uma referência para o objeto criado.&lt;/p&gt;

&lt;p&gt;Acredito que esses tipos de métodos são criados com a intenção de “facilitar” a codificação. Ao invés de criar um objeto &lt;code&gt;TBar&lt;/code&gt; e ter que iniciar suas propriedades em muitos lugares no código, cria-se um método que &lt;a href=&quot;/encapsulamento&quot;&gt;encapsula&lt;/a&gt; a criação do objeto sem ter que &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/&quot;&gt;duplicar o código&lt;/a&gt; em outros lugares.&lt;/p&gt;

&lt;p&gt;Parece bom?&lt;/p&gt;

&lt;p&gt;Eu considero essa abordagem &lt;em&gt;péssima&lt;/em&gt;, pois é o início para ocorrer eventuais vazamentos de memória.&lt;/p&gt;

&lt;p&gt;A linguagem Object Pascal não obriga o desenvolvedor a armazenar o retorno de um método em alguma variável — assim como Java e C#. Então, se não tivermos uma referência através de um variável, o objeto não seria liberado, gerando um vazamento de memória.&lt;/p&gt;

&lt;p&gt;Mas você poderia dizer que não há sentido em criar um objeto e não fazer nada com ele, então o desenvolvedor iria ter uma variável… bem, nem sempre. Mas no caso acima, eu concordo.&lt;/p&gt;

&lt;p&gt;Então, digamos que o desenvolvedor armazena o objeto em uma variável.&lt;/p&gt;

&lt;p&gt;Infelizmente, isso também não garante que ele irá liberar a memória após seu uso.&lt;/p&gt;

&lt;p&gt;OK. Esse não é um problema. Sei que isso é intrínseco ao design da linguagem: O desenvolvedor deve liberar os objetos chamando os destrutores.&lt;/p&gt;

&lt;p&gt;No entanto, há uma grande diferença.&lt;/p&gt;

&lt;p&gt;Por exemplo: Quando temos objetos que possuem objetos, naturalmente não nos preocupamos quem irá liberar a memória alocada. Sabemos que alguém irá liberá-los. O motivo é simples: &lt;em&gt;não fomos nós que os criamos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Então, temos uma regra aqui:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aquele que cria é também o responsável por destruir a instância e/ou liberar o recurso.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mas, quando utilizamos métodos que retornam objetos, como saber se devemos ou não liberar os recursos manualmente?&lt;/p&gt;

&lt;p&gt;Será que o próprio objeto irá fazer o trabalho?&lt;/p&gt;

&lt;p&gt;Como o desenvolvedor iria saber?&lt;/p&gt;

&lt;p&gt;Só lendo a documentação ou código da classe, o que é um péssimo design de projeto.&lt;/p&gt;

&lt;p&gt;Ao voltarmos para o nosso primeiro exemplo, a instância da classe &lt;code&gt;TFoo&lt;/code&gt; seria, então, responsável por liberar quaisquer objetos que porventura tenha criado para estar de acordo com a regra acima. O que não é o caso.&lt;/p&gt;

&lt;p&gt;O que fazer?&lt;/p&gt;

&lt;p&gt;Existe alguma técnica que nos permite criar e retornar novos objetos sem ter de nos preocupar (muito) quem irá liberar a memória?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Sim&lt;/em&gt;, contanto que você utilize &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;interfaces&lt;/a&gt; ao invés de instâncias de classes. Para esses casos eu proponho a técnica do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;método estático New&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Jul 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/quem-libera-os-objetos</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/quem-libera-os-objetos</guid>
      </item>
    
      <item>
        <title>Free Pascal Macros</title>
        <description>&lt;p&gt;Uma linguagem simples e com um design elegante como Object Pascal não necessitaria de suporte a macros como existem em C/C++. No entanto, Free Pascal as tem. Devemos utilizá-las?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/remi-jacquaint-441559-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Rémi Jacquaint on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O uso de &lt;a href=&quot;https://en.wikipedia.org/wiki/Macro_(computer_science)&quot;&gt;macros&lt;/a&gt; já existe no Free Pascal faz tempo, porém nunca havia pensando utilizar tal feature.&lt;/p&gt;

&lt;p&gt;Se você é leitor assíduo do blog já deve ter percebido que eu prefiro ter um bom design e consistência no código do que utilizar “hacks” para escrever menos, porém com a perda da legibilidade e da manutenibilidade.&lt;/p&gt;

&lt;p&gt;Na minha opinião, macros são &lt;em&gt;hacks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bem, talvez a maioria…&lt;/p&gt;

&lt;p&gt;Não acho que o suporte a macros não tenha sido implementado com o objetivo de melhorar o design e legibilidade do código.&lt;/p&gt;

&lt;p&gt;No entanto, acredito que podemos tirar proveito dessa feature.&lt;/p&gt;

&lt;h2 id=&quot;macros&quot;&gt;Macros&lt;/h2&gt;

&lt;p&gt;No código Pascal podemos definir macros que serão pré-processadas pelo compilador. Esse processamento irá gerar um resultado, que será como uma constante. Mas, essa constante pode representar uma expressão, um algorítimo, uma unidade, etc.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{$macro on}
{$define VALUE := A+B}

function Sum(A, B: Integer): Integer;
begin
  Result := VALUE;
end;

function Concat(const A, B: string): string;
begin
  Result := VALUE;
end;
{ TForm1 }

procedure TForm1.Button1Click(Sender: TObject);
begin
  ShowMessage(Sum(1,2).ToString); // 3
  ShowMessage(Concat(&#39;A&#39;,&#39;B&#39;));   // &#39;AB&#39;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A primeira coisa a se fazer é ativar o uso de macros utilizando a diretiva &lt;code&gt;{$macro on}&lt;/code&gt;, pois macros não são ativadas por padrão. Outra maneira de ativá-as para todas as unidades é passando o argumento &lt;code&gt;-Sm&lt;/code&gt; para o compilador.&lt;/p&gt;

&lt;p&gt;O exemplo acima não faz muito sentido, pois para se fazer uma soma não é necessário o uso de macros. No entanto, serviu para lhe mostrar o que é possível fazer com elas.&lt;/p&gt;

&lt;p&gt;Repare que &lt;code&gt;A&lt;/code&gt; e &lt;code&gt;B&lt;/code&gt; são definidos na macro como 2 identificadores que ainda não existem. Esses identificadores virão do contexto onde as macros serão chamadas, ou seja, as funções &lt;code&gt;Sum&lt;/code&gt; e &lt;code&gt;Concat&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para a macro, não importa o tipo de &lt;code&gt;A&lt;/code&gt; e &lt;code&gt;B&lt;/code&gt;. Então, elas funcionam como &lt;em&gt;Generics&lt;/em&gt;, o que já é bem legal.&lt;/p&gt;

&lt;p&gt;Mas &lt;em&gt;Generics&lt;/em&gt; são muito mais poderosos do que isso, então não pense em macros como substitutos aos Generics.&lt;/p&gt;

&lt;p&gt;Vamos a outro exemplo onde Generics não ajudam em nada:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{$macro on}
{$ifdef debug}
  {$define foo := foo.debug}
{$else}
  {$define foo := foo.run}
{$endif}

uses
  foo;
begin
  foo.SomeFunc;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo acima, há um teste se a diretiva &lt;code&gt;debug&lt;/code&gt; foi definida. Se for verdadeiro, definimos uma macro &lt;code&gt;foo&lt;/code&gt; com o nome da unidade &lt;code&gt;foo.debug&lt;/code&gt;, senão definimos &lt;code&gt;foo&lt;/code&gt; como &lt;code&gt;foo.run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Repare que na cláusula &lt;code&gt;uses&lt;/code&gt; há somente &lt;code&gt;foo&lt;/code&gt;. Imagine agora por as diretivas em outro lugar, talvez arquivos &lt;code&gt;.inc&lt;/code&gt;, e teremos uma unidade com o código limpo que irá utilizar as classes corretas dependendo da diretiva escolhida.&lt;/p&gt;

&lt;p&gt;Bem legal, não é?&lt;/p&gt;

&lt;p&gt;Entretanto, isso também não foi o que mais me chamou atenção no uso das macros. Pois, para fazer o mesmo que no exemplo acima, não é preciso macros. Basta você ter unidades como o mesmo nome, porém em diretórios diferentes, e passar o path correspondente ao compilador dependendo se há ou não a diretiva &lt;code&gt;debug&lt;/code&gt;. O Lazarus IDE lhe dá essa opção.&lt;/p&gt;

&lt;p&gt;Se há outras alternativas na própria linguagem para o uso de macros, por quê então utilizá-las?&lt;/p&gt;

&lt;h2 id=&quot;alias&quot;&gt;Unit Alias&lt;/h2&gt;

&lt;p&gt;Faz muito tempo que solicitei a implementação de uma nova sintaxe à equipe Free Pascal para ser possível &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclarar&lt;/a&gt; uma unidade diretamente no código. A linguagem C# tem isso, assim como Python.&lt;/p&gt;

&lt;p&gt;A razão para esse pedido é poder declarar unidades com nomes longos no código, mas dar-lhes um apelido curto para servir de prefixo a algumas classes que tem nomes iguais em unidades diferentes.&lt;/p&gt;

&lt;p&gt;Então pensei numa alternativa que chamei de &lt;a href=&quot;/api-unit&quot;&gt;API Unit&lt;/a&gt;. As vantagens e desvantagens estão no artigo.&lt;/p&gt;

&lt;p&gt;Infelizmente essa ideia não se mostrou muito eficaz para projetos com muitas unidades, já que é necessário redeclarar todas as unidades, suas classes e interfaces em um único arquivo.&lt;/p&gt;

&lt;p&gt;Mas com macros, tudo muda.&lt;/p&gt;

&lt;p&gt;Hipoteticamente, vamos supor que as unidades &lt;code&gt;Windows&lt;/code&gt; e &lt;code&gt;Graphics&lt;/code&gt; pertencem ao namespace &lt;code&gt;FPC.RTL.&lt;/code&gt;, ou seja, um “nome longo”.&lt;/p&gt;

&lt;p&gt;Então, minha proposta (antiga) seria utilizar essa sintaxe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  FPC.RTL.Windows as Win,
  FPC.RTL.Graphics as Graph;
var
  B1: Win.TBitmap;
  B2: Graph.TBitmap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eu não estou me referindo aqui o uso de namespaces do Delphi — que já foi implementado no Free Pascal — onde poderíamos definir um &lt;code&gt;NS=&quot;FPC.RTL&quot;&lt;/code&gt; e declarar apenas &lt;code&gt;Windows&lt;/code&gt; e &lt;code&gt;Graphics&lt;/code&gt; respectivamente.&lt;/p&gt;

&lt;p&gt;Não é isso.&lt;/p&gt;

&lt;p&gt;Utilizando essa sintaxe, teríamos o &lt;em&gt;controle local&lt;/em&gt; sobre a nomenclatura das unidades.&lt;/p&gt;

&lt;p&gt;Quando solicitei isso na época, eu pensava que iria exigir mudanças no parser da linguagem, que daria muito trabalho, etc.&lt;/p&gt;

&lt;p&gt;Não era prioridade.&lt;/p&gt;

&lt;p&gt;Porém, veja que com o uso de macros, bastaria o compilador substituir os &lt;code&gt;uses&lt;/code&gt; acima, que utiliza a palavra reservada &lt;code&gt;as&lt;/code&gt;, pelo código abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  {$macro on}
  FPC.RTL.Windows,
  {$define Win := FPC.RTL.Windows}
  FPC.RTL.Graphics;
  {$define Graph := FPC.RTL.Graphics}
var
  B1: Win.TBitmap;
  B2: Graph.TBitmap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E então eu poderia “renomear” as unidades com nomes longos como &lt;code&gt;Acme.SysFoo.Finances.Billing.Utils.Classes&lt;/code&gt; para apenas &lt;code&gt;Billing&lt;/code&gt;. Porém, em outra unidade, eu poderia renomear para &lt;code&gt;Utils&lt;/code&gt; se assim o desejasse.&lt;/p&gt;

&lt;p&gt;Teríamos a possibilidade de definir um apelido local (por unidade) a cada unidade. Perfeito.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A resposta a pergunta inicial é, sim. O uso de macros, quando bem utilizado, pode melhorar muito a legibilidade e design do código.&lt;/p&gt;

&lt;p&gt;Não temos (ainda?) a sintaxe com o uso de &lt;code&gt;as&lt;/code&gt;, que seria apenas uma &lt;em&gt;syntax sugar&lt;/em&gt; para o uso de macros, porém já podemos renomear unidades localmente. O que é um grande avanço, na minha opinião.&lt;/p&gt;

&lt;p&gt;O único contra que eu vejo é que, infelizmente, essa feature não existe no Delphi… por enquanto?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jun 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpc-macros</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpc-macros</guid>
      </item>
    
      <item>
        <title>fpWeb: Verificando Vazamentos de Memória</title>
        <description>&lt;p&gt;A linguagem Object Pascal, assim como C ou C++, não possui &lt;em&gt;Garbage Collector&lt;/em&gt; para liberar os objetos e recursos da memória automaticamente. Pode ser difícil ter 100% de certeza que todos os objetos estão sendo liberados (manualmente) pelo código. Mas, se algum objeto não for liberado, ocorrerá um vazamento de memória.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-steve-johnson-548294-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Steve Johnson on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Quando utilizamos a linguagem Object Pascal precisamos nos preocupar com &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#vazamentos-de-memoria&quot;&gt;vazamentos de memória&lt;/a&gt;, até mesmo nos sistemas mais simples.&lt;/p&gt;

&lt;p&gt;Vazamentos de memória podem ser ainda mais prejudiciais em sistemas Web comparado com sistemas Desktop. Se uma aplicação Desktop tem vazamentos de memória, em algum momento o usuário poderá fechar a aplicação e todo o vazamento será recuperado pelo Sistema Operacional. Mas em aplicações Web, onde podem haver múltiplas requisições por segundo enquanto o servidor mantém em memória cópias do executável (FastCGI), tais vazamentos poderiam diminuir drasticamente com os recursos do servidor.&lt;/p&gt;

&lt;p&gt;No &lt;a href=&quot;/fpweb-hello&quot;&gt;artigo anterior&lt;/a&gt; fizemos um programa simples que responde “Hello!” quando uma determinada URL  acessada.&lt;/p&gt;

&lt;p&gt;Como não há vazamentos de memória nesse programa, teremos que simulá-lo, alterando o método &lt;code&gt;HandleRequest&lt;/code&gt; conforme abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure THelloRoute.HandleRequest(
  ARequest: TRequest; AResponse: TResponse);
begin
  TStringList.Create;
  AResponse.Content := &#39;Hello!&#39;;
  AResponse.SendResponse;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mesmo após compilar o programa com o &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/heaptrc/usage.html&quot;&gt;HeapTrc&lt;/a&gt; habilitado, iniciá-lo e executá-lo utilizando o browser, não será possível ver o vazamento — diferentemente de aplicações Desktop que, ao término do programa, mostra um “relatório” sobre a memória &lt;em&gt;utilizada vs. liberada&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para ser possível ver o relatório, você tem que finalizar a aplicação apropriadamente. O problema é que, mesmo após finalizada a requisição pelo browser, ela continua em execução aguardando mais e mais requisições.&lt;/p&gt;

&lt;p&gt;Felizmente, há uma maneira de ver o relatório do HeapTrc, alterando o código conforme a seguir:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/90b319e7bcf5d37383c1083179b69546.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, foi introduzido um procedimento &lt;code&gt;TerminateCall&lt;/code&gt;, algumas configurações do &lt;code&gt;heaptrc&lt;/code&gt; e a inclusão de uma nova rota &lt;code&gt;/quit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compile e execute a aplicação novamente. Depois, faça uma requisição a URL &lt;code&gt;/hello&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, aponte seu browser para fazer uma requisição a URL &lt;code&gt;/quit&lt;/code&gt;. Nesse momento você verá que a janela da aplicação foi finalizada.&lt;/p&gt;

&lt;p&gt;Finalmente, abra o arquivo &lt;code&gt;log.txt&lt;/code&gt;, localizado no mesmo diretório do executável, para visualizar todos os vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Jun 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpweb-memleak</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpweb-memleak</guid>
      </item>
    
  </channel>
</rss>
