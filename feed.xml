<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Assertions é uma boa prática</title>
        <description>&lt;p&gt;Assertions auxiliam o programador no desenvolvimento e depuração do código, sendo a primeira linha de defesa contra bugs.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-andrew-ruiz-394426-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Andrew Ruiz on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Quando estamos desenvolvendo, é comum executar o programa várias vezes, digitar alguma entrada de dados “falsa”, e seguir adiante, afim de testar outras funcionalidades.&lt;/p&gt;

&lt;p&gt;Assim, vamos construindo um protótipo.&lt;/p&gt;

&lt;p&gt;Um protótipo pode ser codificado muito rapidamente, sendo comum codificarmos várias funcionalidades apenas para visualizarmos como seria o sistema real.&lt;/p&gt;

&lt;p&gt;Como um protótipo pode ser alterado inúmeras vezes, vários bugs podem aparecer.&lt;/p&gt;

&lt;p&gt;Aqui entram as &lt;a href=&quot;https://www.freepascal.org/docs-html/3.0.2/rtl/system/assert.html&quot;&gt;Assertions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;De acordo com a &lt;a href=&quot;https://en.wikipedia.org/wiki/Assertion_(software_development)&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In computer programming, an assertion is a statement that a predicate (Boolean-valued function, i.e. a true–false expression) is expected to always be true at that point in the code. If an assertion evaluates to false at run time, an assertion failure results, which typically causes the program to crash, or to throw an assertion exception.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Então, uma Assertion sempre deve ser verdadeira ou uma exceção &lt;code&gt;EAssertionFailed&lt;/code&gt; será gerada e o sistema será abortado, retornando o código &lt;code&gt;227&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;No entanto, se a unit &lt;code&gt;SysUtils&lt;/code&gt; for declarada em algum lugar do código, é possível verificar mais informações da exceção como a linha e a unit onde o erro foi gerado, além da &lt;i&gt;mensagem&lt;/i&gt; opcional que o desenvolvedor pode utilizar para cada Assertion.&lt;/p&gt;

&lt;p&gt;Uma Assertion funciona dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TForm1.Button1Click(Sender: TObject);
var
  I: Integer;
begin
  I := 0;
  Assert(I = 1, &#39;The I variable is not 1&#39;);
  ShowMessage(I.ToString);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No código acima, temos um &lt;code&gt;Form&lt;/code&gt; com um botão. No evento desse botão o Assert irá verificar se a variável &lt;code&gt;I&lt;/code&gt; é igual a &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O resultado será falso e uma exceção será gerada.&lt;/p&gt;

&lt;p&gt;Na minha IDE eu vejo essa mensagem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The I variable is not 1 (unit1.pas, line 34).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eu compilei o projeto &lt;i&gt;sem&lt;/i&gt; informações de &lt;i&gt;debugger&lt;/i&gt;. Mesmo assim, é possível ver a linha onde a validação ocorreu, tornando muito útil o uso de Assert para identificar onde e por quê um erro ocorreu.&lt;/p&gt;

&lt;p&gt;Entretanto, as Assertions não deve ser utilizadas em produção. Suas informações técnicas só deveriam ser vistas por programadores, não usuários finais.&lt;/p&gt;

&lt;p&gt;Por esse motivo nós &lt;b&gt;devemos&lt;/b&gt; desabilitar as Assertions quando fizermos o &lt;i&gt;deploy&lt;/i&gt; do sistema para o usuário final.&lt;/p&gt;

&lt;p&gt;Para desabilitar Assertions, o compilador tem uma diretiva de compilação global.&lt;/p&gt;

&lt;p&gt;Há duas opções:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ASSERTIONS ON/OFF (long form)
$C +/- (short form)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mas isso pode ser definido diretamente na IDE, na sessão de debugger nas  opções do projeto, sem haver necessidade de escrever uma linha de código.&lt;/p&gt;

&lt;p&gt;Quando as Assertions estão desabilitadas, as verificações não são executadas. Isso libera o sistema de todo &lt;i&gt;overhead&lt;/i&gt; das verificações no produto final.&lt;/p&gt;

&lt;p&gt;Finalmente, Assertions não substituem Testes de Unidade ou Teste de Integração, sendo apenas mais um tipo de ferramenta para testar o código na fase de desenvolvimento.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Mar 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/assertions</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/assertions</guid>
      </item>
    
      <item>
        <title>Construtores Virtuais</title>
        <description>&lt;p&gt;A linguagem Object Pascal possui uma feature que não existe em nenhuma outra linguagem &lt;i&gt;mainstream&lt;/i&gt; do mercado.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-eddie-kopp-264813-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Eddie Kopp on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Construtores Virtuais permitem a criação customizada de novas instâncias sem a necessidade do uso de classes de fábricas.&lt;/p&gt;

&lt;p&gt;É possível que desenvolvedores Object Pascal ao redor do mundo utilizem essa feature diariamente mesmo sem saber que só é possível utilizá-la na linguagem Object Pascal.&lt;/p&gt;

&lt;p&gt;Toda classe possui um ou mais &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt; no qual são responsáveis por instanciar um novo objeto.&lt;/p&gt;

&lt;p&gt;Entretanto, ter um construtor virtual &lt;a href=&quot;https://stackoverflow.com/questions/3651354/in-net-can-a-class-have-virtual-constructor&quot;&gt;não é comum&lt;/a&gt; em outras linguagens.&lt;/p&gt;

&lt;p&gt;Diferentemente das demais linguagens, os construtores na linguagem Object Pascal são como métodos “marcados” para serem construtores. Um fato sobre isso é que, em Object Pascal, podemos dar o nome que quisermos aos construtores — mesmo que o padrão de nomenclatura recomendado e utilizado seja &lt;code&gt;Create&lt;/code&gt; — e como os métodos podem ser &lt;i&gt;virtuais&lt;/i&gt;, assim também são os construtores.&lt;/p&gt;

&lt;p&gt;Mas, qual é a grande vantagem de utilizá-los?&lt;/p&gt;

&lt;h2 id=&quot;construtores&quot;&gt;Construtores Virtuais&lt;/h2&gt;

&lt;p&gt;Na documentação sobre &lt;em&gt;Factory and Repository patterns&lt;/em&gt; do framework &lt;a href=&quot;https://synopse.info/files/html/Synopse%20mORMot%20Framework%20SAD%201.18.html#TITLE_600&quot;&gt;Synopse mORMot&lt;/a&gt; você encontrará o seguinte texto:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In fact, Delphi is ahead of Java or C#, since it allows virtual constructors to be defined. Those virtual constructors are in fact a clean and efficient way of implementing a Factory, and also fulfill SOLID principles, especially the Liskov Substitution Principle: the parent class define an abstract constructor on which you rely, but the implementation will take place in the overridden constructor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No texto acima, eu sugiro apenas alterarmos a palavra “Delphi” por “Object Pascal”, visto que essa é uma feature da linguagem Object Pascal e não apenas da implementação do Delphi.&lt;/p&gt;

&lt;p&gt;Na maioria das linguagens, o padrão Factory é implementado através de métodos (estáticos, abstratos ou virtuais) das classes e não através dos construtores. Esse é um dos motivos para o autor afirmar que o Delphi (Object Pascal) está a frente de C# e Java nesse quesito. Eu concordo.&lt;/p&gt;

&lt;p&gt;Em Object Pascal podemos criar uma fábrica de objetos onde o tipo da classe original é a própria fábrica.&lt;/p&gt;

&lt;p&gt;Pense no modelo clássico implementado em várias linguagens. Por exemplo, teríamos uma entidade principal &lt;code&gt;TFoo&lt;/code&gt; e uma fábrica &lt;code&gt;TFooFactory&lt;/code&gt;,  que retorna classes-filhas da entidade principal. É importante lembrar que &lt;code&gt;TFoo&lt;/code&gt; deveria &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;implementar alguma Interface&lt;/a&gt; relacionada ao domínio, porém isso é irrelevante para o entendimento do problema.&lt;/p&gt;

&lt;p&gt;O código principal iria utilizar a fábrica para ter instâncias de &lt;code&gt;TFoo&lt;/code&gt;. A fábrica, no entanto, poderia retornar instâncias de novas classes-filhas, herdadas de &lt;code&gt;TFoo&lt;/code&gt; e isso seria transparente para o código principal. Essa é uma das features que queremos ao utilizarmos uma fábrica.&lt;/p&gt;

&lt;p&gt;Mas, primeiro teríamos que criar a fábrica para que ela retornasse as instâncias que realmente necessitamos.&lt;/p&gt;

&lt;p&gt;Em Object Pascal não precisamos de uma classe específica para ser a fábrica de objetos. Nós podemos ter variáveis/argumentos do tipo classe e, dessa maneira, podemos passar diretamente a classe que deve ser utilizada para criar a instância; sem intermediários.&lt;/p&gt;

&lt;p&gt;Imagine que temos uma simples library (lib) que soma 2 números. Essa lib tem uma classe &lt;i&gt;default&lt;/i&gt; para fazer a soma, mas ela permite que a classe seja customizada, lembrando muito o &lt;a href=&quot;https://en.wikipedia.org/wiki/Strategy_pattern&quot;&gt;padrão Strategy&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/0294f260c0d44b7c8b7f9a78df7662c1.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No exemplo acima temos a classe &lt;code&gt;TLibCalc&lt;/code&gt; que representa a lib. No construtor podemos customizar a classe que representa o algoritmo da soma, caso contrário a lib irá utilizar a classe &lt;code&gt;TSum&lt;/code&gt; padrão.&lt;/p&gt;

&lt;p&gt;A classe &lt;code&gt;TSum&lt;/code&gt; é simples. Ela soma dois inteiros. Mas repare que seu construtor é &lt;code&gt;virtual&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O próximo passo é criar um programa de teste.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/8589ff42e90b1311aa3f4b5bab2b7d16.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A saída do programa será: &lt;code&gt;Result is 8&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se tudo estiver funcionando por aí, vamos aos próximos passos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;criar nossa própria classe para somar 2 números&lt;/li&gt;
  &lt;li&gt;alterar o programa, customizando a lib&lt;/li&gt;
&lt;/ol&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/e364be559715b056463868d849e681ef.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima foi implementado uma nova classe &lt;code&gt;TMySum&lt;/code&gt; e inicializamos a lib &lt;code&gt;TLibCalc.Create(TMySum);&lt;/code&gt; com essa classe.&lt;/p&gt;

&lt;p&gt;Execute o programa e veja o resultado.&lt;/p&gt;

&lt;p&gt;Não foi necessária nenhuma fábrica. Nenhum “registro de classes” também foi necessário. Implementamos um padrão utilizando apenas classes simples da linguagem.&lt;/p&gt;

&lt;p&gt;Finalmente, a linguagem Object Pascal é tão simples que bastou utilizarmos uma &lt;i&gt;instância de classe&lt;/i&gt; contendo &lt;i&gt;construtores virtuais&lt;/i&gt; para instanciar a classe correta.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Em Object Pascal não é necessário termos fábricas; a classe customizada é a própria fábrica.&lt;/p&gt;

&lt;p&gt;Até onde eu sei, não existe essa feature em nenhuma linguagem &lt;i&gt;mainstream&lt;/i&gt;, apenas em Object Pascal.&lt;/p&gt;

&lt;p&gt;Com essa feature não é necessário criar classes de fábrica apenas para inicializar nossos verdadeiros objetos. Teremos menos classes, menos objetos, menos métodos, menos uso de memória, mais eficiência e &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/construtores-virtuais</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/construtores-virtuais</guid>
      </item>
    
      <item>
        <title>Listas Genéricas, sem Generics</title>
        <description>&lt;p&gt;É possível utilizarmos listas genéricas, com checagem de tipo, mas sem o uso da sintaxe com &lt;em&gt;Generics&lt;/em&gt;?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-john-murzaku-269690.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by John Murzaku on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Muitos programadores adoram utilizar novas &lt;em&gt;features&lt;/em&gt; dos compiladores. Uma dessas “novidades” — bem, já faz alguns anos — é o uso de Generics.&lt;/p&gt;

&lt;p&gt;Com Generics é possível, por exemplo, termos listas genéricas que podem ser utilizados com qualquer tipo de classe ou interface. Generics possuem uma “checagem estática” de tipo, tanto para armazenamento como para a recuperação dos itens da lista.&lt;/p&gt;

&lt;p&gt;Ao invés de termos as “velhas” listas de ponteiros, fazendo &lt;em&gt;casting&lt;/em&gt; dos objetos quando acessamos seus itens, hoje, utilizando Generics, podemos utilizar classes de listas já existentes na VCL/LCL para instanciar e manter uma lista de objetos que irão trabalhar com os tipos já definidos no nosso código.&lt;/p&gt;

&lt;p&gt;Na declaração de uma variável de uma lista genérica, informamos o &lt;em&gt;tipo&lt;/em&gt; dos itens que irão compor a lista e o compilador faz o resto do trabalho.&lt;/p&gt;

&lt;p&gt;Esse artigo não irá abordar as vantagens e desvantagens no uso de Generics. Ao invés disso, irei apenas mostrar como &lt;em&gt;simular&lt;/em&gt; uma lista genérica utilizando Object Pascal “clássico”.&lt;/p&gt;

&lt;p&gt;Por quê isso é relevante?&lt;/p&gt;

&lt;p&gt;Existem alguns motivos como, por exemplo, estar trabalhando com código legado numa versão do compilador sem suporte a Generics; almejar uma melhor performance, mesmo utilizando objetos; manter projetos (libs e frameworks) que podem ser utilizados desde os compiladores mais antigos até a versão mais atual.&lt;/p&gt;

&lt;p&gt;O problema de termos uma lista genérica, sem o uso de Generics, é o &lt;em&gt;casting&lt;/em&gt; que precisaríamos fazer todas as vezes que recuperarmos os itens da lista.&lt;/p&gt;

&lt;p&gt;O mesmo &lt;em&gt;casting&lt;/em&gt; seria &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/&quot;&gt;replicado&lt;/a&gt; várias vezes, em todos os pontos que fossem necessário recuperar os objetos.&lt;/p&gt;

&lt;p&gt;Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  Contnrs;

type
  TFoo = class
    Name: string;
  end;

procedure TForm1.Button1Click(Sender: TObject);
var
  F: TFoo;
  OL: TObjectList;
begin
  OL := TObjectList.Create(True);
  try
    F := TFoo.Create;
    F.Name := &#39;Bar&#39;;
    OL.Add(F);
    ShowMessage(
      (OL.Items[0] as TFoo).Name // &amp;lt;&amp;lt;&amp;lt; casting
    );
  finally
    OL.Free;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código acima utiliza a classe &lt;code&gt;TObjectList&lt;/code&gt; da unit &lt;code&gt;Contnrs&lt;/code&gt;. Essa classe trabalha com itens de objetos. Em seu construtor, um argumento &lt;code&gt;boolean&lt;/code&gt; indica que os objetos serão automaticamente liberados quando a lista for destruída.&lt;/p&gt;

&lt;p&gt;Funciona. Mas, o inconveniente é termos que fazer o casting na chamada de &lt;code&gt;Items[]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, é possível não utilizar casting, mesmo sem o uso de Generics. Para tal, vamos utilizar apenas classes simples e sintaxe clássica de Object Pascal.&lt;/p&gt;

&lt;p&gt;Primeiro, precisamos codificar nossa própria lista de objetos, &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/#classes-de-suporte&quot;&gt;sem herdar diretamente de classes de infraestrutura&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TMyObjects = class
  private
    FList: TObjectList;
  public
    constructor Create;
    destructor Destroy; override;
    function Add(Obj: TObject): TMyObjects;
    function Get(Index: Integer): TObject;
    function Count: Integer;
end;

{ TMyObjects }

constructor TMyObjects.Create;
begin
  FList := TObjectList.Create(True);
end;

destructor TMyObjects.Destroy;
begin
  FList.Free;
  inherited;
end;

function TMyObjects.Add(Obj: TObject): TMyObjects;
begin
  Result := Self;
  FList.Add(Obj);
end;

function TMyObjects.Get(Index: Integer): TObject;
begin
  Result := FList.Items[Index];
end;

function TMyObjects.Count: Integer;
begin
  Result := FList.Count;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A classe &lt;code&gt;TMyObjects&lt;/code&gt; poderá ser utilizada para armazenar qualquer tipo de instância de &lt;code&gt;TObject&lt;/code&gt;. Mas, o inconveniente ainda permanece, pois ao utilizar &lt;code&gt;Get(Index)&lt;/code&gt; o casting será necessário.&lt;/p&gt;

&lt;p&gt;Segundo, a solução mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; é utilizarmos &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança de classe&lt;/a&gt; e &lt;em&gt;reintroduzir&lt;/em&gt; o método que recupera os objetos, utilizando uma nova assinatura.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFooObjects = class(TMyObjects)
  public
    function Get(Index: Integer): TFoo; reintroduce;
  end;

{ TFooObjects }

function TFooObjects.Get(Index: Integer): TFoo;
begin
  Result := inherited Get(Index) as TFoo;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A nova classe &lt;code&gt;TFooObjects&lt;/code&gt; tem uma nova assinatura de &lt;code&gt;Get()&lt;/code&gt;. Isso quer dizer que quando o desenvolvedor utilizar o &lt;em&gt;code-completion&lt;/em&gt; da IDE, apenas essa “versão” do &lt;code&gt;Get(Index: Integer): TFoo&lt;/code&gt; será exibida.&lt;/p&gt;

&lt;p&gt;Então, podemos alterar o código de teste anterior para utilizar a nova classe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TForm1.Button1Click(Sender: TObject);
var
  F: TFoo;
  OL: TFooObjects;
begin
  OL := TFooObjects.Create;
  try
    F := TFoo.Create;
    F.Name := &#39;Bar&#39;;
    OL.Add(F);
    ShowMessage(OL.Get(0).Name);
  finally
    OL.Free;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sem casting, limpo e mais “elegante” do que utilizar Generics.&lt;/p&gt;

&lt;p&gt;A mesma técnica deve ser utilizada para o método &lt;code&gt;Add(Obj)&lt;/code&gt; afim de certificarmos que apenas instâncias de &lt;code&gt;TFoo&lt;/code&gt; serão armazenadas.&lt;/p&gt;

&lt;p&gt;A classe &lt;code&gt;TMyObjects&lt;/code&gt; foi codificada apenas uma vez e poderá ser reutilizada como base para várias outras classes.&lt;/p&gt;

&lt;p&gt;Entretanto, alguns desenvolvedores poderão sugerir que tivemos que implementar “muito” código para ter a mesma funcionalidade que a sintaxe de Generics já nos dá. Bem, isso depende do ponto de vista. Além dos motivos sugeridos nesse artigo, o &lt;em&gt;não&lt;/em&gt; uso de Generics pode fazer muito sentido quando estamos trabalhando na Camada de Negócio, onde o código deve representar as Regras de Negócio do cliente. Uma classe “inchada” com dezenas de métodos de manipulação de itens na lista pode não representar fielmente, por exemplo, uma “lista de produtos” do cliente.&lt;/p&gt;

&lt;p&gt;Finalmente, é você quem vai decidir sobre os &lt;em&gt;trade-offs&lt;/em&gt; envolvidos no design do seu código. Mas, sempre tenha em mente que nem tudo que é &lt;em&gt;antigo&lt;/em&gt; será pior que o mais &lt;em&gt;novo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/listas-genericas-sem-generics</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/listas-genericas-sem-generics</guid>
      </item>
    
      <item>
        <title>Namespaces Inteligentes</title>
        <description>&lt;p&gt;Na minha opinião, a implementação atual de Namespaces no Delphi poderia ser muito mais inteligente, simples e sem ambiguidades.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-fervent-jan-121249.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Fervent Jan on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A linguagem Pascal foi criada com o conceito de Namespace desde o início chamado &lt;em&gt;Units&lt;/em&gt;. As Unidades agrupam os identificadores, variáveis, tipos, classes…tudo que faz parte de um mesmo contexto.&lt;/p&gt;

&lt;p&gt;No entanto, hoje em dia nós, desenvolvedores Object Pascal, ganhamos uma definição diferente para Unit e Namespace.&lt;/p&gt;

&lt;p&gt;Talvez, devido a influência de outras linguagens “mais modernas”, ter apenas Unidades não parece ser mais suficiente para a modularização de sistemas.&lt;/p&gt;

&lt;p&gt;Concordo que ainda há espaço para melhorias no conceito das Unidades, porém a implementação proposta pela Embarcadero é suficiente para, agora, dizermos que a linguagem foi atualizada e que Namespaces é uma evolução?&lt;/p&gt;

&lt;h1 id=&quot;atual&quot;&gt;Namespaces Atual&lt;/h1&gt;

&lt;p&gt;A partir do Delphi 2007~2009 a Embarcadero implementou o “novo” conceito chamado &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Using_Namespaces_with_Delphi&quot;&gt;Namespace&lt;/a&gt;, onde é possível termos nomes de Unidades pontilhadas, como já existem em algumas outras linguagens.&lt;/p&gt;

&lt;p&gt;Além da questão estética para termos &lt;a href=&quot;/posts/nomeando-unidades/&quot;&gt;nomes de arquivos&lt;/a&gt; mais legíveis, esse conceito permite que o compilador localize as Unidades declaradas no código não apenas por seu nome, mas também levando em consideração o Namespace (prefixo) da Unidade.&lt;/p&gt;

&lt;p&gt;Segundo a Embarcadero, um Namespace é um &lt;a href=&quot;/posts/datamodule-e-apenas-um-container/&quot;&gt;container&lt;/a&gt; de Unidades.&lt;/p&gt;

&lt;p&gt;Nesse &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Using_Namespaces_with_Delphi&quot;&gt;link&lt;/a&gt;
oficial diz que &lt;em&gt;“Namespaces fornece uma maneira de organizar identificadores e tipos, e são utilizados para desambiguar tipos com o mesmo nome”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas já temos isso com as Unidades então, qual é a grande atualização?&lt;/p&gt;

&lt;p&gt;O documento segue dizendo: &lt;em&gt;“Desde que eles são um container para Unidades Delphi, os Namespaces também podem ser utilizados para diferenciação de unidades com o mesmo nome, que residem em pacotes diferentes”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Aqui parece haver uma vantagem. O texto afirma que podemos ter pacotes distintos porém cada um deles contendo Unidades com o mesmo nome e mesmo assim poderíamos utilizar tais pacotes em um mesmo projeto — algo que não seria possível sem essa &lt;em&gt;feature&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Enquanto eu escrevo esse artigo, tomando uma xícara quente de café na Starbucks, não tenho disponível uma versão atual do Delphi para fazer esse teste, mas eu acredito que funcione desde que eu utilize o Namespace do Pacote para referenciar todas as Unidades dele no meu projeto.&lt;/p&gt;

&lt;p&gt;Meu entendimento é esse:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Existe um Pacote chamado &lt;code&gt;Acme.Xpto.MyPack&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Dentro desse pacote existe as Unidades &lt;code&gt;Foo.pas&lt;/code&gt; e &lt;code&gt;Bar.pas&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;No meu projeto eu desejo utilizar as Unidades do Pacote, então eu preciso declara-las como &lt;code&gt;Acme.Xpto.Foo&lt;/code&gt; e &lt;code&gt;Acme.Xpto.Bar&lt;/code&gt; respectivamente.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Se eu tenho que escrever as Unidades de forma totalmente qualificada, qual é a grande vantagem? Não seria mais simples todas as Unidades do Pacote já serem totalmente qualificadas?&lt;/p&gt;

&lt;p&gt;De fato, é possível não escrever os Namespaces, em alguns casos.&lt;/p&gt;

&lt;p&gt;É possível, por exemplo, declarar a Unidade &lt;code&gt;Dialogs&lt;/code&gt; no código do seu projeto mas a referência real será &lt;code&gt;Vcl.Dialogs&lt;/code&gt; ou &lt;code&gt;FMX.Dialogs&lt;/code&gt;, bastando definir um parâmetro para o compilador. Parece ser uma &lt;em&gt;feature&lt;/em&gt; interessante mas, e se eu quisesse utilizar ambas as Unidades no mesmo projeto, como o compilador iria saber qual &lt;code&gt;Dialogs&lt;/code&gt; utilizar? Será que uma das Unidades deveria ser totalmente qualificada enquanto a outra não? Se assim for, é uma solução &lt;em&gt;inconsistente&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Talvez, o Objetivo da implementação padrão serviu apenas aos interesses da Embarcadero para o uso da VCL/FMX ao invés de ser realmente uma nova &lt;em&gt;feature&lt;/em&gt; para o desenvolvedor.&lt;/p&gt;

&lt;p&gt;Namespaces, na minha opinião, deveriam ser implementados de outra forma.&lt;/p&gt;

&lt;h2 id=&quot;problema&quot;&gt;O Problema&lt;/h2&gt;

&lt;p&gt;Uma Unidade já agrupa, de forma inequívoca, um identificador. Sempre tivemos isso na linguagem Object Pascal mas muitos acham que esse conceito só apareceu em linguagens mais recentes.&lt;/p&gt;

&lt;p&gt;Porém, hoje em dia eu posso ver uma referência a &lt;code&gt;Dialogs&lt;/code&gt; no código e não ter certeza se é da VCL ou qualquer outra Lib que utiliza Namespaces. É necessário verificar as configurações do compilador.&lt;/p&gt;

&lt;p&gt;Olhar “só” o código não é mais suficiente.&lt;/p&gt;

&lt;p&gt;Outro problema existe com o uso de Libs externas. Não sabemos, previamente, quais nomes de Unidades serão utilizadas pelos programadores ao redor do mundo. Esse é o motivo pelo qual sempre utilizamos prefixos (2~3 letras) nos nomes da Unidades/Classes para simular um Namespace único.&lt;/p&gt;

&lt;p&gt;Incrivelmente, essa pratica tem sido suficiente para a maioria dos casos. Pelo menos, para a maioria dos projetos Open Source mais conhecidos como Zeos(Z), RX, Indy(Id), JEDI(Jc) ou Synopse mORMot(Syn). Parece haver um certo “cavalheirismo” entre programadores em não utilizar os prefixos “já em uso” na comunidade Open Source.&lt;/p&gt;

&lt;p&gt;No Java, eles resolveram esse problema de forma mais simples: Utilize a URL da empresa/projeto como um Namespace para cada projeto.&lt;/p&gt;

&lt;p&gt;E é só isso. Não há ambiguidades, pois não há URL iguais.&lt;/p&gt;

&lt;p&gt;Então, bastaria fazermos o mesmo em Object Pascal. O mesmo que a comunidade de Java fez. Basta utilizar o maior nome possível para uma Unidade. Não haverá ambiguidade. Não haverá conflito. Não é necessário implementar nada no compilador.&lt;/p&gt;

&lt;p&gt;Resolvido?&lt;/p&gt;

&lt;p&gt;Em teoria sim. No entanto a implementação atual do Namespaces clama em dizer que é muito mais quem um nome único (veremos mais sobre isso abaixo).&lt;/p&gt;

&lt;p&gt;Além disso, Object Pascal não é assim, tão verboso. Gostamos de nomes simples e de fácil memorização. Podemos programar utilizando um editor simples de texto. Em Java, por exemplo, é necessário haver uma IDE inteligente para ter o mínimo de eficiência na codificação, visto que a IDE incluí automaticamente as “unidades” que serão importadas, além de fazer uma tonelada de checagens.&lt;/p&gt;

&lt;p&gt;Bem, se vamos alterar ou melhorar o conceito de Unidades, por quê não fazer isso de forma inteligente, ainda mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, eficaz e sem os problemas de ambiguidades na utilização dos Namespaces atuais?&lt;/p&gt;

&lt;p&gt;Podemos sugerir algumas ideias.&lt;/p&gt;

&lt;h2 id=&quot;desejavel&quot;&gt;Namespaces Desejável&lt;/h2&gt;

&lt;p&gt;Então, qual seria o &lt;em&gt;nirvana&lt;/em&gt; da implementação de Namespaces no Delphi e Lazarus?&lt;/p&gt;

&lt;p&gt;Eu posso lhe dizer minhas ideias (atuais) e no fim veremos se você concorda.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespaces deveriam ser únicos e explícitos no código&lt;/strong&gt;, sem ambiguidades.&lt;/p&gt;

&lt;p&gt;É &lt;em&gt;errado&lt;/em&gt; e anti-Pascal ter uma Unidade que não está 100% explícita no código sobre o que ela representa ou se há ambiguidades sobre o que ela representa.&lt;/p&gt;

&lt;p&gt;Isso quer dizer que &lt;code&gt;Dialogs&lt;/code&gt; &lt;em&gt;não&lt;/em&gt; pode representar, ora &lt;code&gt;FMX.Dialogs&lt;/code&gt;, ora &lt;code&gt;Vcl.Dialogs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mesmo que eles possam ser configuráveis, eles deveriam ser únicos no código para não haver ambiguidades.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespaces deveriam ser dinâmicos&lt;/strong&gt;, porém explícitos no código.&lt;/p&gt;

&lt;p&gt;Ser dinâmico implica em configuração. Então, a ideia de definirmos Namespaces como argumentos do compilador é boa, porém sua implementação atual não foi bem executada.&lt;/p&gt;

&lt;p&gt;Sim, Namespaces deveriam ser definidos &lt;em&gt;por&lt;/em&gt; Pacote, porém o &lt;em&gt;erro&lt;/em&gt; é defini-los utilizando os nomes dos Pacotes.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;configuração&lt;/em&gt; deveria ser local.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespaces deveriam ser locais&lt;/strong&gt;, ou seja, cada projeto implementa os Namespaces de acordo com a nomenclatura que desejar.&lt;/p&gt;

&lt;p&gt;Na minha opinião, ao adicionar um Pacote ao meu projeto, eu poderia (ou deveria) definir um Namespace para ele. É o mesmo que dizer que todas as Unidades do Pacotes seriam “renomeadas” com o novo prefixo — muito similar com a solução atual — porém sem ambiguidades.&lt;/p&gt;

&lt;p&gt;Imagine 2 Pacotes: &lt;code&gt;FooPack&lt;/code&gt; e &lt;code&gt;BarPack&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Os desenvolvedores de ambos não deveriam se importar sobre Namespaces. Cada Pacote está bem definido em seus próprios contextos locais, sem se preocupar com o mundo afora. Não importa se os projetos que irão utilizá-los serão pequenos ou gigantescos com inúmeras dependências de vários outros Pacotes. Isso deveria ser irrelevante para os autores de Pacotes.&lt;/p&gt;

&lt;p&gt;Cabe a cada Projeto definir o Namespace para cada Pacote, se assim o desejar.&lt;/p&gt;

&lt;p&gt;Por exemplo, se ambos os Pacotes tem uma Unidade chamada &lt;code&gt;Utils&lt;/code&gt;, nos iríamos referenciá-las como &lt;code&gt;Foo.Utils&lt;/code&gt; e &lt;code&gt;Bar.Utils&lt;/code&gt; dentro do código do Projeto.&lt;/p&gt;

&lt;p&gt;Essa foram escolhas óbvias. Mas ou invés de &lt;code&gt;Foo.Utils&lt;/code&gt; e &lt;code&gt;Bar.Utils&lt;/code&gt; poderiam ser &lt;code&gt;FoPack.Utils&lt;/code&gt; e &lt;code&gt;BrPack.Utils&lt;/code&gt;, respectivamente. O mais importante aqui é que estas são &lt;em&gt;escolhas do Projeto&lt;/em&gt;, do usuário do Pacote, não daqueles que criaram os Pacotes.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;É necessário uma implementação mais moderna do conceito de Namespace, porém sem perder as características originais do Object Pascal.&lt;/p&gt;

&lt;p&gt;Tudo na linguagem é previamente declarado, exatamente para não haver ambiguidades. Unidades devem ser únicas em todo o projeto. Não importa se elas estão na VCL/LCL, RTL, Libs, etc. Não deveriam haver ambiguidades.&lt;/p&gt;

&lt;p&gt;Tudo é ou deveria ser explícito no código. Deixar o compilador decidir se um identificador corresponde a X ou a Y em tempo de execução, não me parece ser algo tão explícito.&lt;/p&gt;

&lt;p&gt;Finalmente, as ideias propostas nesse artigo tem a finalidade e o desejo de melhorar a linguagem Object Pascal e não depreciar as escolhas de &lt;em&gt;design&lt;/em&gt; dos desenvolvedores da linguagem e do compilador.&lt;/p&gt;

&lt;p&gt;Esses são meus pensamentos… Você concorda?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/namespaces-inteligentes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/namespaces-inteligentes</guid>
      </item>
    
      <item>
        <title>Interfaces COM vs. CORBA</title>
        <description>&lt;p&gt;Existem dois tipos de Interfaces no Free Pascal definidos como COM e CORBA. No Delphi temos apenas o tipo COM. Mas será que existem vantagens ao utilizar o tipo CORBA?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-hermes-rivera-265372.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Hermes Rivera on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No Delphi, quando definimos que um Objeto é do tipo Interface, quer dizer que (por padrão) ele será a liberado automaticamente da memória pelo compilador quando a variável sair do escopo e sua &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#contador-de-referencias&quot;&gt;contagem de referência&lt;/a&gt; chegar a zero.&lt;/p&gt;

&lt;p&gt;Para utilizar essa &lt;em&gt;feature&lt;/em&gt;, basta implementar sua Classe herdando de &lt;code&gt;TInterfacedObject&lt;/code&gt;, afim de utilizar a implementação padrão para Interfaces COM.&lt;/p&gt;

&lt;p&gt;Se você não quiser utilizar &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;, terá que implementar os &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#contador-de-referencias&quot;&gt;3-métodos&lt;/a&gt; obrigatórios para toda Classe que implementa Interfaces COM e isso realmente pode parecer estranho para programadores que estão vindo de outras linguagens.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Por quê eu deveria implementar métodos que não estão definidos na Interface?”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Realmente, não parece fazer muito sentido.&lt;/p&gt;

&lt;h2 id=&quot;corba&quot;&gt;CORBA&lt;/h2&gt;

&lt;p&gt;No Free Pascal você tem uma escolha. Pode-se utilizar Interfaces COM ou CORBA. O primeiro tipo se comporta do mesmo jeito que no Delphi. Tem contagem de referência e liberação automática de memória, enquanto o tipo CORBA é exatamente o contrário. Esse tipo não tem contagem de referência e, por isso, não tem a ajuda do compilador para liberar a memória automaticamente. Cabe ao programador liberar os Objetos utilizando seus respectivos destrutores.&lt;/p&gt;

&lt;p&gt;Também não é possível liberar uma instância apenas atribuindo &lt;code&gt;nil&lt;/code&gt;. É necessário que se tenha a instância de uma Classe ou que a Interface tenha algum método que possa ser utilizado como destrutor, por exemplo, &lt;code&gt;Free&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IFoo = interface
    procedure Execute;
    procedure Free;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O tipo CORBA não exige do programador a implementação “obscura” de métodos de &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#infraestrutura&quot;&gt;infraestrutura&lt;/a&gt; além do que está declarado na Interface. Apenas os métodos das Interfaces devem ser implementados nas Classes. Essa é uma vantagem em relação ao tipo COM.&lt;/p&gt;

&lt;p&gt;Então, se você estiver desenvolvendo utilizando Free Pascal e não quer trabalhar com contagem de referência, utilizar CORBA pode ser uma boa opção.  Sua sintaxe e &lt;em&gt;design&lt;/em&gt; “limpos” não obrigam o programador a implementar os 3-métodos padrões de COM.&lt;/p&gt;

&lt;p&gt;Entretanto, lembre-se que todas as Interfaces dentro da mesma Unit terão o mesmo tipo, seja COM ou CORBA.&lt;/p&gt;

&lt;h2 id=&quot;com&quot;&gt;COM&lt;/h2&gt;

&lt;p&gt;Muitos programadores não gostam de utilizar o tipo COM devido aos problemas com referência de Objetos. Mesmo que a &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;solução&lt;/a&gt; seja simples para resolvê-los.&lt;/p&gt;

&lt;p&gt;Enquanto o tipo CORBA pode ter um &lt;em&gt;design&lt;/em&gt; mais simples, o tipo COM é mais &lt;em&gt;customizável&lt;/em&gt; pois pode ser implementado sem contagem de referência. Basta implementarmos os 3-métodos obrigatórios sem incrementar a contagem.&lt;/p&gt;

&lt;p&gt;Pessoalmente, sempre prefiro utilizar o tipo COM e a contagem de referência para a liberação automática dos objetos na memória. Entretanto, se eu quiser que apenas algumas Classes não tenham a contagem de referência, basta sobrescrever os métodos necessários para ter o mesmo comportamento das Classes que implementam Interfaces CORBA.&lt;/p&gt;

&lt;p&gt;Considero isso uma &lt;em&gt;grande&lt;/em&gt; vantagem!&lt;/p&gt;

&lt;p&gt;Por exemplo. Posso ter uma única Interface mas com implementações distintas em Classes diferentes, utilizando ou não a contagem de referência.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Minha conclusão é que o tipo COM é &lt;em&gt;melhor&lt;/em&gt; do que CORBA por quê podemos implementar os dois tipos de comportamentos (com ou sem contagem de referência), enquanto com CORBA implementamos apenas um comportamento.&lt;/p&gt;

&lt;p&gt;O comportamento deve estar nas Classes, não nas Interfaces ou diretivas de compilação.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/com-vs-corba</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/com-vs-corba</guid>
      </item>
    
      <item>
        <title>Versões Antigas dos Compiladores</title>
        <description>&lt;p&gt;A primeira versão do Delphi data de 1995, após o Turbo Pascal,enquanto o compilador Free Pascal é de 1993.&lt;/p&gt;

&lt;p&gt;Estamos em 2018 agora. Será que vale a pena manter seu código executando nas versões antigas do compilador?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-danielle-macinnes-222441.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Danielle MacInnes on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Talvez não valha a pena manter o código dos seus projetos funcionando nas versões antigas, uma vez que você tenha conseguido migrar todo o código-fonte para uma versão mais nova. No entanto, suas bibliotecas — especialmente as públicas, Open Source — poderiam (ou deveriam?) continuar compilando nas versões mais antigas dos compiladores.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O primeiro motivo&lt;/strong&gt; é bem simples. &lt;em&gt;Compatibilidade&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas por quê isso é importante?&lt;/p&gt;

&lt;p&gt;Trabalho profissionalmente com o Delphi desde sua versão 4 e um dos critérios que me fizeram continuar na ferramenta foi a retrocompatibilidade. Um código que executava na versão anterior, continuava executando na versão mais nova.&lt;/p&gt;

&lt;p&gt;Lembro das palestras e encontros proporcionados pela antiga Borland, onde o palestrante abria aquele “Projeto dos Peixinhos” feito no Delphi 1~2 e ele continuava compilando normalmente, sem alterações, na versão mais nova.&lt;/p&gt;

&lt;p&gt;É difícil ver esse nível de comprometimento com o usuário/desenvolvedor hoje em dia. Quantos frameworks a Microsoft já criou e matou na plataforma .NET? Temos que ficar correndo como “ratos” atrás do próximo “queijo sofisticado” para fazer o mesmo tipo de projeto que já estávamos fazendo a 20 anos atrás? Tenho certeza que não.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O segundo motivo&lt;/strong&gt; é proporcionar mais &lt;em&gt;opções&lt;/em&gt; de bibliotecas à comunidade Object Pascal.&lt;/p&gt;

&lt;p&gt;Hoje em dia a linguagem se tornou um (pequeno) nicho. Enquanto nascem “centenas” de frameworks JavaScript todos os dias, não vemos o mesmo empenho na comunidade Pascal. Então, é importante manter o código legado funcionando para manter os desenvolvedores fieis a linguagem. Senão eles irão procurar alternativas lá fora. Melhor ainda, seria se tivéssemos mais opções a escolher, no entanto.&lt;/p&gt;

&lt;p&gt;Eu já publiquei algumas bibliotecas Open Source a alguns anos, mas agora elas não existem mais. Não valiam a pena. Eram só “brinquedos”. Elas deveriam mesmo desaparecer. No entanto existem bibliotecas que fizeram e ainda fazem muita diferença no desenvolvimento hoje como a RX e JEDI. Acredito que essas bibliotecas não compilem utilizando versões antigas, no entanto elas foram atualizadas, o que já é um grande mérito para seus mantenedores.&lt;/p&gt;

&lt;p&gt;Existem ainda alguns &lt;em&gt;ninjas&lt;/em&gt; do Object Pascal que mantém uma &lt;em&gt;única&lt;/em&gt; base de código desde o Delphi 6 até o Delphi 10.2 Tokyo, compilando também no FPC 2.7.1/3.1.1 em diante. Me refiro ao framework &lt;a href=&quot;https://synopse.info/fossil/wiki?name=SQLite3+Framework&quot;&gt;mORMot&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mORMot é o estado-da-arte&lt;/strong&gt; dentre todos os projetos Object Pascal que conheço. Com uma &lt;em&gt;única&lt;/em&gt; base de código e sintaxe “old-school”, sem generics, sem classes anônimas, sem métodos anônimos, sem n.a.m.e.s.p.a.c.e.s, ou seja, “apenas” com Classes, Interfaces e funções, o autor Arnaud Bouchez e colaboradores foram capazes de criar e manter ao longo dos anos, um framework Client-Server ORM/ODM SOA MVC completo, quase sem dependências externas, com performance &lt;em&gt;superior&lt;/em&gt; as soluções &lt;em&gt;modernas&lt;/em&gt; como Node.js.&lt;/p&gt;

&lt;p&gt;Isso prova que &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt; e arquitetura bem feita são muito mais importantes que novas &lt;em&gt;features&lt;/em&gt; na linguagem, novos componentes, nova IDE…&lt;/p&gt;

&lt;p&gt;A alguns anos eu voltei a publicar projetos Open Source, com uma nova abordagem e profissionalismo. Mas quando vejo projetos como o mORMot, tenho a plena convicção do quanto eu ainda tenho que aprender.&lt;/p&gt;

&lt;p&gt;Hoje utilizo FPC/Lazarus mais do que Delphi. Comecei a migrar meus sistemas e bibliotecas privadas para a “plataforma concorrente” a alguns anos. Nessa época o Lazarus era um “brinquedo” mas, felizmente, continuei a utilizá-lo e hoje o Lazarus é tão bom quanto o Delphi — talvez melhor. No entanto, o &lt;em&gt;Delphi 7&lt;/em&gt; ainda faz parte do meu dia-a-dia. Então, vale a pena fazer bibliotecas para essa versão? Talvez.&lt;/p&gt;

&lt;p&gt;Saber que as mesmas bibliotecas que eu sempre utilizei foram sendo atualizadas ao londo de todos esses anos, é um conforto. Não precisarei reescrever meus sistemas… pelo menos enquanto mantermos a linguagem viva.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/versoes-antigas-dos-compiladores</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/versoes-antigas-dos-compiladores</guid>
      </item>
    
      <item>
        <title>Objetos Complexos</title>
        <description>&lt;p&gt;Um Objeto não é apenas uma instância de uma Classe. Ele pode conter instâncias (quase) infinitas de diferentes Classes combinadas.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-chuttersnap-378918.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by chuttersnap on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;No mundo real convivemos constantemente com Objetos (humanos, animais, plantas, coisas, etc) que possuem todo tipo de &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamento&lt;/a&gt; especializado. Alguns desses Objetos — talvez a maioria — fazem coisas demais, ou seja, eles agregam muitas funcionalidades num único “corpo”. Eles são &lt;em&gt;complexos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Quando tentamos abstrair e implementar um &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Objeto ou Entidade&lt;/a&gt; no &lt;em&gt;software&lt;/em&gt;, utilizando uma linguagem de programação em conjunto com o paradigma da Orientação a Objetos, uma dúvida comum em quase todos os desenvolvedores iniciantes — ou mesmo experientes — é tentar identificar quais métodos irão ser implementados na Classe, baseado apenas no comportamento “final” do Objeto ou Entidade do mundo real.&lt;/p&gt;

&lt;p&gt;O comportamento final ao que me refiro é como vemos um Objeto e suas funcionalidades sem considerar as partes que os compõem. Vemos um Objeto como um &lt;em&gt;todo&lt;/em&gt; e não como uma soma das partes.&lt;/p&gt;

&lt;p&gt;Esse é um grande equívoco no desenvolvimento de software.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo. Como representamos um &lt;em&gt;Carro&lt;/em&gt; utilizando a &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;O primeiro passo seria determinar o nível de abstração dos comportamentos que precisamos implementar ou descartar. Em outras palavras, é necessário saber os requisitos do sistema para sabermos o que é realmente necessário.  Se a cor do carro é irrelevante para os requisitos do usuário dentro do &lt;em&gt;software&lt;/em&gt;, então não há necessidade de implementarmos. É necessário saber se a carroceria utiliza fibra de carbono ou alumínio? Se o carro é 4x4, sua velocidade máxima, quantidade de airbags, tipo de roda? Se nada disso for importante, descartamos. Então, o mais fácil a fazer é pensarmos no que é &lt;em&gt;necessário&lt;/em&gt;, pois é quase certo que qualquer Objeto implementado não irá representar uma entidade completamente, ou seja, com todo comportamento que a entidade possui no mundo real.&lt;/p&gt;

&lt;p&gt;Após termos o comportamento necessário já definido, o próximo passo é pensar na estrutura da Classe.&lt;/p&gt;

&lt;p&gt;É aqui, neste momento, que a grande maioria dos desenvolvedores utiliza o paradigma procedural, porém pensam que estão programando Orientado a Objetos apenas por quê estão utilizando Classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TCar = class
  public
    procedure Run;
    procedure Brake;
    function CheckBrakeFluid: Boolean;
    function CheckOil: Boolean;
    function CheckWater: Boolean;
    procedure LockDoors;
    procedure UnlockDoors;
    procedure StartEngine;
    procedure StopEngine;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Classe acima mostra de forma simples os comportamentos necessários que foram solicitados, hipoteticamente, nos requisitos do usuário. Mas será esse é o design &lt;em&gt;correto&lt;/em&gt; para representar um carro dentro do &lt;em&gt;software&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Apesar das funcionalidades estarem bem evidentes e com &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/&quot;&gt;nomes de métodos&lt;/a&gt; bem “explicativos”, essa é uma implementação totalmente equivocada.&lt;/p&gt;

&lt;p&gt;Um carro não &lt;em&gt;corre&lt;/em&gt;. É o motor que gira e, através de mecanismos e engrenagens, passa energia para as rodas fazendo o carro se mover através do atrito dos pneus com o asfalto.&lt;/p&gt;

&lt;p&gt;Um carro não &lt;em&gt;freia&lt;/em&gt;. É o motorista que através de um pedal, em conjunto com cabos ou mesmo eletrônica, envia um comando às pinças de freio. Essas, em conjunto com os discos de freio, fazem o carro parar.&lt;/p&gt;

&lt;p&gt;Um carro não faz &lt;em&gt;checagens&lt;/em&gt; de fluídos. Existem sensores específicos para fazer essa leitura a cada segundo ou microssegundo.&lt;/p&gt;

&lt;p&gt;Fica claro aqui, que não devemos ver a entidade como um todo, mas sim pensar nas partes específicas que a compõe. No entanto, não devemos especializar demais para não complicarmos o modelo desnecessariamente.&lt;/p&gt;

&lt;p&gt;Vamos reescrever a Classe acima.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TBrakes = class(TInterfacedObject, IBrakes)
  public
    function Brake(AForce: Double): IBrakes;
  end;
  
  TSensors = class(TInterfacedObject, ISensors)
  public
    function CheckBrakeFluid: Boolean;
    function CheckOil: Boolean;
    function CheckWater: Boolean;
  end;
  
  TDoors = class(TInterfacedObject, IDoors)
  public
    function Lock: IDoors;
    function Unlock: IDoors;
  end;
  
  TEngine = class(TInterfacedObject, IEngine)
  public
    procedure Start;
    procedure Stop;
    function Work: IEngine;
  end;
  
  TCar = class(TInterfacedObject, ICar)
  public
    procedure Run;
    function Brakes: IBrakes;
    function Sensors: ISensors;
    function Doors: IDoors;
    function Engine: IEngine;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Há várias possibilidade de implementação, mas a opção sugerida acima separa bem o comportamento de um carro através da composição de Objetos. No entanto, não há necessidade de especializar tudo. Por exemplo, o método &lt;code&gt;Run&lt;/code&gt; continua o mesmo; existe apenas uma Classe &lt;code&gt;TSensors&lt;/code&gt; para todos os sensores — seria muito melhor se tivéssemos uma Classe por sensor.&lt;/p&gt;

&lt;p&gt;O design deve ser o mais simples possível, porém correto, reutilizável (partes independentes) e testável (cada parte em separado).&lt;/p&gt;

&lt;p&gt;Na minha opinião, a &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt;, a reutilização e a testabilidade devem ser alguns dos maiores objetivos a serem seguidos no design de cada Classe.&lt;/p&gt;

&lt;p&gt;Essa foi uma maneira de implementar algo complexo de forma simples.&lt;/p&gt;

&lt;p&gt;Um outro padrão de desenvolvimento que podemos utilizar para implementarmos algo complexo é chamado de &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração de Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Imagine que você tenha diferentes modelos de motores. Utilizar &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança de Classes&lt;/a&gt; pode ser a primeira técnica que vem a sua mente, porém a Decoração de Objetos pode ser bem melhor. Utilizando essa técnica, podemos decorar Objetos em &lt;em&gt;runtime&lt;/em&gt; de acordo com os requisitos ou escolhas feita pelos usuários num determinado momento.&lt;/p&gt;

&lt;p&gt;Então, seguindo nosso exemplo, imagine um motor chamado X13 e uma versão com mais performance chamada X15 que possui um turbo compressor. Ao implementarmos essas Classes, gostaríamos de reutilizar as partes em comum. Sendo o X15 uma melhoria do X13, que tal &lt;em&gt;decorar&lt;/em&gt; o X13 em &lt;em&gt;runtime&lt;/em&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  Engine: IEngine;
begin
  Engine := 
    TX15Engine.New(
      0.6, // pressure
      TX13Engine.New()
    );
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo, a variável &lt;code&gt;Engine&lt;/code&gt; será, de certa forma, um Objeto &lt;em&gt;combinado&lt;/em&gt; de duas instâncias de Classes diferentes, porém complementares.&lt;/p&gt;

&lt;p&gt;Para implementarmos Objetos complexos, devemos analisar suas partes, de acordo com o nível de abstração requerido, e implementar cada uma delas, combinando-as entre si, para então termos a implementação de um Objeto maior e mais &lt;em&gt;complexo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“O todo é maior que a soma das partes”.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/objetos-complexos</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/objetos-complexos</guid>
      </item>
    
      <item>
        <title>O Procedimento Exit</title>
        <description>&lt;p&gt;Todos os programadores Pascal conhecem o procedimento &lt;code&gt;Exit()&lt;/code&gt; desde as primeiras versões dos compiladores. Mas será que todos sabem utilizá-lo corretamente?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-kev-seto-94686.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Kev Seto on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;O procedimento &lt;code&gt;Exit()&lt;/code&gt; é utilizado quando queremos sair de um escopo em execução. Esse escopo pode ser uma função, procedimento, método ou até mesmo o próprio programa.&lt;/p&gt;

&lt;p&gt;Vamos dizer que um programa console chame um procedimento &lt;code&gt;Execute&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  Writeln(&#39;1. Passing on this line...&#39;);
  Exit;
  Writeln(&#39;2. It will not pass here&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, somente a informação do primeiro &lt;code&gt;Writeln&lt;/code&gt; será mostrado no console.&lt;/p&gt;

&lt;p&gt;Ao sair de um escopo, o programa retorna imediatamente para o escopo anterior (outra função/procedimento/método ou o próprio programa). A única exceção a essa regra é quando há blocos &lt;code&gt;try-finally&lt;/code&gt;. Se &lt;code&gt;Exit()&lt;/code&gt; for chamado dentro de um bloco &lt;code&gt;try-finally&lt;/code&gt; o compilador irá executar o código dentro do &lt;code&gt;finally-end&lt;/code&gt; &lt;em&gt;antes&lt;/em&gt; de sair do escopo.&lt;/p&gt;

&lt;p&gt;Aqui está outro exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  try
    Writeln(&#39;1. Passing on this line...&#39;);
    Exit;
  finally
    Writeln(&#39;2. I am still here!&#39;);
  end;
  Writeln(&#39;3. It will not pass here&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os textos #1 e #2 serão mostrados no console. Mesmo que &lt;code&gt;Exit()&lt;/code&gt; tenha sido chamado antes da impressão do texto #2, ainda sim o código é executado devido ao &lt;code&gt;try-finally&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Outro exemplo de uso do &lt;code&gt;Exit()&lt;/code&gt; é quando fazemos validações. Se uma validação ou checagem não retornar verdadeiro, utilizamos o &lt;code&gt;Exit()&lt;/code&gt; para parar a execução do escopo atual.&lt;/p&gt;

&lt;p&gt;Suponha que queremos somar dois números inteiros, mas só queremos números maiores que zero:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;lt; 0) or (B &amp;lt; 0) then
    Exit;
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, o retorno da função &lt;code&gt;Sum&lt;/code&gt; é inicializado com um valor inválido e depois há uma validação para saber se os valores são menores que &lt;code&gt;0&lt;/code&gt;. Se o teste falhar, o programa irá retornar para o escopo anterior à chamada da função &lt;code&gt;Sum&lt;/code&gt; com o resultado inválido. Mas se o teste não falhar, o resultado da função será a soma de A e B.&lt;/p&gt;

&lt;p&gt;Há aqueles que são adeptos da programação estruturada e preferem não “quebrar” a execução do programa com uma “saída antecipada”, ou seja, não fazem uso do &lt;code&gt;Exit()&lt;/code&gt; por acreditarem que o código ficaria mais simples.&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  if (A &amp;gt; 0) and (B &amp;gt; 0) then
    Result := Format(&#39;The result is %d&#39;, [A + B]);
  else
    Result := &#39;Invalid result&#39;;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parece mais simples? Bem, nesse exemplo eu diria que sim. Porém para exemplos com mais condicionais, eu diria que não (vamos ver isso mais abaixo).&lt;/p&gt;

&lt;p&gt;E se quiséssemos dizer ao usuário que seus dados não estão corretos?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;gt; 0) then
  begin
    if (B &amp;gt; 0) then
      Result := Format(&#39;The result is %d&#39;, [A + B]);
    else
      Writeln(&#39;B should be greater than zero&#39;);
  end
  else
    Writeln(&#39;A should be greater than zero&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo não utilizamos &lt;code&gt;Exit()&lt;/code&gt; e eu acho que o código está bem confuso. Os testes estão “separados” do retorno de aviso para o usuário (&lt;code&gt;Writeln&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Kent Beck , Martin Fowler &lt;a href=&quot;https://en.wikipedia.org/wiki/Structured_programming#Early_exit&quot;&gt;afirmaram&lt;/a&gt; categoricamente que &lt;em&gt;“um ponto de saída não é realmente uma regra útil. A clareza é o princípio chave: se o método for mais claro com um ponto de saída, use um ponto de saída, caso contrário, não”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior com o uso de &lt;code&gt;Exit()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;lt; 0) then
  begin
    Writeln(&#39;A should be greater than zero&#39;);
    Exit;
  end;
  if (B &amp;lt; 0) then
  begin
    Writeln(&#39;B should be greater than zero&#39;);
    Exit;
  end;
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código ficou um pouco maior, é verdade, porém os testes e avisos para o usuário ficaram mais simples, na minha opinião. Você não precisa acompanhar todos os &lt;code&gt;if-else&lt;/code&gt; aninhados. A cada teste que falhar, o aviso está logo abaixo e o escopo será abortado com o uso do &lt;code&gt;Exit()&lt;/code&gt;. Se todos os testes não falharem, a função irá retornar a soma de A e B.&lt;/p&gt;

&lt;p&gt;No Delphi, a partir da &lt;a href=&quot;http://docs.embarcadero.com/products/rad_studio/delphiAndcpp2009/HelpUpdate2/EN/html/delphivclwin32/System_Exit.html&quot;&gt;versão 2009&lt;/a&gt;, o procedimento &lt;code&gt;Exit()&lt;/code&gt; ganhou uma melhoria: &lt;code&gt;Exit()&lt;/code&gt; pode ter um parâmetro especificando um resultado. O parâmetro deve ser do mesmo tipo que o resultado da função.&lt;/p&gt;

&lt;p&gt;O FPC também tem a &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/exit.html&quot;&gt;mesma definição&lt;/a&gt;, porém não sei quem implementou essa nova &lt;em&gt;feature&lt;/em&gt; primeiro.&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  if (A &amp;lt; 0) then
    Exit(&#39;A should be greater than zero&#39;);
  if (B &amp;lt; 0) then
    Exit(&#39;B should be greater than zero&#39;);
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/posts/simplicidade/&quot;&gt;Simples&lt;/a&gt; e limpo.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Exit()&lt;/code&gt; pode receber como parâmetro qualquer tipo de retorno, até mesmo instâncias de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;. Utilizando esse parâmetro, é como se ganhássemos o mesmo comportamento da palavra reservada &lt;code&gt;return&lt;/code&gt;, em Java. No entanto, &lt;code&gt;Exit()&lt;/code&gt; em conjunto com &lt;code&gt;Result&lt;/code&gt; nos dá ainda mais possibilidades de retorno para as funções.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/exit-proc</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/exit-proc</guid>
      </item>
    
      <item>
        <title>Pas2JS: Codificando em Pascal, Executando em JavaScript</title>
        <description>&lt;p&gt;A equipe do Free Pascal e Lazarus nos deram um grande presente de Final de Ano: Um Transpiler de Pascal para JavaScript.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-greg-rakozy-129733.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Greg Rakozy on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O uso do JavaScript é necessário para qualquer aplicação Web. Somos obrigados a utilizá-lo por quê (por enquanto) é a única linguagem que os &lt;em&gt;browsers&lt;/em&gt; entendem.&lt;/p&gt;

&lt;p&gt;Mas JavaScript não é fortemente tipado como Pascal e isso pode ser um grande problema quando codificamos aplicações maiores utilizando somente JavaScript.&lt;/p&gt;

&lt;p&gt;JavaScript pode ser &lt;em&gt;confuso&lt;/em&gt; e &lt;em&gt;ambíguo&lt;/em&gt;. Por isso muitos desenvolvedores &lt;em&gt;devem&lt;/em&gt; utilizar &lt;em&gt;frameworks&lt;/em&gt; que facilitam o desenvolvimento e padronizam a codificação.&lt;/p&gt;

&lt;p&gt;Codificar utilizando JavaScript &lt;em&gt;puro&lt;/em&gt; não é uma tarefa fácil.&lt;/p&gt;

&lt;p&gt;Então surgiram os &lt;a href=&quot;https://en.wikipedia.org/wiki/Source-to-source_compiler&quot;&gt;Transpilers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Um Transpiler é um compilador que, a partir de um código-fonte escrito em uma linguagem de programação como sua entrada, produz um código-fonte equivalente em outra linguagem de programação.&lt;/p&gt;

&lt;p&gt;Existem &lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS&quot;&gt;vários&lt;/a&gt; Transpilers para JavaScript a partir de várias linguagens de programação. O mais famoso deles, eu acredito, é a linguagem TypeScript da Microsoft.&lt;/p&gt;

&lt;p&gt;A linguagem Pascal está incluída nesse pacote de Transpilers, no entanto, além de existir poucos, eles são comerciais.&lt;/p&gt;

&lt;p&gt;Felizmente, agora temos uma opção gratuita e Open Source chamada &lt;strong&gt;Pas2JS&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;pas2js&quot;&gt;Pas2JS&lt;/h2&gt;

&lt;p&gt;Michael Van Canneyt (Free Pascal Team), Mattias Gaertner (Lazarus Team), e colaboradores, &lt;a href=&quot;http://lists.lazarus-ide.org/pipermail/lazarus/2017-December/233592.html&quot;&gt;lançaram oficialmente&lt;/a&gt; o compilador utilitário chamado &lt;a href=&quot;http://wiki.freepascal.org/pas2js&quot;&gt;Pas2JS&lt;/a&gt;, em 16 de Dezembro de 2017, na lista oficial do Free Pascal.&lt;/p&gt;

&lt;p&gt;O JavaScript gerado a partir de um código-fonte Pascal é utilizável no &lt;em&gt;browser&lt;/em&gt; ou até mesmo no Node.js.&lt;/p&gt;

&lt;p&gt;Ao invés de gerar um executável com seu código Pascal, um arquivo .js será gerado, compatível com seu &lt;em&gt;browser&lt;/em&gt;, sem a necessidade de haver um servidor de aplicação (CGI, FastCGI, ISAPI, etc) se o aplicativo não necessitar de dados externos.&lt;/p&gt;

&lt;p&gt;Como disse Michael no seu email de lançamento (tradução livre):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Isso torna o Free Pascal um ambiente de desenvolvimento completo para o desenvolvimento Web”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Na verdade, o desenvolvimento ainda não está (totalmente) completo. Funciona muito bem, porém ainda há melhorias a serem feitas, como pode ser visto &lt;a href=&quot;http://wiki.freepascal.org/pas2js#Other_not_implemented_features&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A sintaxe básica é a mesma do Delphi 7&lt;/strong&gt;, porém ainda não temos o suporte a Interfaces. Acredito que teremos isso em breve, no entanto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A RTL teve que ser reescrita&lt;/strong&gt;, gerando novas versões das Unidades padrão para que pudessem ser utilizadas perfeitamente na conversão de Pascal para JavaScript. A lista das unidades você pode ver &lt;a href=&quot;http://wiki.freepascal.org/pas2js#RTL&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O debugging pode ser feito diretamente no código Object Pascal&lt;/strong&gt;, dentro do &lt;em&gt;browser&lt;/em&gt;. Isso é possível por quê o Pas2JS emite um &lt;em&gt;“source map”&lt;/em&gt; para que o &lt;em&gt;browser&lt;/em&gt; exiba o código original em vez do código JavaScript, o que é muito útil para encontrar bugs no código original Pascal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lazarus já tem suporte para a sintaxe do Pas2JS&lt;/strong&gt;, então o &lt;em&gt;code completion&lt;/em&gt; irá funcionar (versão trunk).&lt;/p&gt;

&lt;p&gt;A integração completa do Pas2JS está sendo codificada no Lazarus e, futuramente, eles já falam em desenvolver pacotes de componentes para execução no &lt;em&gt;browser&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TMS Web componentes vai chegar no início de 2018&lt;/strong&gt;. São componentes visuais no bom estilo RAD para desenvolver aplicações Web utilizando &lt;code&gt;TForm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cito a TMS aqui por quê, no email do Michael, ele diz (tradução livre):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Em um futuro muito próximo, um importante fornecedor de componentes da Delphi anunciará um pacote completo para desenvolvimento web RAD no Delphi IDE.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu &lt;em&gt;acredito&lt;/em&gt; que ele estava falando da &lt;a href=&quot;https://www.tmssoftware.com/site/&quot;&gt;TMS&lt;/a&gt;, empresa conceituada que se dedica à fabricação de componentes e frameworks para Delphi e Lazarus.&lt;/p&gt;

&lt;p&gt;A alguns dias atrás os desenvolvedores do Brasil tiveram a chance de ver algumas palestras sobre Delphi e uma delas foi o anúncio da nova tecnologia da TMS para desenvolvimento Web, por Wagner Landgraf.&lt;/p&gt;

&lt;p&gt;Para quem acompanha os pré-anúncios do Pas2JS já algum tempo — pois ele está sendo desenvolvido ao longo de 10 anos — basta “ligar os pontos” para ter quase certeza que os componentes TMS Web utiliza a tecnologia Pas2JS ou, no mínimo, se inspirou nela.&lt;/p&gt;

&lt;p&gt;No entanto, na palestra do Wagner não há nenhuma menção ao Pas2JS.&lt;/p&gt;

&lt;p&gt;Se eu estou certo, ou seja, se a TMS Web realmente utiliza o Pas2JS no seu novo produto, eu considero uma &lt;em&gt;falha&lt;/em&gt; não mencionar quem criou o Transpiler.&lt;/p&gt;

&lt;p&gt;Não há nenhum problema em criar componentes para comercialização, no entanto é necessário dar o crédito a quem é devido.&lt;/p&gt;

&lt;p&gt;Entretanto, isso é apenas uma suposição pessoal. Se a TMS não utiliza/utilizou o Pas2JS, acredito que saberemos disso em breve.&lt;/p&gt;

&lt;p&gt;Mas, independentemente da TMS utilizar ou não o Pas2JS, fico ansioso para ver o lançamento oficial do novo &lt;em&gt;framework&lt;/em&gt;, visto que tais componentes irão funcionar também no Lazarus.&lt;/p&gt;

&lt;p&gt;Sendo a TMS &lt;em&gt;referência&lt;/em&gt; em componentes desde a primeira versão do Delphi, é de se esperar que esse será mais um grande sucesso.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;preview&lt;/em&gt; da tecnologia exposto na palestra foi excelente e motivador.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Para uma linguagem que muitos consideram “morta”, ter um Transpiler de Object Pascal para JavaScript é um grande impulso para por a linguagem (novamente) nos “trilhos do mercado”.&lt;/p&gt;

&lt;p&gt;Sabemos que hoje em dia muitas empresas optam por desenvolver soluções 100% online, via &lt;em&gt;browser&lt;/em&gt;, ao invés de aplicações Desktop.&lt;/p&gt;

&lt;p&gt;Com o Pas2JS será possível termos uma &lt;em&gt;única&lt;/em&gt; base de código Object Pascal — uma linguagem fortemente tipada, limpa e de fácil aprendizagem — onde poderemos utilizar todo o nosso conhecimento da linguagem, da RTL e componentes, para provermos aplicações 100% Web. Confiáveis, rápidas e de fácil manutenção.&lt;/p&gt;

&lt;p&gt;É esperar, pra ver.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/pas2js</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/pas2js</guid>
      </item>
    
      <item>
        <title>Mais Performance usando Argumentos &quot;const&quot; para Interfaces</title>
        <description>&lt;p&gt;Se você utiliza instâncias de Interfaces em todos os lugares e quer aumentar um pouco a performance do seu código, leia esse artigo.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-alex-holyoake-334209.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Alex Holyoake on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Em um código verdadeiramente Orientado a Objetos, as instâncias dos Objetos devem ser do tipo Interface em &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;todos os lugares&lt;/a&gt; do código.&lt;/p&gt;

&lt;p&gt;Além de prover um contrato entre os Objetos, as instâncias de Interfaces são auto-gerenciadas, ou seja, a memória é liberada automaticamente pelo compilador.&lt;/p&gt;

&lt;p&gt;No Free Pascal, no entanto, podemos ter instâncias de Interfaces que não são auto-gerenciadas. Essas interfaces utilizam o modelo &lt;a href=&quot;https://www.freepascal.org/docs-html/prog/progsu37.html&quot;&gt;CORBA&lt;/a&gt; com a directiva &lt;code&gt;{$interfaces corba}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Porém, o &lt;em&gt;default&lt;/em&gt; de uso de Interfaces é o modelo COM, com auto-gerenciamento de memória através de um contador interno de referências à instância.&lt;/p&gt;

&lt;p&gt;Esse auto-gerenciamento tem um custo computacional de execução, mas pode ser extremamente minimizado com apenas uma pequena alteração no código.&lt;/p&gt;

&lt;p&gt;Entretanto, para você entender como essa pequena alteração irá afetar a performance do seu código, antes você precisa saber como o compilador faz o auto-gerenciamento de memória de instâncias de Interfaces.&lt;/p&gt;

&lt;h2 id=&quot;metodos-especiais&quot;&gt;Métodos Especiais&lt;/h2&gt;

&lt;p&gt;Todo Objeto que implementa uma Interface COM — &lt;code&gt;IUnknown&lt;/code&gt; — deve implementar 3 Métodos especiais que não fazem parte da Interface.&lt;/p&gt;

&lt;p&gt;Funciona assim:&lt;/p&gt;

&lt;p&gt;Quando criamos uma instância do tipo Interface, o compilador irá chamar um método especial do Objeto chamado &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown._addref.html&quot;&gt;_AddRef&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse método irá aumentar uma contagem de referência, toda vez que uma nova variável receber a mesma instância do Objeto.&lt;/p&gt;

&lt;p&gt;Da mesma forma, toda vez que uma variável sair do escopo de execução, o compilador irá chamar o método &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown._release.html&quot;&gt;_Release&lt;/a&gt; para decrementar a contagem.&lt;/p&gt;

&lt;p&gt;Quando a contagem de referência — o atributo &lt;code&gt;FRefCount: LongInt&lt;/code&gt; — chegar a zero, o destrutor do Objeto será executado e a memória será liberada.&lt;/p&gt;

&lt;p&gt;Esse mecanismo é muito, muito mais simples do que ter um &lt;em&gt;garbage collector&lt;/em&gt; sendo executado em paralelo, como é feito em outras linguagens.&lt;/p&gt;

&lt;p&gt;Existe mais um terceiro e último método chamado &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown.queryinterface.html&quot;&gt;QueryInterface&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse método é utilizado quando fazemos &lt;a href=&quot;/posts/nao-utilize-casting/&quot;&gt;&lt;em&gt;casting&lt;/em&gt;&lt;/a&gt; do Objeto para Interface utilizando a estrutura &lt;code&gt;Intf := Obj as IMyInterface;&lt;/code&gt; ou quando utilizamos a função &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/sysutils/supports.html&quot;&gt;Supports&lt;/a&gt; para determinar se uma instância implementa ou não uma determinada Interface.&lt;/p&gt;

&lt;p&gt;Todas as Classes que implementam uma ou mais Interfaces, devem ter esses 3 métodos implementados.&lt;/p&gt;

&lt;p&gt;Esse é o motivo de herdarmos quase todas as nossas Classes de &lt;code&gt;TInterfacedObject&lt;/code&gt;, pois ela já contém a implementação destes métodos para lidar com a contagem de referência.&lt;/p&gt;

&lt;p&gt;Implementamos esses métodos apenas para o compilador e é possível sabermos o momento no qual o compilador irá chamá-los, sobrecarregando o código com execuções além da implementação padrão dos Métodos do Objeto.&lt;/p&gt;

&lt;p&gt;Então, se conseguirmos evitar tais chamadas, nosso código terá mais performance pois ciclos de CPU serão poupados.&lt;/p&gt;

&lt;h2 id=&quot;sobrecarga&quot;&gt;Sobrecarga&lt;/h2&gt;

&lt;p&gt;Devido as chamadas automáticas de &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; em toda atribuição e saída de escopo das variáveis, muitos desenvolvedores acham que essa é uma &lt;em&gt;grande&lt;/em&gt; sobrecarga para o código.&lt;/p&gt;

&lt;p&gt;Na Engenharia nada é grátis, havendo sempre prós e contras.&lt;/p&gt;

&lt;p&gt;Se por um lado temos o auto-gerenciamento de memória para instâncias de Interfaces, por outro temos essa sobrecarga do incremento e decremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;Além disso, toda vez que &lt;code&gt;_Release&lt;/code&gt; for chamado, haverá uma checagem para saber se a contagem chegou a zero para que o destrutor do Objeto também seja chamado.&lt;/p&gt;

&lt;p&gt;Eu acredito que essa é uma sobrecarga &lt;em&gt;mínima&lt;/em&gt;, considerando todas as &lt;em&gt;vantagens&lt;/em&gt; que temos ao utilizar instâncias de Interfaces.&lt;/p&gt;

&lt;p&gt;Mas nem todos os desenvolvedores pensam da mesma forma.&lt;/p&gt;

&lt;p&gt;De fato, existem algoritmos que não podem se dar o luxo de perder ciclos de CPU fazendo operações de infraestrutura da linguagem — incremento/decremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;Entretanto, a linguagem Object Pascal nos dá uma “saída” bastante elegante para a diminuição de toda essa sobrecarga.&lt;/p&gt;

&lt;h2 id=&quot;argumentos-const&quot;&gt;Argumentos “const”&lt;/h2&gt;

&lt;p&gt;Sempre que uma instância for passada por parâmetro a outro Objeto através de um argumento, haverá o incremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;A menos que você utilize Argumentos “const”.&lt;/p&gt;

&lt;p&gt;Vamos chamá-los de “&lt;em&gt;ConstArgs&lt;/em&gt;”, para encurtar.&lt;/p&gt;

&lt;p&gt;Aqui está a definição, em tradução livre, de &lt;a href=&quot;https://www.freepascal.org/docs-html/ref/refsu67.html&quot;&gt;const&lt;/a&gt; na documentação do Free Pascal:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Especificar um parâmetro como Constante está dando ao compilador uma dica de que o conteúdo do parâmetro não será alterado pela rotina chamada. Isso permite que o compilador execute otimizações que não poderia fazer de outra forma, e também para executar determinadas verificações no código dentro da rotina: ou seja, pode proibir atribuições ao parâmetro. Além disso, um parâmetro const não pode ser transmitido para outra função que requer um parâmetro variável: o compilador pode verificar isso também. O principal uso para isso é reduzir o tamanho da pilha, portanto, melhorar o desempenho e ainda manter a semântica de passagem por valor…”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eles não falam nada sobre utilizar “const” para argumentos do tipo Interface, no entanto eu posso lhe afirmar que utilizá-los irá aumentar a performance do seu código.&lt;/p&gt;

&lt;p&gt;O motivo é simples: &lt;em&gt;ConstArgs&lt;/em&gt; não executam &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Isso quer dizer que o incremento/decremento do atributo de contagem de referência não irão ocorrer.&lt;/p&gt;

&lt;p&gt;A checagem se o contador interno chegou a zero também não irá existir no ASSEMBLY final gerado pelo compilador.&lt;/p&gt;

&lt;p&gt;Vou demostrar isso, começando com a unidade base de todos os exemplos:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/d7583833ddaf07df796321c95ee8faa8.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A &lt;code&gt;Unit1&lt;/code&gt; contém uma Interface e uma Classe que a implementa.&lt;/p&gt;

&lt;p&gt;Os Métodos &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram sobrescritos para termos o controle do que ocorre dentro deles quando o compilador chamá-los.&lt;/p&gt;

&lt;p&gt;Então vamos criar o primeiro programa de teste que utiliza a &lt;code&gt;Unit1&lt;/code&gt;:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/ac9932e2b0e5a3525fdf05223051d5c9.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Esse é um programa &lt;em&gt;CLI&lt;/em&gt; (&lt;em&gt;command-line&lt;/em&gt;) bem simples.&lt;/p&gt;

&lt;p&gt;É necessário setar a utilização do &lt;a href=&quot;http://wiki.freepascal.org/heaptrc&quot;&gt;&lt;em&gt;heaptrc&lt;/em&gt;&lt;/a&gt; no Lazarus para mostrar os vazamentos de memória (se houver) no final da execução do programa.&lt;/p&gt;

&lt;p&gt;Então, após a execução, no meu laptop a saída foi essa:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
_AddRef called
RefCount is 1
_AddRef called
RefCount is 2
Acting...
_Release called
_Release called
RefCount is 0
Destroing...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
64 memory blocks freed     : 1593/1720
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A execução foi bem sucedida, e não contém vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Porém, veja que &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram, ambos, chamados 2 vezes cada. Isso ocorre por quê, ao criar a instância em &lt;code&gt;A&lt;/code&gt;, há o incremento e ao passar essa instância para &lt;code&gt;Execute&lt;/code&gt;, há um novo incremento da contagem.&lt;/p&gt;

&lt;p&gt;Agora apenas altere a assinatura do procedimento, adicionando &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute(const A: IAction);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute novamente.&lt;/p&gt;

&lt;p&gt;Esse é o resultado por aqui:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
_AddRef called
RefCount is 1
Acting...
_Release called
RefCount is 0
Destroing...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
64 memory blocks freed     : 1593/1720
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A mesma memória foi consumida, mas &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram chamados apenas 1 vez cada.&lt;/p&gt;

&lt;p&gt;Isso se traduz em &lt;em&gt;mais&lt;/em&gt; performance ou &lt;em&gt;menos&lt;/em&gt; sobrecarga, dependendo do seu ponto de vista.&lt;/p&gt;

&lt;p&gt;Imagine se esse mesmo procedimento fosse chamado 100 vezes. Sem o “const” haveria mais de 100 chamadas aos Métodos especiais.&lt;/p&gt;

&lt;p&gt;Mas, se é tão simples eliminar essa sobrecarga apenas especificando o tipo do argumento, por quê nem todos os desenvolvedores utilizam essa técnica?&lt;/p&gt;

&lt;p&gt;Talvez seja apenas falta de conhecimento ou talvez eles tenham lido sobre problemas obscuros de vazamento de memória com o uso de &lt;em&gt;ConstArgs&lt;/em&gt; e Interfaces.&lt;/p&gt;

&lt;h2 id=&quot;problemas&quot;&gt;Argumentos e Interfaces&lt;/h2&gt;

&lt;p&gt;Há alguns artigos na Internet dizendo que temos que ter &lt;a href=&quot;https://pascal.today/2016/12/16/take-care-of-const-and-interface-parameters/&quot;&gt;cuidado&lt;/a&gt; ao utilizarmos &lt;em&gt;ConstArgs&lt;/em&gt; em conjunto com instâncias de Interfaces.&lt;/p&gt;

&lt;p&gt;Sim, &lt;em&gt;devemos&lt;/em&gt; ter cuidado.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O código realmente pode ficar intrincado e vazamentos de memória podem ocorrer&lt;/strong&gt; em lugares onde tudo parece estar correto.&lt;/p&gt;

&lt;p&gt;Para demonstrar vamos a outro exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/979c82ffe9288ec129b5792cfef0d9b0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;É o mesmo programa anterior, porém agora a instância de &lt;code&gt;TAction&lt;/code&gt; é criada “inline”.&lt;/p&gt;

&lt;p&gt;Após executar, esse é o resultado por aqui:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
Acting...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
63 memory blocks freed     : 1577/1704
1 unfreed memory blocks : 16
True heap size : 229376 (80 used in System startup)
True free heap : 229200
Should be : 229216
Call trace for block $01872E88 size 16
  $004015C7  main,  line 14 of C:/temp/project1.lpr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que os Métodos especiais não foram executados e há um vazamento de memória, o que não é nada bom.&lt;/p&gt;

&lt;p&gt;Mas se você retirar o “const” do procedimento, o vazamento é corrigido.&lt;/p&gt;

&lt;p&gt;Se o argumento não for um &lt;em&gt;ConstArgs&lt;/em&gt; ele poderá incrementar a contagem e não haverá vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Por isso há o mito de que “não devemos utilizar &lt;em&gt;ConstArgs&lt;/em&gt; com Interfaces” ou que devemos evitar seu uso.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Felizmente a solução para toda essa complexidade é muito simples&lt;/strong&gt;, bastando utilizar uma técnica que eu publiquei a quase dois anos atrás, na qual eu chamo de &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Altere &lt;code&gt;TAction&lt;/code&gt; adicionando o Método &lt;code&gt;New&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TAction = class(TInterfacedObject, IAction)
public
  class function New: IAction;
  // ...
end;

implementation

class function TAction.New: IAction;
begin
  Result := Create;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Altere também o programa, dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
  Execute(TAction.New);
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute e veja o resultado você mesmo.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Se você criar suas instâncias utilizando &lt;code&gt;New&lt;/code&gt; — um método da Classe — ao invés de chamar diretamente os &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt;, eu lhe asseguro que você não terá problemas de vazamento de memória, se a utilizar corretamente.&lt;/p&gt;

&lt;p&gt;Vimos nesse artigo que uma simples mudança no código pode gerar um ganho considerável de performance.&lt;/p&gt;

&lt;p&gt;Utilizando &lt;em&gt;ConstArgs&lt;/em&gt; em conjunto com a técnica chamada &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;, você poderá deixar seu código mais rápido e sem vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Dec 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/argumentos-const</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/argumentos-const</guid>
      </item>
    
  </channel>
</rss>
