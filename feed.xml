<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Usando Paths ao invés de Diretivas de Compilação</title>
        <description>&lt;p&gt;Já pensou em utilizar paths, ao invés de diretivas de compilação, para compilar seu projeto em diferentes plataformas?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/claudio-hirschberger-1326178-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Nathan Dumlao on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Em meados de 2017 eu escrevi um &lt;a href=&quot;/diretivas-de-compilacao&quot;&gt;artigo&lt;/a&gt; sobre Diretivas de Compilação, explicando como poderíamos encapsulá-las para ajudar a tornar o código &lt;em&gt;multiplatform&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Basicamente teríamos uma unidade comum a todas as plataformas (FPC e Delphi) e outra(s) unidade(s) específica(s) para cada uma delas.&lt;/p&gt;

&lt;p&gt;Por exemplo: uma unidade &lt;code&gt;FooFuncs&lt;/code&gt; seria a principal enquanto &lt;code&gt;FooFuncsFPC&lt;/code&gt; e &lt;code&gt;FooFuncsDelphi&lt;/code&gt; seriam as especializadas.&lt;/p&gt;

&lt;p&gt;A unidade &lt;code&gt;FooFuncs&lt;/code&gt; utilizaria as unidades especializadas e seus identificadores—interfaces e classes—seriam &lt;a href=&quot;/redeclarando-classes&quot;&gt;redefinidos&lt;/a&gt; utilizando uma nomenclatura mais genérica para toda a lib ou projeto e sem dependências com qualquer plataforma.&lt;/p&gt;

&lt;p&gt;Após quase 2 anos, eu mudei esse conceito para um modelo que considero ainda mais simples e sem utilizar diretivas de compilação: utilização de apenas &lt;em&gt;paths&lt;/em&gt; para cada plataforma.&lt;/p&gt;

&lt;center&gt;&lt;span style=&quot;font-size: 1.0em;&quot;&gt;* * *&lt;/span&gt;&lt;/center&gt;

&lt;p&gt;Veja o projeto &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;Xavier lib&lt;/a&gt;, por exemplo.&lt;/p&gt;

&lt;p&gt;Dentro do diretório &lt;code&gt;xavier/src/&lt;/code&gt; podemos ver dois subdiretórios: &lt;code&gt;fpc&lt;/code&gt; e &lt;code&gt;delphi&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cada diretório possui 1 unidade com o mesmo nome: &lt;code&gt;XavierCorePlatform&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Sabemos que um projeto não pode ter unidades duplicadas, então como isso funciona?&lt;/p&gt;

&lt;p&gt;Basta aplicar o path por plataforma, ou seja, apenas 1 unidade será utilizada por projeto. Se você está utilizando o Delphi, irá utilizar apenas o path &lt;code&gt;src\delphi&lt;/code&gt;, por exemplo.&lt;/p&gt;

&lt;p&gt;E é só isso.&lt;/p&gt;

&lt;p&gt;As &lt;em&gt;vantagens&lt;/em&gt; são visíveis em relação a abordagem anterior que utilizava diretivas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sem necessidade de diretivas de compilação&lt;/li&gt;
  &lt;li&gt;não é necessário redeclarar identificadores de unidades especializadas&lt;/li&gt;
  &lt;li&gt;não é necessário haver uma unidade genérica—ex: &lt;code&gt;FooFuncs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;basta 1 unidade por plataforma&lt;/li&gt;
  &lt;li&gt;menos código&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No entanto, você poderia considerar a (possível) &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/&quot;&gt;duplicação de código&lt;/a&gt; como uma desvantagem, visto que haverá implementações de classes, com o mesmo nome, em unidades por plataforma. No projeto Xavier, por exemplo, vemos que há algumas linhas muito similares… mas isso não é um problema real.&lt;/p&gt;

&lt;p&gt;A implementação por plataforma pode ser muito diferente uma da outra. Existir algumas linhas similares—ou mesmo iguais—é um preço mínimo a se pagar, na minha humilde opinião.&lt;/p&gt;

&lt;p&gt;Finalmente, repare que todo código comum entre as plataformas devem estar em outras unidades—no caso do Xavier, tais códigos compartilhados estão em &lt;code&gt;XavierCore&lt;/code&gt; e &lt;code&gt;XavierAdapters&lt;/code&gt;, utilizados pelas respectivas &lt;code&gt;XavierCorePlatform&lt;/code&gt; em cada plataforma.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 15 Apr 2019 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/usando-paths-ao-inves-de-diretivas</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/usando-paths-ao-inves-de-diretivas</guid>
      </item>
    
      <item>
        <title>Trabalhando com Exceções em Requisições HTTP</title>
        <description>&lt;p&gt;Em requisições HTTP, devemos levantar uma exceção quando recebermos, por exemplo, um código 500?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/nathan-dumlao-744702-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Nathan Dumlao on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Tivemos uma discussão em um grupo do &lt;a href=&quot;https://telegram.org/&quot;&gt;Telegram&lt;/a&gt; sobre utilizar ou não exceções em requisições HTTP, o que me inspirou a escrever esse artigo.&lt;/p&gt;

&lt;p&gt;Como todos sabemos, o &lt;a href=&quot;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol&quot;&gt;protocolo HTTP&lt;/a&gt; é baseado em texto simples.&lt;/p&gt;

&lt;p&gt;Cada requisição do cliente é composto por um cabeçalho e um corpo (opcional):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /index.html HTTP/1.1
Host: www.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A resposta do servidor segue o mesmo protocolo, contendo um cabeçalho e um corpo (também opcional) de resposta:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 138
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
ETag: &quot;3f80f-1b6-3e1cb03b&quot;
Accept-Ranges: bytes
Connection: close

&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;An Example Page&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  Hello World, this is a very simple HTML document.
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A beleza desse protocolo é que mesmo seres humanos, não apenas máquinas, podem ler entender (a maioria do) seu conteúdo.&lt;/p&gt;

&lt;p&gt;Então podemos perceber que há um padrão em ambas as mensagens acima, identificado na primeira linha, indicando o sucesso ou erro da requisição ou resposta.&lt;/p&gt;

&lt;p&gt;O padrão é determinado por um par de &lt;em&gt;código&lt;/em&gt; e &lt;em&gt;texto&lt;/em&gt; no qual identificaremos por &lt;em&gt;status&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;No exemplo acima, o status é determinado pelo código 200 e o texto “OK”. Mostrando uma resposta padrão de &lt;em&gt;sucesso&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Há uma &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_HTTP_status_codes&quot;&gt;grande lista&lt;/a&gt; de códigos pré-determinados e toda aplicação deveria respeitá-los em todas as  requisições e respostas.&lt;/p&gt;

&lt;p&gt;Agora, repare que não existem objetos e tão pouco &lt;em&gt;objetos de exceções&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;No início do artigo eu disse que a dúvida que gerou a discussão foi utilizar ou não exceções, ou seja, objetos &lt;code&gt;Exception&lt;/code&gt; e derivados em clientes HTTP.&lt;/p&gt;

&lt;p&gt;Minha resposta?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Você não deveria utilizar exceções em clientes HTTP, somente nas suas classes de negócio.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Se o protocolo não tem exceções, por quê implementá-lo na classe mais básica, ou seja, a que faz a ponte entre o seu sistema e a requisição HTTP?&lt;/p&gt;

&lt;p&gt;Para mim, não faz sentido.&lt;/p&gt;

&lt;p&gt;É verdade que existem vários frameworks que implementam clientes HTTP como, por exemplo, &lt;a href=&quot;https://www.indyproject.org/&quot;&gt;Indy&lt;/a&gt;, &lt;a href=&quot;http://www.ararat.cz/synapse/doku.php/start&quot;&gt;Synapse&lt;/a&gt; ou até mesmo os clientes padrão da linguagem.&lt;/p&gt;

&lt;p&gt;Talvez esses clientes podem gerar uma exceção quando recebem um código 500 ou talvez não. Não importa. Você deveria encapsular essas classes de terceiros em suas próprias classes de acesso HTTP. Assim, você poderia mudar de framework apenas alterando essas classes.&lt;/p&gt;

&lt;p&gt;Pense apenas em um cliente HTTP genérico, cru, que implementa o protocolo como ele deve ser: envio e recebimento de mensagens no formato texto. A partir dele você constrói classes de negócio que utilizam o cliente, adicionando comportamento referente as regras de negócio.&lt;/p&gt;

&lt;p&gt;Na &lt;a href=&quot;/posts/microservices-delphi-parte-final/&quot;&gt;parte final&lt;/a&gt; da série “Microservices com Delphi” você poderá ver mais um exemplo de como fazer o tratamento de códigos de retorno do cliente HTTP. Esse é apenas mais um exemplo e não um padrão. Tudo irá depender da sua aplicação, quais códigos verificar e o que fazer quando recebê-los.&lt;/p&gt;

&lt;p&gt;Apenas mantenha os clientes o mais simples possível.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 01 Apr 2019 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/exceptions-no-protocolo-http</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/exceptions-no-protocolo-http</guid>
      </item>
    
      <item>
        <title>Tipo object Continua Vivo</title>
        <description>&lt;p&gt;Existe uma estrutura no Object Pascal que foi o precursor das classes.&lt;/p&gt;

&lt;p&gt;Você conhece o tipo &lt;code&gt;object&lt;/code&gt;?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/namroud-gorguis-253765-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Namroud Gorguis on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Em um &lt;a href=&quot;/formularios-e-widgets&quot;&gt;artigo&lt;/a&gt; anterior eu expliquei com dividir o código de um formulário em diferentes objetos, organizando os widgets em diferentes classes para dividir as responsabilidades em diferentes objetos.&lt;/p&gt;

&lt;p&gt;Separar partes do código em classes distintas melhoram a legibilidade e manutenção do código. Mas você pode implementar o mesmo conceito sem utilizar classes.&lt;/p&gt;

&lt;p&gt;Muitas vezes eu utilizo o tipo &lt;code&gt;object&lt;/code&gt; como um &lt;em&gt;helper&lt;/em&gt; para um widget ou conjunto deles.&lt;/p&gt;

&lt;p&gt;De fato, essa técnica pode ser utilizada não só na implementação de formulários, mas em &lt;em&gt;qualquer&lt;/em&gt; parte do código.&lt;/p&gt;

&lt;p&gt;Não confunda com os tipos Helpers que &lt;em&gt;adiciona&lt;/em&gt; comportamento a tipos já existentes. Existe uma sintaxe especial para declara-los, estendendo outros tipos sem utilizar herança… mas não é deles que estou falando.&lt;/p&gt;

&lt;p&gt;Se você não gosta de nomenclatura &lt;em&gt;helper&lt;/em&gt;, poderíamos chamá-los de &lt;em&gt;ferramentas&lt;/em&gt;, pois eles &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;não representam&lt;/a&gt; uma entidade e não implementam uma &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;interface&lt;/a&gt;. São apenas ferramentas que serão utilizadas pelos verdadeiros objetos.&lt;/p&gt;

&lt;p&gt;Não representar uma entidade é um bom motivo para utilizar o tipo &lt;code&gt;object&lt;/code&gt;, mas há outras vantagens.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Performance&lt;/strong&gt;, por utilizar o stack ou invés do heap na alocação de memória.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Utiliza menos memória&lt;/strong&gt;, pois são estruturas mais simples, comparadas às classes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Uso de herança&lt;/strong&gt; é possível.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Determinar um escopo&lt;/strong&gt; para um conjunto de funções utilitárias, genéricas e reutilizáveis, ao invés de declarar funções e procedimentos diretamente no escopo da unit.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Simplicidade&lt;/strong&gt;, sempre será um ótimo motivo para tomar decisões na arquitetura. Por exemplo: não é necessário o uso de &lt;code&gt;try..finally&lt;/code&gt;, tornando o código menos verboso.&lt;/p&gt;

&lt;p&gt;Uma &lt;strong&gt;desvantagem&lt;/strong&gt;, entretanto, é não existir um [construtor] e por isso não tem como garantir uma inicialização adequada dos campos privados. Diferentemente de uma classe, onde é &lt;em&gt;obrigatório&lt;/em&gt; o uso de seu construtor, um tipo &lt;code&gt;object&lt;/code&gt; pode ser utilizado diretamente como qualquer outra variável primitiva.&lt;/p&gt;

&lt;p&gt;Além disso, a Embarcadero descontinuou o uso do tipo &lt;code&gt;object&lt;/code&gt; desde o Delphi 2010, sugerindo o uso de “records com métodos” em seu lugar—uma decisão equivocada, na minha opinião, e &lt;a href=&quot;http://blog.synopse.info/post/2013/10/09/Good-old-object-is-not-to-be-deprecated-it-is-the-future&quot;&gt;não estou sozinho&lt;/a&gt; nesse pensamento. Além de perder a compatibilidade com o código legado, introduzir métodos em records é, no mínimo, duvidoso.&lt;/p&gt;

&lt;p&gt;Já tínhamos o tipo &lt;code&gt;object&lt;/code&gt; e ninguém solicitou pela sua descontinuidade, &lt;a href=&quot;http://blog.synopse.info/post/2010/08/06/Save-object%2C-stop-class-hegemony%21&quot;&gt;por quê não mantê-lo&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;E para aqueles que não conhecem a sintaxe do seu uso, aqui está um simples exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TMsg = object
    procedure Show(const aText: string);
  end;
{...}
var
  msg: TMsg;
begin
  msg.Show;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simples, direto, sem &lt;code&gt;try..finally&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Felizmente o tipo &lt;code&gt;object&lt;/code&gt; continua vivo no Free Pascal.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Mar 2019 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/tipo-object-vivo</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/tipo-object-vivo</guid>
      </item>
    
      <item>
        <title>Array de Objetos</title>
        <description>&lt;p&gt;Quando você precisa de uma simples lista de objetos, qual estrutura você utiliza?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/antonio-garcia-339626-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Antonio Garcia on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Todo sistema utiliza listas para armazenar desde valores primitivos até instancias de objetos.&lt;/p&gt;

&lt;p&gt;Aqui eu sempre advoguei sobre utilizar objetos em (quase) todos os lugares. Mas temos que ser eficientes e não desperdiçar recursos. Não devemos criar estruturas mais complexas, como classes e interfaces, quando outra estrutura pode resolver o problema, além de simplificar a solução.&lt;/p&gt;

&lt;p&gt;Basicamente uma lista pode ser representada por um array, um &lt;a href=&quot;/listas-genericas-sem-generics&quot;&gt;objeto genérico&lt;/a&gt; (ex: &lt;code&gt;TList&lt;/code&gt;) ou um objeto especializado que possui regras de negócio que irão trabalhar com os elementos de acordo com requisitos &lt;em&gt;específicos&lt;/em&gt; do usuário.&lt;/p&gt;

&lt;p&gt;Se você não precisa de uma lista com &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#regras-de-negocio&quot;&gt;regras de negócio&lt;/a&gt;, arrays podem ser um boa escolha.&lt;/p&gt;

&lt;h2 id=&quot;vs&quot;&gt;Array vs Lista&lt;/h2&gt;

&lt;p&gt;Poderíamos utilizar lista de objetos em todos os lugares, mas os arrays continuam relevantes.&lt;/p&gt;

&lt;p&gt;Arrays armazenam informações no &lt;em&gt;stack&lt;/em&gt;, enquanto Listas utilizam o &lt;em&gt;heap&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A utilização do stack tem muito mais performance pois o acesso a esse tipo de memória é muito mais rápido. A alocação da memória é determinada já na compilação do programa, tornando fácil o seu gerenciamento.&lt;/p&gt;

&lt;p&gt;O stack é protegido e mais rápido, pois é mais fácil para o compilador alocar/desalocar memória lá. Entretanto, ele é mais limitado quanto ao espaço, comparado ao heap. O heap é “ilimitado” (pode ocupar toda a memória RAM), porém mais lento. Sendo o heap compartilhado por toda a aplicação, é mais difícil/custoso para o compilador alocar/desalocar a memória. E, sendo esses dados “globais” à aplicação, eles muitas vezes devem ser sincronizados quando os acessamos utilizando multi-threading.&lt;/p&gt;

&lt;p&gt;Então, como escolher entre eles?&lt;/p&gt;

&lt;p&gt;Podemos definir 3 tópicos básicos que você deverá levar em conta, quando for tomar sua decisão: Performance, Regras de Negócio e Transferência de Dados.&lt;/p&gt;

&lt;h3 id=&quot;performance&quot;&gt;Performance&lt;/h3&gt;

&lt;p&gt;Você usa o stack quando souber a quantidade de dados à alocar na memória já em tempo de compilação. No entanto, não deve ser uma massa muito grande de dados—mesmo havendo configurações/diretivas em cada compilador para customização—ou você poderá obter um erro de memória em tempo de execução.&lt;/p&gt;

&lt;p&gt;O heap é utilizado quando você não souber, exatamente, quantos dados irá precisar em tempo de execução ou se houver a tendência de que será uma massa muito grande de dados.&lt;/p&gt;

&lt;p&gt;O stack sempre será mais rápido que o heap. Então, se você necessitar da máxima performance, tenha isso em mente quando tiver instanciando novas listas de objetos.&lt;/p&gt;

&lt;h3 id=&quot;regras&quot;&gt;Regras de Negócio&lt;/h3&gt;

&lt;p&gt;Imagine um sistema de estacionamento de veículos. Se você tem uma classe que representa o estacionamento, então você tem uma lista especializada para armazenar as vagas e carros ou ao menos uma lista genérica dentro da classe especializada.&lt;/p&gt;

&lt;p&gt;Você teria regras de negócios referente ao estacionamento como: horário de entrada/saída, número da vagas, serviço de manobrista, etc. Não vem ao caso pensar em todas as regras de negócio de um estacionamento. O mais importante é sabermos que &lt;em&gt;haveria&lt;/em&gt; regras de negócio para essa &lt;em&gt;lista especializada&lt;/em&gt;, o estacionamento.&lt;/p&gt;

&lt;p&gt;Apesar da maioria dos estacionamentos terem um número limitado de vagas, virtualmente pode-se adicionar mais carros em “vagas não-oficiais”, deixando um total de vagas “em aberto”—se isso não acontece na sua cidade/país, bem, apenas considere a possibilidade.&lt;/p&gt;

&lt;p&gt;Se o número de vagas é bem grande ou incerto, a melhor opção de escolha nesse caso seria uma lista especializada, alocada no heap, com outros métodos adicionais que implementam as regras de negócio.&lt;/p&gt;

&lt;h3 id=&quot;transferencia&quot;&gt;Transferência de Dados&lt;/h3&gt;

&lt;p&gt;Se sua lista existe apenas para armazenar temporariamente objetos ou para passagem de parâmetro entre contextos, por exemplo, um simples array poderia ser utilizado.&lt;/p&gt;

&lt;p&gt;Chamo de transferência de &lt;a href=&quot;/posts/pensando-em-dados/&quot;&gt;dados&lt;/a&gt;, pois você poderá transferir desde elementos simples e primitivos até objetos complexos de listas especializadas, entre contextos distintos. Esse seria o meio-termo entre performance vs especialização. Você pode ter listas de objetos, carregando instâncias de objetos complexos, mas utilizar os arrays para transportar apenas parte desses objetos de forma eficiente.&lt;/p&gt;

&lt;p&gt;Exemplo. A sua lista de vagas acima, o estacionamento, possui um número X de vagas em uso em um determinado momento. Cada vaga pode ser representada por uma instância. Imagine que o usuário selecionou 3 vagas para “deixar livre”. Após a seleção, é necessário fazer algumas operações com essas instâncias (vagas). Essas operações irão receber um “array de vagas” como parâmetro.&lt;/p&gt;

&lt;p&gt;O array seria utilizado por quê você já sabe a quantidade de elementos que ele iria ter—determinado pela seleção do usuário. Criar uma nova lista de vagas (do tipo estacionamento) para adicionar apenas 3 instâncias e então passar como parâmetro seria um desperdício de processamento, além de não fazer muito sentido passar “todo um estacionamento”—uma instância da mesma classe—ou uma cópia da lista oficial com menos registros, apenas para fazer o processamento da liberação das vagas.&lt;/p&gt;

&lt;p&gt;Um array seria a escolha mais simples. No entanto, não há só um tipo de array.&lt;/p&gt;

&lt;h2 id=&quot;utilizando&quot;&gt;Utilizando Arrays Dinâmicos&lt;/h2&gt;

&lt;p&gt;Existem alguns tipos de arrays como estáticos, constantes, dinâmicos, multi-dimensionais, etc.&lt;/p&gt;

&lt;p&gt;Para esse artigo, iremos utilizar os &lt;em&gt;arrays dinâmicos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Utilizar arrays dinâmicos no Object Pascal é relativamente fácil, porém temos que prestar atenção em duas regras principais:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;O índice do primeiro elemento sempre será 0 (zero);&lt;/li&gt;
  &lt;li&gt;É necessário determinar o tamanho do array antes de inserir seus elementos;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;O índice&lt;/strong&gt; do primeiro elemento sempre será zero, diferentemente de arrays contantes, por exemplo, onde você pode informar outro valor para o primeiro elemento. Tenha sempre isso em mente quando utilizar o array em loops.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O tamanho&lt;/strong&gt; de um array é determinado pela função &lt;code&gt;SetLength(array, size)&lt;/code&gt; padrão.&lt;/p&gt;

&lt;p&gt;Abaixo um exemplo do uso da função e a carga de um &lt;code&gt;array of Integer&lt;/code&gt; com valores:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  a: array of Integer;
begin
  SetLength(a, 10); // from 0 to 9 positions
  for i := 0 to 10 do
    a[i] := i;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Diferentemente de classes e interfaces, para definir um array para armazenar elementos de um determinado tipo, basta apenas uma linha de código, como visto acima.&lt;/p&gt;

&lt;p&gt;Foi definido um array para &lt;code&gt;Integer&lt;/code&gt;, mas a mesma sintaxe vale para tipos de classes ou interfaces. Se estivermos trabalhando com Vagas—instâncias da interface &lt;code&gt;ISpot&lt;/code&gt;, por exemplo—poderíamos definir um array dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TSpotArray = array of ISpot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Não precisamos nos preocupar com herança, métodos ou sobrescrita de métodos, caso estivéssemos definindo uma nova classe.&lt;/p&gt;

&lt;p&gt;Apenas uma única linha define um novo &lt;em&gt;container&lt;/em&gt; dinâmico de instâncias de &lt;code&gt;ISpot&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Utilizando uma variação do algoritmo acima, você é capaz de inicializar o array e adicionar os 3 itens que o usuário selecionou, passando-o como um parâmetro para o algoritmo que irá desalocar as vagas.&lt;/p&gt;

&lt;p&gt;Não há necessidade de se preocupar com o desalocamento de memória, pois tudo será feito automaticamente pelo compilador.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Arrays são ótimas opções para trabalhar com objetos em memória e passagem de dados entre contextos.&lt;/p&gt;

&lt;p&gt;Eles são &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, gerenciados pelo compilador no stack e muito mais rápidos que listas de objetos.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Mar 2019 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/array-de-objetos</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/array-de-objetos</guid>
      </item>
    
      <item>
        <title>Variáveis Locais Deveriam ter Nomes Curtos</title>
        <description>&lt;p&gt;Já pensou que você pode estar dificultando a leitura do seu código por utilizar nomes mais longos e verbosos em variáveis locais do que utilizando nomes mais curtos?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2019/chuttersnap-413007-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by chuttersnap on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/&quot;&gt;Nomenclatura&lt;/a&gt; é quase uma arte, especialmente no desenvolvimento de software.&lt;/p&gt;

&lt;p&gt;Escolher bons nomes irá deixar seu código mais legível e isso será imprescindível para a manutenção do mesmo no longo prazo.&lt;/p&gt;

&lt;p&gt;Entretanto, um bom nome não quer dizer um nome mais longo e verboso.&lt;/p&gt;

&lt;p&gt;Um bom nome irá depender de alguns fatores. Por exemplo: se o nome identificar uma variável de &lt;em&gt;índice&lt;/em&gt; para um &lt;em&gt;loop&lt;/em&gt;, a maioria dos programadores irá utilizar “i”.&lt;/p&gt;

&lt;p&gt;Por quê “i” e não “index”, já que este último é mais explícito?&lt;/p&gt;

&lt;p&gt;É claro que haverá todo tipo e código, todo tipo de nomenclatura. Mas, me refiro a maioria. E a maioria utiliza “i” para a nomenclatura de variáveis de índices.&lt;/p&gt;

&lt;p&gt;E se quisermos nos referir a uma posição na tela? Eu diria que a nomenclatura mais utiliza é “x,y”. Podemos declarar um &lt;em&gt;record&lt;/em&gt; ou classe como &lt;code&gt;TPoint&lt;/code&gt; mas é bem provável que seus atributos sejam &lt;code&gt;X&lt;/code&gt; e &lt;code&gt;Y&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;“Convenção” — você diria.&lt;/p&gt;

&lt;p&gt;Sim, convenção, porém eu acho que o motivo está além disso.&lt;/p&gt;

&lt;p&gt;Trata-se de &lt;strong&gt;legibilidade&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Quando estamos trabalhando em um contexto bem menor, como a implementação de um método por exemplo, não precisamos de nomes longos e verbosos. Sabemos o que X e Y significam; sabemos que “i” é o índice de um loop; sabemos que “s1” e “s2” (provavelmente) significam &lt;em&gt;strings&lt;/em&gt; 1 e 2, respectivamente.&lt;/p&gt;

&lt;p&gt;Não me entenda mal. Não estou dizendo que &lt;em&gt;todas&lt;/em&gt; as variáveis locais devem ter apenas uma ou duas letras. Depende. E talvez não haja uma regra para determinar qual nomenclatura mais adequada, uma regra que abrange todos os casos possíveis. Mas podemos utilizar o bom senso.&lt;/p&gt;

&lt;p&gt;Sugiro que os nomes sejam os menores possíveis, porém sem haver &lt;em&gt;ambiguidades&lt;/em&gt;. Por exemplo: seria estranho haver duas variáveis assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  s1: string;      
  s2: TStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;São dois tipos completamente diferentes, porém utilizando a mesma nomenclatura. É ambíguo e confuso. Por quê &lt;code&gt;s2&lt;/code&gt; representa o &lt;code&gt;TStream&lt;/code&gt; e não &lt;code&gt;s1&lt;/code&gt;? Falta lógica.&lt;/p&gt;

&lt;p&gt;Porém ainda assim, na minha opinião, ainda seriam melhores que isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  ClientNameTrimed: string;      
  ClientReturnedAsStream: TStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O motivo é simples: se você está nomeando suas variáveis de forma tão longa, é por quê o método está fazendo coisas demais e você precisa identificar cada variável — talvez existam &lt;a href=&quot;/posts/menos-e-mais/#variaveis-locais&quot;&gt;mais de cinco&lt;/a&gt; — como única para tentar melhorar a legibilidade do método, mas ignorando os indícios de que o método deveria ser refatorado (dividido) em partes menores. Métodos menores poderiam ter menos variáveis, com nomenclatura mais simples.&lt;/p&gt;

&lt;p&gt;Seguindo o primeiro exemplo, podemos refatorar as variáveis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  str: string;      
  stm: TStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apesar de ainda haver certa ambiguidade — &lt;code&gt;str&lt;/code&gt; ainda poderia ser considerada uma abreviação de &lt;code&gt;TStream&lt;/code&gt; — a legibilidade é melhor. Poderíamos simplificar, refatorando &lt;code&gt;str&lt;/code&gt; para apenas &lt;code&gt;s&lt;/code&gt; já que trata-se de um tipo primitivo, aplicando a lógica de que “tipos primitivos estão abaixo de classes” e, portanto, utilizam menos caracteres…&lt;/p&gt;

&lt;p&gt;O importante é haver alguma &lt;em&gt;lógica de nomenclatura&lt;/em&gt; entre a equipe.&lt;/p&gt;

&lt;p&gt;Outro exemplo de nomenclatura interessante é dar nomes próprios às variáveis, quando estas são do tipo interface ou classe. Vejamos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  bob: TStream;      
  john: TStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Temos 2 &lt;em&gt;streams&lt;/em&gt; e, ao invés de nomear como &lt;code&gt;stm1&lt;/code&gt; e &lt;code&gt;stm2&lt;/code&gt; ou algo parecido, apenas damos nomes próprios e curtos, de &lt;em&gt;fácil&lt;/em&gt; memorização.&lt;/p&gt;

&lt;p&gt;Uma vez que seu cérebro já sabe que &lt;code&gt;bob&lt;/code&gt; contém a entrada de dados (apenas um exemplo) e &lt;code&gt;john&lt;/code&gt; irá conter a saída processada, seria mais difícil esquecer dos nomes comparado a &lt;code&gt;stm1&lt;/code&gt; e &lt;code&gt;stm2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mantenha os nomes de variáveis locais o mais curto possível.&lt;/p&gt;

&lt;p&gt;Essa é a minha sugestão.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/variaveis-locais</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/variaveis-locais</guid>
      </item>
    
      <item>
        <title>Como Dividir e Organizar o Código em Formulários com Muitos Widgets</title>
        <description>&lt;p&gt;Definir dezenas de métodos em formulários e DataModules parece ser comum entre programadores. Podemos fazer algo para minimizar essa prática?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/robert-bye-200739-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Robert Bye on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Em um formulário com muitos widgets, haveria dezenas de métodos para controlá-los. Esses métodos lidariam com o estado visual (visível, checado, cores,…); com os dados (texto, grids, labels,…); mensagens (dialogs, popups,…) e todo tipo de interação entre os componentes visuais e não-visuais.&lt;/p&gt;

&lt;p&gt;Definir dezenas de métodos em formulários e DataModules parece ser comum. O programador cria um DataModule com queries e componentes relacionados, acrescenta 50 métodos e considera ter feito um ótimo trabalho na reutilização e organização do código — no entanto ele só criou mais uma classe inchada, seguindo o anti-padrão conhecido como a &lt;a href=&quot;http://wiki.c2.com/?GodClass&quot;&gt;síndrome da classe Deus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nesse artigo você poderá aprender algumas técnicas para se livrar dessas classes com dezenas de métodos, difíceis de entender e gerenciar.&lt;/p&gt;

&lt;h2 id=&quot;rad&quot;&gt;A culpa é do RAD?&lt;/h2&gt;

&lt;p&gt;Na minha opinião, Delphi sempre foi a melhor IDE para desenvolvimento de aplicações Desktop — até surgirem opções como Lazarus — e grande parte desse sucesso é devido ao conceito e uso do RAD (Rapid Application Development).&lt;/p&gt;

&lt;p&gt;Largue um componente no formulário, defina algumas propriedades, implemente alguns eventos e pronto. Fácil. Rápido. Mas talvez, sujo.&lt;/p&gt;

&lt;p&gt;Para prototipagem é ótimo. Você consegue mostrar ao cliente algo funcionando em minutos. Mas para código real, para a manutenção, esse tipo de design pode se tornar um pesadelo no médio prazo.&lt;/p&gt;

&lt;p&gt;Mas a culpa não é do RAD. Ele é apenas uma ferramenta. Ferramentas sozinhas não fazem mal projetos. Os desenvolvedores fazem.&lt;/p&gt;

&lt;p&gt;RAD foi feito para agilizar o desenvolvimento, especialmente no design de formulários. Mas levaram esse conceito tão longe que muitos desenvolvedores só conhecem esse caminho para o desenvolvimento, desde formulários, regras de negócio, até a persistência.&lt;/p&gt;

&lt;p&gt;RAD significou o sucesso mas também a “desgraça” do Delphi. É por causa do RAD que o Delphi (até hoje) não é bem visto em círculos de desenvolvimento mais voltados a regras de negócio, padrões de projetos, aplicações em camadas, etc.&lt;/p&gt;

&lt;p&gt;Mas, novamente, não é culpa do RAD. Não há nada de errado com RAD. O errado e tentar implementar tudo no modelo RAD, na minha opinião.&lt;/p&gt;

&lt;p&gt;É mais fácil largar componentes no formulário e setar propriedades e eventos, do que pensar em padrões de projeto, orientação a objetos e desenvolvimento em camadas.&lt;/p&gt;

&lt;p&gt;RAD funciona, mas não é sustentável no longo prazo.&lt;/p&gt;

&lt;h2 id=&quot;forms&quot;&gt;Formulários sem Métodos&lt;/h2&gt;

&lt;p&gt;O uso indiscriminado do RAD pode deixar a aplicação tão acoplada que seria muito difícil ter camadas separadas entre GUI, regras de negócio e persistência.&lt;/p&gt;

&lt;p&gt;Acredito que para remover o conceito de “RAD para tudo”, temos que começar com o básico, por exemplo, como desenvolver formulários com uma quantidade mínima de métodos.&lt;/p&gt;

&lt;p&gt;A quantidade de métodos não está relacionado diretamente ao RAD — você pode ter uma classe com 100 métodos em qualquer linguagem, utilizando RAD ou não — no entanto, eu acredito que o RAD “estimula” essa prática, pois se todos os widgets e eventos estão declarados no formulário, onde mais eu iria implementar os métodos para lidar com esses componentes, certo?&lt;/p&gt;

&lt;p&gt;Essa prática e muito comum, porém equivocada. Uma classe deveria ser pequena — menor quantidade de métodos possível — e coesa — todos os seus atributos são utilizados na maior quantidade de métodos possível. E fazer isso em um formulário e praticamente impossível.&lt;/p&gt;

&lt;p&gt;A tendência é que cada novo método trabalhe com poucos widgets; os métodos terão uma nomenclatura tão verbosa quanto uma frase, pois todos irão fazer parte de uma mesma classe e não pode haver ambiguidade ou colisão de nomes.&lt;/p&gt;

&lt;p&gt;Quantas vezes isso já aconteceu com você?&lt;/p&gt;

&lt;p&gt;Seria possível termos formulários com o &lt;a href=&quot;https://objectpascalprogramming.com/posts/menos-e-mais/#metodos&quot;&gt;mínimo de métodos&lt;/a&gt; ou até nenhum e, mesmo assim, capazes de controlar as interações entre todos os widgets e componentes visuais e não-visuais?&lt;/p&gt;

&lt;p&gt;A primeira prática que eu recomendo é separar widgets em frames — disponíveis no Delphi desde as primeiras versões através da classe &lt;code&gt;TFrame&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Muitos formulários possuem &lt;em&gt;tabs&lt;/em&gt; e cada tab pode ser um frame que desconhece completamente o formulário onde ele está contido.&lt;/p&gt;

&lt;p&gt;Cada frame irá ter seu próprio conjunto de widgets, com nomenclatura simplificada, visto que não há colisões de nomes entre outros widgets se tudo estivesse em um mesmo formulário.&lt;/p&gt;

&lt;p&gt;Esse é o &lt;em&gt;primeiro&lt;/em&gt; nível da refatoração.&lt;/p&gt;

&lt;p&gt;Mas isso não elimina a quantidade enorme de métodos que poderão existir, pois o desenvolvedor precisa por ação nos formulários e frames.&lt;/p&gt;

&lt;p&gt;O segundo nível consiste em dividir para conquistar, eliminando quase que totalmente os métodos de um formulário.&lt;/p&gt;

&lt;h2 id=&quot;dividir&quot;&gt;Dividir para Conquistar&lt;/h2&gt;

&lt;p&gt;Independente de ser um formulário, frame ou DataModule, considere todos como sendo &lt;a href=&quot;2016-02-22-datamodule-e-apenas-um-container&quot;&gt;containers&lt;/a&gt; de componentes (visuais ou não).&lt;/p&gt;

&lt;p&gt;O objetivo é dividir os métodos em pequenos objetos que irão fazer uso dos componentes do container.&lt;/p&gt;

&lt;p&gt;Mesmo que esse artigo se refira a formulários complexos, vou lhe dar um exemplo simples, mostrando que com apenas 1 widget, poderíamos adicionar vários métodos ao formulário, erroneamente.&lt;/p&gt;

&lt;p&gt;Considere uma instância de um &lt;code&gt;TStatusBar&lt;/code&gt; para exibir informações da aplicação.&lt;/p&gt;

&lt;p&gt;O usuário precisaria ver a versão da aplicação; o database em uso; o status atual de algum processamento.&lt;/p&gt;

&lt;p&gt;Um StatusBar possui a propriedade &lt;code&gt;Panels[]&lt;/code&gt;que é como um array de objetos de texto — dado um índice, você altera o texto naquela posição.&lt;/p&gt;

&lt;p&gt;Um programador iniciante talvez iria utilizá-lo dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;StatusBar1.Panels[0].Text := version;
StatusBar1.Panels[1].Text := database;
StatusBar1.Panels[2].Text := &#39;Loading...&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Um programador mais experiente saberia que não se deve utilizar índices arbitrários pelo código — se quisermos mudar a posição de alguma informação, teríamos que percorrer todo o código para mudar os índices para novas posições. Esse programador provavelmente iria criar constantes para cada índice, o que resolveria a manutenção futura, no entanto teríamos constantes (verbosas) no código que estão “desacopladas” do objeto no qual elas atuam, ou seja, o StatusBar.&lt;/p&gt;

&lt;p&gt;O código ficaria dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const
  STATUSBAR_VERSION = 0;
  STATUSBAR_DATABASE = 1;
  STATUSBAR_STATUS = 2;

StatusBar1.Panels[STATUSBAR_VERSION].Text := version;
StatusBar1.Panels[STATUSBAR_DATABASE].Text := database;
StatusBar1.Panels[STATUSBAR_STATUS].Text := &#39;Loading...&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja o quão é verboso cada constante, pois é (quase) obrigatório utilizar prefixos para deixar claro em qual componente(s) esse  “grupo de constantes” trabalham.&lt;/p&gt;

&lt;p&gt;Outro tipo de desenvolvedor iria utilizar métodos no formulário. O exemplo abaixo pode ser meio extremo, mas considere que eu não poderia dar um exemplo real pois não caberia nesse artigo. Portanto, utilizar tais métodos não estaria tão longe da realidade:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  procedure SetStatusBarVersion(const aValue: string);
  procedure SetStatusBarDatabase(const aValue: string);
  procedure SetStatusBarStatus(const aValue: string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Criando métodos no formulário elimina as constantes e índices, porém incha a classe do formulário.&lt;/p&gt;

&lt;p&gt;Veja, também, o quão é verboso cada método, novamente utilizando prefixos longos e entediantes — nomes longos em métodos e variáveis são sinais de que eles podem não fazer parte da classe onde estão.&lt;/p&gt;

&lt;p&gt;Foram adicionados 3 métodos para lidar com apenas 1 componente que exibe texto.&lt;/p&gt;

&lt;p&gt;Finalmente, um arquiteto de software teria objetivos maiores como: reutilizar os métodos em outro formulário ou projeto; simplificar o formulário, removendo métodos que lidam apenas com poucos componentes; retirar índices e constantes arbitrárias; trabalhar com o StatusBar sem pensar que ele é um StatusBar, abstraindo-o.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TStatusBarWidget = class
private
  fOrigin: TStatusBar;
  fVersion: string;
  fDatabase: string;
  fStatus: string;
public
  constructor Create(aOrigin: TStatusBar); reintroduce;
  property Version: string read fVersion;
  property Database: string read fDatabase;
  property Status: string read fStatus write fStatus;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essa classe iria receber a instância do StatusBar real no construtor, inicializada no construtor do formulário; iria obter os dados da versão e database automaticamente, disponibilizando propriedades somente leitura; o status poderia ser atualizado e lido dentro dos eventos do formulário.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
   fStatusBar.Status := &#39;Loading...&#39;;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toda a lógica referente ao StatusBar estaria encapsulada dentro da classe &lt;code&gt;TStatusBarWidget&lt;/code&gt;, podendo ser reutilizada em outro lugar.&lt;/p&gt;

&lt;p&gt;Outros programadores que porventura trabalhem no código, não iriam precisar lembrar de índices ou constantes arbitrárias. Eles iriam utilizar apenas um único objeto com métodos bem definidos para cada atividade, abstraindo sobre o que esta acontecendo internamente ao objeto — a atualização do StatusBar.&lt;/p&gt;

&lt;p&gt;O formulário não teria nenhum método (relacionado a StatusBar), contendo apenas um atributo privado do tipo &lt;code&gt;TStatusBarWidget&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O exemplo é simples, porém acredito que você tenha visualizado que poderá utilizar essa técnica não apenas para encapsular um componente, mas também para todo um conjunto deles, implementando toda a interação entre eles num único objeto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Toda vez que você nomear um método com nomenclatura composta, pare e pense se esse método deveria estar em outra classe.&lt;/p&gt;

&lt;p&gt;Não implemente vários métodos numa única classe. Separe-os em objetos menores e coesos, mesmo que esses objetos trabalhem diretamente com os componentes do container.&lt;/p&gt;

&lt;p&gt;É melhor ter vários objetos pequenos, mesmo que fortemente acoplados, do que por tudo num único objeto onde a manutenção irá se tornar um caos em pouco tempo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

&lt;h2 id=&quot;bnus&quot;&gt;Bônus&lt;/h2&gt;

&lt;p&gt;Eu fiz um Webinar sobre esse artigo.&lt;/p&gt;

&lt;p&gt;Você pode baixar os fontes &lt;a href=&quot;/code/webinar-2.zip&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Zvc8Vnv0JnI&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
</description>
        <pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/formularios-e-widgets</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/formularios-e-widgets</guid>
      </item>
    
      <item>
        <title>Pascal Deveria ser Modernizado?</title>
        <description>&lt;p&gt;Ao longo dos anos, desde Turbo Pascal até as versões mais atuais do Delphi e Lazarus, temos visto muitas mudanças na linguagem.&lt;/p&gt;

&lt;p&gt;Você acha que estamos modernizando a linguagem Object Pascal?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/hayes-potter-1054894-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Hayes Potter on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;É incrível como até hoje eu ainda tenho que responder perguntas sobre os motivos de continuar utilizando a linguagem Object Pascal.&lt;/p&gt;

&lt;p&gt;Vou desenvolver utilizando Object Pascal — eu digo a um possível cliente.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Object Pas… Ah, aquela linguagem da Apple? (Objective C)&lt;/li&gt;
  &lt;li&gt;Acho que você quer dizer Delphi, não é?&lt;/li&gt;
  &lt;li&gt;Por quê você continua utilizando “isso”?&lt;/li&gt;
  &lt;li&gt;Por quê não utilizar C# ou Java?&lt;/li&gt;
  &lt;li&gt;Você ainda consegue achar emprego?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Eu já escrevi meus &lt;a href=&quot;/porque-eu-escolhi-delphi-e-object-pascal#motivos&quot;&gt;motivos&lt;/a&gt; mas entendo como pode ser difícil para a maioria das pessoas acreditarem.&lt;/p&gt;

&lt;p&gt;Talvez eles pensem que Object Pascal não é tão &lt;a href=&quot;https://castle-engine.io/modern_pascal_introduction.html&quot;&gt;moderno&lt;/a&gt; quanto as linguagens &lt;em&gt;mainstream&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;prioridade&quot;&gt;Quando o Concorrente é Prioridade&lt;/h2&gt;

&lt;p&gt;Existem linguagens muito mais “modernas” hoje em dia e escolher uma que “está morta” não parece uma opção razoável &lt;del&gt;para aqueles que só sabem seguir cegamente o que a maioria diz&lt;/del&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Se você quer chegar onde a maioria não chega, faça o que a maioria não faz — Bill Gates&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Talvez esse sentimento de modernização está abalando até mesmo os diretores e desenvolvedores do atual Delphi.&lt;/p&gt;

&lt;p&gt;A “modernização” a que me refiro pode ser simplificada dessa forma:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Se meu concorrente tem tal feature, eu preciso ter também.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;E isso pode matar a linguagem.&lt;/p&gt;

&lt;h3 id=&quot;inline&quot;&gt;Inline Variable Declarations&lt;/h3&gt;

&lt;p&gt;A alguns dias recebemos a notícia que a linguagem Delphi irá ter &lt;em&gt;Inline Variables&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Marco Cantu — respeitado e conceituado no mundo Delphi — já começou a “matar” a sintaxe Pascal clássica de declaração de variáveis quando inicia seu &lt;a href=&quot;http://blog.marcocantu.com/blog/2018-october-inline-variables-delphi.html&quot;&gt;artigo&lt;/a&gt; escrevendo “Old Style Var Blocks”.&lt;/p&gt;

&lt;p&gt;Então é oficial, estamos &lt;em&gt;defasados&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Na linguagem Object Pascal, declaramos as variáveis em blocos bem definidos e organizados, diferentemente de outras linguagens onde pode-se declarar onde quiser. Entretanto, agora isso parece ser ruim, já que a maioria faz diferente.&lt;/p&gt;

&lt;p&gt;Solução? Ora, vamos copiar o concorrente!&lt;/p&gt;

&lt;p&gt;O foco parece ser mais no que o concorrente anda fazendo nos compiladores deles do que nos seus fieis usuários e desenvolvedores Pascal.&lt;/p&gt;

&lt;h3 id=&quot;inference&quot;&gt;Type Inference for Inline Variables&lt;/h3&gt;

&lt;p&gt;Na linguagem Pascal, tudo deve ser previamente declarado.&lt;/p&gt;

&lt;p&gt;Tudo.&lt;/p&gt;

&lt;p&gt;Isso é algo intrínseco a linguagem desde o seu nascimento e é um dos pontos fortes dela, pois minimiza qualquer ambiguidade na declaração de tipos.&lt;/p&gt;

&lt;p&gt;Tem quem goste, tem quem odeie. Não importa. Ela foi feita dessa forma e deve ser respeitada.&lt;/p&gt;

&lt;p&gt;Mas, agora temos a &lt;em&gt;inferência de tipo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Isso existe em outras linguagens mas é provável que você conheça através do C#.&lt;/p&gt;

&lt;p&gt;E as pessoas “aplaudiram”…&lt;/p&gt;

&lt;p&gt;Sim, pode ser considerada uma facilidade. Você irá escrever menos. E 99% dos programadores Object Pascal — especialmente Delphi — adoram uma facilidade sem se preocupar com o custo. Sim, o custo, por quê na engenharia nada vem de graça.&lt;/p&gt;

&lt;p&gt;A compilação pode ficar mais lenta; pode haver erros de conversão obscuros; o código pode ficar menos legível… além de ir contra a própria filosofia da linguagem, que é declarar tudo antes.&lt;/p&gt;

&lt;p&gt;Mesmo assim, se é fácil para escrever e o concorrente tem… por quê não?&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Não há problemas com a declaração de variáveis atual. Esse é o estilo Pascal. Entretanto, parecem que estão mais preocupados em adicionar mais features a linguagem do que corrigir &lt;em&gt;bugs&lt;/em&gt;. Bem, cada um sabe o que é melhor para sua empresa.&lt;/p&gt;

&lt;p&gt;Trabalho com sistemas de alta performance que ainda utilizam a sintaxe clássica do Delphi 7. Então, posso afirmar que não é isso que irá deixar a linguagem melhor que seus concorrentes.&lt;/p&gt;

&lt;p&gt;Não me entenda mal. Não estou dizendo que não podemos alterar a linguagem. Existem algumas features ou acertos que que seriam muito bem vindos como, por exemplo, a correção da sintaxe &lt;a href=&quot;/a-declaracao-with-do-perfeita&quot;&gt;WITH-DO&lt;/a&gt; ou uma nova sintaxe para para determinar um &lt;a href=&quot;/fpc-macros#alias&quot;&gt;alias para uma Unit&lt;/a&gt;. Esses seriam melhorias que iriam corrigir problemas no design da linguagem, melhorando a leitura do código e tudo de acordo com a filosofia e estilo Pascal.&lt;/p&gt;

&lt;p&gt;Não quero um &lt;a href=&quot;https://en.wikipedia.org/wiki/Frankenstein&quot;&gt;Frankenstein&lt;/a&gt; de várias linguagens. Quero um design limpo, &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e eficiente.&lt;/p&gt;

&lt;p&gt;Não quero copiar o concorrente. Quero escrever código Object Pascal.&lt;/p&gt;

&lt;p&gt;Não faz sentido levar seu BMW clássico ao mecânico dizendo para deixá-lo mais parecido com uma Mercedes-Benz mais moderna. Você acabará ficando com  &lt;em&gt;nenhum&lt;/em&gt; dos dois, apenas sucata.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/pascal-deveria-ser-modernizado</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/pascal-deveria-ser-modernizado</guid>
      </item>
    
      <item>
        <title>Records - Antiga Nova Tecnologia</title>
        <description>&lt;p&gt;O tipo Record pode ter métodos e até mesmo campos privados. Seria isso considerado uma abominação para um código Orientado a Objetos?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/alvaro-reyes-517391-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;br /&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Alvaro Reyes on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Na programação Orientada a Objetos, utilizamos objetos.&lt;/p&gt;

&lt;p&gt;Se você precisasse de um objeto para representar os &lt;em&gt;dados&lt;/em&gt; de um usuário, apenas login, password e nome, como seria a definição da classe?&lt;/p&gt;

&lt;p&gt;Vamos tentar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TUserData = class
private
  fLogin: string;
  fPassword: string;
  fName: string;
public
  property Login: string read fLogin write fLogin;
  property Password: string read fPassword write fPassword;
  property Name: string read fName write fName;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse seria um estilo de implementação que podemos ver em muitos sistemas que se dizem ser Orientados a Objetos.&lt;/p&gt;

&lt;p&gt;No entanto, essa classe irá gerar “objetos” que são mais conhecidos como DTO (Data Transfer Object) o que, por definição, é um conceito errado.&lt;/p&gt;

&lt;p&gt;Objetos não são &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/#objeto-nao-e-um-balde-de-funcoes-e-dados&quot;&gt;“baldes de dados”&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Objetos verdadeiros possuem comportamento e &lt;a href=&quot;/encapsulamento&quot;&gt;encapsulam&lt;/a&gt; dados e/ou outros objetos em seu interior. O que está encapsulado não deveria ser visível ou acessado diretamente por outro objeto externo.&lt;/p&gt;

&lt;p&gt;Essa é a &lt;em&gt;teoria&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas, e se no contexto do seu sistema você realmente não necessitasse de nenhum método para representar os dados de um usuário?&lt;/p&gt;

&lt;p&gt;Por muito tempo eu tenho utilizado objetos para tudo, até mesmo para representar dados, mas sem utilizar objetos anêmicos como esse, no entanto.&lt;/p&gt;

&lt;p&gt;Para representar os dados acima, eu utilizaria a técnica do &lt;a href=&quot;/posts/diga-me-algo-sobre-voce/#metodo-about&quot;&gt;Método About()&lt;/a&gt;, que iria retornar um XML ou JSON, conforme explicado em 2016…&lt;/p&gt;

&lt;p&gt;Há vantagens nessa técnica como ter uma única interface que qualquer classe possa implementar para retornar um XML/JSON. Mas também há desvantagens, como não haver checagem estática do compilador e o &lt;em&gt;overhead&lt;/em&gt; em “montar/desmontar” o &lt;em&gt;stream&lt;/em&gt; se houver a necessidade de repassar a informação por uma cadeia de objetos.&lt;/p&gt;

&lt;p&gt;Nesses ~2 anos, eu diria que muita coisa mudou.&lt;/p&gt;

&lt;p&gt;Estou trabalhando em alguns projetos que necessitam de extrema velocidade de processamento, mas nem por isso eles são menos Orientados a Objetos.&lt;/p&gt;

&lt;p&gt;Como?&lt;/p&gt;

&lt;p&gt;Redescobrindo o tipo Record.&lt;/p&gt;

&lt;p&gt;Mas antes eu quero lhe contar por quê eu neglicenciei os Records por muito tempo.&lt;/p&gt;

&lt;p&gt;Bem, Records existem desde o Turbo Pascal. Eles representam uma estrutura de dados. Você define uma estrutura e depois define &lt;em&gt;procedures&lt;/em&gt; e &lt;em&gt;functions&lt;/em&gt; para trabalhar com as estruturas — como ainda fazemos na linguagem C.&lt;/p&gt;

&lt;p&gt;Na Orientação a Objetos, nós unimos comportamento aos dados num único artefato chamado objeto.&lt;/p&gt;

&lt;p&gt;Então, a ideia de ter um Record com todos os seus dados públicos e funções “soltas” que o utilizam, implementadas muitas vezes em Unidades diferentes, me soa muito “anti-objeto”, muito anti-encapsulamento.&lt;/p&gt;

&lt;p&gt;Records, dessa forma, são estruturas para programas procedurais.&lt;/p&gt;

&lt;p&gt;Mas, já faz uns anos que os arquitetos da linguagem Object Pascal introduziram métodos em Records.&lt;/p&gt;

&lt;p&gt;Sim, métodos, em Records.&lt;/p&gt;

&lt;p&gt;Quando eu li isso pela primeira vez, achei que os arquitetos tinham ficado loucos. Métodos em Records? Qual o sentido? Já temos objetos, não precisamos de Records com métodos. Isso não faz o menor sentido! — eu pensava.&lt;/p&gt;

&lt;p&gt;Entretanto, hoje em dia, Records podem ter métodos e eles podem ser até mesmo privados, assim como ter &lt;em&gt;fields&lt;/em&gt; privados!&lt;/p&gt;

&lt;p&gt;Ora, não é isso um objeto?&lt;/p&gt;

&lt;p&gt;Não.&lt;/p&gt;

&lt;p&gt;Então, não seria melhor utilizar um objeto?&lt;/p&gt;

&lt;p&gt;Depende.&lt;/p&gt;

&lt;p&gt;Records são estruturas de dados — mesmo que eles tenham métodos — e deveria ser utilizados como tal.&lt;/p&gt;

&lt;p&gt;Records são alocados automaticamente pelo compilador na área de memória &lt;em&gt;stack&lt;/em&gt;, ao invés da área de memória &lt;em&gt;heap&lt;/em&gt;, como fazem os objetos. Utilizar o &lt;em&gt;stack&lt;/em&gt; é mais rápido e mais simples para o compilador gerenciar a memória.&lt;/p&gt;

&lt;p&gt;Então, se você necessita representar &lt;em&gt;apenas&lt;/em&gt; dados, Record é a melhor opção.&lt;/p&gt;

&lt;p&gt;Records não podem utilizar herança e muito menos implementar uma interface, então não há polimorfismo — lembre-se, são apenas dados.&lt;/p&gt;

&lt;p&gt;Então, se você necessita de polimorfismo e comportamento, objeto é a melhor opção.&lt;/p&gt;

&lt;p&gt;Dito isso, por quê métodos em Records pode mudar a maneira em como utilizamos Records em programas Orientados a Objetos?&lt;/p&gt;

&lt;p&gt;Quando declaramos um Record, seus campos não são inicializados, como acontece com os atributos de um objeto. Então, podemos definir um método para iniciá-lo, sem ter que fazer isso externamente — mesmo que seus campos sejam públicos — encapsulando a inicialização dos campos na própria estrutura de dados:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TUserData = record
  login: string;
  password: string;
  name: string;
  procedure Init;
end;

procedure TUserData.Init;
begin
  login := &#39;&#39;;
  password := &#39;&#39;;
  name := &#39;&#39;;
end;

var
  u: TUserData;
begin
  u.Init;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outra opção é utilizar a função &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/default.html&quot;&gt;Default()&lt;/a&gt; mas o importante é que você tem a opção de fazer o que quiser no procedimento que será como um construtor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TUserData.Init;
begin
  Default(self);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se o &lt;em&gt;password&lt;/em&gt; precisar ser criptografado/descriptografado, você não precisa de funções externas para isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TUserData.EncryptedPassword: string;
begin
  result := &#39;&amp;lt;using some algorithm to encrypt&amp;gt;&#39;;
end;

function TUserData.DecryptedPassword: string;
begin
  result := &#39;&amp;lt;using some algorithm to decrypt&amp;gt;&#39;;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Existem algumas regras a seguir:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Não implemente métodos que se comportem como objetos, ou seja, trabalhe &lt;em&gt;apenas&lt;/em&gt; com os dados do Record, transformando-os;&lt;/li&gt;
  &lt;li&gt;Não retorne instâncias de objetos em seus métodos, com exceção de instâncias de interfaces, mas evite a todo custo;&lt;/li&gt;
  &lt;li&gt;Só utilize campos com tipos primitivos ou gerenciados (ex: strings, Variant, etc), nunca instâncias de objetos;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Faça isso e você estará seguro.&lt;/p&gt;

&lt;p&gt;Seu código não será considerado menos Orientado a Objetos por estar utilizando estruturas de dados que representam dados. Records foram criados exatamente para isso e a implementação de métodos apenas facilitaram seu uso.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Oct 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/records-antiga-nova-tecnologia</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/records-antiga-nova-tecnologia</guid>
      </item>
    
      <item>
        <title>Builder Classes Simplificado</title>
        <description>&lt;p&gt;O padrão Builder utiliza no mínimo 2 classes: 1 classe para instância a ser construída e 1 classe para a instância construtora.&lt;/p&gt;

&lt;p&gt;Nesse artigo irei utilizar um Builder simplificado, que irá utilizar a mesma classe tanto para construir como para representar a instância final.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/christopher-burns-360244-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Christopher Burns on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;O padrão &lt;a href=&quot;https://en.wikipedia.org/wiki/Builder_pattern&quot;&gt;Builder&lt;/a&gt; já é muito conhecido e utilizado mundo afora.&lt;/p&gt;

&lt;p&gt;Esse artigo não tem a pretensão de ensiná-lo para que serve esse padrão — há milhares de artigos sobre isso na Internet, com implementação em várias linguagens diferentes.&lt;/p&gt;

&lt;p&gt;No entanto, um bom resumo é encontrado na Wikipedia:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Separar a construção de um objeto complexo da sua representação de modo que o mesmo processo de construção possa criar diferentes representações.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Como podemos ver nos exemplos em C# da Wikipedia, foi utilizado uma classe &lt;code&gt;Car&lt;/code&gt; e uma interface &lt;code&gt;ICarBuilder&lt;/code&gt;. Depois, temos uma implementação dessa interface com a definição da classe &lt;code&gt;FerrariBuilder&lt;/code&gt; e, finalmente, outra classe para customizar a Ferrari chamada &lt;code&gt;SportsCarBuildDirector&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Podemos simplificar esse exemplo?&lt;/p&gt;

&lt;p&gt;Primeiramente, &lt;code&gt;Car&lt;/code&gt; poderia ser uma interface &lt;code&gt;ICar&lt;/code&gt; e não uma classe. Então, poderíamos ter a classe &lt;code&gt;TFerrari&lt;/code&gt; que implementa &lt;code&gt;ICar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Na minha opinião, o único &lt;code&gt;Builder&lt;/code&gt; do exemplo é a classe &lt;code&gt;TSportsCarBuildDirector&lt;/code&gt; que customiza uma Ferrari para diretores. No entanto, eu também não concordo com sua existência e acho que podemos simplificar ainda mais esse exemplo — veja mais abaixo.&lt;/p&gt;

&lt;p&gt;Vamos começar pela primeira interface, mantendo-a &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, retornando tipos primitivos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ICar = interface
  function Model: string;
  function NumDoors: Integer;
  function Color: TColor;
  procedure Run;
end;      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depois, codificamos a classe &lt;code&gt;TFerrari&lt;/code&gt;, que implementa &lt;code&gt;ICar&lt;/code&gt;. Veja que essa classe não é um Builder, mas sim apenas uma classe comum.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TFerrari = class(TInterfacedObject, ICar)
private
  fModel: string;
  fNumDoors: Integer;
  fColor: TColor;
public
  constructor Create(const aModel: string;
    aNumDoors: Integer; aColor: TColor);
  function Model: string;
  function NumDoors: Integer;
  function Color: TColor;
  procedure Run;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como disse acima, não acho necessidade de haver um &lt;code&gt;Builder&lt;/code&gt; chamado &lt;code&gt;TSportsCarBuildDirector&lt;/code&gt;. Para implementar essa classe seria necessário implementar uma nova interface &lt;code&gt;ICarBuilder&lt;/code&gt; além da própria classe, o que seria desnecessário.&lt;/p&gt;

&lt;p&gt;Podemos simplificar esse exemplo utilizando &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/&quot;&gt;herança&lt;/a&gt; dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TDirectorSportCar = class(TFerrari)
public
  constructor Create(aColor: TColor); reintroduce;
end;

constructor TDirectorSportCar.Create(aColor: TColor);
begin
  inherited Create(&#39;488 Spider&#39;, 2, aColor);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Acabamos de criar um Builder mas utilizando a própria classe que irá representar um &lt;code&gt;ICar&lt;/code&gt;, ou seja, a &lt;code&gt;TDirectorSportCar&lt;/code&gt;. Não precisamos de mais uma interface abstrata como &lt;code&gt;ICarBuilder&lt;/code&gt; ou sua implementação.&lt;/p&gt;

&lt;p&gt;Para demonstrar o código, poderíamos ter algo assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure DoSomethingWithCars;
var
  car: ICar;
begin
  car := TDirectorSportCar.Create(clRed);
  car.Run;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sem Builders (aparentes), sem o método “Construct”, sem o método “GetResult”, e utilizando objetos &lt;a href=&quot;/posts/objetos-imutaveis/&quot;&gt;imutáveis&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/builder-classes-simplificado</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/builder-classes-simplificado</guid>
      </item>
    
      <item>
        <title>Como Transformar uma Instância de Classe em Instância de Interface</title>
        <description>&lt;p&gt;E se a linguagem Object Pascal nos permitisse codificar uma instância de classe que se auto destrói quando não mais precisamos dela?&lt;/p&gt;

&lt;p&gt;É possível transformar uma instância de classe para se comportar como uma instância de interface?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/julie-north-720719-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Julie North on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Há alguns dias eu acompanhei alguns desenvolvedores solicitarem algumas “novas features” para o compilador Free Pascal..&lt;/p&gt;

&lt;p&gt;Uma dessas features é a possibilidade de fazer um &lt;em&gt;“auto free”&lt;/em&gt; de uma instância de classe. Sim, como no Java ou C#, onde um objeto do tipo de uma classe é liberado automaticamente quando a VM acha que deve fazê-lo.&lt;/p&gt;

&lt;p&gt;No entanto, devemos lembrar dos princípios da linguagem Object Pascal antes de solicitar tais mudanças. A linguagem Object Pascal não possui uma VM, portanto não temos um “robozinho” para ficar monitorando nossos objetos. Devemos liberar nossos objetos “manualmente” chamando &lt;code&gt;obj.Free&lt;/code&gt; na maioria dos casos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/simplicidade/&quot;&gt;Simples&lt;/a&gt; e eficiente.&lt;/p&gt;

&lt;p&gt;Mas eu posso entender o motivo de tal solicitação: É muito cômodo declarar objetos sem se preocupar em liberá-los da memória… e eu tenho feito isso há anos utilizando a “técnica” do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt; em conjunto com instâncias de interfaces.&lt;/p&gt;

&lt;p&gt;O tipo de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;interface&lt;/a&gt; é liberado automaticamente pelo compilador quando a variável sai do escopo. Mas isso não existe para instâncias de classe, proposto no pedido da nova feature.&lt;/p&gt;

&lt;p&gt;Então, se houvesse um jeito de liberar automaticamente as instâncias de classes, “convertendo-as” em instâncias de interfaces, sem utilizar nenhum tipo de &lt;a href=&quot;/posts/nao-utilize-casting/&quot;&gt;casting&lt;/a&gt;, teríamos a liberação automática sem que fosse necessária alterações no compilador.&lt;/p&gt;

&lt;p&gt;Bem, o que vou lhe apresentar agora pode já estar sendo utilizando por muitos desenvolvedores ao redor do mundo, e é algo tão simples que podemos até mesmo substituir o &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt; — tão difundido na comunidade brasileira e mundo afora — por essa simples “técnica” que mostrarei mais abaixo.&lt;/p&gt;

&lt;p&gt;Mas antes, o que há de errado com o &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Esse método foi criado com o intuito de implementar a liberação automática da instância, sem haver a necessidade de declarar uma variável local para incrementar a contagem de referência.&lt;/p&gt;

&lt;p&gt;Funciona.&lt;/p&gt;

&lt;p&gt;No entanto, há alguns problemas com essa abordagem.&lt;/p&gt;

&lt;p&gt;Primeiro, ele é um método estático da classe. Deveríamos &lt;del&gt;não utilizar&lt;/del&gt; evitar métodos de classe a todo custo, dando [preferência] em utilizar instâncias de interfaces, onde não existem métodos estáticos.&lt;/p&gt;

&lt;p&gt;Segundo, é redundante ter que codificar sempre os mesmos parâmetros da(s) mesma(s) assinatura do(s) construtor(es). Isso, além de ser no mínimo chato, é um pouco custoso para a manutenção pois (quase sempre) haverá 2 lugares para alterar os argumentos.&lt;/p&gt;

&lt;p&gt;Terceiro, o método não impede que um programador que não conheça a técnica, chame diretamente o construtor da classe, &lt;em&gt;by passing&lt;/em&gt; o método estático. Isso pode gerar &lt;em&gt;memory leaks&lt;/em&gt;, como já foi explicado em alguns outros artigos aqui do blog.&lt;/p&gt;

&lt;p&gt;Embora haja todos esses problemas, a utilização do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt; se mostrou eficiente, melhorando e simplificando a base de código em muitos projetos.&lt;/p&gt;

&lt;p&gt;Entretanto, a técnica a seguir traz todas as vantagens do &lt;code&gt;New&lt;/code&gt; porém sem as desvantagens.&lt;/p&gt;

&lt;p&gt;Você pode fazer essa “mágica” adicionando mais um método na classe.&lt;/p&gt;

&lt;p&gt;Eu o chamo de Método &lt;code&gt;Ref&lt;/code&gt;, que significa &lt;em&gt;reference for&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TFoo.Ref: ISomething;
begin
  result := self;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sim, é só isso.&lt;/p&gt;

&lt;p&gt;Um método que retorna &lt;code&gt;self&lt;/code&gt;, sendo o tipo do retorno a interface que a classe implementa.&lt;/p&gt;

&lt;p&gt;Diferentemente do &lt;code&gt;New&lt;/code&gt;, o método &lt;code&gt;Ref&lt;/code&gt; não é estático e não duplica a assinatura do(s) construtor(s), eliminando as primeiras duas desvantagens.&lt;/p&gt;

&lt;p&gt;Sim, há a possibilidade do desenvolvedor esquecer de utilizá-lo ao chamar o construtor da classe diretamente ao invés do &lt;code&gt;New&lt;/code&gt;e isso poderia ocasionar &lt;em&gt;memory leaks&lt;/em&gt;. Mas sua vantagem é que você tem a &lt;em&gt;opção&lt;/em&gt; em não utilizá-lo para aumentar a performance na criação dos objetos &lt;em&gt;by passing&lt;/em&gt; um método de classe (o método &lt;code&gt;New&lt;/code&gt;) antes de chegar ao construtor, ganhando, talvez, alguns milionésimos de segundos.&lt;/p&gt;

&lt;p&gt;Veja um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure DoIt;
begin
  TFoo.Create(TBar.Create).Ref.Execute;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se ambas as classes implementam interfaces, temos a possibilidade de não utilizar &lt;code&gt;Ref&lt;/code&gt; no argumento do construtor de &lt;code&gt;TFoo&lt;/code&gt;, chamando apenas o construtor de &lt;code&gt;TBar&lt;/code&gt;. Mas, somos “obrigados” a utilizar &lt;code&gt;Ref&lt;/code&gt; na chamada mais externa para executar algum método da interface que &lt;code&gt;TFoo&lt;/code&gt; implementa, afim de evitar &lt;em&gt;memory leaks&lt;/em&gt;, pois não há nenhuma variável (local) para receber a instância da interface.&lt;/p&gt;

&lt;p&gt;Agora você deve estar se perguntando, o que isso tem have com o título do artigo?&lt;/p&gt;

&lt;p&gt;Tudo.&lt;/p&gt;

&lt;p&gt;É padrão da linguagem que, ao trabalharmos com instâncias de interfaces, o compilador utilize um contador de referências para saber quando destruir um objeto, liberando a memória alocada.&lt;/p&gt;

&lt;p&gt;Então, se você criar um objeto do tipo de classe e depois utilizar o método &lt;code&gt;Ref&lt;/code&gt; ou apenas atribuir a instância a uma variável do tipo interface, você irá “transformar” sua instância de classe em instância de interface, ganhando a contagem de referência e a auto destruição do objeto… de graça.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo completo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program Project1;

{$mode delphi}

uses
  SysUtils,
  Classes;

type
  IFoo = interface
  [&#39;{1D26066C-984B-4632-95B2-B25253AF149E}&#39;]
    procedure ShowMsg;
  end;

type
  TFoo = class(TInterfacedObject, IFoo)
  private
    fText: string;
  public
    constructor Create(const aText: string);
    destructor Destroy; override;
    function Ref: IFoo;
    procedure ShowMsg;
  end;

{ TFoo }

constructor TFoo.Create(const aText: string);
begin
  inherited Create;
  fText := aText;
  writeln(&#39;Creating &#39;+ FRefCount.ToString);
end;

destructor TFoo.Destroy;
begin
  writeln(&#39;Destroing &#39; + FRefCount.ToString);
  inherited Destroy;
end;

function TFoo.Ref: IFoo;
begin
  result := self;
end;

procedure TFoo.ShowMsg;
begin
  writeln(fText);
end;

var
  f: TFoo; // class, not an interface
begin
  f := TFoo.Create(&#39;teste&#39;);
  f.Ref.ShowMsg;
  // f.Free; &amp;lt;&amp;lt; you don&#39;t need it
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute o código acima e verá que não existe nenhum &lt;em&gt;memory leak&lt;/em&gt;, mesmo &lt;code&gt;f&lt;/code&gt; sendo do tipo &lt;code&gt;TFoo&lt;/code&gt;, uma classe.&lt;/p&gt;

&lt;p&gt;A mágica acontece quando chamamos &lt;code&gt;Ref&lt;/code&gt;. Ele retorna um tipo de interface que é o próprio objeto &lt;code&gt;self&lt;/code&gt;. Assim, a “nova” instância passa a ter uma contagem de referência e será destruída automaticamente.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
Creating 1
teste
Destroing 0
Heap dump by heaptrc unit of c:\temp\project1.exe
76 memory blocks allocated : 1967/2120
76 memory blocks freed     : 1967/2120
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A linguagem Object Pascal pode parecer simples demais para alguns desenvolvedores (que não conhecem bem a linguagem).&lt;/p&gt;

&lt;p&gt;Alguns dizem que é “apenas uma linguagem para aprendizado” ou que não acompanhou as “novas features” das linguagens mais “modernas”.&lt;/p&gt;

&lt;p&gt;Me diga então, qual linguagem você conhece que nos dá a eficiência em poder liberar nossos objetos no melhor momento que quisermos, mas também ter objetos que se “auto destroem” e ainda conseguir fazer a transição de um tipo para o outro?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Aug 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/metodo-ref</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/metodo-ref</guid>
      </item>
    
  </channel>
</rss>
