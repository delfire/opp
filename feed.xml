<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Herança pode ser o Mal da Orientação a Objetos — Parte Final</title>
        <description>&lt;p&gt;No artigo anterior falei sobre Forte Acoplamento.
Nesse artigo irei falar sobre &lt;strong&gt;Hierarquias Complexas&lt;/strong&gt; e concluir a série.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1457473075527-b0db85c08e66.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-4/&quot;&gt;Clique aqui&lt;/a&gt; para ler a &lt;strong&gt;Parte #4&lt;/strong&gt; dessa série, caso ainda não tenha lido.&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A maioria dos desenvolvedores esqueceram ou nunca aprenderam que a Herança foi feita para proporcionar o Polimorfismo e não  para reutilizar código.&lt;/p&gt;

&lt;p&gt;O reuso de código é apenas um “efeito colateral” da Herança.&lt;/p&gt;

&lt;p&gt;Polimorfismo é importante e em linguagens como C++, por exemplo, a única maneira de implementarmos Polimorfismo é através da Herança de Classes.
A linguagem C++ não tem Interfaces, sendo Herança de Classe uma escolha correta.&lt;/p&gt;

&lt;p&gt;Arquitetos de linguagens de programação vem copiando as ideias de outras linguagens a muito tempo. Se uma linguagem nova for muito diferente das mais populares, corre o risco de nunca ter um público que as utilize. Então, por que não copiar caracteristicas de outras linguagens que já fazem sucesso?&lt;/p&gt;

&lt;p&gt;Se C++ tem Herança de Classes, porque não ter em Java, Ruby, Object Pascal… os programadores já estão acostumados, então vamos implementar essa característica também.&lt;/p&gt;

&lt;p&gt;Imagino que seja assim ao criar uma nova linguagem. Mas nem sempre. As linguagens funcionais são bem diferentes das imperativas. A Go Language, por exemplo, não é funcional mas também não implementa Herança — mas parece uma nova cópia da liguagem C, não?&lt;/p&gt;

&lt;p&gt;Então, cada nova linguagem deve ter alguma referência anterior para não ser completamente alienígena. Pra mim, esse é o maior motivo de ainda termos Herança de Classes nas novas linguagens.&lt;/p&gt;

&lt;p&gt;Se você programa em Object Pascal, no entanto, já tem o suporte a &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;, que é uma melhor opção para implementar Polimorfismo do que utilizar Herança de Classes.
Se podemos implementar o Polimorfismo através de Interfaces e reutilizar código através da Composição de Objetos e delegação, por que iríamos limitar nossas Classes a herdar de uma única hierarquia rígida de Classes?&lt;/p&gt;

&lt;p&gt;Não faz sentido.&lt;/p&gt;

&lt;p&gt;Por que uma Classe Gato deveria herdar de Animal, Mamífero ou quadrúpede se o sistema só precisa conhecer um Gato?
Essas implementações de Super Classes, muitas vezes, &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-3/#solucao&quot;&gt;nem existem&lt;/a&gt; no modelo de negócios.&lt;/p&gt;

&lt;h2 id=&quot;hierarquias-complexas&quot;&gt;Hierarquias Complexas&lt;/h2&gt;

&lt;p&gt;Eu defino Hierarquias Complexas todos os modelos de Classes que utilizam Herança e que contenham erros conceituais ou reais. E eu sempre encontro esses tipos de erros. Sempre. A não ser que seu modelo seja muito pequeno, ele também conterá esses erros. O motivo é simples. É quase impossível definir uma Hierarquia de Classes perfeita porque o mundo real, o qual modelamos utilizando Classes, não é estruturado.&lt;/p&gt;

&lt;p&gt;Isso mesmo, a natureza não é estruturada. Não disse que não ela não é perfeita. Estou dizendo que ela não é estruturada como Classes perfeitamente agrupadas numa Hierarquia bonita e elegante. Na minha opinião, a natureza é um caos.&lt;/p&gt;

&lt;p&gt;Na &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-3/#exemplo-1&quot;&gt;Parte #3&lt;/a&gt; dessa série eu apresentei um modelo de Classes do Mundo Animal.&lt;/p&gt;

&lt;p&gt;Aqui está o Diagrama:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Diagram02.png&quot; alt=&quot;Diagram1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A princípio, parece simples e correto. Todos os animais no modelo são Animais, obviamente, e todos eles Caminham. Bem, com exceção do Tubarão, pois ele não tem pernas mas… vamos ignorar isso. Imagine um &lt;code&gt;raise Exception.Create&lt;/code&gt; no método &lt;code&gt;Caminhar&lt;/code&gt; do Tubarão e vamos em frente.&lt;/p&gt;

&lt;p&gt;E se quisermos adicionar mais animais nessa Hierarquia? Talvez um Tigre.&lt;/p&gt;

&lt;p&gt;Você pode imaginar que um Tigre herde de Gato — ou seria o contrário? — e tudo irá continuar funcionando. Bonito e elegante.&lt;/p&gt;

&lt;p&gt;O mesmo para um Leão, Lobo, Urso… e então precisamos implementar um Ornitorrinco.&lt;/p&gt;

&lt;p&gt;O que é um Ornitorrinco?&lt;/p&gt;

&lt;blockquote&gt;
Com bico de ave, semelhante a pato, é um mamífero semiaquático natural da Austrália e Tasmânia. É o único representante vivo da família Ornithorhynchidae, e a única espécie do gênero Ornithorhynchus. Juntamente com as equidnas, formam o grupo dos monotremados, os únicos mamíferos ovíparos existentes. A espécie é monotípica, ou seja, não tem subespécies ou variedades reconhecidas.
  &lt;footer&gt;&lt;cite title=&quot;wikipedia&quot;&gt;— Wikipedia&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;

&lt;p&gt;É um mamífero, ovíparo, tem bico e nadadeiras e é uma mono espécie… se a natureza fosse estruturada, esse seria um dos seus &lt;em&gt;bugs&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Pense agora no peixe-voador…&lt;/p&gt;

&lt;p&gt;Brincadeira a parte, eu acredito que não, que não há nada de errado com o Ornitorrinco ou qualquer outro animal.&lt;/p&gt;

&lt;p&gt;Nosso Modelo de Classes, baseado em Herança, é que está errado.&lt;/p&gt;

&lt;p&gt;Imagine o modelo acima bem maior, com mais métodos e Subclasses. Para tentar colocar o Ornitorrinco na Hierarquia você teria que fazer uma refatoração possivelmente grande. Criar novas classes abastratas, mover métodos para Classes acima, outros para Classes abaixo, “desabilitar” alguns métodos utilizando &lt;code&gt;raise&lt;/code&gt; e seguir a vida.&lt;/p&gt;

&lt;p&gt;A Hierarquia iria ficar &lt;strong&gt;extremamente complexa&lt;/strong&gt;. Iriam existir Classes que só existiram para compartilhar código, e não porque o &lt;strong&gt;modelo de negócios&lt;/strong&gt; exige que existam.&lt;/p&gt;

&lt;p&gt;Sempre foi assim nos sistema que utilizam Herança, certo? Aquele &lt;em&gt;Form&lt;/em&gt; que tem um botão que não é necessário na Subclasse, basta setar um &lt;code&gt;Visible = False&lt;/code&gt; e tudo certo; um botão que faz algo a mais do que é preciso na nova Subclasse, basta “refatorar” o código dividindo em 2 métodos com nomes insípedos e fazer a chamada deles, sobrescrevendo o método original para chamar apenas uma parte do código; sobrescrever métodos da super Classe para “não fazer nada”; copiar código de outra hierarquia de Classes… uma verdadeira bagunça.&lt;/p&gt;

&lt;p&gt;Eu conheço esses problemas. Eu passei por muitos deles. E, acredite, em grande parte o motivo dos problemas sempre foram as Hierarquias Complexas que criamos sem pensar, quando estamos tentando “reaproveitar” código utilizando Herança.&lt;/p&gt;

&lt;p&gt;Na natureza, eu acredito, não há “reaproveitamento de código”, só composição.&lt;/p&gt;

&lt;p&gt;Átomos, elementos químicos. Alguns organismos tem mais disso, outros mais daquilo. Um animal tem 0,0003% desse elemento, mais 0,0006% de outro. A composição desses Objetos determinam o comportamento e a evolução de cada indivíduo.&lt;/p&gt;

&lt;p&gt;DNA.&lt;/p&gt;

&lt;p&gt;Lembre-se que &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-3/#solucao&quot;&gt;a árvore&lt;/a&gt; não existe. Tetrápodes, Bípedes, Mamíferos, Anfíbios, Aves… nada disso existe. São abstrações que nós criamos para organizar as coisas, mas elas &lt;strong&gt;não existem no mundo real&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Qualquer Hierarquia de Classes que tente implementar o mundo, terá falhas.&lt;/p&gt;

&lt;p&gt;Parece que os biólogos conseguem separar os indivíduos em “hierarquias perfeitas”. Eles observam os indivíduos na natureza e classificam. Se descobrem um animal que não se encaixa em nenhuma hierarquia não há problema, basta criar uma nova. Nenhum animal já classificado será afetado. Não há um “fio” que liga os animais às hierarquias. 
O indivíduo determina a hierarquia, ou seja, de baixo pra cima. As hierarquias são apenas nomes e classificações. Ontologia.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A ontologia não define o comportamento das amostras individuais.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nós, desenvolvedores de software, fazemos o inverso. Vamos codificando nossas hierarquias e tentando definir o comportamento dos objetos de cima pra baixo! É como se tentássemos prever o futuro da evolução de nossas Classes separando-as em hierarquias pré-definidas. É praticamente impossível dar certo.&lt;/p&gt;

&lt;h2 id=&quot;solucao&quot;&gt;Solução&lt;/h2&gt;

&lt;p&gt;A solução é a Composição de Objetos em conjunto com Interfaces. Já falei isso. Falei e repeti muitas vezes. Mas para quem ainda não entendeu, vou revelar mais uma dica através de uma pergunta:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Se seu sistema trabalha com Tigres, quantas Classes Tigre você teria?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A grande maioria, acredito, responderia &lt;strong&gt;apenas uma classe&lt;/strong&gt; &lt;code&gt;TTigre&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Concorda?&lt;/p&gt;

&lt;p&gt;A pergunta é capciosa.&lt;/p&gt;

&lt;p&gt;Esse é um dos problemas ao tentarmos modelar sistemas Orientados a Objetos. O desenvolvedor acha que apenas uma Classe deve representar o conceito quando, na verdade, podemos ter &lt;strong&gt;diferentes Classes para representar o mesmo conceito em diferentes contextos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;As pessoas me perguntaram quais eram as soluções para os problemas apontados nessa série. Eu lhes disse, Composição de Objetos.&lt;/p&gt;

&lt;p&gt;Mas elas esperavam ler a solução definitiva: Quais classes criar; quais interfaces; usar ou não herança; em quais Classes por tais métodos.&lt;/p&gt;

&lt;p&gt;Não há uma única resposta, porque tudo irá depender do seu modelo de negócios. Uma vez que você saiba o modelo de negócios, deverá haver a definição de contextos — Bounded Context no DDD — e assim você terá “N” &lt;a href=&quot;/posts/objetos-representam-entidades/#o-que-e-uma-entidade&quot;&gt;variações de um único conceito&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lembra do &lt;code&gt;TTigre&lt;/code&gt;? Se nesse sistema hipotético você precisa analisar na tela a pata de um tigre, não haveria necessidade de instânciar um objeto da Classe &lt;code&gt;TTigre&lt;/code&gt; que contém tudo de um tigre (olhos, tipo, peso, tamanho, cor, que corre, nada, caça, etc). Não estou dizendo isso pensando em performance ou alocação de memória, não! Estou dizendo isso porque essa Classe seria enorme e complexa. Iria implementar muitas interfaces para poder Correr, Nadar, Pular… num sistema precisamos abstrair o que não é necessário. Esse é um dos motivos de não precisarmos de Hierarquias Complexas. Se você precisa examinar uma pata, então:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;IPaw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// function...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  
  &lt;span class=&quot;n&quot;&gt;TTigerPaw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TInterfacedObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IPaw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;public&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// function...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Assim como você poderá utilizar os Objetos da Classe &lt;code&gt;TTigerPaw&lt;/code&gt; para compor outras abstrações de Tigre em outros contextos.&lt;/p&gt;

&lt;p&gt;Sim, você terá muito mais definições de Classes. Mas isso já é previsto na Composição de Objetos. Fazer o certo dá mais trabalho, mas só no início.&lt;/p&gt;

&lt;h2 id=&quot;conclusao-final&quot;&gt;Conclusão Final&lt;/h2&gt;

&lt;p&gt;Chegamos ao final dessa série. Falei sobre como a Herança Viola o Encapsulamento, pode Duplicar o Código, promove Forte Acoplamento e
Hierarquias Complexas.&lt;/p&gt;

&lt;p&gt;Espero ter lhe ajudado a entender mais sobre Herança de Classes e os males que ela pode trazer ao código.&lt;/p&gt;

&lt;p&gt;O título dessa série é “Herança &lt;strong&gt;pode&lt;/strong&gt; ser o Mal da Orientação a Objetos”. Eu não falei que ela &lt;strong&gt;é&lt;/strong&gt;, disse que pode ser.
Eu lhe mostrei os problemas que vem com a Herança de Classes. Tenha conhecimento deles e evite-os.&lt;/p&gt;

&lt;p&gt;Herança de Classe pode ser benéfica em alguns (poucos) contextos. Mas ao usá-la uma vez, a tentação é grande em continuar utilizando. 
Não faça isso.&lt;/p&gt;

&lt;p&gt;Modele suas Classes utilizando Composição de Objetos que implementam Interfaces. Esse é o segredo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Jun 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-final/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-final/</guid>
      </item>
    
      <item>
        <title>Herança pode ser o Mal da Orientação a Objetos — Parte 4</title>
        <description>&lt;p&gt;No artigo anterior falei sobre Duplicação de Código.
Nesse artigo irei falar sobre o &lt;strong&gt;Forte Acoplamento&lt;/strong&gt; que ocorre ao utilizarmos a Herança de Classe.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1461287159820-04de78c094e9.jpg&quot; alt=&quot;Acoplamento&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-3/&quot;&gt;Clique aqui&lt;/a&gt; para ler a &lt;strong&gt;Parte #3&lt;/strong&gt; 
dessa série, caso ainda não tenha lido.&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Se um gato possui raça e patas, e um cachorro possui raça, patas e tipoDoPelo, logo Cachorro extends Gato?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;O texto acima é emprestado &lt;a href=&quot;http://blog.caelum.com.br/como-nao-aprender-orientacao-a-objetos-heranca/&quot;&gt;desse artigo&lt;/a&gt; que
fala sobre Herança e Hierarquia de Classes. O artigo fala sobre o erro de &lt;em&gt;design&lt;/em&gt; dos projetistas da linguagem Java quando
codificaram as Classes &lt;code&gt;Stack&lt;/code&gt; e &lt;code&gt;Properties&lt;/code&gt;. Não precisa conhecer Java para entender o artigo.&lt;/p&gt;

&lt;p&gt;No mesmo artigo ele mostra o erro &lt;strong&gt;grotesco&lt;/strong&gt; no &lt;em&gt;design&lt;/em&gt; da Classe &lt;code&gt;HttpServlet&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se você já utilizou Java e precisou extender essa Classe, deve ter reparado no mesmo problema citado no artigo.&lt;/p&gt;

&lt;p&gt;Na época da faculdade eu reparei nesse erro de &lt;em&gt;design&lt;/em&gt; mas, &lt;strong&gt;ignorei&lt;/strong&gt;. Achei que eu estava errado, que não tinha entendido a “maneira correta
de programar utilizando Orientação a Objetos com Java”. Eu não sabia muita coisa mesmo. Talvez
ainda não saiba… sempre que leio textos de outrem fico indignado o quanto ainda preciso aprender. Pois é.&lt;/p&gt;

&lt;p&gt;O fato é que o pensamento comum da maioria das pessoas é: Será que uma grande empresa, projetista do Java por exemplo, 
poderia estar errada?&lt;/p&gt;

&lt;p&gt;Sim as empresas erram, muito.&lt;/p&gt;

&lt;p&gt;Sim, elas também ganham muito dinheiro. Mas não é porque seus &lt;em&gt;softwares&lt;/em&gt; são perfeitos, mas sim porque elas se adaptam
rapidamente e dão aos seus clientes o que eles querem — ou o que está na moda; ou algo similar ao concorrente; ou talvez algo
“legal de se ter”.&lt;/p&gt;

&lt;p&gt;Por isso muitas empresas não se importam em descontinuar aplicativos e &lt;em&gt;frameworks&lt;/em&gt; se eles não dão lucro ou não estão mais em conformidade
com a visão de longo prazo delas — vide Microsoft — o que é perfeitamente normal. Elas precisam gerar lucro, certo?&lt;/p&gt;

&lt;p&gt;Então não pense que as empresas milionárias como a Microsoft, Sun/Oracle, Embarcadero e muitas outras, estão sempre certas “só” porque
elas são milionárias. Bem, elas estão corretíssimas sobre gerar lucro, mas nem sempre estão corretas sobre &lt;strong&gt;arquitetura e desenvolvimento&lt;/strong&gt;
de &lt;em&gt;softwares&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;forte-acoplamento&quot;&gt;Forte Acoplamento&lt;/h2&gt;

&lt;p&gt;O termo &lt;a href=&quot;https://en.wikipedia.org/wiki/Coupling_(computer_programming)&quot;&gt;Acoplamento&lt;/a&gt; é uma medida de quão duas rotinas, módulos ou 
Classes estão ligados &lt;strong&gt;intimamente&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  Em engenharia de software, acoplamento é a maneira e grau de interdependência entre módulos de software.
  &lt;footer&gt;&lt;cite title=&quot;Coupling&quot;&gt;Coupling - Wikipedia&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;

&lt;p&gt;Existem várias formas de acoplamento.&lt;/p&gt;

&lt;p&gt;O Forte Acoplamento entre Classes se dá quando uma Classe “conhece” uma outra diretamente. 
Por exemplo. Quando você inicializa um atributo de uma Classe utilizando uma Classe concreta, 
você está acoplando as Classes.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TCustomer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;inherited&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FAddress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;No exemplo acima existe um acoplamento entre &lt;code&gt;TCustomer&lt;/code&gt; e &lt;code&gt;TAddress&lt;/code&gt;. Conceitualmente isso é ruim. O mais correto seria utilizar
&lt;strong&gt;injeção de dependência&lt;/strong&gt; passando a instância de &lt;code&gt;TAddress&lt;/code&gt; através de um argumento do tipo Interface no construtor de &lt;code&gt;TCustomer&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TCustomer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;inherited&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FAddress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Devemos evitar o acoplamento. O motivo é simples. Toda vez que você alterar uma Classe que está acoplada a outra, haverá grandes
chances de você ter que alterar ambas.&lt;/p&gt;

&lt;p&gt;Se utilizar argumentos do tipo &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interface&lt;/a&gt; e injeção de dependência, 
o acoplamento será apenas de Interfaces.&lt;/p&gt;

&lt;p&gt;O exemplo acima não é sobre Herança, mas sobre &lt;strong&gt;Composição de Objetos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Apesar de ser ruim o acoplamento sem utilizar injeção de dependência, é possível refatorar essas Classes (se necessário) 
sem termos que alterar todas as Classes envolvidas.
Poderíamos começar a codificação de &lt;code&gt;TCustomer&lt;/code&gt; sem injetar &lt;code&gt;TAddress&lt;/code&gt; e, depois, resolver alterar o código para tornar &lt;code&gt;TCustomer&lt;/code&gt;
mais desacoplada.&lt;/p&gt;

&lt;p&gt;No entanto, se utilizássemos &lt;strong&gt;Herança de Classe&lt;/strong&gt;, a mesma refatoração poderia ser &lt;strong&gt;muito mais difícil&lt;/strong&gt;. 
Por exemplo. Se &lt;code&gt;TCustomer&lt;/code&gt; fosse uma Subclasse de &lt;code&gt;TPerson&lt;/code&gt; e essa Classe inicializasse &lt;code&gt;FAddress&lt;/code&gt; em seu construtor,
&lt;code&gt;TCustomer&lt;/code&gt; não poderia — ou não deveria — alterar a instância de &lt;code&gt;FAddress&lt;/code&gt;, reinicializando-a com um outro tipo de Classe.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;cm&quot;&gt;{ TPerson }&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TPerson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;inherited&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FAddress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;{ TCustomer }&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TCustomer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;inherited&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FAddress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TAnotherAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Nesse exemplo simples, existem alguns problemas.&lt;/p&gt;

&lt;p&gt;Primeiro, para que &lt;code&gt;TCustomer&lt;/code&gt; consiga alterar &lt;code&gt;FAddress&lt;/code&gt;, esta deve ter a visibilidade de &lt;code&gt;protected&lt;/code&gt;, o que é uma
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/&quot;&gt;Violação de Encapsulamento&lt;/a&gt;, pois
&lt;code&gt;TCustomer&lt;/code&gt; teria conhecimento interno sobre o estado de &lt;code&gt;TPerson&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Segundo, se &lt;code&gt;TCustomer&lt;/code&gt; tem acesso de alteração dos atributos herdados de &lt;code&gt;TPerson&lt;/code&gt;, esta mudança poderia causar inúmeros
problemas pois o comportamento de &lt;code&gt;TPerson&lt;/code&gt; poderia ser alterado ou invalidado para todos as outras Subclasse de &lt;code&gt;TPerson&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;E terceiro, se &lt;code&gt;FAddress&lt;/code&gt; não fosse &lt;code&gt;protected&lt;/code&gt; nenhuma opção estaria disponível.&lt;/p&gt;

&lt;h2 id=&quot;a-classe-tdataset&quot;&gt;A Classe TDataSet&lt;/h2&gt;

&lt;p&gt;Erros de &lt;em&gt;design&lt;/em&gt; de Classes não existem só na linguagem Java. No Delphi também temos erros. Um deles, na minha opinião, 
é a Classe &lt;code&gt;TDataSet&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Por simplicidade, talvez, alguém pensou em fazer uma Classe para manipulação de dados. É o famoso &lt;em&gt;data-ware&lt;/em&gt;. Componentes mostram
dados em &lt;em&gt;widgets&lt;/em&gt; (edits, grids, etc) obtendo esses dados de instâncias de Subclasses de &lt;code&gt;TDataSet&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Esse é um abuso clássico da Herança: Utilização da Herança para reaproveitar código.&lt;/p&gt;

&lt;p&gt;Bem, se a Herança fosse mesmo uma boa escolha, eu estaria utilizando Herança nas minhas Classes. Teria minha própria Hierarquia de 
Classes e Subclasses, certo?&lt;/p&gt;

&lt;p&gt;Então eu lhes pergunto: Onde &lt;code&gt;TDataSet&lt;/code&gt; faria sentido na minha Hierarquia de Classes? Provavelmente nenhum sentido.
No entanto eu sou &lt;strong&gt;obrigado&lt;/strong&gt; a herdar de &lt;code&gt;TDataSet&lt;/code&gt; se eu quiser exibir dados num &lt;code&gt;TDBGrid&lt;/code&gt;. Esse &lt;em&gt;design&lt;/em&gt; é muito errado.&lt;/p&gt;

&lt;p&gt;E qual seria o &lt;em&gt;design&lt;/em&gt; correto?&lt;/p&gt;

&lt;p&gt;Você já sabe.&lt;/p&gt;

&lt;p&gt;Todos os lugares que esperam uma instância de &lt;code&gt;TDataSet&lt;/code&gt; deveriam esperar uma Interface &lt;code&gt;IDataSet&lt;/code&gt;. Tão simples quanto
utilizar Herança, porém mais eficiente e desacoplado.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A utilização de Herança é a pior forma de acoplamento porque é mais difícil de corrigir e refatorar.&lt;/p&gt;

&lt;p&gt;Utilizar Herança é como usar concreto, após secar você não consegue mover mais nada.&lt;/p&gt;

&lt;h2 id=&quot;no-prximo-artigo&quot;&gt;No próximo artigo…&lt;/h2&gt;

&lt;p&gt;No próximo artigo irei falar sobre &lt;strong&gt;Hierarquias Complexas&lt;/strong&gt; entre Classes que utilizam Herança.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-final/&quot;&gt;Clique aqui&lt;/a&gt; para ler a &lt;strong&gt;Parte Final&lt;/strong&gt; dessa série.&lt;/p&gt;

&lt;p&gt;Caso você tenha alguma dúvida ou quiser compartilhar seus pensamentos sobre essa série, utilize a área 
abaixo para comentários.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-4/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-4/</guid>
      </item>
    
      <item>
        <title>Herança pode ser o Mal da Orientação a Objetos — Parte 3</title>
        <description>&lt;p&gt;No artigo anterior falei sobre Violação de Encapsulamento.
Nesse artigo irei falar sobre a &lt;strong&gt;Duplicação de Código&lt;/strong&gt; ao utilizarmos a Herança de Classe.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-90abc28jsj8383.jpg&quot; alt=&quot;Duplicação&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/&quot;&gt;Clique aqui&lt;/a&gt; para ler a &lt;strong&gt;Parte #2&lt;/strong&gt; 
dessa série, caso ainda não tenha lido.&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Duplicação de Código utilizando Herança. Essa afirmação pode parecer &lt;strong&gt;heresia&lt;/strong&gt; porque a maioria dos programadores
utilizam Herança de Classe justamente para &lt;strong&gt;não&lt;/strong&gt; duplicar o código.&lt;/p&gt;

&lt;p&gt;Em uma hierarquia de classes onde &lt;code&gt;B&lt;/code&gt; e &lt;code&gt;C&lt;/code&gt; herdam de &lt;code&gt;A&lt;/code&gt;, basta adicionar a nova funcionalidade em &lt;code&gt;A&lt;/code&gt; para termos 
disponível em &lt;code&gt;B&lt;/code&gt; e &lt;code&gt;C&lt;/code&gt;. Simples, rápido e sem duplicar código.&lt;/p&gt;

&lt;p&gt;Mas será esse o melhor &lt;em&gt;design&lt;/em&gt; para &lt;strong&gt;reaproveitar&lt;/strong&gt; e não duplicar código?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Herança de Classe é simples de usar e entender, mas no longo prazo é provado que essa não é a melhor escolha
ao projetar seu diagrama de Classes. Ao invés de Herança a melhor escolha é a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;Composição de Objetos&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Quando estamos começando um novo projeto — ou um novo módulo — sim, essa &lt;strong&gt;parece&lt;/strong&gt; ser ser a “melhor maneira”
para reaproveitar código.&lt;/p&gt;

&lt;p&gt;Parece.&lt;/p&gt;

&lt;p&gt;Com certeza a Herança é &lt;strong&gt;simples&lt;/strong&gt; e &lt;strong&gt;intuitiva&lt;/strong&gt; no entanto não é o melhor &lt;em&gt;design&lt;/em&gt; no médio e longo prazo.&lt;/p&gt;

&lt;p&gt;Herança de Classe leva a um código altamente acoplado e sem flexibilidade.&lt;/p&gt;

&lt;h2 id=&quot;duplicando-o-codigo&quot;&gt;Duplicando o código&lt;/h2&gt;

&lt;p&gt;Então, como é possível duplicar o código utilizando Herança?&lt;/p&gt;

&lt;p&gt;Utilizando &lt;strong&gt;Hierarquias de Classes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;É contra intuitivo pensar nisso, mas é verdade. Pense por um minuto. Se você tem um comportamento/funcionalidade
espalhado entre Classes e Subclasses dentro de uma Hierarquia, como &lt;strong&gt;reutilizar&lt;/strong&gt; esse código em outras Classes 
ou Hierarquias diferentes? Difícil.&lt;/p&gt;

&lt;p&gt;Não estou dizendo que é impossível. Estou dizendo que &lt;strong&gt;dificulta&lt;/strong&gt; muito a reutilização devido o comportamento não
ter sido codificado de maneira &lt;strong&gt;coesa&lt;/strong&gt;, utilizando &lt;strong&gt;Classes pequenas&lt;/strong&gt; com 
&lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/&quot;&gt;apenas uma responsabilidade&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Quando utilizamos Herança somos seduzidos pelo &lt;strong&gt;fácil reaproveitamento&lt;/strong&gt; do código e por isso vamos agregando mais e 
mais funcionalidades nas Classes e Subclasses, tornando-as “inchadas” e dificultando o reaproveitamento entre módulos
ou Projetos distintos.&lt;/p&gt;

&lt;p&gt;Na maioria das vezes exigirá uma refatoração massiva no código para haver reutilização, devido as Classes e Subclasses
estarem muito acopladas umas as outras.&lt;/p&gt;

&lt;p&gt;Esse é o motivo da &lt;strong&gt;Duplicação de Código&lt;/strong&gt;. É muito mais fácil e confortável — para a maioria dos programadores 
com prazos curtos e chefes estressados — duplicar o código do que refatorar, talvez, toda a Hierarquia.&lt;/p&gt;

&lt;h2 id=&quot;exemplo&quot;&gt;Exemplo&lt;/h2&gt;

&lt;p&gt;Vejamos agora um exemplo utilizando Diagramas de Classes.&lt;/p&gt;

&lt;p&gt;Antes eu gostaria de lembrá-lo que é fácil olhar um exemplo simples e pensar em inúmeras maneiras de fazê-lo melhor. 
Mas pense que esses são apenas exemplos para lhe mostrar o conceito e não a melhor maneira de implementar uma solução.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-1&quot;&gt;O Mundo Animal&lt;/h3&gt;

&lt;p&gt;Vou começar com o bom e velho “Exemplo de Animais”. O exemplo é antigo, sim, porém você ainda tem dúvidas sobre
utilizar ou não herança — senão não estaria lendo esse artigo — então acho que o exemplo continua sendo válido.&lt;/p&gt;

&lt;p&gt;Precisamos implementar um sistema que lida com Animais e resolvemos utilizar Herança de Classes para implementar
uma Hierarquia e “reutilizar o código”.&lt;/p&gt;

&lt;p&gt;Primeiramente o sistema só irá trabalhar com Cachorros e Gatos então temos o primeiro modelo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Diagram01.png&quot; alt=&quot;Diagram1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;No diagrama acima temos 3 Classes simples: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Cachorro&lt;/code&gt; e &lt;code&gt;Gato&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Apenas a Classe &lt;code&gt;Animal&lt;/code&gt; tem um método &lt;code&gt;Caminhar()&lt;/code&gt; que é herdado para as Classes &lt;code&gt;Cachorro&lt;/code&gt; e &lt;code&gt;Gato&lt;/code&gt;. Queremos 
reaproveitar o código então basta implementar na Classe mais acima da Hierarquia, ou seja, &lt;code&gt;Animal&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então vamos imaginar como seria a implementação do método &lt;code&gt;Caminhar()&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TAnimal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Caminhar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TAnimal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;bp&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MovePata1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MovePata2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MovePata3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MovePata4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Como estamos trabalhando, a princípio, com tetrápodes ou quadrúpedes, precisamos mover as 4 patas para caminhar.
Tudo funciona perfeitamente.&lt;/p&gt;

&lt;p&gt;Então precisamos acrescentar mais alguns animais: Pato, Tubarão, Sapo, Morcego e Crocodilo.&lt;/p&gt;

&lt;p&gt;Como somos espertos, vamos acrescentar mais abstrações para deixar o modelo mais “legal” e “sofisticado”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Diagram02.png&quot; alt=&quot;Diagram1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Um &lt;code&gt;Pato&lt;/code&gt; também caminha, no entanto ele caminha utilizando 2 membros. O &lt;code&gt;Sapo&lt;/code&gt; e &lt;code&gt;Crocodilo&lt;/code&gt; caminham com 4 patas, assim
como o &lt;code&gt;Cachorro&lt;/code&gt; e &lt;code&gt;Gato&lt;/code&gt;. O &lt;code&gt;Morcego&lt;/code&gt; tem pernas, mas ele realmente caminha? Não sei. O &lt;code&gt;Tubarão&lt;/code&gt;… complicou.&lt;/p&gt;

&lt;p&gt;Veja que pelo simples fato de termos acrescentado outros animais, &lt;strong&gt;toda a hierarquia deverá ser verificada&lt;/strong&gt; afim 
de saber se os métodos de Classes ancestrais continuam fazendo sentido para a nova hierarquia.&lt;/p&gt;

&lt;p&gt;O que fazer? Há inúmeras possibilidades. Algumas mais certas, outras mais erradas. Mas o que é que a &lt;strong&gt;maioria&lt;/strong&gt; 
dos programadores fazem — 
inclusive em &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#exemplo-3&quot;&gt;grandes empresas&lt;/a&gt; —
quando a hierarquia não reflete o mundo real?&lt;/p&gt;

&lt;p&gt;Eles sobrescrevem métodos, &lt;strong&gt;ignorando-os&lt;/strong&gt; (métodos em branco) ou &lt;strong&gt;lançando uma exceção&lt;/strong&gt; (métodos que existem, mas não devem ser
utilizados… WTF!).&lt;/p&gt;

&lt;p&gt;Nesse ponto emerge a Duplicação de Código.&lt;/p&gt;

&lt;p&gt;Como assim?&lt;/p&gt;

&lt;p&gt;Dependendo da quantidade de Classes numa hierarquia, duplicar a implementação será o método escolhido.
No caso do nosso exemplo o método &lt;code&gt;Caminhar()&lt;/code&gt; seria modificado para utilizar apenas
2 patas em algumas Classes. Em outras levantaríamos uma exceção naqueles Animais que não deveriam caminhar, como no caso da Classe &lt;code&gt;Tubarão&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mas isso é uma &lt;strong&gt;solução alternativa&lt;/strong&gt; que está longe de ser a ideal.&lt;/p&gt;

&lt;h2 id=&quot;solucao&quot;&gt;Solução&lt;/h2&gt;

&lt;p&gt;A Hierarquia está errada? Qual seria a implementação “certa”? Como reaproveitar o código sem usar Herança?&lt;/p&gt;

&lt;p&gt;Quando os cientistas separam os animais em “Classes”, eles fizeram-na baseado no que eles são (identidade) e não no que eles fazem (comportamento).&lt;/p&gt;

&lt;p&gt;Um pato nada, assim como um crocodilo. Mas o ato de nadar &lt;strong&gt;não pertence&lt;/strong&gt; ao pato nem ao crocodilo, pois nadar é um &lt;strong&gt;comportamento&lt;/strong&gt; “implementado” em vários outros Animais (Classes).&lt;/p&gt;

&lt;p&gt;Vou lhe contar como resolver o problema da implementação da Hierarquia Animal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Atenção&lt;/strong&gt;. Aqui está:&lt;/p&gt;

&lt;p&gt;Um Animal não caminha. Quem caminha é um Cachorro, Gato ou Pato. Animal é uma abstração, uma classificação, 
assim como Mamífero ou Anfíbio. Animal não existe.&lt;/p&gt;

&lt;p&gt;Tetrápodes, Bípedes, Mamíferos, Anfíbios, Aves, Peixes, Pássaros… &lt;strong&gt;eles não existem&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;Que?!&lt;/p&gt;

&lt;p&gt;É isso aí.&lt;/p&gt;

&lt;p&gt;Não entendeu? Aqui vai outro exemplo.&lt;/p&gt;

&lt;p&gt;Você já viu uma Árvore? Tenho certeza que não! Você viu, talvez, uma goiabeira, bananeira, macieira… Árvore é uma abstração, uma classificação. Árvore não existe.&lt;/p&gt;

&lt;p&gt;Se Mamíferos, Anfíbios, Aves, Peixes…e Árvores não existem, o que são?&lt;/p&gt;

&lt;p&gt;São apenas &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt; que definem uma classificação para algum comportamento.&lt;/p&gt;

&lt;p&gt;Então não há — ou não deveria haver — Hierarquia de Classes, apenas &lt;strong&gt;Hierarquias de Interfaces&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;Cientistas não tem problemas em classificar novas espécieis porque a inclusão na hierarquia existente não “quebra” nenhuma “funcionalidade”
nas “Classes” abaixo desta. São apenas Interfaces.&lt;/p&gt;

&lt;p&gt;Então, se não há Hierarquia de Classes, como reaproveitar código sem duplicar?&lt;/p&gt;

&lt;p&gt;Resposta: &lt;strong&gt;Composição de Objetos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Objetos tem comportamento, Interfaces não. Um cachorro é um Objeto; um pato é um Objeto; o ato de caminhar é um comportamento de 
“algum objeto” que os pássaros sabem utilizar… ou será que &lt;strong&gt;Alguém&lt;/strong&gt; “Duplicou o Código” em cada DNA porque era mais fácil de implementar? :)&lt;/p&gt;

&lt;h2 id=&quot;no-prximo-artigo&quot;&gt;No próximo artigo…&lt;/h2&gt;

&lt;p&gt;No próximo artigo irei falar sobre &lt;strong&gt;Forte Acoplamento&lt;/strong&gt; entre Classes que utilizam Herança.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-4/&quot;&gt;Clique aqui&lt;/a&gt; para ler a &lt;strong&gt;Parte #4&lt;/strong&gt; dessa série.&lt;/p&gt;

&lt;p&gt;Caso você tenha alguma dúvida ou quiser compartilhar seus pensamentos sobre essa série, utilize a área 
abaixo para comentários.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jun 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-3/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-3/</guid>
      </item>
    
      <item>
        <title>Herança pode ser o Mal da Orientação a Objetos — Parte 2</title>
        <description>&lt;p&gt;No artigo anterior citei alguns males ao utilizarmos Herança de Classe. Nesse artigo irei falar sobre
um deles, a &lt;strong&gt;Violação de Encapsulamento&lt;/strong&gt; ao utilizarmos Subclasses.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1456087468887-17b7d7b076e0.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;Clique aqui&lt;/a&gt; para ler a &lt;strong&gt;Parte #1&lt;/strong&gt; 
dessa série, caso ainda não tenha lido.&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Há muitos artigos na internet que falam sobre esse assunto, mas não encontrei nenhum que tenha apresentado esse conceito,
de forma satisfatória, para programadores &lt;em&gt;Object Pascal&lt;/em&gt; e, aqui estamos.&lt;/p&gt;

&lt;p&gt;Então, como um dos pilares da Orientação a Objetos, a Herança, pode se &lt;strong&gt;contrapor&lt;/strong&gt; a outro princípio, o &lt;strong&gt;Encapsulamento&lt;/strong&gt;?&lt;/p&gt;

&lt;blockquote&gt;
  ...a herança de classe permite definir a implementação de uma classe em termos da implemetação de outra.
  A reutilização por meio de sublcasses é frequentemente chamada de reutilização de caixa branca (ou aberta).
  O termo &quot;caixa branca&quot; se refere à visibilidade: com herança, os interiores das classes ancestrais são frequentemente
  visíveis para subclasses.
  &lt;footer&gt;&lt;cite title=&quot;Padrões de Projetos&quot;&gt;Padrões de Projetos, 2002 — p.34 — Erich Gamma e outros — ISBN 85-7307-610-0&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;

&lt;p&gt;O texto é claro.&lt;/p&gt;

&lt;p&gt;O autor escreveu que &lt;strong&gt;“…os interiores das classes ancestrais são frequentemente visíveis para subclasses”&lt;/strong&gt;.
Ele não escreveu, especificamente, que a Herança Viola o Encapsulamento mas você percebeu que é a mesma coisa?&lt;/p&gt;

&lt;p&gt;O interior de uma Classe não pode ser visível, mesmo para Subclasses, porque isso significaria &lt;strong&gt;violação de 
encapsulamento&lt;/strong&gt;. Ponto.&lt;/p&gt;

&lt;blockquote&gt;
  Porque a herança expõe para uma subclasse os detalhes da implementação dos seus ancestrais, frequentemente
   é dito que &quot;a herança viola a encapsulação&quot;[Sny86]
  &lt;footer&gt;&lt;cite title=&quot;Padrões de Projetos&quot;&gt;Padrões de Projetos, 2002 — p.34&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;

&lt;p&gt;Quando li isso a primeira vez, pouco tempo depois que comecei a codificar software “Orientado a Objetos” — eu achava
que estava utilizando Orientação a Objetos — tive o sentimento de &lt;strong&gt;negação&lt;/strong&gt; que você pode estar tendo agora:&lt;/p&gt;

&lt;p&gt;— “Ora, isso não faz o menor sentido!”&lt;/p&gt;

&lt;p&gt;Mas faz todo o sentido. Vou repetir: A Herança Viola o Encapsulamento.&lt;/p&gt;

&lt;p&gt;Isso é um &lt;strong&gt;fato lógico&lt;/strong&gt;. Pode não parecer lógico se é a primeira vez que você lê essa afirmação, mas você entenderá.&lt;/p&gt;

&lt;h2 id=&quot;encapsulamento&quot;&gt;Encapsulamento&lt;/h2&gt;

&lt;p&gt;Precisamos definir o que é Encapsulamento que, de acordo com o dicionário, significa:
&lt;strong&gt;colocar ou encerrar em cápsula; capsular&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Uma cápsula não pode — ou não deveria — ser quebrada. O mundo externo ao Objeto não pode saber o que há em seu
interior a menos que o Objeto queira lhes dizer “com suas próprias palavras”, ou seja, através de métodos que 
retornam informações mas não necessariamente seu &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/#objeto-nao-e-um-balde-de-funcoes-e-dados&quot;&gt;Estado&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O mundo externo só deve conhecer os métodos públicos de um Objeto. Seus métodos públicos representam sua
&lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interface&lt;/a&gt; para fazer o que ele deve fazer. Qualquer método ou
atributo interno ao Objeto é de propriedade dele e de mais ninguém.&lt;/p&gt;

&lt;p&gt;Um Objeto pode ter um único método em sua Interface
porém pode haver 10 outros métodos privados apenas para resolver um único problema. Mas o mundo externo não sabe e não deve
saber como o Objeto trabalha internamente.&lt;/p&gt;

&lt;p&gt;Um subtipo de Classe viola esse conceito.&lt;/p&gt;

&lt;h2 id=&quot;heranca-de-classe&quot;&gt;Herança de Classe&lt;/h2&gt;

&lt;p&gt;O motivo de termos Subclasses é &lt;strong&gt;acrescentar&lt;/strong&gt; mais funcionalidade às Classes ancestrais, criando um novo tipo.
Ao acrescentar funcionalidades a nova Subclasse deverá, inevitavelmente, interagir com o Estado e Métodos protegidos da 
Classe ancestral. Em outras palavras, a Subclasse deverá conhecer como a Classe ancestral trabalha (internamente) para
poder adicionar funcionalidade, o que é uma clara &lt;strong&gt;Violação de Encapsulamento&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  A implementação de uma Subclasse, dessa forma, torna-se tão amarrada à implementação da sua classe-mãe que qualquer mudança
  na implementação desta forçará uma mudança naquela.
  &lt;footer&gt;&lt;cite title=&quot;Padrões de Projetos&quot;&gt;Padrões de Projetos, 2002 — p.34&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;

&lt;p&gt;A Herança de Classe é simples de usar e entender, mas no longo prazo é provado que essa não é a melhor escolha
ao projetar seu diagrama de Classes. Ao invés de Herança a melhor escolha é a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;Composição de Objetos&lt;/a&gt;. Esse é um
dos princípios proposto no livro Padrões de Projetos:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Favoreça a composição de objetos em relação à herança de classe&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Foi o que fizeram os engenheiros do Google ao projetar a &lt;a href=&quot;https://golang.org/&quot;&gt;Go language&lt;/a&gt;. 
A linguagem &lt;a href=&quot;https://talks.golang.org/2012/splash.article#TOC_15&quot;&gt;não tem nenhuma forma&lt;/a&gt; de Herança de Classes,
ou seja, Herança baseada em subtipos. Não há hierarquia de tipos!&lt;/p&gt;

&lt;h2 id=&quot;me-mostre-o-codigo&quot;&gt;Me mostre o Código&lt;/h2&gt;

&lt;p&gt;A teoria foi explicada. Agora vou lhe mostrar alguns exemplos de código.&lt;/p&gt;

&lt;p&gt;Não posso colocar exemplos completos e reais senão o artigo iria virar um “repositório de código” e não um
artigo. Então veja os exemplos e imagine como seria no código real.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-1&quot;&gt;Exemplo 1 — &lt;em&gt;Stack Overflow&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;É um exemplo simples que poderia ser evitado pelo programador que fez a Classe A, a classe ancestral, 
no entanto veja que para descobrir o problema o programador da Classe B, a Subclasse, deve ver como a Classe A
foi implementada, Violando o Encapsulamento, pois ele deverá fazer ajustes em função da implementão interna da 
Classe A:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TClasseA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;protected&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;virtual&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;public&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;TClasseB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TClasseA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;protected&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;override&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;{ TClasseA }&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TClasseA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ShowMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Exec&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TClasseA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;{ TClasseB }&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TClasseB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;{ TForm1 }&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TForm1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Button1Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TClasseA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TClasseB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Proc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A Classe B sobrescreve um método da Classe A. Simples. Fazemos isso todo tempo.
Então, qual é o problema desse código?&lt;/p&gt;

&lt;p&gt;Se você copiar/colar o código na sua IDE e executar, verá uma mensagem de erro na segunda execução de &lt;code&gt;Proc&lt;/code&gt;.
Essa mensagem pode variar de IDE mas basicamente é um &lt;em&gt;Stack Overflow&lt;/em&gt;. Ao sobrescrever &lt;code&gt;Exec&lt;/code&gt; 
na Classe B, o programador chamou &lt;code&gt;Proc&lt;/code&gt; internamente. O problema é que na Classe A, &lt;code&gt;Proc&lt;/code&gt; já está chamando &lt;code&gt;Exec&lt;/code&gt; e,
dessa forma, o programa entra em um &lt;em&gt;loop&lt;/em&gt; infinito.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-2&quot;&gt;Exemplo 2 — Utilizar &lt;code&gt;inherited&lt;/code&gt; ou não?&lt;/h3&gt;

&lt;p&gt;Quando sobrescrevemos um método há a possibilidade de chamar o código do mesmo método da Classe ancestral. 
Para isso utilizamos a palavra reservada &lt;code&gt;inherited&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mas como saber se devo ou não chamar o código da Classe ancestral?&lt;/p&gt;

&lt;p&gt;Somente olhando a implementação privada da Classe para termos certeza se &lt;strong&gt;devemos ou não&lt;/strong&gt; chamar o código.
Novamente, temos uma Violação de Encapsulamento.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TClasseA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;protected&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;public&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;virtual&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;TClasseB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TClasseA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;public&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;override&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;{ TClasseA }&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TClasseA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ShowMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Count=&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;IntToStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=1&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ShowMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Exec A&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;{ TClasseB }&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TClasseB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;inherited&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ShowMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Count=&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;IntToStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//=2&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ShowMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Exec B&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;{ TForm1 }&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TForm1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Button1Click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TClasseB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Quando executado teremos as mensagens:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;“Count=1”&lt;/li&gt;
  &lt;li&gt;“Exec A”&lt;/li&gt;
  &lt;li&gt;“Count=2”&lt;/li&gt;
  &lt;li&gt;“Exec B”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nesse exemplo o programador utilizar &lt;code&gt;inherited&lt;/code&gt; porque ele sabe — olhando para a implementação de &lt;code&gt;TClasseA.Exec&lt;/code&gt; —
que a execução da Classe ancestral iria incrementar o atributo &lt;code&gt;FCount&lt;/code&gt; antes que ele fosse incrementado novamente no 
método sobrescrito.&lt;/p&gt;

&lt;p&gt;É um exemplo idiota, mas serve para o que eu quero lhe mostrar.&lt;/p&gt;

&lt;p&gt;Como eu disse, tente imaginar um código em produção, pensando quantas vezes você já teve que
ver o código da Classe ancestral (ou uma hierarquia de classes inteira) para saber se podia ou não chamar um método; se devia ou não
chamar o código ancestral do método; se um determinado atributo já havia sido inicializado, etc.&lt;/p&gt;

&lt;p&gt;Antigamente, nos compiladores mais antigos, era possível fazer uma chamada a um método abstrato — sei que o compilador FreePascal
não permite, nem compila — mas não sei se o compilador atual do Delphi permite. Bem, em compiladores antigos esse é mais um problema:
“Será que posso utilizar &lt;code&gt;inherited&lt;/code&gt; nesse método? Como saber se é abstrato?”&lt;/p&gt;

&lt;p&gt;Se não me engano, acho que o Java permite a chamada a métodos abstratos — me corrijam se eu estiver errado.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-3&quot;&gt;Exemplo 3 — Herança pode ser o Mal em qualquer lugar&lt;/h3&gt;

&lt;p&gt;O próximo exemplo não é sobre &lt;em&gt;Object Pascal&lt;/em&gt;, mas sim Java. Muitas pessoas pensam que algo está correto só
porque foi feito por uma grande empresa. Não. Pode ser uma grande empresa lucrativa, porém seus programadores
não são robôs, eles falham.&lt;/p&gt;

&lt;blockquote&gt;
  Quando então usar herança? Essa é uma questão difícil. Na minha visão particular, a resposta seria um enfático “quase nunca”.
  &lt;footer&gt;&lt;cite title=&quot;Paulo Silveira&quot;&gt;Como não aprender orientação a objetos: Herança — Paulo Silveira&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.caelum.com.br/como-nao-aprender-orientacao-a-objetos-heranca/&quot;&gt;Clique aqui&lt;/a&gt; para ler o artigo na íntegra e
ver como os arquitetos do Java erraram incrivelmente no &lt;em&gt;design&lt;/em&gt; da arquitetura de &lt;em&gt;Servlets&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A solução proposta pelo autor do artigo é a mesma que proponho em quase todos os posts aqui no blog:
&lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Utilize Interfaces&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;no-prximo-artigo&quot;&gt;No próximo artigo…&lt;/h2&gt;

&lt;p&gt;Espero que você tenha entendido. Herança viola o Encapsulamento. Não é apenas um conceito, mas um fato.&lt;/p&gt;

&lt;p&gt;No próximo artigo irei falar mais sobre &lt;strong&gt;Duplicação de Código&lt;/strong&gt; ao utilizarmos a Herança de Classe.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-3/&quot;&gt;Clique aqui&lt;/a&gt; para ler a &lt;strong&gt;Parte #3&lt;/strong&gt; dessa série.&lt;/p&gt;

&lt;p&gt;Caso você tenha alguma dúvida ou quiser compartilhar seus pensamentos sobre essa série, utilize a área 
abaixo para comentários.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 30 May 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/</guid>
      </item>
    
      <item>
        <title>Herança pode ser o Mal da Orientação a Objetos — Parte 1</title>
        <description>&lt;p&gt;Se você utiliza Herança em seu código, especificamente &lt;strong&gt;Herança de Classe&lt;/strong&gt;, pode estar
cometendo um &lt;strong&gt;erro&lt;/strong&gt; terrível.&lt;/p&gt;

&lt;p&gt;Com o uso da Herança você &lt;strong&gt;viola o encapsulamento&lt;/strong&gt; de suas Classes, deixa seu código menos
&lt;strong&gt;flexível&lt;/strong&gt; e mais &lt;strong&gt;complexo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Herança de Classe deve ser &lt;strong&gt;evitada&lt;/strong&gt; a todo custo.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1444212477490-ca407925329e.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Se você já programa utilizando &lt;strong&gt;Orientação a Objetos&lt;/strong&gt; há muito tempo, utilizando &lt;strong&gt;Classes e 
Subclasses&lt;/strong&gt; em seu código para “reutilizar” funcionalidades, eu realmente &lt;strong&gt;não&lt;/strong&gt; espero que você 
entenda e concorde comigo tão rapidamente.&lt;/p&gt;

&lt;p&gt;Será necessário &lt;strong&gt;tempo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Tempo para digerir as informações. Tempo para uma &lt;strong&gt;releitura&lt;/strong&gt;. Tempo para &lt;strong&gt;pesquisas&lt;/strong&gt; feitas por
você mesmo. Tempo para ler sobre &lt;strong&gt;outras linguagens&lt;/strong&gt;. Tempo para ler outros &lt;strong&gt;artigos e livros&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Depois você poderá formar sua opinião própria. Mas faça isso baseado em &lt;strong&gt;fatos&lt;/strong&gt; e não baseado
em &lt;strong&gt;preconceitos&lt;/strong&gt; ou ignorância de informações.&lt;/p&gt;

&lt;p&gt;No fim eu espero veementemente que você junte tudo isso e chegue a mesma conclusão que eu cheguei: 
&lt;strong&gt;Herança é o Mal&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;E, claro, é importante saber que grandes empresas e desenvolvedores ao redor do mundo já 
chegaram a mesma conclusão faz muito tempo.&lt;/p&gt;

&lt;p&gt;Mas porfavor, não pense que estou &lt;strong&gt;abolindo&lt;/strong&gt; completamente a Herança. Estou lhe dizendo que ela é má,
mas mesmo assim haverá momentos em que poderá ser mais &lt;strong&gt;simples&lt;/strong&gt; ou eficiente utitilizá-la do que outra 
abordagem. Por exemplo, um médico pode tomar a decisão de amputar a perna de um paciente para mantê-lo vivo. 
Não é algo “bom” para se fazer se pensarmos somente na amputação, no entanto pode ser a melhor decisão se 
você pensar no todo — a sobrevivência do paciente.&lt;/p&gt;

&lt;p&gt;É o mesmo com a Herança. Você tem essa possibilidade, mas só deverá utilizar em último recurso.&lt;/p&gt;

&lt;h2 id=&quot;heranca&quot;&gt;Herança&lt;/h2&gt;

&lt;p&gt;A Herança é um dos pilares da Orientação a Objetos, assim como &lt;strong&gt;Encapsulamento&lt;/strong&gt; e &lt;strong&gt;Polimorfismo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Se uma Classe B herda de A, então B &lt;strong&gt;é-um&lt;/strong&gt; A. Herança é isso. As Subclasses serão substitutas mais especializadas
de suas Super Classes.&lt;/p&gt;

&lt;p&gt;Quando comecei a estudar Orientação a Objetos — 20 anos atrás — foi a primeira coisa que li. Esse era o 
mantra na época: &lt;strong&gt;Herança, Encapsulamento e Polimorfismo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Para alguém como eu que só tinha visto &lt;strong&gt;código procedural&lt;/strong&gt; em C ou Pascal, declarar uma Classe e Subclasses para
herdar o comportamento reutilizando o código era… &lt;strong&gt;mágico&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Acho que Herança é o que mais &lt;strong&gt;impressiona&lt;/strong&gt; quem está aprendendo — ou mesmo quem já é veterano — a
programar Orientado a Objetos.&lt;/p&gt;

&lt;p&gt;Com Herança o programador consegue extender uma Classe com novos
métodos ou mesmo alterar o comportamento da Hierarquia com pouco código. Mágica.&lt;/p&gt;

&lt;p&gt;E isso não é bom?!&lt;/p&gt;

&lt;p&gt;Quase nunca.&lt;/p&gt;

&lt;p&gt;Eu não entendi logo na primeira vez que li sobre “Herança ser ruim”. Eu já me considerava um desenvolvedor
&lt;strong&gt;experiente&lt;/strong&gt; em Orientação a Objetos, no entanto eu tive que mudar meus conceitos. Na verdade eu tive que
&lt;strong&gt;reaprender&lt;/strong&gt; o que era Orientação a Objetos. Não só por causa do uso da Herança, mas por causa de uma série
de “novas” ideias que venho coletando, estududando e divulgando aqui mesmo, nesse blog.&lt;/p&gt;

&lt;p&gt;E é por isso que eu acho que o mesmo deve acontecer à você, ou seja, mais cedo ou mais tarde você terá que 
mudar/atualizar seus conceitos sobre Orientação a Objetos. É inevitável.&lt;/p&gt;

&lt;p&gt;Mas se você for uma pessoa mais &lt;strong&gt;sábia&lt;/strong&gt; do que eu fui na época quando li sobre &lt;strong&gt;Herança ser ruim e que deve
ser evitada&lt;/strong&gt;, você poderá obter o benefício de ler sobre isso agora e não ter que perder tempo em busca 
de uma resposta para a &lt;strong&gt;dor&lt;/strong&gt; que eu sei que você tem hoje, quando seu código começa a não fazer mais sentido; 
quando sua &lt;strong&gt;Hierarquia de Classes&lt;/strong&gt; se torna um peso e atrapalha mais do que ajuda; quando você tem que sobrescrever
métodos para não “fazer nada”, desabilitando funcionalidades; ou quando você tem que &lt;strong&gt;duplicar código&lt;/strong&gt; porque sua
Classe foi codificada numa “Hierarquia errada”.&lt;/p&gt;

&lt;h2 id=&quot;os-males&quot;&gt;Os Males&lt;/h2&gt;

&lt;p&gt;Se você nunca ouviu dizer que Herança é ruim, deve estar pensando que eu sou louco. Bem, saiba que eu não inventei
tal afirmação. Gostaria de citar um artigo que encontrei na Internet há bastante tempo e que serviu
de inspiração para o título desse artigo que você está lendo agora.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&quot;http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html&quot;&gt;artigo&lt;/a&gt; foi publicado na JavaWorld em
&lt;strong&gt;1 de Agosto de 2003&lt;/strong&gt;, intitulado: “&lt;em&gt;Why extends is evil&lt;/em&gt;”.&lt;/p&gt;

&lt;p&gt;Abaixo um pequeno trecho desse artigo. (Tradução Livre)&lt;/p&gt;

&lt;blockquote&gt;
  Uma vez fui a uma reunião do grupo de usuários Java, onde James Gosling (inventor do Java) foi o orador de destaque. 
  Durante o memorável Q&amp;amp;A sessão, alguém lhe perguntou: &quot;Se você pudesse fazer Java novamente, o que você mudaria?&quot; 
  &quot;Eu deixaria de fora as Classes&quot;, ele respondeu. Após sessarem os risos, ele explicou que o verdadeiro problema 
  não era as Classes em si, mas sim a Herança de Implementação (extends). Herança de Interface 
  (implements) é preferível. Você deve evitar a Herança de Implementação, sempre que possível.
  &lt;footer&gt;&lt;cite title=&quot;JavaWorld&quot;&gt;Why extends is evil — JavaWorld&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nessa série de artigos vou tentar explicar os motivos porque eu — e milhares de desenvolvedores ao redor do mundo — 
considero Herança algo ruim e que deve ser evitada a todo custo.&lt;/p&gt;

&lt;p&gt;Os principais motivos são:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Viola o Encapsulamento&lt;/li&gt;
  &lt;li&gt;Duplicação de Código&lt;/li&gt;
  &lt;li&gt;Forte Acoplamento&lt;/li&gt;
  &lt;li&gt;Hierarquias Complexas&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;no-prximo-artigo&quot;&gt;No próximo artigo…&lt;/h2&gt;

&lt;p&gt;No próximo artigo irei explicar em detalhes porque a Herança &lt;strong&gt;Viola o Encapsulamento&lt;/strong&gt;, com exemplos de código.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/&quot;&gt;Clique aqui&lt;/a&gt; para ler a &lt;strong&gt;Parte #2&lt;/strong&gt; dessa série.&lt;/p&gt;

&lt;p&gt;Caso você tenha alguma dúvida ou quiser compartilhar seus pensamentos sobre essa série, utilize a área 
abaixo para comentários.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 23 May 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/</guid>
      </item>
    
      <item>
        <title>Singleton é um anti-padrão?</title>
        <description>&lt;p&gt;O padrão &lt;em&gt;Singleton&lt;/em&gt; garante a existência de &lt;strong&gt;apenas uma instância&lt;/strong&gt; de &lt;strong&gt;uma classe&lt;/strong&gt;, 
mantendo &lt;strong&gt;um ponto global&lt;/strong&gt; de acesso ao seu Objeto.&lt;/p&gt;

&lt;p&gt;O &lt;strong&gt;conceito&lt;/strong&gt; do &lt;em&gt;Singleton&lt;/em&gt; não está errado, mas sua &lt;strong&gt;implementação&lt;/strong&gt; clássica está.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1462826743322-63f0fbb29f87.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ter um &lt;strong&gt;ponto global de acesso&lt;/strong&gt; é bom.&lt;/p&gt;

&lt;p&gt;Garantir uma &lt;strong&gt;única instância&lt;/strong&gt; para um Objeto, pode ser bom.&lt;/p&gt;

&lt;p&gt;O &lt;strong&gt;erro&lt;/strong&gt; é ter uma única instância de uma &lt;strong&gt;classe&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Por que?&lt;/p&gt;

&lt;p&gt;Simples. Você não deve utilizar pontos globais com &lt;strong&gt;Referência Direta&lt;/strong&gt; em seu código.&lt;/p&gt;

&lt;p&gt;Quando digo Referência Direta quero dizer:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Variáveis globais&lt;/li&gt;
  &lt;li&gt;Métodos estáticos que não trabalham com &lt;em&gt;Interfaces&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;variaveis-globais&quot;&gt;Variáveis globais&lt;/h2&gt;

&lt;p&gt;Você já deve saber que não devemos utilizar variáveis globais.&lt;/p&gt;

&lt;p&gt;Seu uso é considerado um anti-padrão porque seu conteúdo pode ser modificado/acessado de 
qualquer parte do seu código. Haverá uma dependência direta dessa variável aumentando a 
complexidade do código. Qualquer alteração no valor dessa variável poderá ocasionar problemas
em qualquer parte do código que a utilize.&lt;/p&gt;

&lt;h2 id=&quot;metodos-estaticos&quot;&gt;Métodos estáticos&lt;/h2&gt;

&lt;p&gt;Um &lt;a href=&quot;/posts/nao-utilize-metodos-estaticos/&quot;&gt;método estático&lt;/a&gt; é acessado
diretamente na Classe. Assim como uma variável global, o método estático é uma dependência 
direta e isso não é bom. No entanto o valor retornado 
por um método estático pode ser dinâmico. Pode ser um Objeto. Pode ser uma instância
de uma &lt;em&gt;Interface&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New()&lt;/a&gt; é estático, 
mas seu retorno é dinâmico. Ele também retorna uma instância de uma &lt;em&gt;Interface&lt;/em&gt; ao invés de 
um tipo primitivo ou Classe.&lt;/p&gt;

&lt;h2 id=&quot;padrao-singleton&quot;&gt;O Padrão &lt;em&gt;Singleton&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Um &lt;a href=&quot;https://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;&lt;em&gt;Singleton&lt;/em&gt;&lt;/a&gt; utiliza uma variável global, 
que está encapsulada dentro da própria classe. Também utiliza um método estático, que irá 
retornar a instância única encapsulada na Classe. Essa instância é do tipo da própria Classe.&lt;/p&gt;

&lt;p&gt;Precisamos utilizar esse Padrão?&lt;/p&gt;

&lt;p&gt;Sim, por simplicidade.&lt;/p&gt;

&lt;p&gt;Explico.&lt;/p&gt;

&lt;p&gt;É possível nunca utilizar o &lt;em&gt;Singleton&lt;/em&gt;. Basta você utilizar Injeção de Dependência nos
&lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt; das Classes.&lt;/p&gt;

&lt;p&gt;Mas para cada dependência teríamos que definir um argumento em todos os construtores, de todas as 
Classes, que necessitam utilizar a dependência.&lt;/p&gt;

&lt;p&gt;Isso irá gerar &lt;strong&gt;Complexidade&lt;/strong&gt; no código.&lt;/p&gt;

&lt;p&gt;Você precisa de uma única instância de Objetos para:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Conexão com um SGBD&lt;/li&gt;
  &lt;li&gt;Log de execução/&lt;em&gt;debugging&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Configurações da Aplicação&lt;/li&gt;
  &lt;li&gt;Etc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;São exemplos. Na verdade eu posso querer utilizar um &lt;em&gt;pool&lt;/em&gt; de conexões para o SGBD; ter várias Classes
que representam as Configurações, etc. Mas, você entendeu.&lt;/p&gt;

&lt;p&gt;Então garantir a existência de &lt;strong&gt;apenas uma instância&lt;/strong&gt; mantendo &lt;strong&gt;um ponto global&lt;/strong&gt; de acesso ao Objeto 
é importante. Isso minimiza a complexidade.
Ao invés de ter sempre um parâmetro a mais em todos os construtores das Classes — ou da maioria delas — eu
só preciso ter um único ponto de acesso para “algum” Objeto.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;Singleton&lt;/em&gt; clássico parece resolver isso. Sim, mas ele nos traz um problema maior do que o benefício.&lt;/p&gt;

&lt;h3 id=&quot;o-problema&quot;&gt;O Problema&lt;/h3&gt;

&lt;p&gt;Não há como implementar um &lt;em&gt;Singleton&lt;/em&gt; sem haver uma &lt;strong&gt;variável&lt;/strong&gt; para retornar &lt;strong&gt;uma única instância&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;O problema não é a variável, pois ela estará encapsulada na Classe. Isso quer dizer que
ela estará protegida. Bem, talvez não tão protegida mas ainda melhor que uma variável global.&lt;/p&gt;

&lt;p&gt;O problema também não é o &lt;strong&gt;método estático&lt;/strong&gt; — mesmo tendo seu uso desencorajado na maioria dos casos —
pois podemos retornar qualquer valor.&lt;/p&gt;

&lt;p&gt;O &lt;strong&gt;real problema&lt;/strong&gt; do Padrão &lt;em&gt;Singleton&lt;/em&gt;, em sua implementação clássica, é o &lt;strong&gt;tipo de retorno&lt;/strong&gt; do método estático.&lt;/p&gt;

&lt;h3 id=&quot;implementacao-classica&quot;&gt;Implementação Clássica&lt;/h3&gt;

&lt;p&gt;Existem variações de implementação do Padrão &lt;em&gt;Singleton&lt;/em&gt; que utilizam algumas técnicas para inicializar 
a variável encapsulada, ou seja, a instância que será retornada pelo método estático que, na maioria das 
vezes, é denominado &lt;code&gt;GetInstance&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Na implementação mais básica, que pode ser feita em praticamente qualquer linguagem Orientada a Objetos,
implementamos construtores da Classe 
como privados. Assim o utilizador da Classe não conseguirá instanciar Objetos dessa Classe diretamente. Depois
é definido um (ou mais) método estático — &lt;code&gt;GetInstance&lt;/code&gt; — para retornar uma instância da Classe… do mesmo tipo da Classe!&lt;/p&gt;

&lt;p&gt;Aí está o problema.&lt;/p&gt;

&lt;p&gt;Um &lt;strong&gt;grave&lt;/strong&gt; problema.&lt;/p&gt;

&lt;p&gt;Se você retornar uma instância do mesmo tipo da Classe, seu código terá uma dependência direta com essa Classe.
Só isso pode arruinar qualquer tentativa de testes automatizados no código.&lt;/p&gt;

&lt;p&gt;Veja um exemplo:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TUserAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ChangePassword&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewPassword&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewPassword&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Invalid Password&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewPassword&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;Must have 8 characters or more&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Password&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewPassword&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TMSSQL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;É um código idiota, mas serve ao propósito.&lt;/p&gt;

&lt;p&gt;Vejamos.&lt;/p&gt;

&lt;p&gt;Existe um Classe &lt;code&gt;TUserAction&lt;/code&gt; que tem um método para alterar o &lt;em&gt;password&lt;/em&gt; do usuário logado. Esse método tem 
algumas validações simples.&lt;/p&gt;

&lt;p&gt;Alteramos seu &lt;em&gt;password&lt;/em&gt; e depois essa alteração será persistida no SGBD.&lt;/p&gt;

&lt;p&gt;A chamada &lt;code&gt;TMSSQL.GetInstance&lt;/code&gt; é um &lt;em&gt;Singleton&lt;/em&gt;. O método irá retornar uma conexão &lt;code&gt;TMSSQLConnection&lt;/code&gt; para o MSSQL.&lt;/p&gt;

&lt;p&gt;Utilizamos então o método &lt;code&gt;Save(User)&lt;/code&gt; para persistir as alterações.&lt;/p&gt;

&lt;p&gt;Não importa como &lt;code&gt;Save(User)&lt;/code&gt; sabe como persistir um usuário. Isso não é relevante. O problema aqui é
como iremos testar &lt;code&gt;ChangePassword&lt;/code&gt; sem fazer a integração/conexão real com o SGBD (MSSQL).&lt;/p&gt;

&lt;p&gt;Eu só quero testar o método utilizando um &lt;strong&gt;teste automatizado&lt;/strong&gt;. Eu não quero ter que conectar num SGBD real,
utilizar &lt;em&gt;user/password&lt;/em&gt; reais e muito menos alterar algum dado.&lt;/p&gt;

&lt;p&gt;Quero fazer &lt;strong&gt;testes de unidade&lt;/strong&gt;, não &lt;strong&gt;testes de integração&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Bem, se &lt;code&gt;TMSSQL.GetInstance&lt;/code&gt; me retorna uma instância de &lt;code&gt;TMSSQLConnection&lt;/code&gt;, uma Classe concreta, &lt;strong&gt;não é possível
fazer o teste automatizado&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;É um exemplo simples. Vejo isso na maioria dos códigos “&lt;em&gt;Object Pascal&lt;/em&gt;” — que não tem nada de Orientação a Objetos.&lt;/p&gt;

&lt;p&gt;Na verdade, a maioria iria utilizar uma instância de algum
&lt;a href=&quot;/posts/datamodule-e-apenas-um-container/&quot;&gt;DataModule&lt;/a&gt; e iria substituir a chamada &lt;code&gt;TMSSQL.GetInstance&lt;/code&gt;
por apenas &lt;code&gt;DM.conMSSQL&lt;/code&gt; ou seja, duas variáveis. Triste.&lt;/p&gt;

&lt;p&gt;Entendeu por que não devemos utilizar uma instância de Classe concreta?&lt;/p&gt;

&lt;p&gt;E qual a solução?&lt;/p&gt;

&lt;p&gt;Retornar uma instância de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interface&lt;/a&gt; ao invés
de uma instância do tipo Classe.&lt;/p&gt;

&lt;h3 id=&quot;implementacao-sugerida&quot;&gt;Implementação Sugerida&lt;/h3&gt;

&lt;p&gt;O que irei sugerir para a implementação de um &lt;em&gt;Singleton&lt;/em&gt; é tão simples quanto parece, mas com um ganho
incontestável: &lt;strong&gt;Desacoplamento&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Utilize &lt;em&gt;Interfaces&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ao invés de &lt;code&gt;TMSSQL.GetInstance&lt;/code&gt; retornar um &lt;code&gt;TMSSQLConnection&lt;/code&gt;, o método irá retornar um &lt;code&gt;IConnection&lt;/code&gt; ou seja,
uma &lt;em&gt;Interface&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se agora temos um retorno que é uma &lt;em&gt;Interface&lt;/em&gt;, podemos ter qualquer Classe que implemente essa &lt;em&gt;Interface&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TMSSQLConnection&lt;/code&gt; deverá implementar &lt;code&gt;IConnection&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;E onde está desacoplamento?&lt;/p&gt;

&lt;p&gt;Você poderá retornar qualquer instância que implemente &lt;code&gt;IConnection&lt;/code&gt; e isso pode ser feito de várias formas.&lt;/p&gt;

&lt;p&gt;Se quiser escrever menos, utilize &lt;strong&gt;diretivas de compilação&lt;/strong&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TMSSQL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IConnection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Assigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;{$IFDEF TEST}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;FInstance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TFakeConnection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;{$ELSE}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;FInstance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TMSSQLConnection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;password&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;{$ENDIF}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;bp&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Essa é a maneira “Rápido e sujo”. Você pode começar por aí caso nunca tenha pensado nisso. Quando estiver
em “modo de teste”, ative a diretiva &lt;code&gt;TEST&lt;/code&gt;, do contrário a Classe de produção será utilizada.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TFakeConnection&lt;/code&gt; não se conecta em nenhum SGBD. Talvez você possa utilizá-la para fazer 
um log das instruções SQL ou &lt;strong&gt;não fazer nada&lt;/strong&gt; quando chamar o método &lt;code&gt;Save&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se você está testando as &lt;strong&gt;Regras de Negócio&lt;/strong&gt;, a persistência é irrelevante.&lt;/p&gt;

&lt;p&gt;Depois você pode &lt;strong&gt;refatorar&lt;/strong&gt; esse código e deixá-lo mais Orientado a Objetos, utilizando 
Injeção de Dependência em conjunto com &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_factory_pattern&quot;&gt;&lt;em&gt;Abstract Factory Pattern&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Como?&lt;/p&gt;

&lt;p&gt;Bem, em algum lugar no seu código você deverá ter uma chamada para “inicializar” a Classe &lt;code&gt;TMSSQL&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TMSSQL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IConnectionFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Factory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;initialization&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TMSSQL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TDbConnectionFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;mssql&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Mais um vez estaremos utilizando métodos estáticos. Mas estamos em busca de simplicidade.
Não devemos ser &lt;strong&gt;puristas&lt;/strong&gt; em Orientação a Objetos se não há nenhum benefício. Sempre haverá partes do código
que poderiam melhorar, refatorar, eliminar, etc. Enfim.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TMSSQL&lt;/code&gt; deverá ser bem pequena e sem complexidade.&lt;/p&gt;

&lt;p&gt;O atributo &lt;code&gt;FFactory&lt;/code&gt; é um &lt;code&gt;class var&lt;/code&gt; assim como &lt;code&gt;FInstance&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então você poderá ter novas Classes que implementam &lt;code&gt;IConnectionFactory&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;No exemplo temos &lt;code&gt;TDbConnectionFactory&lt;/code&gt;. Optei por utilizar um parâmetro que me diz qual “tipo” de Classe será
utilizada. Se eu quiser testar o código bastaria chamar &lt;code&gt;TDbConnectionFactory.New(&#39;test&#39;)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Utilize seu estilo.&lt;/p&gt;

&lt;p&gt;Após essa alteração o método &lt;code&gt;GetInstance&lt;/code&gt; pode ser refatorado:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TMSSQL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IConnection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Assigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FInstance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConnection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FUser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FPassword&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;bp&quot;&gt;Result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;A chamada a &lt;code&gt;FFactory.NewConnection&lt;/code&gt; irá gerar uma nova instância de &lt;code&gt;IConnection&lt;/code&gt;. Qual a Classe que 
estará sendo utilizada é irrelevante para o código que utiliza &lt;code&gt;TMSSQL.GetInstance&lt;/code&gt; em todos os lugares,
como deve ser. O retorno poderia ser &lt;code&gt;TMSSQLConnection&lt;/code&gt;, &lt;code&gt;TFakeConnection&lt;/code&gt; ou qualquer outra classe que
implemente &lt;code&gt;IConnection&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Esse é um &lt;em&gt;Singleton&lt;/em&gt; &lt;strong&gt;simples&lt;/strong&gt;, &lt;strong&gt;desacoplado&lt;/strong&gt; e &lt;strong&gt;Orientado a Objetos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 16 May 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/singleton-e-um-anti-padrao/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/singleton-e-um-anti-padrao/</guid>
      </item>
    
      <item>
        <title>Validações no Construtor</title>
        <description>&lt;p&gt;Dizem que um Objeto não pode ter um &lt;strong&gt;estado inválido&lt;/strong&gt; e que 
sua validação deve ser feita no seu &lt;strong&gt;Construtor&lt;/strong&gt;, ou seja, se 
os argumentos do Construtor não são suficientes, não deveríamos
criar o Objeto.&lt;/p&gt;

&lt;p&gt;Imagine um mundo onde tudo são objetos.&lt;/p&gt;

&lt;p&gt;Como você irá verificar se um Objeto é inválido antes de você criá-lo?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-EnF7DhHROS8OMEp2pCkx_Duferfood.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;O que significa &lt;strong&gt;estado inválido&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;Se os argumentos do construtor de um Objeto não forem suficientes, e não fizermos uma
validação prévia desses argumentos, poderíamos criar um Objeto com estado inválido.
Quero dizer que seu &lt;strong&gt;Estado&lt;/strong&gt; não estaria válido para que ele pudesse fazer o trabalho
para o qual ele foi/será designado.&lt;/p&gt;

&lt;p&gt;E porque isso seria um problema?&lt;/p&gt;

&lt;p&gt;Bem, eu não acho que seria um problema. A única &lt;strong&gt;exceção&lt;/strong&gt; é
a utilização de &lt;a href=&quot;/posts/nao-utilize-nil-ou-null/&quot;&gt;Objetos Nulos&lt;/a&gt;. Nesse 
caso sim, seria um &lt;strong&gt;erro&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo. Vamos definir uma classe &lt;code&gt;TDbQuery&lt;/code&gt; que irá encapsular um SQL.
Essa classe só terá um método (simplificando) para executar o SQL.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-pascal&quot; data-lang=&quot;pascal&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;TDbQuery&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;private&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FScript&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;public&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;construtor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Script&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;O construtor tem um argumento do tipo &lt;code&gt;string&lt;/code&gt; e o usuário da classe poderia passar qualquer
valor como um SQL válido, mas também letras, números ou até mesmo uma string em branco.&lt;/p&gt;

&lt;p&gt;Precisamos saber se o SQL é válido antes da hora de chamar &lt;code&gt;Execute&lt;/code&gt;? &lt;strong&gt;Não&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Existem validações simples como verificar se uma &lt;code&gt;string&lt;/code&gt; está em branco, mas há outras validações
muito mais complexas.&lt;/p&gt;

&lt;p&gt;Para validar a classe acima seria muito complexo.&lt;/p&gt;

&lt;p&gt;Por que?&lt;/p&gt;

&lt;p&gt;Você teria que validar a sintaxe do SQL,
talvez utilizando &lt;em&gt;Regular Expression&lt;/em&gt; (RegExpr). Se tivéssemos Objetos que implementam RegExpr, então
teríamos muitas instâncias de Objetos para validar a &lt;code&gt;string&lt;/code&gt;. São Objetos, que chamam outros, que chamam outros…&lt;/p&gt;

&lt;p&gt;E, mesmo depois de toda essa validação sintática, a execução do SQL ainda poderia gerar erro! A tabela não existe,
o nome da coluna foi digitado errado, etc.&lt;/p&gt;

&lt;p&gt;Pior. Talvez o algoritmo em execução nem precisasse chamar esse Objeto, talvez o usuário tenha cancelado a operação
antes… então você perdeu tempo validando e nem precisou executar o &lt;em&gt;Script&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Se tudo são Objetos, eles devem ser criados &lt;strong&gt;antes&lt;/strong&gt; de serem validados. Essa operação deve ocorrer o &lt;strong&gt;mais rápido&lt;/strong&gt;
possível, no &lt;strong&gt;menor custo&lt;/strong&gt; computacional possível, mesmo em “estado inválido”.&lt;/p&gt;

&lt;p&gt;Em outro momento ele será validado pois não há como validar algo que ainda não existe!&lt;/p&gt;

&lt;p&gt;Ainda não concorda?&lt;/p&gt;

&lt;p&gt;Então vamos ver um exemplo no mundo real.&lt;/p&gt;

&lt;p&gt;Para fazer um bom prato você precisa ter bons ingredientes. Um &lt;em&gt;Spaghetti a Lá Carbonara&lt;/em&gt; precisa de uns 4 ovos — eu
gosto de fazer esse prato — bacon, queijo parmesão…
No &lt;a href=&quot;https://en.wikipedia.org/wiki/Mise_en_place&quot;&gt;Mise en place&lt;/a&gt; você precisa bater os ovos e misturar com parmesão; 
então você vai quebrando os ovos e descobre que um deles está podre (estado inválido). Você não vai utilizá-lo.
Esse Objeto não serve… mas ele existe! Estava lá, junto com os outros “ovos válidos”. Ele ocupava espaço, tinha a 
mesma aparência dos demais mas estava “inválido”. O mundo é assim.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Se existisse um mundo onde todos os Objetos fossem validados antes de serem criados, então seria um mundo perfeito com Objetos perfeitos.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Matrix&quot;&gt;Matrix&lt;/a&gt; tentou criar um mundo assim — ou foram 3, talvez 4? Não lembro — 
mas não deu muito certo… ao que parece os seres humanos precisam de estado inválido e não lidam bem com perfeição 
— o primeiro filme da série foi o melhor, não é? :)&lt;/p&gt;

&lt;p&gt;Se nosso &lt;strong&gt;mundo real&lt;/strong&gt; foi “implementado” assim, contendo “Objetos com estado inválido”, porque você acha que 
seus Objetos são — ou deveriam ser — mais &lt;strong&gt;perfeitos&lt;/strong&gt; do que os objetos do mundo real, do qual eles representam?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 09 May 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/validacoes-no-construtor/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/validacoes-no-construtor/</guid>
      </item>
    
      <item>
        <title>Decorator Pattern</title>
        <description>&lt;p&gt;Como agregar responsabilidade a Objetos individuais, em tempo de execução, independente de sua Classe?&lt;/p&gt;

&lt;p&gt;Utilizando &lt;em&gt;Decorator Pattern&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Os Decoradores oferecem uma alternativa simples e flexível ou uso de subclasses para extensão de funcionalidades.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1461709444300-a6217cec3dff.jpg&quot; alt=&quot;Decorator&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Para mim, &lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;&lt;em&gt;Decorador&lt;/em&gt;&lt;/a&gt; é um dos mais importantes padrões de &lt;em&gt;design&lt;/em&gt;.
Infelizmente esse padrão quase nunca é utilizado, pelo menos nos projetos que vi nos últimos anos, independentemente
da linguagem de programação utilizada.&lt;/p&gt;

&lt;p&gt;Por que?&lt;/p&gt;

&lt;p&gt;Não tenho uma resposta exata, mas suponho que o motivo do não uso de Decoradores seja devido a escolha “natural” de 
utilizarmos &lt;strong&gt;Herança de Classes&lt;/strong&gt; para estender funcionalidades.&lt;/p&gt;

&lt;p&gt;Aprendemos que a Orientação a Objetos tem 3 pilares: &lt;strong&gt;Herança, Encapsulamento e Polimorfismo.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Herança de Classe é utilizada para estender funcionalidades, implementando uma nova Classe que herda as funcionalidades
da primeira e de toda uma hierarquia. Então você acha que usar Herança sempre será a escolha mais correta para extensão de funcionalidades?&lt;/p&gt;

&lt;p&gt;Eu acho que não. Em 90~95% dos casos, eu utilizo &lt;strong&gt;Decoradores&lt;/strong&gt; e &lt;strong&gt;Composição de Objetos&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;
    Um Decorador oferece uma abordagem do tipo &quot;use quando for necessário” para adição de responsabilidades. Em vez de tentar
    suportar todas as características previsíveis em uma Classe complexa e customizada, você pode definir uma Classe simples e 
    acrescentar funcionalidade de modo incremental com objetos Decoradores.
  &lt;/p&gt;
  &lt;footer&gt;&lt;cite title=&quot;Padrões de Projeto&quot;&gt;— Padrões de Projeto, Erich Gamma, pág.173&lt;/cite&gt;&lt;/footer&gt;
&lt;/blockquote&gt;

&lt;p&gt;Decoradores são tão simples de implementar como Herança, mas traz mais benefícios.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Você não precisa prever o futuro utilizando Decoradores. Utilizando Herança você tem que se preocupar com a hierarquia
  das Classes desde o início, desde a Classe mais básica até a mais específica, como se pudesse prever o futuro;&lt;/li&gt;
  &lt;li&gt;Evita Classes sobrecarregadas de características e funcionalidades;&lt;/li&gt;
  &lt;li&gt;Classes pequenas e coesas;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Exemplos de código?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Parte do código de um projeto em produção que utiliza Decoradores para consumir um WebService, &lt;a href=&quot;/posts/pensando-em-objetos/#exemplo-2&quot;&gt;aqui&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Implementação de um Log com Decoradores para memória, arquivo, banco de dados e e-mail, &lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/#implementacao-oo&quot;&gt;aqui&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;Utilizando a Classe &lt;code&gt;TEmployeeSalaryWithCommission&lt;/code&gt; como Decorador de &lt;code&gt;TEmployeeSalary&lt;/code&gt;, &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/#versao-orientada-a-objetos&quot;&gt;aqui&lt;/a&gt;;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 May 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/decorator-pattern/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/decorator-pattern/</guid>
      </item>
    
      <item>
        <title>Nomeando Classes</title>
        <description>&lt;p&gt;O nome de uma Classe deve significar quem ela representa e não o que ela faz.&lt;/p&gt;

&lt;p&gt;Não utilize nomes como Validador, Leitor, Controlador, &lt;em&gt;Parser&lt;/em&gt;, 
Executor, &lt;em&gt;Manager&lt;/em&gt;, &lt;em&gt;Handle&lt;/em&gt;, etc. Esses nomes dizem o que fazem, não o que são.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1453946610176-6be21147c400.jpg&quot; alt=&quot;Naming&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Considere alguns exemplos:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;#1&lt;/strong&gt; Seu software trabalha com &lt;strong&gt;Arquivos Texto&lt;/strong&gt; enviados pelo Banco
(arquivos de retorno de pagamentos). Então &lt;em&gt;TBankFileParser&lt;/em&gt; é o nome da sua Classe?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;#2&lt;/strong&gt; Você precisa &lt;strong&gt;importar&lt;/strong&gt; um arquivo CSV proveniente de outro software. Então &lt;em&gt;TCSVImporter&lt;/em&gt;
é o nome da sua Classe?&lt;/p&gt;

&lt;p&gt;Não faça isso.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“O nome de uma Classe deve corresponder ou representar uma Entidade pura ou uma versão dela”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Se não conseguimos encontrar um bom nome para as Classes e Interfaces, quer dizer que não 
sabemos o suficiente sobre o domínio do problema ou é apenas preguiça para pensar em nomes melhores.&lt;/p&gt;

&lt;p&gt;Temos que pensar nas &lt;strong&gt;Entidades&lt;/strong&gt; em si, e não nas &lt;strong&gt;funções&lt;/strong&gt; que elas exercem.&lt;/p&gt;

&lt;p&gt;Por exemplo, considere &lt;em&gt;File&lt;/em&gt;. Um nome de &lt;strong&gt;Entidade pura&lt;/strong&gt;, ou seja, um Arquivo de computador ou arquivo em
papel, dependendo do contexto. Se temos um arquivo para ler &lt;strong&gt;não&lt;/strong&gt; devemos nomear a classe como &lt;em&gt;Reader&lt;/em&gt;!
Utilize &lt;em&gt;File&lt;/em&gt; ou uma variação deste.&lt;/p&gt;

&lt;p&gt;Um nome como &lt;em&gt;TextFile&lt;/em&gt;, é uma versão ou variação de &lt;em&gt;File&lt;/em&gt;. Também está correto. Simples. Perfeito.&lt;/p&gt;

&lt;p&gt;Então se temos um Arquivo Texto do Banco (exemplo #1) ele também deveria representar uma
Entidade. Seu nome deveria ser &lt;code&gt;TBankFile&lt;/code&gt; ou algo parecido.&lt;/p&gt;

&lt;p&gt;Se enviamos o Arquivo para o Banco (Remessa) e obtemos outro Arquivo de resposta
(Retorno), então poderíamos ter uma única interface &lt;code&gt;IBankFile&lt;/code&gt; e duas classes 
&lt;code&gt;TBankShipmentFile&lt;/code&gt; e &lt;code&gt;TBankReturnFile&lt;/code&gt;. Ambas as Classes implementariam 
a Interface.&lt;/p&gt;

&lt;p&gt;Mas o nome de uma Classe nem sempre será &lt;strong&gt;exatamente igual&lt;/strong&gt; a mesma nomenclatura da Entidade real que está representando.&lt;/p&gt;

&lt;p&gt;Em um dos meus projetos, o &lt;a href=&quot;https://github.com/mdbs99/aws&quot;&gt;AWS Lib&lt;/a&gt;, tenho classes como &lt;code&gt;TS3Service&lt;/code&gt;,
&lt;code&gt;TS3Bucket&lt;/code&gt;, &lt;code&gt;TAWSSignatureVersion1&lt;/code&gt; e muitas outras.&lt;/p&gt;

&lt;p&gt;Por que não apenas &lt;em&gt;Service&lt;/em&gt;, &lt;em&gt;Bucket&lt;/em&gt; ou &lt;em&gt;Signature&lt;/em&gt; respectivamente?
Porque Classes precisam de um &lt;strong&gt;contexto&lt;/strong&gt; — um prefixo — quando seus nomes são muito ambíguos.&lt;/p&gt;

&lt;p&gt;Na vida real o contexto está implícito, mesmo se for somente através da linguagem corporal. Exemplo:
Quando falamos para uma pessoa “sua &lt;strong&gt;manga&lt;/strong&gt; está suja”&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; olhando para sua &lt;strong&gt;camisa&lt;/strong&gt; fica claro do que se trata. 
Não há confusão com a &lt;strong&gt;fruta&lt;/strong&gt; manga se ninguém está comendo no momento.&lt;/p&gt;

&lt;p&gt;No código é mais difícil. Só tem… texto! Tudo tem a mesma “forma”. Então como diferenciar os nomes?&lt;/p&gt;

&lt;p&gt;Temos &lt;em&gt;units&lt;/em&gt; que são &lt;em&gt;namespaces&lt;/em&gt; e que poderiam ser utilizadas como “prefixo”
de todas as classes, mas quem faz isso?! Ficaria muito verboso. Ninguém quer isso — bem, talvez o pessoal do Java, 
eles gostam de escrever… :)&lt;/p&gt;

&lt;p&gt;Então para ter um padrão no código eu tenho uma regra para a nomenclatura das Classes: &lt;strong&gt;Contexto + Nome&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Isso evita a colisão de nomes com Classes já existentes na VCL/LCL e também deixa o código mais homogêneo, mais
pradronizado. Ajuda na visualização e facilita o &lt;em&gt;code-completion&lt;/em&gt; da IDE.&lt;/p&gt;

&lt;p&gt;Mas cuidado para não ir somando Contextos um após o outro.&lt;/p&gt;

&lt;p&gt;Exemplo: &lt;code&gt;TAWSNetHTTPClient&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Que tal esse nome de Classe?&lt;/p&gt;

&lt;p&gt;A Classe tem 3 contextos (AWS, Net e HTTP) e mais o nome &lt;em&gt;Client&lt;/em&gt;. 
Apesar da &lt;strong&gt;vantagem&lt;/strong&gt; que ganhamos ao evitar a colisão de nomes, é &lt;strong&gt;verboso&lt;/strong&gt; demais para codificar e, o mais 
importante, &lt;strong&gt;ler&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Não é uma regra perfeita, mas funciona pra mim.&lt;/p&gt;

&lt;p&gt;Mesmo assim, após anos de codificação, ainda é uma &lt;strong&gt;arte&lt;/strong&gt; bem difícil.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Não fará sentido se você traduzir o artigo para o Inglês, já que a ambiguidade da palavra “manga” só faz sentido em Português. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 25 Apr 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/nomeando-classes/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/nomeando-classes/</guid>
      </item>
    
      <item>
        <title>Não Utilize Casting</title>
        <description>&lt;p&gt;Sua equipe precisa de um programador Object Pascal para trabalhar num projeto que está
sendo codificado em FreePascal. Este projeto terá integração com um ERP codificado em Java e
um website codificado em PHP. Tudo utilizando MS SQLServer como SGBD.&lt;/p&gt;

&lt;p&gt;Como você iria descrever o anúncio dessa vaga?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1445451983996-ac6b92ffb1fb.jpg&quot; alt=&quot;Casting&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Uma tradução para &lt;em&gt;Casting&lt;/em&gt;, em Português, seria &lt;strong&gt;moldagem&lt;/strong&gt;. Você recebe algo e o “molda” em outra coisa.&lt;/p&gt;

&lt;p&gt;Fazemos isso muitas vezes. Temos um &lt;em&gt;Integer&lt;/em&gt; e o moldamos em uma &lt;em&gt;String&lt;/em&gt; e vice-versa.&lt;/p&gt;

&lt;p&gt;Mas será que o uso de &lt;em&gt;Casting&lt;/em&gt; é necessário para codificarmos nossas &lt;strong&gt;Regras de Negócio&lt;/strong&gt; utilizando
Objetos?&lt;/p&gt;

&lt;center&gt;&lt;p&gt;&lt;strong&gt;. . .&lt;/strong&gt;&lt;/p&gt;&lt;/center&gt;

&lt;p&gt;O arquiteto da equipe — sr. Anderson — já definiu o projeto.&lt;/p&gt;

&lt;p&gt;Anderson definiu a API de integração, diagramas de classes, componentes, módulos, etc. Mas o projeto 
ficou maior que o esperado e agora precisam de um programador experiente para compor a equipe.&lt;/p&gt;

&lt;p&gt;O arquiteto solicita ao seu gerente o novo programador, mas sem lhe dar instruções específicas.&lt;/p&gt;

&lt;p&gt;O gerente repassa o pedido ao pessoal do RH e então eles anunciam a vaga em sites:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Empresa ACME Inc. precisa de programador experiente.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A empresa recebe currículos com especialidade em COBOL, Delphi, C/C++, Java… PHP foi a maioria. :)&lt;/p&gt;

&lt;p&gt;Todos perdem tempo, pois terão muito mais currículos para &lt;strong&gt;analisar e verificar&lt;/strong&gt; se o canditato 
se &lt;strong&gt;encaixa nos critérios&lt;/strong&gt;, pois não definiram as &lt;strong&gt;habilidades necessárias&lt;/strong&gt; que o programador deve ter
quando fizeram o anúncio.&lt;/p&gt;

&lt;p&gt;O mesmo acontece quando utilizamos &lt;em&gt;Casting&lt;/em&gt;. É necessário ter &lt;strong&gt;código de verificação&lt;/strong&gt; para o Objeto 
afim de determinar sua Classe.&lt;/p&gt;

&lt;blockquote&gt;
  Seus Objetos devem trabalhar sob contratos, ou seja, interfaces. Somente Objetos
  qualificados — que implementam a Interface — poderão ser utilizados para fazer o serviço.
&lt;/blockquote&gt;

&lt;p&gt;Se você tem um trabalho a fazer, chame um &lt;strong&gt;especialista&lt;/strong&gt; apto para fazer o trabalho — ou faça você mesmo.&lt;/p&gt;

&lt;p&gt;O trabalho é determinado por um &lt;strong&gt;contrato&lt;/strong&gt; que especifica as habilidades necessárias que o especialista 
precisa ter.&lt;/p&gt;

&lt;p&gt;Na Orientação a Objetos os &lt;a href=&quot;/posts/interfaces-em-todo-lugar/#interfaces-sao-contratos&quot;&gt;contratos são representados por Interfaces&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Interfaces, &lt;strong&gt;não Classes.&lt;/strong&gt;&lt;/p&gt;

&lt;center&gt;&lt;p&gt;&lt;strong&gt;. . .&lt;/strong&gt;&lt;/p&gt;&lt;/center&gt;

&lt;p&gt;Anderson precisa de um programador.&lt;/p&gt;

&lt;p&gt;O RH altera os requisitos da vaga.&lt;/p&gt;

&lt;p&gt;O programador deve saber:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Object Pascal&lt;/li&gt;
  &lt;li&gt;MS SQLServer&lt;/li&gt;
  &lt;li&gt;Desejável PHP, Java&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Agora ficou mais fácil de encontrar o programador específico para o trabalho.&lt;/p&gt;

&lt;p&gt;É isso que você deve fazer no seu código. Especifique Interfaces que definam o contrato necessário para fazer 
o trabalho.&lt;/p&gt;

&lt;p&gt;Não defina argumentos do tipo de &lt;strong&gt;Classes genéricas&lt;/strong&gt; — TObject, etc — sendo necessário utilizar &lt;em&gt;Casting&lt;/em&gt; para verificar
qual o tipo de Classe do Objeto para fazer algum &lt;strong&gt;processamento específico&lt;/strong&gt; dependendo da Classe. Não faça isso!&lt;/p&gt;

&lt;p&gt;Interfaces são contratos de trabalho.&lt;/p&gt;

&lt;p&gt;Defina bem seus contratos e você não precisará fazer &lt;em&gt;Casting&lt;/em&gt; pois saberá que
somente &lt;strong&gt;Objetos especialistas&lt;/strong&gt; irão se “candidatar” ao trabalho. Do contrário não fique surpreso de receber 
um &lt;strong&gt;tomate&lt;/strong&gt; quando você esperava uma &lt;strong&gt;maçã&lt;/strong&gt;! :)&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Apr 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/nao-utilize-casting/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/nao-utilize-casting/</guid>
      </item>
    
  </channel>
</rss>
