<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Injeção de Dependência sem XML, Atributos/Anotações ou Frameworks</title>
        <description>&lt;p&gt;É possível utilizar a Injeção de Dependência na Orientação Objetos sem depender de características específicas da linguagem, Arquivos XML, Atributos/Anotações ou &lt;em&gt;Frameworks&lt;/em&gt;?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-vadim-sherbakov-36.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Vadim Sherbakov on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Injeção de Dependência&lt;/a&gt; ou apenas DI (em Inglês: &lt;em&gt;“Dependency Injection”&lt;/em&gt;) pode ser um assunto bem controverso que ainda geram muitas dúvidas entre desenvolvedores.&lt;/p&gt;

&lt;p&gt;Será que DI é algo complexo que exige um &lt;em&gt;framework&lt;/em&gt; para gerenciar as dependências entre Classes de um &lt;em&gt;software&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;É necessário um arquivo XML para que o desenvolvedor possa configurar tais dependências?&lt;/p&gt;

&lt;p&gt;Talvez possamos utilizar Atributos/Anotações para facilitar essas configurações?&lt;/p&gt;

&lt;p&gt;Como podemos utilizar o conceito de &lt;a href=&quot;https://en.wikipedia.org/wiki/Inversion_of_control&quot;&gt;IoC&lt;/a&gt; sem um &lt;em&gt;framework&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;O mercado tem várias maneiras de “injetar” alguma coisa, porém eu lhe digo: Injeção de Dependência é apenas passagem de parâmetro entre Objetos.&lt;/p&gt;

&lt;h2 id=&quot;artefatos&quot;&gt;Artefatos&lt;/h2&gt;

&lt;p&gt;Qualquer sistema &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt; que faça algo de útil, terá dependências entre suas Classes ou Módulos.&lt;/p&gt;

&lt;p&gt;Um Módulo/Classe &lt;code&gt;A&lt;/code&gt; que usa &lt;code&gt;B&lt;/code&gt; que usa &lt;code&gt;C&lt;/code&gt; (&lt;code&gt;A-&amp;gt;B-&amp;gt;C&lt;/code&gt;) estão conectados entre si.&lt;/p&gt;

&lt;p&gt;Sempre devemos minimizar essas dependências afim de facilitarmos a manutenção do código, porém é impossível não tê-las.&lt;/p&gt;

&lt;p&gt;Mesmo assim, o mercado resolveu criar todo tipo de “artefatos” como &lt;em&gt;frameworks&lt;/em&gt;, atributos/anotações ou configurações em arquivos XML, para “facilitar” a comunicação entre os Objetos, tornando “transparente” para o desenvolvedor as dependências existentes entre as Classes.&lt;/p&gt;

&lt;p&gt;Na minha opinião, eles trouxeram mais problemas e &lt;em&gt;complexidade&lt;/em&gt; do que uma real solução.&lt;/p&gt;

&lt;p&gt;Pense bem:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Um &lt;em&gt;Framework&lt;/em&gt; para Injeção de Dependência, deixa seu código &lt;em&gt;dependente&lt;/em&gt; do próprio &lt;em&gt;framework&lt;/em&gt; que gerencia as dependências!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Os Atributos/Anotações que informam quais atributos do Objeto devem ser inicializados “magicamente” utilizando &lt;em&gt;reflection/RTTI&lt;/em&gt; ou utilizando &lt;a href=&quot;https://en.wikipedia.org/wiki/Service_locator_pattern&quot;&gt;&lt;em&gt;Services Locators&lt;/em&gt;&lt;/a&gt;, retiram do Objeto seus &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt;, tornando-o &lt;em&gt;anêmico&lt;/em&gt; e &lt;em&gt;procedural&lt;/em&gt;, pois é preciso chamar &lt;a href=&quot;/posts/getters-e-setters/#setters&quot;&gt;&lt;em&gt;Setters&lt;/em&gt;&lt;/a&gt; para “configurar” o Objeto antes de fazer algo de útil com ele. Seu uso é totalmente desencorajado pois viola o &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; transformando o Objeto num &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/#objeto-nao-e-um-balde-de-funcoes-e-dados&quot;&gt;“saco de dados”&lt;/a&gt;, além de introduzir &lt;a href=&quot;http://blog.ploeh.dk/2011/05/24/DesignSmellTemporalCoupling/&quot;&gt;acoplamento temporal&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Arquivos XML de configuração que armazenam quais Classes serão utilizadas para instanciar tais &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt; é algo abominável: é estático, não segue o princípio &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY&lt;/a&gt;, e não tem checagem de sintaxe.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tais “soluções” criam, na verdade, outros problemas.&lt;/p&gt;

&lt;p&gt;Mas, e se fosse possível ter um código mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, sem XML, sem Atributos/Anotações ou mesmo sem &lt;em&gt;Frameworks&lt;/em&gt;, para trabalharmos com a Injeção de Dependência utilizando &lt;em&gt;somente&lt;/em&gt; Classes e Objetos, você iria continuar utilizando outros artefatos complexos?&lt;/p&gt;

&lt;p&gt;Vamos ver quais são os tipos de dependências mais utilizadas e então veremos se é possível termos soluções simples para cada uma delas.&lt;/p&gt;

&lt;h2 id=&quot;dependencia-por-construtor&quot;&gt;Dependência por Construtor&lt;/h2&gt;

&lt;p&gt;Dependência por Construtor é a maneira mais simples e eficaz de resolver dependências entre Objetos.&lt;/p&gt;

&lt;p&gt;Esse é o tipo de &lt;em&gt;dependência pura&lt;/em&gt; que é negligenciado por muitos desenvolvedores.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;THash.New(
  TFile.New(&#39;file.xml&#39;).Stream
).Calc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima a Classe &lt;code&gt;THash&lt;/code&gt; recebe um &lt;code&gt;Stream&lt;/code&gt; (dependência) no seu construtor. Obviamente o tipo do argumento é uma Interface (ex: &lt;code&gt;IStream&lt;/code&gt;) para que não haja uma dependência “física” entre as Classes.&lt;/p&gt;

&lt;p&gt;Não há &lt;em&gt;nenhum&lt;/em&gt; problema a ser solucionado aqui. Essa é a forma mais correta e eficaz para “injetar” uma dependência.&lt;/p&gt;

&lt;p&gt;Sempre tente utilizar construtores para passar as dependências para os Objetos. A única exigência é que os argumentos do construtor sejam do tipo Interface ao invés de Classes.&lt;/p&gt;

&lt;h2 id=&quot;dependencia-por-decoracao&quot;&gt;Dependência por Decoração&lt;/h2&gt;

&lt;p&gt;A utilização de bibliotecas (Libs) é muito útil para desenvolvermos mais rápido. Ao invés de criamos tudo que o software precisa, podemos delegar vários serviços às Libs especialistas no assunto. É como “contratar” consultores profissionais para cada especialidade.&lt;/p&gt;

&lt;p&gt;O “problema” é que essas Libs utilizam seus próprios Objetos. Bem, elas sabem o que fazem, porém há momentos que gostaríamos de “dizer” a essas Libs quais Objetos deveriam retornar em alguns momentos.&lt;/p&gt;

&lt;p&gt;Seria interessante se pudéssemos &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;decorar&lt;/a&gt; instâncias retornadas por Objetos pertencentes a Lib.&lt;/p&gt;

&lt;p&gt;Por exemplo. No código abaixo nós obtemos uma instância de um Objeto que representa um Atributo num arquivo XML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Attr := 
  TXMLPack.New(
    TFile.New(&#39;file.xml&#39;).Stream
  )
  .Node(&#39;/root&#39;)
  .Attrs
  .Item(&#39;id&#39;);
ShowMessage(Attr.Text);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que o desenvolvedor não tem controle sobre como a Lib irá instanciar esse Objeto internamente, pois primeiro &lt;code&gt;TXMLPack&lt;/code&gt; retorna outro Objeto em &lt;code&gt;Node()&lt;/code&gt; e então retorna uma lista &lt;code&gt;Attrs&lt;/code&gt; para então pesquisar e retornar a instância que queremos.&lt;/p&gt;

&lt;p&gt;É claro que podemos decorar qualquer instância retornada por qualquer Lib dentro do nosso próprio código, mas teríamos que fazer isso todas as vezes em todos os lugares.&lt;/p&gt;

&lt;p&gt;Por exemplo, se quiséssemos decorar instâncias de &lt;code&gt;TXMLAttribute&lt;/code&gt; (Lib) com a nossa Classe &lt;code&gt;TMyAttribute&lt;/code&gt;, teríamos que implementar dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node := TXMLPack.New(
  TFile.New(&#39;file.xml&#39;).Stream
)
.Node(&#39;/root&#39;);

// id attribute
IdAttr := 
  TMyAttribute.New(
    Node(&#39;/root&#39;).Attrs.Item(&#39;id&#39;)
  );

// name attribute
NameAttr := 
  TMyAttribute.New(
    Node(&#39;/root&#39;).Attrs.Item(&#39;name&#39;)
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja acima que foi preciso decorar cada instância (Atributos &lt;code&gt;id&lt;/code&gt; e &lt;code&gt;name&lt;/code&gt;) com a nossa Classe.&lt;/p&gt;

&lt;p&gt;Mas mesmo sendo um código &lt;em&gt;repetitivo&lt;/em&gt;, é &lt;em&gt;viável&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, se a Lib for desenvolvida para dar a opção ao desenvolvedor para decorar esses Objetos criados internamente, é provável que ela utilize o padrão &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_factory_pattern&quot;&gt;&lt;em&gt;Abstract Factory&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Essa seria uma opção simples para utilizar Injeção de Dependência de forma totalmente desacoplada e sem repetições.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ First we need to include a factory
  in some place of the code }
  
TXAttributeFactories.New
  .Add(
    // your own factory
    TMyAttributeFactory.New
  );

// ...  
  
{ Then, Lib&#39;s code will use these factories
  to decorate each new Attribute instance }
  
function TCAttributes.Item(AIndex: Integer): IXAttribute;
var
  A: TDOMNode;
begin
  A := FNode.Attributes.Item[AIndex];
  if not Assigned(A) then
    raise EXError.CreateFmt(
      &#39;Node not found on index %d.&#39;, [AIndex]
    );

  { At this point, factories instance will 
    find TMyAttributeFactory instance and it 
    will use to return a new instance, 
    wrapping TCAttribute instance }

  Result := 
    TXAttributeFactories.New
      .Decorate(
        TCAttribute.New(FNode, A)
      );
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código acima é do &lt;a href=&quot;https://github.com/mdbs99/xavier/blob/47240049ff594904a856320d0b6e4ed8c979529f/src/xavier.xml.fpc.pas#L179&quot;&gt;Projeto Xavier&lt;/a&gt;, porém a chamada à Classe &lt;code&gt;TXAttributeFactories&lt;/code&gt; é apenas uma simulação, exemplificando como a implementação poderia ser codificada.&lt;/p&gt;

&lt;p&gt;Veja que o método &lt;code&gt;Decorate(Attr: IXAttribute)&lt;/code&gt; recebe apenas uma instância já criada, ou seja, a fábrica não sabe como criar uma nova instância de &lt;code&gt;IXAttribute&lt;/code&gt;, ela apenas sabe como decorar uma instância já existente.&lt;/p&gt;

&lt;h2 id=&quot;dependencia-tardia&quot;&gt;Dependência Tardia&lt;/h2&gt;

&lt;p&gt;Chamo de dependência tardia quando um &lt;code&gt;Objeto A&lt;/code&gt; só precisa de uma instância &lt;code&gt;B&lt;/code&gt; num dado momento, dependendo de uma escolha do usuário ou evento externo. Em outras palavras, não sabemos se iremos precisar ou não da instância do &lt;code&gt;Objeto B&lt;/code&gt; quando estivermos compondo nossos Objetos para trabalhar numa determinada tarefa.&lt;/p&gt;

&lt;p&gt;Talvez esse tenha sido o grande problema que mais motivou a construção dos artefatos e &lt;em&gt;frameworks&lt;/em&gt; já citados.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo:&lt;/p&gt;

&lt;p&gt;Suponha que o &lt;code&gt;Objeto A&lt;/code&gt; receba uma conexão com um SGBD através de seu construtor e em um dos seus métodos é instanciado um &lt;code&gt;Objeto B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A instância de &lt;code&gt;B&lt;/code&gt; também precisa da conexão com o SGBD, então basta passarmos no construtor de &lt;code&gt;B&lt;/code&gt; a conexão já recebida no &lt;code&gt;Objeto A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então &lt;code&gt;B&lt;/code&gt;, em um de seus métodos, instancia e retorna um &lt;code&gt;Objeto C&lt;/code&gt; e, nesse caso, &lt;code&gt;C&lt;/code&gt; não precisa de uma conexão. No seu construtor não há nenhum argumento desse tipo.&lt;/p&gt;

&lt;p&gt;O programa continua e agora essa instância de &lt;code&gt;C&lt;/code&gt; precisa instanciar um &lt;code&gt;Objeto D&lt;/code&gt;. Esse último Objeto, tem métodos que retornam outros Objetos, porém para instanciá-los uma conexão ao SGBD é necessária… mas nesse ponto não temos esse Objeto da conexão.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A (conection)
  B (conection)
    C ()
      D ()
        E (conection ?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse é o &lt;em&gt;grande&lt;/em&gt; problema.&lt;/p&gt;

&lt;p&gt;Onde o &lt;code&gt;Objeto D&lt;/code&gt; iria conseguir uma conexão ao SGBD para utilizar como argumento na criação de outros Objetos que necessitam de tal argumento?&lt;/p&gt;

&lt;p&gt;Nas linguagens Funcionais, existe o conceito de &lt;a href=&quot;https://pt.wikipedia.org/wiki/Currying&quot;&gt;Currying&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ao invés de termos funções que recebem N parâmetros, haverá funções com apenas 1 parâmetro que chamará outra função, e outra, e mais outra…&lt;/p&gt;

&lt;p&gt;Esse vídeo explica o conceito:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/ZasXwtTRkio&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;No entanto, pode ser um conceito difícil de entender pra quem é acostumando com linguagens imperativas.&lt;/p&gt;

&lt;p&gt;Bem, não temos &lt;em&gt;Currying&lt;/em&gt; nas linguagens Orientadas a Objetos, mas temos &lt;em&gt;Classes&lt;/em&gt; e Objetos.&lt;/p&gt;

&lt;p&gt;Então, utilizando apenas Classes e Objetos, como podemos fazer a Injeção de Dependência e obter argumentos onde e quando for preciso?&lt;/p&gt;

&lt;p&gt;A resposta é a mesma: &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_factory_pattern&quot;&gt;&lt;em&gt;Abstract Factory&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, ao invés de apenas decorar uma instância, a fábrica iria criar uma nova do início.&lt;/p&gt;

&lt;p&gt;Essas fábricas teriam mais métodos, possivelmente métodos com as mesmas assinaturas dos construtores e &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Métodos New&lt;/a&gt; já existente na Classe original.&lt;/p&gt;

&lt;p&gt;No exemplo anterior, o método &lt;code&gt;Decorate(...)&lt;/code&gt; foi utilizado para decorar uma instância já existente. Aqui, sugiro utilizar a nomenclatura &lt;code&gt;Make(...)&lt;/code&gt; que irá criar uma nova instância.&lt;/p&gt;

&lt;p&gt;Esse tipo de fábrica seria muito mais utilizado em aplicações do que em Libs, no entanto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Injeção de Dependência é &lt;a href=&quot;http://blog.ploeh.dk/2017/01/27/dependency-injection-is-passing-an-argument/&quot;&gt;passagem de parâmetro&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Vimos nesse artigo algumas possíveis opções para resolver os tipos de Dependência mais comuns.&lt;/p&gt;

&lt;p&gt;Vimos que não é necessário &lt;em&gt;frameworks&lt;/em&gt; complexos ou qualquer outro artefato além de Classes e Objetos simples para utilizarmos Injeção de Dependência na sua forma mais pura.&lt;/p&gt;

&lt;p&gt;Infelizmente o espaço de um único artigo não é suficiente para implementarmos uma solução completa.&lt;/p&gt;

&lt;p&gt;Seja simples. Utilize Classes e respeite seus Objetos sem quebrar o encapsulamento.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/injecao-de-dependencia</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/injecao-de-dependencia</guid>
      </item>
    
      <item>
        <title>Nomeando Classes em Libraries</title>
        <description>&lt;p&gt;Veja nesse artigo algumas ideias que você deveria considerar ao nomear suas Classes em projetos do tipo Library.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-marcel-strauss-334864.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Marcel Strauß on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Uma Library ou Lib, para encurtar, é definida na &lt;a href=&quot;https://en.wikipedia.org/wiki/Library_(computing)&quot;&gt;Wikipedia&lt;/a&gt; como “uma coleção de subprogramas utilizados no desenvolvimento de software”.&lt;/p&gt;

&lt;p&gt;Eu gosto mais da próxima definição: “Uma Lib é também uma coleção de implementações de &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamento&lt;/a&gt;”.&lt;/p&gt;

&lt;p&gt;Não pense numa Lib somente em termos de arquivos dll/so. Vamos aumentar esse conceito. Pense em Libs como dll/so, pacotes de software ou até mesmo um programa. Pense em termos de definição de comportamento especializado.&lt;/p&gt;

&lt;p&gt;Uma Lib é — ou deveria ser — um especialista em um assunto, dentro de um contexto bem definido.&lt;/p&gt;

&lt;p&gt;Eu diria que é (quase) a mesma definição do Objeto.&lt;/p&gt;

&lt;p&gt;No entanto, enquanto há Objetos tão simples com apenas um método, uma Lib parece mais como uma composição de muitos Objetos, trabalhando colaborativamente entre si, fazendo emergir um comportamento especializado.&lt;/p&gt;

&lt;p&gt;Os Objetos são como peças intercambiáveis. Podem ser simples ou complexos através do uso da composição.&lt;/p&gt;

&lt;p&gt;Uma Lib, eu acredito, é uma personificação de alguma entidade especializada.&lt;/p&gt;

&lt;p&gt;E toda entidade precisa ter um nome.&lt;/p&gt;

&lt;h2 id=&quot;lib&quot;&gt;Nomeando uma Lib&lt;/h2&gt;

&lt;p&gt;Há muitos anos eu já publicava alguns pequenos projetos no &lt;a href=&quot;https://sourceforge.net/&quot;&gt;SourceForge&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A maioria desses projetos eram pequenos pacotes de componentes para Delphi mas, apesar de ter tido alguns pouquíssimos colaboradores, tais projetos nunca foram relevantes para a comunidade.&lt;/p&gt;

&lt;p&gt;Bem, eu sabia quase nada sobre OpenSource e também não tinha muita experiência em desenvolvimento, então utilizei isso apenas como um aprendizado.&lt;/p&gt;

&lt;p&gt;Na época eu nomeava meus pacotes de componentes com nomes abstratos. Eles não representavam uma entidade especializada. Eram apenas arquivos agrupados num pacote. Um bom nome não era relevante naquela época — eu pensava.&lt;/p&gt;

&lt;p&gt;Anos se passaram.&lt;/p&gt;

&lt;p&gt;Então, eu aprendi mais sobre &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt; e &lt;a href=&quot;https://en.wikipedia.org/wiki/Semantics&quot;&gt;semântica&lt;/a&gt; e como é importante utilizar bons nomes nos identificadores no código.&lt;/p&gt;

&lt;p&gt;Dizem que &lt;em&gt;nomear coisas e invalidar cache&lt;/em&gt; são as duas coisas mais difíceis de fazer na computação. E é verdade.&lt;/p&gt;

&lt;p&gt;Nomear coisas é difícil. Nunca fica perfeito. Escolhemos um nome pensando ser a melhor opção e daqui a duas horas estamos refatorando e renomeando…&lt;/p&gt;

&lt;p&gt;É quase uma &lt;em&gt;arte&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Muitas vezes demora mais tempo para descobrirmos que um nome não foi bem escolhido.&lt;/p&gt;

&lt;p&gt;Há pouco mais de 5 anos atrás eu publiquei um projeto OpenSource chamado &lt;a href=&quot;https://github.com/mdbs99/greyhound&quot;&gt;Greyhound&lt;/a&gt;, mas muitos não sabem qual o motivo da escolha desse nome.&lt;/p&gt;

&lt;p&gt;Aqui está a explicação: Enquanto a &lt;em&gt;Cheetah&lt;/em&gt; (símbolo do Free Pascal) é o animal terrestre mais rápido, &lt;em&gt;Greyhound&lt;/em&gt; é a raça mais rápida entre cães.&lt;/p&gt;

&lt;p&gt;E o que esse nome tem haver com um projeto que abstrai entidades de um Banco de Dados? — você pode estar pensando.&lt;/p&gt;

&lt;p&gt;É, concordo com você que esse nome não foi uma boa escolha.&lt;/p&gt;

&lt;p&gt;Mas ainda acho que é um nome bem interessante. Talvez para uma Lib que trabalhe com &lt;em&gt;stream&lt;/em&gt; de dados ou um novo sistema operacional. Talvez algo relacionado a velocidade? Não sei.&lt;/p&gt;

&lt;p&gt;Pode não ter sido a melhor escolha para o meu projeto, mas por causa dele eu passei a utilizar nomes cada vez mais comuns.&lt;/p&gt;

&lt;p&gt;Hoje em dia todos os meus projetos (privados) ganham nomes próprios comuns. Alguns desses nomes provocam sorrisos em reuniões sempre que são pronunciados. Não devido ao nome em si, mas devido a relação do nome com o sistema que ele representa.&lt;/p&gt;

&lt;p&gt;Eu também levei essa nomenclatura para o mundo OpenSource através das minhas Libs mais recentes: &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James&lt;/a&gt; e &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;Xavier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Se esses são bons nomes ou não, você decide.&lt;/p&gt;

&lt;p&gt;O aprendizado aqui é que bons nomes podem fazer a diferença pois o nome não será utilizado apenas na URL do seu projeto, mas sim em (quase) todas as Classes.&lt;/p&gt;

&lt;h2 id=&quot;classes&quot;&gt;Nomeando Classes&lt;/h2&gt;

&lt;p&gt;Na época do SourceForge minhas Classes tinham minhas iniciais “MD” como prefixo ou qualquer outras “duas letras” abstratas.&lt;/p&gt;

&lt;p&gt;Prefixos. Vemos essa prática ainda hoje em dia para diminuir a colisão de nomes entre classes similares. Exemplo: &lt;code&gt;TAbStream&lt;/code&gt; vs &lt;code&gt;TCdStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Essa prática é visto até mesmo em grandes &lt;em&gt;frameworks&lt;/em&gt; e outros ecosistemas como Java e C#.&lt;/p&gt;

&lt;p&gt;Por quê?&lt;/p&gt;

&lt;p&gt;Bem, precisamos diferenciar a classe padrão &lt;code&gt;TStream&lt;/code&gt; da sua &lt;code&gt;TMyStream&lt;/code&gt;, por exemplo.&lt;/p&gt;

&lt;p&gt;Poderíamos utilizar a Unidade como prefixo, mas ninguém gosta de escrever o nome totalmente qualificado como &lt;code&gt;acme.streams.TStream&lt;/code&gt; sempre que tiver que usar a Classe &lt;code&gt;TStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então o prefixo &lt;code&gt;My&lt;/code&gt;, nesse caso, faz diferença.&lt;/p&gt;

&lt;p&gt;No entanto, um grande problema é que não controlamos os prefixos que são utilizados em projetos ao redor do mundo. Eu quero dizer, por exemplo, que se você escolhe &lt;code&gt;Ab&lt;/code&gt; como prefixo de suas Classes, é bem possível que exista alguma outra Lib que já utiliza esse prefixo — e tem, chama-se &lt;a href=&quot;https://github.com/TurboPack/Abbrevia&quot;&gt;Abbrevia&lt;/a&gt; e eu a utilizo.&lt;/p&gt;

&lt;p&gt;O prefixo &lt;code&gt;Ab&lt;/code&gt; deixa os identificadores pequenos — o que é bom — porém a ambiguidade continua existindo, visto que, por serem apenas 2 letras, a probabilidade é que outro desenvolvedor já tenha escolhido esse mesmo prefixo.&lt;/p&gt;

&lt;p&gt;E esse não é o maior problema.&lt;/p&gt;

&lt;p&gt;É comum utilizarmos prefixos em grandes sistemas, compostos de muitos módulos, representando implementações diferentes para um mesmo conceito. Então se um desses prefixos for &lt;code&gt;Ab&lt;/code&gt; e já estiver sendo utilizado dentro de um grande sistema — imagine que esse prefixo faz todo o sentido para o sistema da empresa, podendo representar uma área, setor ou algo bem importante — a ambiguidade é ainda pior, visto que poderia confundir o desenvolvedor: “Essa é uma Classe da empresa ou da Lib?”.&lt;/p&gt;

&lt;p&gt;É claro que basta posicionarmos o mouse em cima do identificador para vermos um &lt;em&gt;hint&lt;/em&gt; com a informação de qual unidade ele pertence. Mas, e se você já utiliza o mesmo nome como &lt;code&gt;TAbStream&lt;/code&gt; (exemplo dado acima) dentro um grande sistema? Você muda o identificador que faz mais sentido para empresa para não conflitar com o identificador da Lib ou &lt;a href=&quot;/redeclarando-classes&quot;&gt;redefine&lt;/a&gt; todas as Classes da Lib?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Nomear coisas e invalidar cache são as duas tarefas mais difíceis na computação.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Acredito que muitos desenvolvedores nem sequer pensam nesses conflitos.&lt;/p&gt;

&lt;p&gt;“Ei! O código está funcionando, é o que importa”, eles dizem.&lt;/p&gt;

&lt;p&gt;Bem, existem bons profissionais, outros nem tanto.&lt;/p&gt;

&lt;p&gt;E como resolver esse impasse?&lt;/p&gt;

&lt;p&gt;Como ter identificadores curtos, porém com uma boa semântica?&lt;/p&gt;

&lt;p&gt;Como diminuir ou (quase) acabar com conflitos de nomenclatura?&lt;/p&gt;

&lt;p&gt;Minha única resposta é: Não use prefixos abstratos em Classes, use um &lt;em&gt;nome&lt;/em&gt; de verdade.&lt;/p&gt;

&lt;p&gt;O primeiro passo é escolher um bom nome: Simples, memorável e que represente um &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contexto&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;contextualizando&quot;&gt;Contextualizando&lt;/h2&gt;

&lt;p&gt;Um contexto encapsula uma possível implementação para um determinado problema.&lt;/p&gt;

&lt;p&gt;Ao invés de utilizar &lt;code&gt;TAbStream&lt;/code&gt;, você utilizaria &lt;code&gt;TAbbreviaStream&lt;/code&gt;, por exemplo — eu não sei se tal Classe realmente existe nessa Lib.&lt;/p&gt;

&lt;p&gt;Não parece muito, mas essa pequena alteração pode fazer uma grande diferença em médios a grandes sistemas.&lt;/p&gt;

&lt;p&gt;Ao invés de termos apenas 2 letras abstratas, temos um nome que identifica um contexto.&lt;/p&gt;

&lt;p&gt;Esse contexto é o mesmo que dizer: “Essa é a implementação de Abbrevia para representar um &lt;em&gt;Stream&lt;/em&gt;” — essa seria a “tradução” ao vermos a Classe &lt;code&gt;TAbbreviaStream&lt;/code&gt; declarada no código.&lt;/p&gt;

&lt;p&gt;É muito menos provável que outra Lib, com a mesma especialidade, utilize o mesmo nome. A probabilidade diminui ao utilizarmos mais letras, concorda?&lt;/p&gt;

&lt;p&gt;Além disso, é muito menos provável que você utilize nomes assim para representar contextos (área, setor ou algo bem importante) dentro de um sistema da empresa.&lt;/p&gt;

&lt;p&gt;Esse foi o tipo de refatoração que fiz a poucos dias no projeto &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;Xavier&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Uma Lib é um especialista em determinado assunto. Dar um nome memorável, apropriado e curto a sua Lib irá facilitar tanto a identificação das Classes quando o uso da mesma.&lt;/p&gt;

&lt;p&gt;Evite o uso de prefixos abstratos. Eles não eliminam a ambiguidade e podem tornar as coisas ainda mais confusas, caso você tenha outros pacotes que, por ventura, utilize o mesmo prefixo.&lt;/p&gt;

&lt;p&gt;Escolha nomes simples, de fácil memorização, curtos o suficiente, que tenham alguma relação ou que personifique a entidade especializada.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Oct 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/nomeando-classes-em-libraries</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/nomeando-classes-em-libraries</guid>
      </item>
    
      <item>
        <title>Versionando e Organizando seus Pacotes</title>
        <description>&lt;p&gt;O desenvolvimento de Pacotes reutilizáveis pode se tornar complicado quando cada projeto está utilizando diferentes versões do mesmo pacote.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-neonbrand-345038.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by NeONBRAND on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A modularização de sistemas é um conceito muito abrangente. Podemos modularizar um projeto desde o nível de arquivos (unidades) até o uso de WebServices e Microservices executando em servidores completamente distintos.&lt;/p&gt;

&lt;p&gt;Nesse meio, temos a modularização por Pacotes.&lt;/p&gt;

&lt;p&gt;Acredito que o uso de Pacotes seja o meio mais eficaz e simples para modularizar sistemas pequenos a médios.&lt;/p&gt;

&lt;p&gt;Até mesmo grandes sistemas podem (e devem) se beneficiar do uso de Pacotes, porém como a interoperabilidade com outras aplicações é quase mandatória em sistemas maiores, outras técnicas de modularização devem ser utilizadas em complemento.&lt;/p&gt;

&lt;p&gt;Mas essa eficácia tem um (baixo) custo que é &lt;del&gt;gastar&lt;/del&gt; investir parte do tempo do desenvolvimento na organização e versionamento desses Pacotes.&lt;/p&gt;

&lt;p&gt;Eu já escrevi sobre esse assunto &lt;a href=&quot;/posts/pacotes-e-versoes-no-lazarus/&quot;&gt;aqui&lt;/a&gt;, porém esse artigo é um aprimoramento sobre como versionar e consequentemente organizar seus Pacotes no &lt;a href=&quot;http://www.lazarus-ide.org/&quot;&gt;Lazarus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Talvez as ideias a seguir possam funcionar também no Delphi, mas eu não sei. Eu não encontrei nenhum artigo sobre como ter mais de uma versão de um mesmo (&lt;em&gt;runtime&lt;/em&gt;) Pacote no Delphi. Na verdade encontrei &lt;em&gt;workarounds&lt;/em&gt; estranhas como &lt;a href=&quot;https://stackoverflow.com/a/998096&quot;&gt;essa resposta&lt;/a&gt; no &lt;em&gt;StackOverflow&lt;/em&gt; sobre como instalar múltiplas versões.&lt;/p&gt;

&lt;h2 id=&quot;pacotes-registrados&quot;&gt;Pacotes Registrados&lt;/h2&gt;

&lt;p&gt;No Lazarus, todo Pacote &lt;em&gt;runtime&lt;/em&gt; é registrado automaticamente na IDE quando você o compila. Simples assim. Abra o Pacote. Compile. Pronto.&lt;/p&gt;

&lt;p&gt;Após o “registro” do Pacote, ele estará disponível para ser adicionado em qualquer projeto através da janela do &lt;em&gt;“Project Inspector -&amp;gt; Required Packages”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Essa funcionalidade é muito, muito útil para a modularização de qualquer projeto.&lt;/p&gt;

&lt;p&gt;Imagine você poder criar um Pacote a qualquer momento, adicionar algumas Unidades e tê-lo disponível para uso sem preocupações com &lt;em&gt;paths&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ao abrirmos a janela &lt;em&gt;Required Packages&lt;/em&gt;, todos os pacotes registrados aparecem numa &lt;em&gt;combo box&lt;/em&gt; com auto-completar ao digitar.&lt;/p&gt;

&lt;p&gt;Quase perfeito.&lt;/p&gt;

&lt;p&gt;No entanto, é comum um Pacote ser utilizado por mais de um projeto. Então, se modificarmos algo nesse Pacote compartilhado, talvez todos os projetos que o utilizam deverão sofrer alterações… o que pode ser um problema caso você tenha dezenas de projetos ou mais.&lt;/p&gt;

&lt;p&gt;Mas, e se tivermos múltiplas versões de um mesmo Pacote, sendo que cada projeto poderá escolher qual versão utilizar?&lt;/p&gt;

&lt;p&gt;Isso resolveria o problema.&lt;/p&gt;

&lt;h2 id=&quot;versionamento&quot;&gt;Versionamento&lt;/h2&gt;

&lt;p&gt;Quando desenvolvemos um Pacote, na maioria das vezes, temos 2 objetivos primários: Modularização e  Compartilhamento.&lt;/p&gt;

&lt;p&gt;Modularizar o sistema em pequenas partes mais gerenciáveis, encapsulando contextos menores e bem definidos, facilita o desenvolvimento e a manutenção de todo o sistema. A modularização por Pacotes já nos dá um grande benefício.&lt;/p&gt;

&lt;p&gt;No entanto, acredito que a principal razão para a maioria dos desenvolvedores criarem pacotes é devido ao compartilhamento de Unidades entre projetos. Esse é um pensamento lógico e razoável. Mas se algo é compartilhado entre mais de um projeto, como ter o controle de qualidade ao fazer uma mudança no código do Pacote que é utilizado em muitos lugares?&lt;/p&gt;

&lt;p&gt;Por exemplo, se você alterar a interface de uma Classe, acrescentar mais um método numa Interface, remover algo que não é mais necessário, etc, como saber quais projetos serão afetados?&lt;/p&gt;

&lt;p&gt;Não há como saber.&lt;/p&gt;

&lt;p&gt;Então você segue em frente e faz as alterações necessárias no seu Pacote e também no seu projeto atual, sem pensar nos projetos mais antigos.&lt;/p&gt;

&lt;p&gt;Poderia haver outros projetos que utilizam o mesmo Pacote e que, ao tentar compilá-los futuramente, eles não irão compilar e você teria que lembrar o que fez anteriormente e ir alterando cada parte do projeto para torná-lo compatível com a nova versão do Pacote, novamente.&lt;/p&gt;

&lt;p&gt;É claro, você terá que fazer isso em algum momento. O problema é que abrimos projetos antigos, na maioria das vezes, apenas para acrescentar ou consertar algo. E o que em teoria seria uma tarefa simples, poderia demorar horas ou dias apenas por que você, primeiro, terá que compatibilizar o código do projeto com o código do seu Pacote recém alterado.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;solução&lt;/em&gt; é o versionamento dos Pacotes.&lt;/p&gt;

&lt;p&gt;Todo Pacote (compartilhado entre projetos) deve ser versionado. Isso quer dizer que você terá que ter N diretórios do mesmo Pacote, ou seja, cada diretório irá tratar de uma específica versão do Pacote. A versão é definida pelos números Mínimo e Máximo para cada versão do Pacote.&lt;/p&gt;

&lt;p&gt;Tendo essas versões definidas, basta &lt;a href=&quot;http://wiki.freepascal.org/Lazarus_Packages#Using_minimum.2C_maximum_version&quot;&gt;escolhermos&lt;/a&gt; uma versão mínima para cada projeto quando o Pacote for incluído como uma dependência.&lt;/p&gt;

&lt;p&gt;As versões de dependência do(s) Pacote(s), que ficam gravadas nos arquivos do projeto, é tudo que o Lazarus precisa saber para carregar a versão correta quando um projeto for aberto na IDE.&lt;/p&gt;

&lt;p&gt;E, &lt;em&gt;voilá&lt;/em&gt;! Você não precisa mas alterar todos os projetos que utilizam determinado Pacote. Você pode evoluir a versão mais atual, mas mantendo as versões antigas totalmente funcionais. Então, ao abrir projetos antigos, você só iria fazer modificações para utilizar a versão do Pacote mais atual se, e somente se, fosse estritamente necessário. Do contrário, continue trabalhando com a versão antiga que o projeto já utilizava anteriormente, pois ela não deixou de funcionar.&lt;/p&gt;

&lt;p&gt;Perfeito agora?&lt;/p&gt;

&lt;h2 id=&quot;solucao&quot;&gt;Fluxo, Organização e Desenvolvimento&lt;/h2&gt;

&lt;p&gt;Se quisermos ter um sistema simples, eficaz e organizado, precisamos dedicar algum tempo à sua manutenção ao invés de somente codificar as &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#regras-de-negocio&quot;&gt;Regras de Negócio&lt;/a&gt; do projeto.&lt;/p&gt;

&lt;p&gt;Ao criamos esses Pacotes, precisamos definir um fluxo de trabalho para que tudo dê certo não só agora, mas principalmente no longo prazo.&lt;/p&gt;

&lt;p&gt;Hoje em dia, com o acesso quase irrestrito a informação, qualquer programador iniciante consegue criar um pequeno ou médio sistema totalmente funcional. Mas o que separa programadores iniciantes dos verdadeiros profissionais, é a arquitetura bem estruturada dos projetos, Pacotes, e todo o resto… no longo prazo.&lt;/p&gt;

&lt;h3 id=&quot;passo-a-passo&quot;&gt;Passo a Passo&lt;/h3&gt;

&lt;p&gt;Essa é a maneira que utilizo para organizar meus Pacotes ou Libs:&lt;/p&gt;

&lt;p&gt;A primeira coisa a fazer, é criar o diretório do Pacote e depois um subdiretório para o primeiro &lt;em&gt;release&lt;/em&gt; — normalmente a versão 1.0.&lt;/p&gt;

&lt;p&gt;Diferentemente do que eu disse &lt;a href=&quot;/posts/pacotes-e-versoes-no-lazarus/#preferencial&quot;&gt;aqui&lt;/a&gt; sobre a nomenclatura, considere nomear os diretórios de Pacotes com o número da versão correspondente — para projetos, no entanto, a nomenclatura sugerida continua válida — mas isso não faz diferença para o compilador, sendo apenas uma questão de organização visual.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yourpack
  |
  1.0
    |
    bin  : todos os arquivos binários e libs
    |
    pkg  : pacotes e configurações
    |
    src  : fontes de produção
    |
    test : fontes de testes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Segundo, você irá trabalhar nos fontes do seu Pacote. Irá criar Unidades, implementar testes, projeto com os testes, etc. Não esqueça de definir a versão atual real, por exemplo, 0.8 (lembre-se que ainda não chegamos na versão 1.0.&lt;/p&gt;

&lt;p&gt;Então, digamos que ele já pode ser utilizado em algum dos seus projetos, mesmo que a versão atual não seja a 1.0.&lt;/p&gt;

&lt;p&gt;Terceiro, você vai adicionar ao seu projeto uma nova dependência para o seu pacote, mas ao adicioná-lo no projeto, irá definir a versão &lt;em&gt;mínima&lt;/em&gt; de uso que, atualmente, é a 0.8.&lt;/p&gt;

&lt;p&gt;A versão &lt;em&gt;máxima&lt;/em&gt; de uso é opcional (nesse caso) pois mesmo que você atualize a versão do Pacote para, digamos 0.9.2, seu projeto continuará funcionando pois apenas a versão mínima foi definida.&lt;/p&gt;

&lt;p&gt;O Lazarus procura os Pacotes pelo seu nome, versão e &lt;em&gt;path&lt;/em&gt;, no arquivo &lt;code&gt;packagesfiles.xml&lt;/code&gt;, que é gerenciado pela IDE.&lt;/p&gt;

&lt;p&gt;Então, ambos os projetos (seu projeto e o Pacote) vão sendo atualizados, até que você resolve publicar a versão 1.0 do Pacote — determinado pelo mesmo nome do diretório.&lt;/p&gt;

&lt;p&gt;Nesse momento, você irá fazer um cópia do diretório &lt;code&gt;/1.0&lt;/code&gt; para gerar um novo diretório, por exemplo o &lt;code&gt;/2.0&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yourpack
  |
  2.0
    |
    bin  : todos os arquivos binários e libs
    |
    doc  : toda a documentação
    |
    pkg  : pacotes e configurações
    |
    src  : fontes de produção
    |
    test : fontes de testes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que, hipoteticamente, somente na versão 2.0 foi criado um diretório &lt;code&gt;/doc&lt;/code&gt; com a documentação do projeto. Está evoluindo…&lt;/p&gt;

&lt;p&gt;A partir do diretório 2.0 você irá continuar seu trabalho com as próximas versões: 1.1, 1.2… até chegar na 2.0 quando o ciclo recomeça.&lt;/p&gt;

&lt;p&gt;No meio desse ciclo, imagine que seu cliente, dono do primeiro projeto de exemplo, abre um &lt;em&gt;ticket&lt;/em&gt;  relatando um problema. Você então abre o antigo projeto e “magicamente” a IDE faz o &lt;em&gt;load&lt;/em&gt; da versão correta do Pacote, ou seja, a versão 1.0 que esse projeto ainda utiliza. Você não precisa compatibilizar esse projeto com a versão 2.0 do seu Pacote agora. Você pode (deve) fazer isso mais tarde, pois a prioridade agora é resolver o &lt;em&gt;ticket&lt;/em&gt; do seu cliente.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Na conclusão do &lt;a href=&quot;/posts/pacotes-e-versoes-no-lazarus/&quot;&gt;artigo&lt;/a&gt; anterior sobre esse assunto, eu disse que &lt;a href=&quot;http://wiki.freepascal.org/Lazarus_Packages#Different_versions_of_a_package&quot;&gt;marcava&lt;/a&gt; as dependências como &lt;em&gt;preferencial&lt;/em&gt; — opção que utiliza o &lt;em&gt;path&lt;/em&gt; do pacote, não a versão. Porém, percebi que utilizando o fluxo descrito acima eu teria &lt;em&gt;liberdade&lt;/em&gt; na configuração das dependências do meu projeto. O &lt;em&gt;path&lt;/em&gt; seria gerenciado pela IDE e para utilizar novas versões dos Pacotes bastaria mudar os números mínimo e máximo.&lt;/p&gt;

&lt;p&gt;Para a maioria dos desenvolvedores, Pacotes são sinônimos de Componentes instalados na IDE. Mas eles são muito mais que isso.&lt;/p&gt;

&lt;p&gt;A modularização de sistemas utilizando Pacotes sempre foi muito negligenciada e espero que esse artigo tenha aberto seus olhos.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Sep 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/versionando-e-organizando-seus-pacotes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/versionando-e-organizando-seus-pacotes</guid>
      </item>
    
      <item>
        <title>Xavier Package</title>
        <description>&lt;p&gt;Xavier é uma biblioteca leve, Orientada a Objetos, para trabalhar com XML.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-xavier.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Hoje em dia, todas as bibliotecas XML são muito complexas. Cada classe pode ter tantos métodos que pode ser muito difícil utilizá-las e compreendê-las. Essas implementações são muito procedurais também.&lt;/p&gt;

&lt;p&gt;Que tal se tivéssemos uma &lt;em&gt;Library&lt;/em&gt; leve, &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientada a Objetos&lt;/a&gt;, que trabalha com XML e que compila em &lt;a href=&quot;https://freepascal.org/&quot;&gt;&lt;em&gt;Free Pascal&lt;/em&gt;&lt;/a&gt; e &lt;a href=&quot;https://www.embarcadero.com/products/delphi&quot;&gt;&lt;em&gt;Delphi&lt;/em&gt;&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Hoje quero apresentar a você o meu mais novo projeto.&lt;/p&gt;

&lt;h2 id=&quot;xavier&quot;&gt;Xavier&lt;/h2&gt;

&lt;p&gt;Eu não trabalhava no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt; já fazia mais ou menos um mês. Além da falta de tempo — os projetos dos clientes são prioridade, certo? — &lt;del&gt;temos&lt;/del&gt; tínhamos uma &lt;a href=&quot;https://github.com/mdbs99/james/issues/65&quot;&gt;&lt;em&gt;issue&lt;/em&gt;&lt;/a&gt; que não nos deixava prosseguir.&lt;/p&gt;

&lt;p&gt;Estávamos tentando compatibilizar o código com o &lt;em&gt;Delphi&lt;/em&gt;, porém a parte que trata de XML é um tanto complicado.&lt;/p&gt;

&lt;p&gt;O maior problema é que o &lt;em&gt;Free Pascal&lt;/em&gt; não tem a mesma implementação do &lt;em&gt;Delphi&lt;/em&gt; para leitura e escrita de &lt;em&gt;streams&lt;/em&gt; e arquivos XML.&lt;/p&gt;

&lt;p&gt;No &lt;em&gt;Free Pascal&lt;/em&gt; a implementação é baseada apenas em Classes, enquanto no &lt;em&gt;Delphi&lt;/em&gt; a implementação é baseada em Interfaces — ponto para o &lt;em&gt;Delphi&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Os desenvolvedores do &lt;em&gt;Free Pascal&lt;/em&gt; sempre tentam compatibilizar suas implementações com o &lt;em&gt;Delphi&lt;/em&gt; porém, ao que parece, a implementação de XML no &lt;em&gt;Free Pascal&lt;/em&gt; foi feita &lt;em&gt;antes&lt;/em&gt; da implementação do &lt;em&gt;Delphi&lt;/em&gt; e eles escolheram fazer tudo apenas com Classes.&lt;/p&gt;

&lt;p&gt;A maioria das &lt;em&gt;libs&lt;/em&gt; que são compativeis entre ambos os compiladores utilizam-se de &lt;a href=&quot;/diretivas-de-compilacao&quot;&gt;diretivas de compilação&lt;/a&gt; para que seus códigos funcionem. Essa técnica, apesar de muito útil, pode transformar seu código em “espaguete” rapidamente.&lt;/p&gt;

&lt;p&gt;Veja esse exemplo de como salvar um &lt;code&gt;TXMLDocument&lt;/code&gt; em &lt;em&gt;stream&lt;/em&gt;, no compilador &lt;em&gt;Free Pascal&lt;/em&gt; e &lt;em&gt;Delphi&lt;/em&gt;, utilizando diretivas:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/c630eb809a9d030917af1efcd7e453d6.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;E que tal isso?&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/96e6f11f9a2184e4e9e932202751b9d0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Meio bizarro, improdutivo e confuso, não?&lt;/p&gt;

&lt;p&gt;Quero escrever código mais elegante, limpo e sustentável usando a Orientação a Objetos e, infelizmente, as opções &lt;em&gt;Open Source&lt;/em&gt; atuais não foram suficientes, considerando meus critérios pessoais.&lt;/p&gt;

&lt;p&gt;Então, criei o &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;Xavier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O principal objetivo do Xavier é substituir o código procedural comum em nossos projetos, que podem ter tantas condicionais e variáveis, num código mais declarativo e Orientado a Objetos, para trabalhar mais facilmente com o XML, sem diretivas de compilação no código final.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A implementação do Xavier ainda está no início mas todo o código disponível hoje está funcionando, com cobertura de testes automatizados.&lt;/p&gt;

&lt;p&gt;Eu escrevi o código em apenas algumas horas. Ainda há muito o que fazer.&lt;/p&gt;

&lt;p&gt;Estou fazendo minha parte…&lt;/p&gt;

&lt;p&gt;E você, que tal fazer um &lt;a href=&quot;https://github.com/mdbs99/xavier#fork-destination-box&quot;&gt;&lt;em&gt;fork&lt;/em&gt;&lt;/a&gt; do projeto e colaborar?&lt;/p&gt;

&lt;p&gt;Link do projeto &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;https://github.com/mdbs99/xavier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 18 Sep 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/xavier-package</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/xavier-package</guid>
      </item>
    
      <item>
        <title>Inter-process Communication</title>
        <description>&lt;p&gt;Gostaria de modularizar seus sistemas &lt;em&gt;Object Pascal&lt;/em&gt; em pequenos executáveis mas não sabe como?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-climate-kic-350836.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Climate KIC on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Muitos sistemas começam simples. Uma dúzia de tabelas, alguns cadastros, um formulário de &lt;em&gt;login&lt;/em&gt; e poucas &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#regras-de-negocio&quot;&gt;Regras de Negócio&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Com o tempo é necessário ter alguns relatórios, mais cadastros, mais tabelas e muito mais Regras de Negócio.&lt;/p&gt;

&lt;p&gt;A complexidade vai aumentando cada vez mais. O que antes era simples, agora é um “monstro” monolítico.&lt;/p&gt;

&lt;p&gt;Essa história parece familiar?&lt;/p&gt;

&lt;p&gt;Isso já aconteceu comigo — mais de uma vez — e talvez esteja acontecendo com você agora mesmo.&lt;/p&gt;

&lt;p&gt;Hoje vou lhe apresentar uma técnica (antiga) para modularizar seus sistemas, facilitando a manutenção e, possivelmente, diminuir a complexidade do código.&lt;/p&gt;

&lt;p&gt;Esse artigo irá focar numa dessas técnicas chamada &lt;a href=&quot;https://en.wikipedia.org/wiki/Inter-process_communication&quot;&gt;Inter-process Communication&lt;/a&gt; ou IPC.&lt;/p&gt;

&lt;h2 id=&quot;ipc&quot;&gt;IPC&lt;/h2&gt;

&lt;p&gt;Um sistema pode ser modularizado de várias maneiras. Podemos utilizar algumas técnicas como DLL’s, &lt;a href=&quot;/posts/pacotes-e-versoes-no-lazarus/&quot;&gt;&lt;em&gt;Packages&lt;/em&gt;&lt;/a&gt;, WebServices, &lt;a href=&quot;/posts/microservices-delphi-parte-1/&quot;&gt;Microservices&lt;/a&gt; e algumas outras.&lt;/p&gt;

&lt;p&gt;O IPC permite que dois processos (executáveis) distintos se comuniquem entre si através de mensagens que são gerenciadas pelo sistema operacional.&lt;/p&gt;

&lt;p&gt;Essa técnica é muito utilizada por sistemas operacionais de microkernel como, por exemplo, o sistema operacional &lt;a href=&quot;http://www.minix3.org/&quot;&gt;MINIX3&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O objetivo principal é diminuir o número de funcionalidades de um executável monolítico, utilizando um &lt;em&gt;design&lt;/em&gt; mas modular, onde haverá uma comunicação entre processos colaborativos ao invés de haver um único processo que faz tudo.&lt;/p&gt;

&lt;p&gt;A comunicação por IPC é do tipo cliente/servidor, sendo que cada processo pode ser tanto um como outro ao mesmo tempo.&lt;/p&gt;

&lt;p&gt;Então, imagine projetar um sistema onde seus módulos seriam divididos em vários executáveis. Um módulo com as Regras de Negócio, outro de Relatórios para disponibilizá-los tanto na Web quanto no Desktop, outro para &lt;em&gt;login&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Alguns destes módulos seriam executados na mesma máquina e, portanto, seria mais vantajoso se esses executáveis se comunicassem através de mensagens gerenciadas pelo Sistema Operacional ao invés de utilizar uma nova camada de protocolos (REST, SOAP, etc). Para esses casos, podemos utilizar o IPC.&lt;/p&gt;

&lt;p&gt;Mas como implementá-lo?&lt;/p&gt;

&lt;h2 id=&quot;simpleipc&quot;&gt;SimpleIPC&lt;/h2&gt;

&lt;p&gt;No compilador &lt;a href=&quot;https://freepascal.org/&quot;&gt;&lt;em&gt;Free Pascal&lt;/em&gt;&lt;/a&gt; existe um &lt;em&gt;package&lt;/em&gt; chamado &lt;a href=&quot;https://svn.freepascal.org/svn/fpc/branches/fixes_3_0/packages/fcl-process/&quot;&gt;fcl-process&lt;/a&gt; que implementa o IPC.&lt;/p&gt;

&lt;p&gt;Essa implementação foi codificada numa única Unidade chamada &lt;code&gt;simpleipc.pp&lt;/code&gt; e é &lt;em&gt;cross-platform&lt;/em&gt;, ou seja, um único código que funciona em sistemas &lt;em&gt;Unix-like&lt;/em&gt; e &lt;em&gt;Windows&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O próprio &lt;a href=&quot;http://www.lazarus-ide.org/&quot;&gt;&lt;em&gt;Lazarus&lt;/em&gt;&lt;/a&gt; utiliza o &lt;em&gt;SimpleIPC&lt;/em&gt; para fazer a &lt;a href=&quot;http://wiki.freepascal.org/Help_protocol&quot;&gt;comunicação&lt;/a&gt; entre a IDE e o &lt;em&gt;Help Viewer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Basicamente são duas classes principais a saber:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A classe &lt;a href=&quot;http://lazarus-ccr.sourceforge.net/docs/fcl/simpleipc/tsimpleipcclient.html&quot;&gt;&lt;code&gt;TSimpleIPCClient&lt;/code&gt;&lt;/a&gt; implementa o envio das mensagens&lt;/li&gt;
  &lt;li&gt;A classe &lt;a href=&quot;http://lazarus-ccr.sourceforge.net/docs/fcl/simpleipc/tsimpleipcserver.html&quot;&gt;&lt;code&gt;TSimpleIPCServer&lt;/code&gt;&lt;/a&gt; implementa o recebimento das mensagens&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Exemplos de uso de ambas as Classes podem ser visto nos &lt;em&gt;demos&lt;/em&gt; disponibilizados no próprio &lt;em&gt;package&lt;/em&gt;, &lt;a href=&quot;https://svn.freepascal.org/svn/fpc/branches/fixes_3_0/packages/fcl-process/examples/&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;alternativas&quot;&gt;Alternativas&lt;/h2&gt;

&lt;p&gt;Para aqueles que não utilizam &lt;em&gt;Free Pascal&lt;/em&gt;, existe a opção de utilizar a implementação do &lt;em&gt;SimpleIPC&lt;/em&gt; no formato de DLL.&lt;/p&gt;

&lt;p&gt;O projeto &lt;a href=&quot;http://wiki.lazarus.freepascal.org/SimpleIPC_Library&quot;&gt;&lt;em&gt;SimpleIPC Library&lt;/em&gt;&lt;/a&gt; encapsula a implementação do &lt;em&gt;Free Pascal&lt;/em&gt; numa DLL que pode ser utilizada por praticamente qualquer linguagem.&lt;/p&gt;

&lt;p&gt;O código é bastante procedural — padrão em DLL’s — porém pode ser uma alternativa rápida para começar a utilizar essa técnica ao invés de implentá-la do zero.&lt;/p&gt;

&lt;p&gt;Considere que mesmo que sua linguagem já implemente tal padrão, talvez ele não seja compatível com outras linguagens. Nesses casos o uso de uma DLL padrão pode fazer sentido.&lt;/p&gt;

&lt;p&gt;No Windows o IPC pode ser “traduzido” como uma &lt;em&gt;Windows Message&lt;/em&gt; do tipo &lt;code&gt;WM_COPYDATA&lt;/code&gt;. Sabemos que é relativamente fácil trabalhar com mensagens do Windows no &lt;em&gt;Object Pascal&lt;/em&gt;  então, se o desenvolvimento for apenas para a plataforma Windows, talvez seja mais simples utilizar mensagens do tipo &lt;code&gt;WM_COPYDATA&lt;/code&gt;. Esses links &lt;a href=&quot;https://www.thoughtco.com/send-information-between-applications-1058476&quot;&gt;aqui&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/7257719/wm-copydata-string-not-appearing-in-target-application&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;https://stackoverflow.com/questions/7540706/wm-copydata-with-and-without-quotes-yields-different-results&quot;&gt;aqui&lt;/a&gt;, podem ajudar.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Nos anos 60 já existiam tais técnicas de modularização. No entanto, ainda hoje, continuamos a desenvolver softwares monolíticos, pesados e de difícil manutenção.&lt;/p&gt;

&lt;p&gt;Como visto nesse artigo, utilizar o IPC pode facilitar a manutenção do código, pois cada subprojeto (executável) iria lidar apenas com poucos &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contextos&lt;/a&gt;, possivelmente diminuindo a complexidade.&lt;/p&gt;

&lt;p&gt;Cada subprojeto poderia evoluir e ser utilizado independentemente.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Sep 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/ipc</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/ipc</guid>
      </item>
    
      <item>
        <title>Porquê eu escolhi Delphi e então, Object Pascal</title>
        <description>&lt;p&gt;Essa é minha contribuição aos artigos na Internet com a &lt;em&gt;hastag&lt;/em&gt; &lt;a href=&quot;https://www.google.com.br/search?q=%23WhyIChooseDelphi&quot;&gt;#WhyIChooseDelphi&lt;/a&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-kace-rodriguez-75513.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Kace Rodriguez on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;inicio&quot;&gt;Quando tudo começou&lt;/h2&gt;

&lt;p&gt;Minha história com &lt;em&gt;Object Pascal&lt;/em&gt; começa em 1999 quando comecei a estudar programação de computadores.&lt;/p&gt;

&lt;p&gt;Havia um curso chamado Programação de Computadores com “Novas” Tecnologias ministrado na PUC-RJ.&lt;/p&gt;

&lt;p&gt;Lá eu aprendi bastante sobre algoritmos, SGBD’s e linguagens de programação como COBOL, C/C++, Pascal, Java, Visual Basic e &lt;a href=&quot;https://www.embarcadero.com/products/delphi&quot;&gt;Delphi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Através dos convênios da PUC com outras empresas, consegui meu primeiro emprego como estagiário numa &lt;em&gt;software house&lt;/em&gt; chamada &lt;em&gt;Fuzion Engenharia de Software&lt;/em&gt; em meados do ano 2000.&lt;/p&gt;

&lt;h2 id=&quot;delphi&quot;&gt;Um caminho diferente&lt;/h2&gt;

&lt;p&gt;Na &lt;em&gt;Fuzion&lt;/em&gt; utilizáva-mos Delphi, Visual Basic e pouca coisa em Java. No entanto, a maioria dos projetos eram desenvolvidos em Delphi.&lt;/p&gt;

&lt;p&gt;Na PUC éramos referência no desenvolvimento &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt;. Veja, em Delphi, não em Java.&lt;/p&gt;

&lt;p&gt;Quando eu entrei na empresa a versão era Delphi 4. Alguns bugs, alguns problemas… mas então veio a tão aclamada versão 5 e a produtividade era sem igual.&lt;/p&gt;

&lt;p&gt;Tínhamos desenvolvido nossa própria metodologia e ferramentas que geravam código automaticamente e eu já tinha um cargo de Desenvolvedor Pleno.&lt;/p&gt;

&lt;p&gt;Nunca utilizamos &lt;em&gt;DB-aware components&lt;/em&gt;, pois tudo era feito através de camadas e Objetos. Esse era um dos motivos para ser tão difícil contratar mais desenvolvedores, pois aqueles que vinham fazer uma prova depois da entrevista, não sabiam como mostrar informações num &lt;em&gt;Form&lt;/em&gt; com “Mestre/Detalhe” e outros &lt;em&gt;widgets&lt;/em&gt;, sem utizar componentes &lt;em&gt;DB-aware&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Essa sempre foi a beleza do Delphi: Você pode utilizar o paradigma que quiser e conseguir um excelente resultado no final.&lt;/p&gt;

&lt;p&gt;Na Fuzion trilhávamos um caminho diferente. Delphi era um dos nossos segredos de performance e eficácia. E tivemos sucesso… enquanto durou.&lt;/p&gt;

&lt;h2 id=&quot;mudando&quot;&gt;A mudança de ambiente&lt;/h2&gt;

&lt;p&gt;Eu abri minha própria empresa em 2003 para trabalhar como consultor alocado em outras empresas.&lt;/p&gt;

&lt;p&gt;Eu já havia mudado de empresa umas duas vezes até estar na atual, onde já trabalho por quase 13 anos.&lt;/p&gt;

&lt;p&gt;Lá também utilizamos Delphi, a versão 7. Na época que entrei nesta empresa, o Delphi ainda dominava o mercado quando se tratava de aplicações Desktop.&lt;/p&gt;

&lt;p&gt;Por volta de 2006 (se não me engano) a Borland estava vendendo o Delphi. Eu acompanhei, com tristeza, o Delphi ser vendido entre as empresas.&lt;/p&gt;

&lt;p&gt;Eu adorava a Borland, a ponto de querer trabalhar pra ela, e Delphi sempre foi a minha escolha, mas eu achava que tinha que seguir em frente, já que agora o caminho parecia incerto.&lt;/p&gt;

&lt;p&gt;Apesar de na época estar num emprego relativamente estável, eu tinha meus próprios clientes. Eu utilizei Delphi para fazer todos os seus &lt;em&gt;softwares&lt;/em&gt; e, como não tinha certeza se o Delphi iria sobreviver, comecei a pensar em migrar para outra linguagem, outro ambiente.&lt;/p&gt;

&lt;p&gt;Apenas em 2010 eu comecei a pensar em outras possibilidades, quando soube um um projeto que “voltou das cinzas”, hoje conhecido como Lazarus.&lt;/p&gt;

&lt;h2 id=&quot;lazarus&quot;&gt;Migrando para Lazarus&lt;/h2&gt;

&lt;p&gt;Eu comecei a utilizar &lt;a href=&quot;http://www.lazarus-ide.org/&quot;&gt;Lazarus&lt;/a&gt; e quase desisti. Comparado com o Delphi, na época, Lazarus era muito inferior.&lt;/p&gt;

&lt;p&gt;Muitos bugs, pouca produtividade e muita diferença entre ambientes. Apesar de ambos utilizarem a mesma linguagem.&lt;/p&gt;

&lt;p&gt;Felizmente eu consegui superar os problemas. Hoje o ambiente Lazarus é bem estável e completo e me sinto “em casa” como eu me sentia na época do Delphi 5~7.&lt;/p&gt;

&lt;p&gt;Então consegui migrar muitos projetos de Delphi para Lazarus e outros parmaneceram nas versões antigas de Delphi — e vão muito bem, obrigado.&lt;/p&gt;

&lt;p&gt;Apesar de ainda haver problemas, hoje em dia a história parece ser outra. Cada vez mais vejo pessoas reclamando de &lt;em&gt;bugs&lt;/em&gt; no Delphi e, em comparação, vejo cada vez mais elogios ao Lazarus e ao compilador &lt;a href=&quot;https://freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hoje em dia tenho aplicações Desktop e Web, construídas em Free Pascal e Lazarus, rodando em servidores Windows IIS utilizando &lt;a href=&quot;https://www.iis.net/downloads/microsoft/fastcgi-for-iis&quot;&gt;FastCGI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nada mal, considerando que tais &lt;em&gt;softwares&lt;/em&gt; foram desenvolvidos utilizando ferramentas gratuitas e livres, não é?&lt;/p&gt;

&lt;p&gt;Free Pascal e Lazarus são ferramentas desenvolvidas apenas nas horas vagas por alguns programadores motivados e apaixonados por &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;motivos&quot;&gt;Simplicidade, Performance e Lucro&lt;/h2&gt;

&lt;p&gt;Hoje em dia existem tantas linguagens e ambientes que alguns programadores continuam querendo saber meus motivos em continuar utilizando &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bem, eu publiquei um vídeo que explica meus principais motivos.&lt;/p&gt;

&lt;div style=&quot;position:relative;height:0;padding-bottom:56.25%&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/iayMGRIRwjY?ecver=2&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; style=&quot;position:absolute;width:100%;height:100%;left:0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;p&gt;E enquanto esses motivos forem válidos, irei continuar utilizando a linguagem &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;hoje&quot;&gt;Object Pascal hoje em dia&lt;/h2&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; é relevante hoje em dia? Bem, depende de como você vê o mundo.&lt;/p&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt;, pra mim, é como um carro esportivo antigo, como essa imagem do &lt;em&gt;Porsche&lt;/em&gt; aí em cima.&lt;/p&gt;

&lt;p&gt;Esse &lt;em&gt;Porsche&lt;/em&gt; — ou quase qualquer outro esportivo antigo —  é simples, manual e puro. Você precisa saber o que está fazendo a todo momento. Não há computadores e sensores para lhe ajudar. Não há muita segurança como &lt;em&gt;airbags&lt;/em&gt;. Você tem que fazer mais força para “domá-lo”. Quase tudo é manual e “barulhento”. Você precisa entender de subesterço e sobre-esterço, se quiser dirigir de forma mais agressiva ao entrar numa curva. Enfim, você precisa saber muita coisa se quiser ter a verdadeira experiência de dirigir.&lt;/p&gt;

&lt;p&gt;Mas no fim do dia, após passar algumas horas atrás do volante, você se sente realizado. Você sabe exatamente o que fez. Você entende como as coisas funcionam nos seus mínimos detalhes. Você estava integrado ao ambiente. Você era apenas um com seu &lt;em&gt;Porsche&lt;/em&gt;. Homem e máquina.&lt;/p&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; é como um clássico esportivo que nunca sai de moda.&lt;/p&gt;

&lt;p&gt;Hoje temos cada vez mais IDE’s e linguagens “inteligentes” que podem mudar a cada nova versão. Esquecem do passado e “inventam” novas maneiras de fazer a mesma coisa que já fazíamos antes. Essas IDE’s nos dão &lt;em&gt;“airbags”&lt;/em&gt;, “segurança” e todo tipo de “artefato” para ajudar no desenvolvimento, mas no fim o desenvolvedor não sabe exatamente o que está fazendo. Ele apenas memorizou quais “botões apertar no painel” e se algo não sai conforme o esperado, sempre haverá a Internet para responder suas dúvidas, certo?&lt;/p&gt;

&lt;p&gt;Vejo desenvolvedores correndo atrás do último lançamento da IDE, &lt;em&gt;Lib&lt;/em&gt; ou compilador, apenas para constatarem que deverão modificar seu código que antes funcionava.&lt;/p&gt;

&lt;p&gt;A última versão do compilador adiciou tais e tais &lt;em&gt;features&lt;/em&gt; e todos querem utilizar, no entanto a maioria não sabe separar um &lt;em&gt;software&lt;/em&gt; em módulos reutilizáveis!&lt;/p&gt;

&lt;p&gt;Então, pra mim, &lt;em&gt;Object Pascal&lt;/em&gt; continua muito relevante. Gosto de “ter trabalho” ao construir meus &lt;em&gt;softwares&lt;/em&gt;, pois gosto do sentimento de ter construído algo por minhas próprias mãos sem ser obrigado a seguir as “regras de desenvolvimento” que algumas empresas consideram ideal.&lt;/p&gt;

&lt;p&gt;Não quero depender de outras empresas e de seus produtos privados, que podem mudar a qualquer momento, para que eu possa entregar valor aos meus clientes. A confiança que eu tinha na antiga Borland se foi… até que me provem o contrário. Hoje eu quero ser livre.&lt;/p&gt;

&lt;p&gt;Liberdade, é disso que se trata.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Eu gosto de imaginar um mundo onde o Delphi fosse disponibilizado de graça, doado ao time do Free Pascal e Lazarus.&lt;/p&gt;

&lt;p&gt;Gosto de pensar numa união de forças entre o &lt;em&gt;Open Source&lt;/em&gt; e a magnífica IDE, Delphi, que sempre ajudou o desenvolvedor (experiente ou não) da melhor forma possível.&lt;/p&gt;

&lt;p&gt;Gosto de pensar num mundo onde iríamos dar um passo pra trás e ver a beleza e a simplicidade da linguagem &lt;em&gt;Object Pascal&lt;/em&gt;, linguagem essa que foi e ainda é inspiração para várias outras.&lt;/p&gt;

&lt;p&gt;Eu &lt;em&gt;escolhi&lt;/em&gt; Delphi no passado e construí minha carreira com a ajuda dele.&lt;/p&gt;

&lt;p&gt;Delphi continua sendo uma ótima escolha para aqueles que sabem aproveitá-lo.&lt;/p&gt;

&lt;p&gt;Eu não o abandonei. Tiraram ele de mim devido a burocracia e altos custos. Mas ele continua no meu coração.&lt;/p&gt;

&lt;p&gt;Minha &lt;em&gt;hastag&lt;/em&gt; hoje — infelizmente ou não — não é mais &lt;strong&gt;#WhyIChooseDelphi&lt;/strong&gt;, mas sim &lt;strong&gt;#WhyIChoseDelphi&lt;/strong&gt; (uma letra faz diferença).&lt;/p&gt;

&lt;p&gt;Felizmente tem algo que nunca mudou: A linguagem &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/porque-eu-escolhi-delphi-e-object-pascal</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/porque-eu-escolhi-delphi-e-object-pascal</guid>
      </item>
    
      <item>
        <title>Redefinindo Classes</title>
        <description>&lt;p&gt;A redeclaração de Classes é um método prático para minimizar a colisão de nomes entre Classes, mesmo utilizando identificadores curtos.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-mpumelelo-macu-283883.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Mpumelelo Macu on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; tem uma &lt;em&gt;feature&lt;/em&gt; muito útil que, acredito, não é muito utilizada pelos desenvolvedores.&lt;/p&gt;

&lt;p&gt;Não sei se há um nome específico pra isso, mas eu a chamo de &lt;em&gt;Redefinição de Classes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Na verdade essa &lt;em&gt;feature&lt;/em&gt; pode ser utilizada para redeclarar Classes, Constantes e até mesmo Funções.&lt;/p&gt;

&lt;p&gt;Porém, na Orientação a Objetos, basicamente só utilizamos Classes. Então esqueça o resto e vamos nos concentrar nelas.&lt;/p&gt;

&lt;p&gt;Vamos ver algumas técnicas que podem ser aplicadas utilizando tal conceito.&lt;/p&gt;

&lt;h2 id=&quot;renomeando&quot;&gt;Renomeando&lt;/h2&gt;

&lt;p&gt;Imagine que você quer utilizar uma classe de alguma &lt;em&gt;Lib&lt;/em&gt;, mas essa Classe tem o mesmo nome — exemplo &lt;code&gt;TSmartMemory&lt;/code&gt;— de uma de suas Classes que você já utiliza por todo o seu código. O que fazer?&lt;/p&gt;

&lt;p&gt;A primeira opção é nunca utilizar ambas as Classes numa mesma Unidade. Mas talvez você não tenha essa sorte.&lt;/p&gt;

&lt;p&gt;A segunda opção é prefixar uma das Classes com o nome da Unidade — muito comum ver isso em projetos Java — por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  LibMemory,
  MyMemory;

begin
  M := TSmartMemory.New;  // your class
  L := LibMemory.TSmartMemory.Create;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A terceira opção, que eu utilizo na maioria das vezes, é &lt;em&gt;“renomear”&lt;/em&gt; a Classe da &lt;em&gt;Lib&lt;/em&gt; para uma nomenclatura que não colide com a nomenclatura já utilizada no meu projeto. Vejamos um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyMemory;

uses
  LibMemory;

type
  // TSmartMemory from LibMemory
  TLibStartMemory = TSmartMemory; 

  // my new class
  TSmartMemory = class
    // ...
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo ambas as Classes estão declaradas na mesma Unidade existente no projeto — a &lt;code&gt;MyMemory&lt;/code&gt; — e o projeto poderá utilizar ambas as Classes sem colisão de nomenclatura.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
  M := TSmartMemory.New;
  L := TLibSmartMemory.Create;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Utilizando essa técnica evitamos o conflito de nomes, o que é muito útil.&lt;/p&gt;

&lt;p&gt;Ao invés de utilizarmos o nome real da Classe, podemos lhe dar um &lt;em&gt;apelido&lt;/em&gt;. O código fica mais limpo, simples e com identificadores curtos, pois não temos a necessidade de utilizar a Unidade como prefixo.&lt;/p&gt;

&lt;p&gt;A linguagem C# &lt;a href=&quot;https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/using-directive&quot;&gt;tem algo muito parecido&lt;/a&gt; o que me faz pensar de onde será que o principal arquiteto da linguagem C# tirou essa ideia.&lt;/p&gt;

&lt;h2 id=&quot;visibilidade&quot;&gt;Visibilidade&lt;/h2&gt;

&lt;p&gt;Muitas vezes precisamos utilizar uma composição de diferentes Classes para resolver um problema.&lt;/p&gt;

&lt;p&gt;Mas se cada uma dessas Classes tiver sido declarada numa Unidade diferente, precisaremos declarar todas essas Unidades, para ter acesso a cada uma dessas Classes.&lt;/p&gt;

&lt;p&gt;Por exemplo. Precisamos da &lt;code&gt;TClass1&lt;/code&gt;, &lt;code&gt;TClass2&lt;/code&gt; e &lt;code&gt;TClass3&lt;/code&gt;. Cada uma delas em Unidades diferentes, &lt;code&gt;Unit1&lt;/code&gt;, &lt;code&gt;Unit2&lt;/code&gt; e &lt;code&gt;Unit3&lt;/code&gt;, respectivamente.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyUnit;

uses
  Unit1, Unit2, Unit3;  
  
begin
  TClass3.New(
    TClass2.New(
      TClass1.New
    )
  )
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se precisarmos utilizar essa composição em muitos lugares do código, teremos sempre que lembrar em quais Unidades essas Classes estão.&lt;/p&gt;

&lt;p&gt;Outra opção é dar visibilidade às Classes, redeclarando todas elas numa única Unidade, por exemplo &lt;code&gt;Unit123&lt;/code&gt;, para que possamos utilizá-las de forma mais simples, porém ainda mantendo cada implementação em Unidades diferentes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit Unit123;

uses
  Unit1, Unit2, Unit3;

type
  TClass1 = Unit1.TClass1;
  TClass2 = Unit2.TClass2;
  TClass3 = Unit3.TClass3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora, basta utilizarmos a &lt;code&gt;Unit123&lt;/code&gt; no código para ter acesso a todas as 3 Classes que anteriormente só poderiam ser acessadas em Unidades distintas.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit UnitTest;

uses
  Unit123;  
  
begin
  TClass3.New(
    TClass2.New(
      TClass1.New
    )
  )
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta técnica é bastante útil para simplificar uma API, fornecendo aos desenvolvedores somente algumas poucas Classes para uso em contextos bem específicos.&lt;/p&gt;

&lt;h2 id=&quot;heranca&quot;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Há momentos que queremos utilizar &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/&quot;&gt;Herança de Classes&lt;/a&gt; — mesmo sendo a Composição de Objetos a melhor escolha — porém gostaríamos de utilizar o mesmo nome da Classe ancestral.&lt;/p&gt;

&lt;p&gt;Vamos imaginar que estamos desenvolvendo um software e que em uma de suas Unidades tem uma Classe que &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;representa&lt;/a&gt; um arquivo PDF. Nomeamos essa Classe como &lt;code&gt;TPDFFile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;No entanto sabemos que poderá haver dezenas ou centenas de &lt;em&gt;Libs&lt;/em&gt; que já trabalham com PDF. Então vamos chamar uma dessas &lt;em&gt;Libs&lt;/em&gt; de &lt;em&gt;“PDFLib”&lt;/em&gt;, apenas como exemplo.&lt;/p&gt;

&lt;p&gt;Na &lt;em&gt;PDFLib&lt;/em&gt; temos uma Classe chamada &lt;code&gt;TPDFFile&lt;/code&gt; que é exatamente o mesmo nome que já decidimos que será utilizada no nosso software, mas o arquiteto do projeto diz que nossa Classe deve herdar de &lt;code&gt;PDFLib.TPDFFile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Acho que você já sabe a resposta:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyPDFUnit;

uses
  PDFLib;

type
  TPDFFile = class(PDFLib.TPDFFile)
    // more methods
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prefixando a Classe da &lt;em&gt;Lib&lt;/em&gt; podemos identificá-la de forma diferente da nossa Classe declarada na mesma Unidade.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TPDFFile&lt;/code&gt; é agora uma extensão de &lt;code&gt;PDFLib.TPDFFile&lt;/code&gt; que pertence a uma &lt;em&gt;Lib&lt;/em&gt; externa. Mas para todo o restante do código no projeto, só existirá a Classe &lt;code&gt;MyPDFUnit.TPDFFile&lt;/code&gt; que representa um PDF.&lt;/p&gt;

&lt;h2 id=&quot;estendendo&quot;&gt;Estendendo&lt;/h2&gt;

&lt;p&gt;A técnica que vou mostrar agora já era utilizada antes mesmo de haver a sintaxe para &lt;em&gt;Classes Helpers&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por exemplo, imagine que você queira incluir novas propriedades ou métodos na Classe &lt;code&gt;TEdit&lt;/code&gt;. O primeiro pensamento é utilizar herança para criar um novo componente. No entanto você não quer substituir cada &lt;code&gt;TEdit&lt;/code&gt; em todos os &lt;code&gt;TForm&lt;/code&gt; já existentes no projeto. Então, o que fazer?&lt;/p&gt;

&lt;p&gt;A resposta continua sendo utilizar Herança. Mas há um truque ou &lt;em&gt;hack&lt;/em&gt; que irei mostrar na técnica a seguir. Mas gostaria de lembrar que isso deve ser utilizado com muita parcimônia. Eu só utilizei essa técnica pouquíssimas vezes e somente para Classes que representam &lt;em&gt;widgets&lt;/em&gt;, ou seja, Classes de componentes que são utilizadas em Formulários.&lt;/p&gt;

&lt;p&gt;Para extender um &lt;code&gt;TEdit&lt;/code&gt; sem criar uma nova Classe e sem ter que alterar os Formulários, basta utilizar a mesma técnica acima:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyStdCtrls;

type
  TEdit = class(StdCtrls.TEdit) // or Vcl.StdCtrls.TEdit
    // more methods and properties
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Você não precisa alterar os &lt;em&gt;widgets&lt;/em&gt; nos Formulários. A renderização do &lt;em&gt;design&lt;/em&gt; do Formulário irá funcionar utilizando os recursos (*.lfm | *.dfm) corretamente.&lt;/p&gt;

&lt;p&gt;Porém há um truque que você não pode esquecer: Em cada um desses Formulários você precisará &lt;a href=&quot;/declarando-unidades&quot;&gt;declarar&lt;/a&gt; sua Unidade &lt;strong&gt;depois&lt;/strong&gt; da Unidade &lt;code&gt;StdCtrls&lt;/code&gt; real.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyForm1;

uses
  StdCtrls, MyStdCtrls;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse &lt;em&gt;hack&lt;/em&gt; é necessário para que o compilador ache a declaração da sua Unidade antes de encontrá-la na &lt;code&gt;StdCtrls&lt;/code&gt; padrão.&lt;/p&gt;

&lt;p&gt;Por isso é tão importante ter uma &lt;a href=&quot;/declarando-unidades&quot;&gt;ordem&lt;/a&gt; na declaração das Unidades.&lt;/p&gt;

&lt;h2 id=&quot;opcional&quot;&gt;Nomenclatura Opcional&lt;/h2&gt;

&lt;p&gt;Essa técnica pode ser considerada o oposto da primeira mostrada nesse artigo, ou seja, ao invés de você “renomear” uma Classe pertencente a outra &lt;em&gt;Lib&lt;/em&gt;, você irá dar ao desenvolvedor opções de nomenclatura para o uso das suas Classes.&lt;/p&gt;

&lt;p&gt;Imagine que você codificou um &lt;em&gt;package&lt;/em&gt; com algumas Classes. Nesse &lt;em&gt;package&lt;/em&gt; você gosta de utilizar nomes simples como &lt;code&gt;TStream&lt;/code&gt;, &lt;code&gt;TMemoryStream&lt;/code&gt;, &lt;code&gt;TString&lt;/code&gt;, &lt;code&gt;TInteger&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;Veja que já temos alguns possíveis “problemas” aqui. Vejamos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;As Classes &lt;code&gt;TStream&lt;/code&gt; e &lt;code&gt;TMemoryStream&lt;/code&gt; já existem no FPC|Delphi e por isso poderá haver colisão de nomes quando os desenvolvedores forem utilizar seu &lt;em&gt;package&lt;/em&gt;, pois é bem provável que eles já estejam utilizando tais Classes padrão em seus projetos;&lt;/li&gt;
  &lt;li&gt;As Classes &lt;code&gt;TString&lt;/code&gt; e &lt;code&gt;TInteger&lt;/code&gt; são Classes com nomes muito simples ou genéricos e, novamente, é provável que alguma outra &lt;em&gt;Lib&lt;/em&gt; ou mesmo os próprios projetos desses desenvolvedores já utilizem tais nomes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O problema aqui é o nome &lt;em&gt;limpo&lt;/em&gt; e &lt;em&gt;curto&lt;/em&gt;. Ao mesmo tempo que esses nomes são &lt;em&gt;perfeitos&lt;/em&gt;, eles tem o grande potencial de gerar o problema da colisão de nomenclatura.&lt;/p&gt;

&lt;p&gt;Mas quando você está criando seu &lt;em&gt;package&lt;/em&gt;, você tem que abstrair o mundo externo. O &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contexto&lt;/a&gt; do &lt;em&gt;package&lt;/em&gt; que deve influenciar a nomenclatura das Classes e não o mundo externo que, talvez, irá utilizá-lo!&lt;/p&gt;

&lt;p&gt;Eu “lutei” contra esse problema por muito anos. Antes de “descobrir” essa técnica, eu prefixava minhas Classes com 1, 2 ou 3 letras — esse parece ser o padrão utilizado por todos os desenvolvedores de componentes do mercado — porém você pode descobrir com o tempo que “seu prefixo” escolhido para suas Classes já foi utilizado em outra &lt;em&gt;Lib&lt;/em&gt; de terceiros.&lt;/p&gt;

&lt;p&gt;Imagine você ter que utilizar nomes verbosos como &lt;code&gt;TXyzMemoryStream&lt;/code&gt; por todo o seu código para, então, descobrir que &lt;code&gt;Xyz&lt;/code&gt; já é o prefixo utilizado por uma grande “fazedora de componentes” do mercado.&lt;/p&gt;

&lt;p&gt;Então eu descobri que a linguagem &lt;em&gt;Object Pascal&lt;/em&gt; já tinha uma resposta e eu poderia ter o melhor dos dois mundos. Eu poderia utilizar nomes simples, compactos e limpos dentro do meu contexto (&lt;em&gt;package&lt;/em&gt;, projeto, &lt;em&gt;lib&lt;/em&gt;) mas dar aos potenciais usuários|desenvolvedores um nome mais verboso, porém com menor possibilidade de haver colisão de nomes, se assim eu desejasse.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo. Uma das Classes do &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.data.clss.pas&quot;&gt;James&lt;/a&gt; tem o nome &lt;code&gt;TDataStream&lt;/code&gt;. Esse nome já evita a colisão com &lt;code&gt;TStream&lt;/code&gt; que é basicamente o que essa Classe representa, porém o “prefixo” &lt;code&gt;Data&lt;/code&gt; não foi utilizado para minimizar a colisão de nomenclatura, mas sim devido a sua semântica.&lt;/p&gt;

&lt;p&gt;Mas digamos que agora o Lazarus e/ou Delphi implementaram uma Classe de uso geral chamada… &lt;code&gt;TDataStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Eu deveria mudar o nome dessa Classe no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt; e em todos os meus projetos que já utilizam essa nomenclatura? É claro que não!&lt;/p&gt;

&lt;p&gt;Eu só iria dar a opção para os (novos) desenvolvedores utizarem outra nomenclatura para a mesma Classe, desse jeito:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TDataStream = class sealed(TInterfacedObject, IDataStream)
  // some methods
  end;
  
  TJamesDataStream = TDataStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código agora tem 2 possibilidades de uso de nomenclatura para a mesma Classe!&lt;/p&gt;

&lt;p&gt;Você pode continuar utilizando &lt;code&gt;TDataStream&lt;/code&gt; por todo o seu código, desde que mantenha a &lt;a href=&quot;/declarando-unidades&quot;&gt;ordem de declaração&lt;/a&gt; das Unidades, ou pode utilizar a nova opção &lt;code&gt;TJamesDataStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;E se mesmo assim ainda houver colisão de nomenclatura, aí caberá ao desenvolvedor utilizar a primeira técnica desse artigo.&lt;/p&gt;

&lt;p&gt;Dessa forma ambos os lados (desenvolvedores de &lt;em&gt;packages&lt;/em&gt; e usuários de &lt;em&gt;packages&lt;/em&gt;) estão &lt;em&gt;livres&lt;/em&gt; para utilizarem os nomes que quiserem em suas Classes.&lt;/p&gt;

&lt;p&gt;A única exceção, até onde eu sei, são os componentes que são instalados na IDE. Ambas as IDE’s (Lazarus e Delphi) não deixam instalar componentes com o mesmo nome, mesmo estando em &lt;em&gt;packages&lt;/em&gt; distintos. No entanto, na minha opinião, isso é um erro de &lt;em&gt;design&lt;/em&gt; das IDE’s. Ambas deveriam permitir a instalação e, ao utilizarmos tais componentes, bastaria a IDE declarar os &lt;em&gt;fields&lt;/em&gt; no Formulário utilizando a nomenclatura totalmente qualificada, como &lt;code&gt;Edit1: StdCtrls.TEdit;&lt;/code&gt; e tudo iria funcionar.&lt;/p&gt;

&lt;p&gt;Eu fiz essa &lt;a href=&quot;http://lists.lazarus-ide.org/pipermail/lazarus/2011-January/123929.html&quot;&gt;proposta&lt;/a&gt; na lista oficial do Lazarus em Janeiro/2011, porém ainda sem previsão, prioridade ou interesse.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A redeclaração ou renomeação de Classes (e constantes, funções, etc) é uma técnica que existe quase desde os primórdios da linguagem, mas que a grande maioria dos desenvolvedores não utiliza, seja por desconhecimento, inabilidade ou mesmo falta de interesse.&lt;/p&gt;

&lt;p&gt;É um conceito &lt;em&gt;antigo&lt;/em&gt;, mas que nos proporciona várias técnicas e possibilidades para codificar melhor &lt;em&gt;hoje&lt;/em&gt;, conforme demonstrado nesse artigo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/redeclarando-classes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/redeclarando-classes</guid>
      </item>
    
      <item>
        <title>Git-work Project</title>
        <description>&lt;p&gt;Git-work são extensões minimalistas para Git, fornecendo operações de repositório de alto nível.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-zachary-nelson-192289.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Zachary Nelson on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Git&lt;/em&gt;&lt;/strong&gt;, segundo a &lt;a href=&quot;https://pt.wikipedia.org/wiki/Git&quot;&gt;Wikipedia&lt;/a&gt;,
é um sistema de controle de versão distribuído e um sistema de gerenciamento de código fonte, com ênfase em velocidade. O Git foi inicialmente projetado e desenvolvido por Linus Torvalds para o desenvolvimento do kernel Linux, mas foi adotado por muitos outros projetos.&lt;/p&gt;

&lt;p&gt;Ele é o padrão atual para o controle de versão de softwares. Não há nenhum outro concorrente que seja tão simples e eficaz.&lt;/p&gt;

&lt;p&gt;Apesar de ser um magnífico sistema, por muito tempo não havia um padrão definido em como trabalhar em equipe ou mesmo sozinho, ou seja, como enviar de forma eficiente uma alteração feita por você; como ser eficaz ao trabalhar com &lt;em&gt;branches&lt;/em&gt;; se devemos trabalhar diretamente no &lt;code&gt;master&lt;/code&gt; ou em &lt;em&gt;branches&lt;/em&gt; secundários; como iniciar uma alteração quando o projeto recebe uma &lt;em&gt;issue&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Hoje em dia temos um padrão chamado &lt;code&gt;git flow&lt;/code&gt;. Ele vem instalado nas últimas versões do Git e você pode configurá-lo digitando &lt;code&gt;git flow&lt;/code&gt; na linha-de-comando.&lt;/p&gt;

&lt;p&gt;No entanto, ainda que o &lt;code&gt;git flow&lt;/code&gt; não seja um padrão complicado de se utilizar, ele não nos deixa customizá-lo de forma simples num único lugar (são alguns arquivos &lt;em&gt;bash&lt;/em&gt; que devem ser editados), é verboso e não define um padrão para as mensagens dos &lt;em&gt;commits&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nesse artigo eu irei lhe apresentar o meu mais novo “&lt;em&gt;pet project&lt;/em&gt;” chamado &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt;, que é uma alternativa minimalista ao &lt;code&gt;git flow&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;git-work&quot;&gt;O que é Git-work&lt;/h2&gt;

&lt;p&gt;Assim como o &lt;code&gt;git flow&lt;/code&gt;, o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; é uma coleção de extensões para a linha-de-comando do Git.&lt;/p&gt;

&lt;p&gt;O nome escolhido é devido a semântica ao digitar os comandos como, por exemplo, &lt;code&gt;git work done&lt;/code&gt; para concluir uma &lt;code&gt;issue&lt;/code&gt;. Legal, não?&lt;/p&gt;

&lt;p&gt;É um projeto extremamente novo (apenas alguns dias) porém com um grande potencial, na minha humilde opinião.&lt;/p&gt;

&lt;p&gt;São extensões minimalistas para Git, fornecendo operações de repositório de alto nível além de padronizar, um &lt;em&gt;fluxo de trabalho&lt;/em&gt; com os &lt;em&gt;branches&lt;/em&gt;, que poderá ser totalmente customizável.&lt;/p&gt;

&lt;h2 id=&quot;motivacao&quot;&gt;Motivação&lt;/h2&gt;

&lt;p&gt;Eu tentei (tento) utilizar alguns &lt;em&gt;clients&lt;/em&gt; para Git como &lt;a href=&quot;https://desktop.github.com/&quot;&gt;Github Desktop&lt;/a&gt;, &lt;a href=&quot;http://www.syntevo.com/smartgit/&quot;&gt;SmartGit&lt;/a&gt; ou &lt;a href=&quot;https://www.gitkraken.com/&quot;&gt;GitKraken&lt;/a&gt;. Apesar desses e dezenas de outras IDE’s serem ótimos produtos, podem ter restrições de uso, além da curva de aprendizado para utilizá-los.&lt;/p&gt;

&lt;p&gt;Além disso, no meu caso, eu utilizo Git em alguns computadores e não posso me dar ao luxo de ter que ficar atualizando e reconfigurando IDE’s em todos esses computadores caso eu queria mudar meu modo de trabalho.&lt;/p&gt;

&lt;p&gt;Eu sou um cara &lt;em&gt;“old-school”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Gosto das coisas mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e manuais. Gosto de saber o que está acontecendo nos “bastidores” quando clico num botão. Gosto de aprender a utilizar algo reduzindo-o à sua interface mais básica.&lt;/p&gt;

&lt;p&gt;Então voltei para a linha-de-commando, onde posso fazer literalmente tudo com o Git. &lt;a href=&quot;/posts/menos-e-mais/&quot;&gt;Menos é mais&lt;/a&gt;, certo?&lt;/p&gt;

&lt;p&gt;Mas a linha-de-comando pode ser assutadora quando você não conhece os comandos. E, mesmo depois de aprendê-los, pode ser ineficaz se você tiver que fazer &lt;em&gt;tudo&lt;/em&gt; de forma manual.&lt;/p&gt;

&lt;p&gt;Então como eu poderia utilizar a linha-de-comando, mas automatizar os comandos mais utilizados e, ao mesmo tempo, definir um fluxo de trabalho padronizado?&lt;/p&gt;

&lt;p&gt;A ideia de construir o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; me ocorreu após uma tarde de intenso trabalho e uso do Git em um projeto particular.&lt;/p&gt;

&lt;p&gt;Trabalhei em algumas &lt;em&gt;issues&lt;/em&gt; e foi bastante ineficaz ter que ficar indo e vindo entre os &lt;em&gt;branches&lt;/em&gt; para fazer a mesclagem além de ter que ficar digitando comandos que poderiam ser automatizados.&lt;/p&gt;

&lt;p&gt;Além disso, não ter um fluxo de trabalho pré-determinado me fazia perder tempo para identificar o próximo passo.&lt;/p&gt;

&lt;p&gt;Então nasceu o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;features&quot;&gt;Características&lt;/h2&gt;

&lt;p&gt;Inicialmente eu pensei em codificar o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; em &lt;em&gt;Object Pascal&lt;/em&gt;. Sério. Porém vi que o mais simples a fazer seria utilizar &lt;em&gt;Bash scripts&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O Git é bem integrado com &lt;em&gt;Bash&lt;/em&gt; então… Por quê não?&lt;/p&gt;

&lt;p&gt;Criei o projeto no Github, codifiquei as primeiras características e subi os fontes.&lt;/p&gt;

&lt;p&gt;Então meu amigo &lt;a href=&quot;https://github.com/fabriciofx/&quot;&gt;Fabrício Cabral&lt;/a&gt; se interessou pelo projeto e começou a trabalhar e melhorar o código.&lt;/p&gt;

&lt;p&gt;No momento da escrita desse artigo já temos algumas funcionalidades.&lt;/p&gt;

&lt;p&gt;Após “instalar”, digite &lt;code&gt;git work&lt;/code&gt; para ver os comandos:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/git-work-1.jpg&quot; alt=&quot;git-work&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Esses comandos ainda serão aperfeiçoados, pois estão em constante desenvolvimento.&lt;/p&gt;

&lt;h3 id=&quot;flow&quot;&gt;Fluxo de Trabalho&lt;/h3&gt;

&lt;p&gt;Após um usuário registrar a &lt;em&gt;issue&lt;/em&gt; #41 no seu sistema de &lt;em&gt;tickets&lt;/em&gt;, você inicia um fluxo:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Digite &lt;code&gt;git work issue 41&lt;/code&gt; para criar uma nova &lt;em&gt;branch&lt;/em&gt; com o nome &lt;code&gt;41&lt;/code&gt; a partir da &lt;code&gt;master&lt;/code&gt;, já com &lt;em&gt;checkout&lt;/em&gt; automático para o &lt;code&gt;41&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Enquanto você vai alterando os fontes, poderá digitar &lt;code&gt;git work commit &quot;mensagem&quot;&lt;/code&gt; para ir comitando seu trabalho;&lt;/li&gt;
  &lt;li&gt;Quando você tiver terminado o trabalho, digite &lt;code&gt;git work done&lt;/code&gt; para ir para o &lt;code&gt;master&lt;/code&gt; enquanto o sistema faz o &lt;em&gt;merge&lt;/em&gt; com a atual &lt;em&gt;branch&lt;/em&gt; &lt;code&gt;41&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Então você pode enviar suas alterações para o servidor digitando &lt;code&gt;git work push&lt;/code&gt; para enviar a &lt;em&gt;branch&lt;/em&gt; atual, que é a &lt;code&gt;master&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Quando tiver uma versão de &lt;em&gt;release&lt;/em&gt;, o comando &lt;code&gt;git work release 1.0&lt;/code&gt; poderá ser utilizado. O git-work irá criar uma nova &lt;em&gt;tag&lt;/em&gt; a partir da &lt;code&gt;master&lt;/code&gt; e enviar ao servidor.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pode não parecer muito agora. Os comandos são muito similares aos comandos do próprio Git, porém tudo ainda está em desenvolvimento.&lt;/p&gt;

&lt;p&gt;Os scripts irão verificar, na medida do possível, se você está utilizando os comandos certos, nos &lt;em&gt;branches&lt;/em&gt; corretos.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;branch&lt;/em&gt; padrão poderá ser &lt;a href=&quot;https://github.com/mdbs99/git-work/issues/9&quot;&gt;configurado&lt;/a&gt; (padrão &lt;code&gt;master&lt;/code&gt;) para que os comandos &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt; e &lt;code&gt;release&lt;/code&gt; saibam onde pegar os fontes atuais.&lt;/p&gt;

&lt;p&gt;As mensagens do &lt;code&gt;commit&lt;/code&gt; poderão ser &lt;a href=&quot;https://github.com/mdbs99/git-work/issues/8&quot;&gt;padronizadas&lt;/a&gt; com o número da &lt;em&gt;issue&lt;/em&gt; no início. Exemplo: &lt;em&gt;“#41 this fix…”.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;E se todos os (futuros) parâmetros customizáveis ainda não sejam suficientes para suas customizações, bastará você alterar apenas o &lt;a href=&quot;https://github.com/mdbs99/git-work/blob/master/git-work.sh&quot;&gt;único arquivo&lt;/a&gt; nesse projeto.&lt;/p&gt;

&lt;p&gt;Ainda há um grande caminho a percorrer.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Essa é apenas a versão &lt;code&gt;0.1&lt;/code&gt; desse projeto que só tem poucos dias de vida.&lt;/p&gt;

&lt;p&gt;Padronização, eficiência e simplicidade. Essa é a proposta desse projeto.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;https://github.com/mdbs99/git-work&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/git-work-project</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/git-work-project</guid>
      </item>
    
      <item>
        <title>Imutabilidade do Estado</title>
        <description>&lt;p&gt;Na Orientação a Objetos, um Objeto pode ser considerável Imutável mesmo que ele… mude.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-morgan-harper-nichols-157838.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Morgan Harper Nichols on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O aprendizado de um conceito complexo, tende a ser melhor absorvido se dividirmos o conceito em pequenas partes.&lt;/p&gt;

&lt;p&gt;Por exemplo, quando começamos a aprender Inglês, nos é ensinado que, para nos referirmos a algo que ocorreu no passado, devemos utilizar os verbos no passado para fazer afirmações ou utilizamos o verbo modal &lt;em&gt;did&lt;/em&gt; ou &lt;em&gt;did not&lt;/em&gt; para fazermos perguntas ou negações. Esse é o tempo verbal &lt;em&gt;Simple Past&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo: &lt;em&gt;I saw this movie&lt;/em&gt; (tradução: eu vi esse filme).&lt;/p&gt;

&lt;p&gt;Então, quando você começa a estudar mais a língua, descobre que existe muitas outras maneiras de expressar algo que ocorreu no passado. Por exemplo, o uso do tempo verbal &lt;em&gt;Present Perfect&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo: &lt;em&gt;I have seen this movie&lt;/em&gt; (tradução: eu vi esse filme).&lt;/p&gt;

&lt;p&gt;Aqui vemos o uso do verbo modal &lt;em&gt;have&lt;/em&gt; e o uso do &lt;em&gt;Past Participle&lt;/em&gt; do verbo &lt;em&gt;to see&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ambas as frases dizem o mesmo quando traduzimos para o Português, porém a segunda frase pode ser considerada mais &lt;em&gt;correta&lt;/em&gt; do que a primeira — você só descobre isso depois que aprende o &lt;em&gt;Present Perfect&lt;/em&gt;.
Mas isso não é um blog de Inglês, vamos voltar para a Orientação a Objetos.&lt;/p&gt;

&lt;p&gt;Essa introdução é para lhe mostrar que primeiro devemos aprender um conceito na sua forma mais simples; depois aprimoramos.&lt;/p&gt;

&lt;h2 id=&quot;conceitos&quot;&gt;Conceitos da Imutabilidade&lt;/h2&gt;

&lt;p&gt;Quando você aprendeu sobre &lt;a href=&quot;/posts/objetos-imutaveis/&quot;&gt;Imutabilidade&lt;/a&gt; pode ter pensado que um Objeto é imutável se, depois de criado, nada é alterado dentro dele ou que o Objeto retorna sempre a mesma informação quando um método é chamado.&lt;/p&gt;

&lt;p&gt;Bem, não é tão simples assim.&lt;/p&gt;

&lt;p&gt;Diferentemente das linguagens funcionais, onde tudo é imutável por padrão, na Orientação a Objetos esse conceito pode ser mais amplo.&lt;/p&gt;

&lt;p&gt;Vamos ver alguns conceitos.&lt;/p&gt;

&lt;h3 id=&quot;ex1&quot;&gt;Conteúdo Externo&lt;/h3&gt;

&lt;p&gt;Uma classe que representa um arquivo pode ser imútável de duas maneiras:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/48237c902271b6f2c3a314d3b6f5b8c0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, o método &lt;code&gt;TFile.Stream: IDataStream&lt;/code&gt; sempre irá retornar o mesmo valor lido na primeira execução.&lt;/p&gt;

&lt;p&gt;O Objeto é imutável e &lt;em&gt;constante&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas, e se alterarmos o método confome abaixo, a classe continuaria sendo imutável?&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/0aea75fefaf8612d0bc84d5fc9ce85a0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Sim, com certeza.&lt;/p&gt;

&lt;p&gt;Apesar do retorno do método poder ser diferente em cada chamada — o conteúdo do arquivo pode ser alterado por outro processo — o Objeto continuaria sendo imutável pois seu &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado&lt;/a&gt; (&lt;code&gt;FFilePath&lt;/code&gt;) não foi alterado.&lt;/p&gt;

&lt;p&gt;Ele é imutável, porém &lt;em&gt;não&lt;/em&gt; é constante.&lt;/p&gt;

&lt;p&gt;O mesmo conceito se aplica para um conteúdo vindo de um Banco de Dados, site na Web, etc.&lt;/p&gt;

&lt;h3 id=&quot;ex2&quot;&gt;Conteúdo em Memória&lt;/h3&gt;

&lt;p&gt;Uma lista de Objetos é considerada mutável se adicionarmos itens após ela ter sido criada?&lt;/p&gt;

&lt;p&gt;Vejamos no código:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/af8769161d1b111128349b05b74bccb9.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Copyright (c) &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James Project&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TDataParams&lt;/code&gt; encapsula uma lista do tipo &lt;code&gt;TInterfaceList&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A cada inclusão de um novo item, é delegada à essa lista interna, a persistência em memória dos Objetos.&lt;/p&gt;

&lt;p&gt;Você acha que, assim, estamos alterando o Estado (&lt;code&gt;FList&lt;/code&gt;) do Objeto?&lt;/p&gt;

&lt;p&gt;Não estamos.&lt;/p&gt;

&lt;p&gt;O motivo é que não estamos redefinindo &lt;code&gt;FList&lt;/code&gt;. Não estamos recriando uma nova lista.&lt;/p&gt;

&lt;p&gt;Uma lista de itens está sendo criada em memória — blocos de memória — mas o endereço inicial de &lt;code&gt;FList&lt;/code&gt; continua intacto.&lt;/p&gt;

&lt;p&gt;Além disso, &lt;code&gt;FList&lt;/code&gt; é um &lt;a href=&quot;/atributos-primarios-secundarios#secundarios&quot;&gt;Atributo Secundário&lt;/a&gt;, então nós até poderíamos redefinir esse atributo sem estar em desacordo com o princípio. Mas, se a instância da lista fosse passada no construtor, então não poderíamos redefinir o Objeto, pois esse seria considerado como um &lt;a href=&quot;/atributos-primarios-secundarios#primarios&quot;&gt;Atributo Primário&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;estado&quot;&gt;Imutabilidade do Estado&lt;/h2&gt;

&lt;p&gt;Se mesmo após algumas mudanças internas ou externas ao Objeto, ele continua sendo considerado imutável, como saber se não estamos violando o princípio da Imutabilidade?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Simples&lt;/strong&gt;: Se o &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado do Objeto&lt;/a&gt;, ou seja, seus &lt;a href=&quot;/atributos-primarios-secundarios#primarios&quot;&gt;Atributos Primários&lt;/a&gt;, não for alterado/redefinindo, então ele é imutável.&lt;/p&gt;

&lt;p&gt;Uma vez que um atributo é instânciado, ele não poderá ter seu &lt;em&gt;endereço de memória&lt;/em&gt; alterado. Esses atributos serão inicializados no &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtor&lt;/a&gt; da classe e jamais poderão ser reinicializados.&lt;/p&gt;

&lt;p&gt;Seu Objeto deve ser &lt;em&gt;fiél&lt;/em&gt; aos argumentos passados no construtor da Classe, no entanto ele é &lt;em&gt;livre&lt;/em&gt; para trabalhar e responder o que quiser em seus métodos.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Imutabilidade, na Orientação a Objetos, não é só sobre as não-mudanças internas ou externas ao Objeto, mas sim sobre não alterar o Estado Primário do Objeto.&lt;/p&gt;

&lt;p&gt;Não confunda &lt;a href=&quot;/posts/classes-de-dados/&quot;&gt;dados&lt;/a&gt; com o Estado do Objeto.&lt;/p&gt;

&lt;p&gt;Infelizmente nenhum compilador &lt;em&gt;Object Pascal&lt;/em&gt; que eu conheça possui uma sintaxe para que essas regras não sejam quebradas. Java, por exemplo, tem atributos &lt;em&gt;final&lt;/em&gt; onde, uma vez inicializados, não podem ter seu endereço de memória substituído.&lt;/p&gt;

&lt;p&gt;Sven Barth, um integrante do FPC team, &lt;a href=&quot;http://lists.freepascal.org/pipermail/fpc-pascal/2017-July/051941.html&quot;&gt;me falou&lt;/a&gt; sobre um &lt;code&gt;{$modeswitch
finalfields}&lt;/code&gt; que foi implementado para a interoperabilidade do FPC para a JVM plataforma, porém ainda não disponível.&lt;/p&gt;

&lt;p&gt;Então temos que trabalhar apenas com o conceito ou utilizar ferramentas de verificação de código para que essa regra não seja quebrada.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/imutabilidade-do-estado</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/imutabilidade-do-estado</guid>
      </item>
    
      <item>
        <title>Diretivas de Compilação</title>
        <description>&lt;p&gt;Diretivas de Compilação podem lhe ajudar a tornar seu código &lt;em&gt;multi-plataform&lt;/em&gt; ou até mesmo &lt;em&gt;cross-compiled&lt;/em&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-mathyas-kurmann-102977.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Mathyas Kurmann on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freepascal.org/docs-html/prog/progch1.html&quot;&gt;Diretivas de Compilação&lt;/a&gt; são comandos poderosos que o desenvolvedor pode utilizar para customizar a compilação.&lt;/p&gt;

&lt;p&gt;Essas Diretivas passam parâmetros para o compilador, informando os &lt;em&gt;argumentos&lt;/em&gt; da compilação, &lt;em&gt;como&lt;/em&gt; deve ser compilado e &lt;em&gt;o que&lt;/em&gt; deve ser compilado.&lt;/p&gt;

&lt;p&gt;Existem basicamente &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Delphi_compiler_directives&quot;&gt;3 tipos&lt;/a&gt; de Diretivas de Compilação:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Switch directive&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Parameter directive&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Conditional compilation directive&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Os dois primeiros tipos alteram os parâmetros de compilação, enquanto o último altera o que o compilador irá executar.&lt;/p&gt;

&lt;p&gt;Nesse artigo iremos tratar do último tipo: &lt;em&gt;Condicionais&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;condicionais&quot;&gt;Condicionais&lt;/h2&gt;

&lt;p&gt;Apesar de serem comandos poderosos, &lt;em&gt;não&lt;/em&gt; devem ser utilizados levianamente.&lt;/p&gt;

&lt;p&gt;Com apenas alguns comandos condicionais, seu código &lt;a href=&quot;https://freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt; ou &lt;a href=&quot;https://www.embarcadero.com/products/delphi&quot;&gt;Delphi&lt;/a&gt; pode ser compilável em várias plataformas.&lt;/p&gt;

&lt;p&gt;Entretanto, a medida que vamos adicionando mais e mais diretivas, o código irá ficar mais complexo.&lt;/p&gt;

&lt;p&gt;Vejamos o exemplo abaixo:
&lt;script src=&quot;https://gist.github.com/mdbs99/dffca8326e924f4e036485a5674ea147.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;No código acima apenas a 1º e 3º chamada da função &lt;em&gt;Writeln&lt;/em&gt; serão executadas.&lt;/p&gt;

&lt;p&gt;Todas as diretivas e também a 2º chamada de &lt;em&gt;Writeln&lt;/em&gt; não irão fazer parte do executável final.&lt;/p&gt;

&lt;p&gt;Bem legal.&lt;/p&gt;

&lt;p&gt;Entretanto, veja que o código ficou bem “poluído” e também temos um &lt;a href=&quot;/posts/objetos-imutaveis/#acoplamento-temporal&quot;&gt;acoplamento temporal&lt;/a&gt;, pois as  constantes precisam ser definidas numa ordem específica.&lt;/p&gt;

&lt;p&gt;Diretivas e Definições de constantes que serão utilizadas em apenas numa única &lt;a href=&quot;/declarando-unidades&quot;&gt;Unidade&lt;/a&gt; pode até ser gerenciável, mas e se tivermos trabalhando com dezenas ou até centenas de Unidades que irão utilizar as mesmas diretivas e definições, ainda acha que essa abordagem é a melhor escolha para a arquitetura do seu projeto com a finalidade de construí-lo como &lt;em&gt;multi-plataform&lt;/em&gt; ou &lt;em&gt;cross-compiled&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Eu acho que &lt;em&gt;não&lt;/em&gt; e é por isso que no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt; estamos utilizando uma abordagem diferente.&lt;/p&gt;

&lt;h2 id=&quot;encapsulando&quot;&gt;Encapsulando Diretivas&lt;/h2&gt;

&lt;p&gt;No James estamos codificando num estilo que chamo de &lt;em&gt;Encapsulamento de Diretivas&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Um dos objetivos desse projeto é ser &lt;em&gt;cross-compiled&lt;/em&gt;, ou seja, ele irá compilar em Free Pascal e Delphi. No entanto não queremos que nem os usuários (desenvolvedores) ou os autores desse projeto se preocupem com diretivas de compilação.&lt;/p&gt;

&lt;p&gt;Atualmente não há diretivas condicionais no código de implementação dos métodos — com exceção da classe &lt;code&gt;TXMLComponent&lt;/code&gt; que deverá ser &lt;a href=&quot;https://github.com/mdbs99/james/issues/65&quot;&gt;refatorada&lt;/a&gt; em breve.&lt;/p&gt;

&lt;p&gt;O motivo dessa abordagem é que não queremos nos preocupar em  quebrar um código que é utilizado por 2 compiladores diferentes.&lt;/p&gt;

&lt;p&gt;Não utilizamos arquivos &lt;em&gt;“include”&lt;/em&gt; com pedaços de código.&lt;/p&gt;

&lt;p&gt;Não utilizamos definições globais de condicionais.&lt;/p&gt;

&lt;p&gt;Diretiva condicional é uma técnica &lt;em&gt;procedural&lt;/em&gt;. Não gostamos.&lt;/p&gt;

&lt;p&gt;Ao invés disso, utilizamos apenas &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;implementacao&quot;&gt;Implementação&lt;/h2&gt;

&lt;p&gt;Imagine uma Unidade que contenha classes para &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;representar&lt;/a&gt; a criptografia &lt;a href=&quot;https://en.wikipedia.org/wiki/MD5&quot;&gt;MD5&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No Free Pascal já temos uma Unidade &lt;code&gt;md5&lt;/code&gt; que tem funções que fazem esse trabalho — e é claro que temos que fazer Objetos para encapsular essas funções.&lt;/p&gt;

&lt;p&gt;No Delphi a Unidade que faz o mesmo trabalho é denominada &lt;code&gt;hash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Não queremos “reinventar a roda”. Queremos utilizar o que já está pronto em ambas as plataformas.&lt;/p&gt;

&lt;p&gt;Então, como fazer essa implementação sem utilizar diretivas condicionais no código de implementação ou arquivos de inclusão?&lt;/p&gt;

&lt;p&gt;Bem, no James temos a Unidade &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.crypto.md5.clss.pas&quot;&gt;James.Crypto.MD5.Clss&lt;/a&gt; com algumas classes que representam MD5.&lt;/p&gt;

&lt;p&gt;Essa é a única Unidade (até a data desse artigo) que os usuários devem utilizar para trabalhar com MD5.&lt;/p&gt;

&lt;p&gt;Nós, autores do projeto, poderíamos separar alguns desenvolvedores para trabalhar na implementação Free Pascal e outros para trabalhar na implementação Delphi, se assim o desejarmos, pois as implementações estão separadas em Unidades distintas.&lt;/p&gt;

&lt;p&gt;Primeiro criamos mais duas Unidades que serão utilizadas pela &lt;code&gt;James.Crypto.MD5.Clss&lt;/code&gt;:
Uma para Free Pascal e outra para o Delphi.&lt;/p&gt;

&lt;p&gt;São elas &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.crypto.md5.fpc.pas&quot;&gt;James.Crypto.MD5.FPC&lt;/a&gt; e &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.crypto.md5.delphi.pas&quot;&gt;James.Crypto.MD5.Delphi&lt;/a&gt;, respectivamente.&lt;/p&gt;

&lt;p&gt;Veja abaixo como implementamos isso:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/1bc867bb6303223496c44d221eae9044.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Ambas as Unidades possuem a definição da Classe &lt;code&gt;TMD5Hash&lt;/code&gt; (sim, mesmo nome em ambas). Então bastou criar um &lt;em&gt;alias&lt;/em&gt; (novamente, com o mesmo nome) direcionando &lt;code&gt;TMD5Hash&lt;/code&gt; para a classe correta (dependente da plataforma) e, &lt;em&gt;voilá!&lt;/em&gt;, temos uma Unidade “limpa” e sem condicionais na implementação dos métodos.&lt;/p&gt;

&lt;p&gt;Agora temos duas Classes distintas, em Unidades diferentes, que podem evoluir independentemente sem receio de quebrar o código entre plataformas.&lt;/p&gt;

&lt;p&gt;A clase &lt;code&gt;TMD5Stream&lt;/code&gt; não tem nenhuma diferença entre os compiladores, então é implementada diretamente na Unidade &lt;code&gt;James.Crypto.MD5.Clss&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Diretiva de Compilação é uma boa ferramenta para customização do código, porém deve ser utilizada com parcimônia.&lt;/p&gt;

&lt;p&gt;No código &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;Orientado a Objetos&lt;/a&gt;, dê preferência aos Objetos para resolver seus problemas.&lt;/p&gt;

&lt;p&gt;Para cada diretiva condicional que você queira adicionar no código de implementação, sugiro implementar um novo Objeto que encapsule a diretiva.&lt;/p&gt;

&lt;p&gt;Seu código ficará mais limpo e sustentável.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/diretivas-de-compilacao</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/diretivas-de-compilacao</guid>
      </item>
    
  </channel>
</rss>
