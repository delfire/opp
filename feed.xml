<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Objetos Complexos</title>
        <description>&lt;p&gt;Um Objeto não é apenas uma instância de uma Classe. Ele pode conter instâncias (quase) infinitas de diferentes Classes combinadas.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-chuttersnap-378918.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by chuttersnap on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;No mundo real convivemos constantemente com Objetos (humanos, animais, plantas, coisas, etc) que possuem todo tipo de &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamento&lt;/a&gt; especializado. Alguns desses Objetos — talvez a maioria — fazem coisas demais, ou seja, eles agregam muitas funcionalidades num único “corpo”. Eles são &lt;em&gt;complexos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Quando tentamos abstrair e implementar um &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Objeto ou Entidade&lt;/a&gt; no &lt;em&gt;software&lt;/em&gt;, utilizando uma linguagem de programação em conjunto com o paradigma da Orientação a Objetos, uma dúvida comum em quase todos os desenvolvedores iniciantes — ou mesmo experientes — é tentar identificar quais métodos irão ser implementados na Classe, baseado apenas no comportamento “final” do Objeto ou Entidade do mundo real.&lt;/p&gt;

&lt;p&gt;O comportamento final ao que me refiro é como vemos um Objeto e suas funcionalidades sem considerar as partes que os compõem. Vemos um Objeto como um &lt;em&gt;todo&lt;/em&gt; e não como uma soma das partes.&lt;/p&gt;

&lt;p&gt;Esse é um grande equívoco no desenvolvimento de software.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo. Como representamos um &lt;em&gt;Carro&lt;/em&gt; utilizando a &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;O primeiro passo seria determinar o nível de abstração dos comportamentos que precisamos implementar ou descartar. Em outras palavras, é necessário saber os requisitos do sistema para sabermos o que é realmente necessário.  Se a cor do carro é irrelevante para os requisitos do usuário dentro do &lt;em&gt;software&lt;/em&gt;, então não há necessidade de implementarmos. É necessário saber se a carroceria utiliza fibra de carbono ou alumínio? Se o carro é 4x4, sua velocidade máxima, quantidade de airbags, tipo de roda? Se nada disso for importante, descartamos. Então, o mais fácil a fazer é pensarmos no que é &lt;em&gt;necessário&lt;/em&gt;, pois é quase certo que qualquer Objeto implementado não irá representar uma entidade completamente, ou seja, com todo comportamento que a entidade possui no mundo real.&lt;/p&gt;

&lt;p&gt;Após termos o comportamento necessário já definido, o próximo passo é pensar na estrutura da Classe.&lt;/p&gt;

&lt;p&gt;É aqui, neste momento, que a grande maioria dos desenvolvedores utiliza o paradigma procedural, porém pensam que estão programando Orientado a Objetos apenas por quê estão utilizando Classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TCar = class
  public
    procedure Run;
    procedure Brake;
    function CheckBrakeFluid: Boolean;
    function CheckOil: Boolean;
    function CheckWater: Boolean;
    procedure LockDoors;
    procedure UnlockDoors;
    procedure StartEngine;
    procedure StopEngine;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Classe acima mostra de forma simples os comportamentos necessários que foram solicitados, hipoteticamente, nos requisitos do usuário. Mas será esse é o design &lt;em&gt;correto&lt;/em&gt; para representar um carro dentro do &lt;em&gt;software&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Apesar das funcionalidades estarem bem evidentes e com &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/&quot;&gt;nomes de métodos&lt;/a&gt; bem “explicativos”, essa é uma implementação totalmente equivocada.&lt;/p&gt;

&lt;p&gt;Um carro não &lt;em&gt;corre&lt;/em&gt;. É o motor que gira e, através de mecanismos e engrenagens, passa energia para as rodas fazendo o carro se mover através do atrito dos pneus com o asfalto.&lt;/p&gt;

&lt;p&gt;Um carro não &lt;em&gt;freia&lt;/em&gt;. É o motorista que através de um pedal, em conjunto com cabos ou mesmo eletrônica, envia um comando às pinças de freio. Essas, em conjunto com os discos de freio, fazem o carro parar.&lt;/p&gt;

&lt;p&gt;Um carro não faz &lt;em&gt;checagens&lt;/em&gt; de fluídos. Existem sensores específicos para fazer essa leitura a cada segundo ou microssegundo.&lt;/p&gt;

&lt;p&gt;Fica claro aqui, que não devemos ver a entidade como um todo, mas sim pensar nas partes específicas que a compõe. No entanto, não devemos especializar demais para não complicarmos o modelo desnecessariamente.&lt;/p&gt;

&lt;p&gt;Vamos reescrever a Classe acima.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TBrakes = class(TInterfacedObject, IBrakes)
  public
    function Brake(AForce: Double): IBrakes;
  end;
  
  TSensors = class(TInterfacedObject, ISensors)
  public
    function CheckBrakeFluid: Boolean;
    function CheckOil: Boolean;
    function CheckWater: Boolean;
  end;
  
  TDoors = class(TInterfacedObject, IDoors)
  public
    function Lock: IDoors;
    function Unlock: IDoors;
  end;
  
  TEngine = class(TInterfacedObject, IEngine)
  public
    procedure Start;
    procedure Stop;
    function Work: IEngine;
  end;
  
  TCar = class(TInterfacedObject, ICar)
  public
    procedure Run;
    function Brakes: IBrakes;
    function Sensors: ISensors;
    function Doors: IDoors;
    function Engine: IEngine;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Há várias possibilidade de implementação, mas a opção sugerida acima separa bem o comportamento de um carro através da composição de Objetos. No entanto, não há necessidade de especializar tudo. Por exemplo, o método &lt;code&gt;Run&lt;/code&gt; continua o mesmo; existe apenas uma Classe &lt;code&gt;TSensors&lt;/code&gt; para todos os sensores — seria muito melhor se tivéssemos uma Classe por sensor.&lt;/p&gt;

&lt;p&gt;O design deve ser o mais simples possível, porém correto, reutilizável (partes independentes) e testável (cada parte em separado).&lt;/p&gt;

&lt;p&gt;Na minha opinião, a &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt;, a reutilização e a testabilidade devem ser alguns dos maiores objetivos a serem seguidos no design de cada Classe.&lt;/p&gt;

&lt;p&gt;Essa foi uma maneira de implementar algo complexo de forma simples.&lt;/p&gt;

&lt;p&gt;Um outro padrão de desenvolvimento que podemos utilizar para implementarmos algo complexo é chamado de &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração de Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Imagine que você tenha diferentes modelos de motores. Utilizar &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança de Classes&lt;/a&gt; pode ser a primeira técnica que vem a sua mente, porém a Decoração de Objetos pode ser bem melhor. Utilizando essa técnica, podemos decorar Objetos em &lt;em&gt;runtime&lt;/em&gt; de acordo com os requisitos ou escolhas feita pelos usuários num determinado momento.&lt;/p&gt;

&lt;p&gt;Então, seguindo nosso exemplo, imagine um motor chamado X13 e uma versão com mais performance chamada X15 que possui um turbo compressor. Ao implementarmos essas Classes, gostaríamos de reutilizar as partes em comum. Sendo o X15 uma melhoria do X13, que tal &lt;em&gt;decorar&lt;/em&gt; o X13 em &lt;em&gt;runtime&lt;/em&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  Engine: IEngine;
begin
  Engine := 
    TX15Engine.New(
      0.6, // pressure
      TX13Engine.New()
    );
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo, a variável &lt;code&gt;Engine&lt;/code&gt; será, de certa forma, um Objeto &lt;em&gt;combinado&lt;/em&gt; de duas instâncias de Classes diferentes, porém complementares.&lt;/p&gt;

&lt;p&gt;Para implementarmos Objetos complexos, devemos analisar suas partes, de acordo com o nível de abstração requerido, e implementar cada uma delas, combinando-as entre si, para então termos a implementação de um Objeto maior e mais &lt;em&gt;complexo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“O todo é maior que a soma das partes”.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/objetos-complexos</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/objetos-complexos</guid>
      </item>
    
      <item>
        <title>O Procedimento Exit</title>
        <description>&lt;p&gt;Todos os programadores Pascal conhecem o procedimento &lt;code&gt;Exit()&lt;/code&gt; desde as primeiras versões dos compiladores. Mas será que todos sabem utilizá-lo corretamente?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-kev-seto-94686.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Kev Seto on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;O procedimento &lt;code&gt;Exit()&lt;/code&gt; é utilizado quando queremos sair de um escopo em execução. Esse escopo pode ser uma função, procedimento, método ou até mesmo o próprio programa.&lt;/p&gt;

&lt;p&gt;Vamos dizer que um programa console chame um procedimento &lt;code&gt;Execute&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  Writeln(&#39;1. Passing on this line...&#39;);
  Exit;
  Writeln(&#39;2. It will not pass here&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, somente a informação do primeiro &lt;code&gt;Writeln&lt;/code&gt; será mostrado no console.&lt;/p&gt;

&lt;p&gt;Ao sair de um escopo, o programa retorna imediatamente para o escopo anterior (outra função/procedimento/método ou o próprio programa). A única exceção a essa regra é quando há blocos &lt;code&gt;try-finally&lt;/code&gt;. Se &lt;code&gt;Exit()&lt;/code&gt; for chamado dentro de um bloco &lt;code&gt;try-finally&lt;/code&gt; o compilador irá executar o código dentro do &lt;code&gt;finally-end&lt;/code&gt; &lt;em&gt;antes&lt;/em&gt; de sair do escopo.&lt;/p&gt;

&lt;p&gt;Aqui está outro exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  try
    Writeln(&#39;1. Passing on this line...&#39;);
    Exit;
  finally
    Writeln(&#39;2. I am still here!&#39;);
  end;
  Writeln(&#39;3. It will not pass here&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os textos #1 e #2 serão mostrados no console. Mesmo que &lt;code&gt;Exit()&lt;/code&gt; tenha sido chamado antes da impressão do texto #2, ainda sim o código é executado devido ao &lt;code&gt;try-finally&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Outro exemplo de uso do &lt;code&gt;Exit()&lt;/code&gt; é quando fazemos validações. Se uma validação ou checagem não retornar verdadeiro, utilizamos o &lt;code&gt;Exit()&lt;/code&gt; para parar a execução do escopo atual.&lt;/p&gt;

&lt;p&gt;Suponha que queremos somar dois números inteiros, mas só queremos números maiores que zero:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;lt; 0) or (B &amp;lt; 0) then
    Exit;
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, o retorno da função &lt;code&gt;Sum&lt;/code&gt; é inicializado com um valor inválido e depois há uma validação para saber se os valores são menores que &lt;code&gt;0&lt;/code&gt;. Se o teste falhar, o programa irá retornar para o escopo anterior à chamada da função &lt;code&gt;Sum&lt;/code&gt; com o resultado inválido. Mas se o teste não falhar, o resultado da função será a soma de A e B.&lt;/p&gt;

&lt;p&gt;Há aqueles que são adeptos da programação estruturada e preferem não “quebrar” a execução do programa com uma “saída antecipada”, ou seja, não fazem uso do &lt;code&gt;Exit()&lt;/code&gt; por acreditarem que o código ficaria mais simples.&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  if (A &amp;gt; 0) and (B &amp;gt; 0) then
    Result := Format(&#39;The result is %d&#39;, [A + B]);
  else
    Result := &#39;Invalid result&#39;;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parece mais simples? Bem, nesse exemplo eu diria que sim. Porém para exemplos com mais condicionais, eu diria que não (vamos ver isso mais abaixo).&lt;/p&gt;

&lt;p&gt;E se quiséssemos dizer ao usuário que seus dados não estão corretos?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;gt; 0) then
  begin
    if (B &amp;gt; 0) then
      Result := Format(&#39;The result is %d&#39;, [A + B]);
    else
      Writeln(&#39;B should be greater than zero&#39;);
  end
  else
    Writeln(&#39;A should be greater than zero&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo não utilizamos &lt;code&gt;Exit()&lt;/code&gt; e eu acho que o código está bem confuso. Os testes estão “separados” do retorno de aviso para o usuário (&lt;code&gt;Writeln&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Kent Beck , Martin Fowler &lt;a href=&quot;https://en.wikipedia.org/wiki/Structured_programming#Early_exit&quot;&gt;afirmaram&lt;/a&gt; categoricamente que &lt;em&gt;“um ponto de saída não é realmente uma regra útil. A clareza é o princípio chave: se o método for mais claro com um ponto de saída, use um ponto de saída, caso contrário, não”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior com o uso de &lt;code&gt;Exit()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;lt; 0) then
  begin
    Writeln(&#39;A should be greater than zero&#39;);
    Exit;
  end;
  if (B &amp;lt; 0) then
  begin
    Writeln(&#39;B should be greater than zero&#39;);
    Exit;
  end;
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código ficou um pouco maior, é verdade, porém os testes e avisos para o usuário ficaram mais simples, na minha opinião. Você não precisa acompanhar todos os &lt;code&gt;if-else&lt;/code&gt; aninhados. A cada teste que falhar, o aviso está logo abaixo e o escopo será abortado com o uso do &lt;code&gt;Exit()&lt;/code&gt;. Se todos os testes não falharem, a função irá retornar a soma de A e B.&lt;/p&gt;

&lt;p&gt;No Delphi, a partir da &lt;a href=&quot;http://docs.embarcadero.com/products/rad_studio/delphiAndcpp2009/HelpUpdate2/EN/html/delphivclwin32/System_Exit.html&quot;&gt;versão 2009&lt;/a&gt;, o procedimento &lt;code&gt;Exit()&lt;/code&gt; ganhou uma melhoria: &lt;code&gt;Exit()&lt;/code&gt; pode ter um parâmetro especificando um resultado. O parâmetro deve ser do mesmo tipo que o resultado da função.&lt;/p&gt;

&lt;p&gt;O FPC também tem a &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/exit.html&quot;&gt;mesma definição&lt;/a&gt;, porém não sei quem implementou essa nova &lt;em&gt;feature&lt;/em&gt; primeiro.&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  if (A &amp;lt; 0) then
    Exit(&#39;A should be greater than zero&#39;);
  if (B &amp;lt; 0) then
    Exit(&#39;B should be greater than zero&#39;);
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/posts/simplicidade/&quot;&gt;Simples&lt;/a&gt; e limpo.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Exit()&lt;/code&gt; pode receber como parâmetro qualquer tipo de retorno, até mesmo instâncias de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;. Utilizando esse parâmetro, é como se ganhássemos o mesmo comportamento da palavra reservada &lt;code&gt;return&lt;/code&gt;, em Java. No entanto, &lt;code&gt;Exit()&lt;/code&gt; em conjunto com &lt;code&gt;Result&lt;/code&gt; nos dá ainda mais possibilidades de retorno para as funções.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/exit-proc</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/exit-proc</guid>
      </item>
    
      <item>
        <title>Pas2JS: Codificando em Pascal, Executando em JavaScript</title>
        <description>&lt;p&gt;A equipe do Free Pascal e Lazarus nos deram um grande presente de Final de Ano: Um Transpiler de Pascal para JavaScript.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-greg-rakozy-129733.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Greg Rakozy on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O uso do JavaScript é necessário para qualquer aplicação Web. Somos obrigados a utilizá-lo por quê (por enquanto) é a única linguagem que os &lt;em&gt;browsers&lt;/em&gt; entendem.&lt;/p&gt;

&lt;p&gt;Mas JavaScript não é fortemente tipado como Pascal e isso pode ser um grande problema quando codificamos aplicações maiores utilizando somente JavaScript.&lt;/p&gt;

&lt;p&gt;JavaScript pode ser &lt;em&gt;confuso&lt;/em&gt; e &lt;em&gt;ambíguo&lt;/em&gt;. Por isso muitos desenvolvedores &lt;em&gt;devem&lt;/em&gt; utilizar &lt;em&gt;frameworks&lt;/em&gt; que facilitam o desenvolvimento e padronizam a codificação.&lt;/p&gt;

&lt;p&gt;Codificar utilizando JavaScript &lt;em&gt;puro&lt;/em&gt; não é uma tarefa fácil.&lt;/p&gt;

&lt;p&gt;Então surgiram os &lt;a href=&quot;https://en.wikipedia.org/wiki/Source-to-source_compiler&quot;&gt;Transpilers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Um Transpiler é um compilador que, a partir de um código-fonte escrito em uma linguagem de programação como sua entrada, produz um código-fonte equivalente em outra linguagem de programação.&lt;/p&gt;

&lt;p&gt;Existem &lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS&quot;&gt;vários&lt;/a&gt; Transpilers para JavaScript a partir de várias linguagens de programação. O mais famoso deles, eu acredito, é a linguagem TypeScript da Microsoft.&lt;/p&gt;

&lt;p&gt;A linguagem Pascal está incluída nesse pacote de Transpilers, no entanto, além de existir poucos, eles são comerciais.&lt;/p&gt;

&lt;p&gt;Felizmente, agora temos uma opção gratuita e Open Source chamada &lt;strong&gt;Pas2JS&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;pas2js&quot;&gt;Pas2JS&lt;/h2&gt;

&lt;p&gt;Michael Van Canneyt (Free Pascal Team), Mattias Gaertner (Lazarus Team), e colaboradores, &lt;a href=&quot;http://lists.lazarus-ide.org/pipermail/lazarus/2017-December/233592.html&quot;&gt;lançaram oficialmente&lt;/a&gt; o compilador utilitário chamado &lt;a href=&quot;http://wiki.freepascal.org/pas2js&quot;&gt;Pas2JS&lt;/a&gt;, em 16 de Dezembro de 2017, na lista oficial do Free Pascal.&lt;/p&gt;

&lt;p&gt;O JavaScript gerado a partir de um código-fonte Pascal é utilizável no &lt;em&gt;browser&lt;/em&gt; ou até mesmo no Node.js.&lt;/p&gt;

&lt;p&gt;Ao invés de gerar um executável com seu código Pascal, um arquivo .js será gerado, compatível com seu &lt;em&gt;browser&lt;/em&gt;, sem a necessidade de haver um servidor de aplicação (CGI, FastCGI, ISAPI, etc) se o aplicativo não necessitar de dados externos.&lt;/p&gt;

&lt;p&gt;Como disse Michael no seu email de lançamento (tradução livre):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Isso torna o Free Pascal um ambiente de desenvolvimento completo para o desenvolvimento Web”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Na verdade, o desenvolvimento ainda não está (totalmente) completo. Funciona muito bem, porém ainda há melhorias a serem feitas, como pode ser visto &lt;a href=&quot;http://wiki.freepascal.org/pas2js#Other_not_implemented_features&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A sintaxe básica é a mesma do Delphi 7&lt;/strong&gt;, porém ainda não temos o suporte a Interfaces. Acredito que teremos isso em breve, no entanto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A RTL teve que ser reescrita&lt;/strong&gt;, gerando novas versões das Unidades padrão para que pudessem ser utilizadas perfeitamente na conversão de Pascal para JavaScript. A lista das unidades você pode ver &lt;a href=&quot;http://wiki.freepascal.org/pas2js#RTL&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O debugging pode ser feito diretamente no código Object Pascal&lt;/strong&gt;, dentro do &lt;em&gt;browser&lt;/em&gt;. Isso é possível por quê o Pas2JS emite um &lt;em&gt;“source map”&lt;/em&gt; para que o &lt;em&gt;browser&lt;/em&gt; exiba o código original em vez do código JavaScript, o que é muito útil para encontrar bugs no código original Pascal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lazarus já tem suporte para a sintaxe do Pas2JS&lt;/strong&gt;, então o &lt;em&gt;code completion&lt;/em&gt; irá funcionar (versão trunk).&lt;/p&gt;

&lt;p&gt;A integração completa do Pas2JS está sendo codificada no Lazarus e, futuramente, eles já falam em desenvolver pacotes de componentes para execução no &lt;em&gt;browser&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TMS Web componentes vai chegar no início de 2018&lt;/strong&gt;. São componentes visuais no bom estilo RAD para desenvolver aplicações Web utilizando &lt;code&gt;TForm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cito a TMS aqui por quê, no email do Michael, ele diz (tradução livre):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Em um futuro muito próximo, um importante fornecedor de componentes da Delphi anunciará um pacote completo para desenvolvimento web RAD no Delphi IDE.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu &lt;em&gt;acredito&lt;/em&gt; que ele estava falando da &lt;a href=&quot;https://www.tmssoftware.com/site/&quot;&gt;TMS&lt;/a&gt;, empresa conceituada que se dedica à fabricação de componentes e frameworks para Delphi e Lazarus.&lt;/p&gt;

&lt;p&gt;A alguns dias atrás os desenvolvedores do Brasil tiveram a chance de ver algumas palestras sobre Delphi e uma delas foi o anúncio da nova tecnologia da TMS para desenvolvimento Web, por Wagner Landgraf.&lt;/p&gt;

&lt;p&gt;Para quem acompanha os pré-anúncios do Pas2JS já algum tempo — pois ele está sendo desenvolvido ao longo de 10 anos — basta “ligar os pontos” para ter quase certeza que os componentes TMS Web utiliza a tecnologia Pas2JS ou, no mínimo, se inspirou nela.&lt;/p&gt;

&lt;p&gt;No entanto, na palestra do Wagner não há nenhuma menção ao Pas2JS.&lt;/p&gt;

&lt;p&gt;Se eu estou certo, ou seja, se a TMS Web realmente utiliza o Pas2JS no seu novo produto, eu considero uma &lt;em&gt;falha&lt;/em&gt; não mencionar quem criou o Transpiler.&lt;/p&gt;

&lt;p&gt;Não há nenhum problema em criar componentes para comercialização, no entanto é necessário dar o crédito a quem é devido.&lt;/p&gt;

&lt;p&gt;Entretanto, isso é apenas uma suposição pessoal. Se a TMS não utiliza/utilizou o Pas2JS, acredito que saberemos disso em breve.&lt;/p&gt;

&lt;p&gt;Mas, independentemente da TMS utilizar ou não o Pas2JS, fico ansioso para ver o lançamento oficial do novo &lt;em&gt;framework&lt;/em&gt;, visto que tais componentes irão funcionar também no Lazarus.&lt;/p&gt;

&lt;p&gt;Sendo a TMS &lt;em&gt;referência&lt;/em&gt; em componentes desde a primeira versão do Delphi, é de se esperar que esse será mais um grande sucesso.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;preview&lt;/em&gt; da tecnologia exposto na palestra foi excelente e motivador.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Para uma linguagem que muitos consideram “morta”, ter um Transpiler de Object Pascal para JavaScript é um grande impulso para por a linguagem (novamente) nos “trilhos do mercado”.&lt;/p&gt;

&lt;p&gt;Sabemos que hoje em dia muitas empresas optam por desenvolver soluções 100% online, via &lt;em&gt;browser&lt;/em&gt;, ao invés de aplicações Desktop.&lt;/p&gt;

&lt;p&gt;Com o Pas2JS será possível termos uma &lt;em&gt;única&lt;/em&gt; base de código Object Pascal — uma linguagem fortemente tipada, limpa e de fácil aprendizagem — onde poderemos utilizar todo o nosso conhecimento da linguagem, da RTL e componentes, para provermos aplicações 100% Web. Confiáveis, rápidas e de fácil manutenção.&lt;/p&gt;

&lt;p&gt;É esperar, pra ver.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/pas2js</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/pas2js</guid>
      </item>
    
      <item>
        <title>Mais Performance usando Argumentos &quot;const&quot; para Interfaces</title>
        <description>&lt;p&gt;Se você utiliza instâncias de Interfaces em todos os lugares e quer aumentar um pouco a performance do seu código, leia esse artigo.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-alex-holyoake-334209.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Alex Holyoake on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Em um código verdadeiramente Orientado a Objetos, as instâncias dos Objetos devem ser do tipo Interface em &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;todos os lugares&lt;/a&gt; do código.&lt;/p&gt;

&lt;p&gt;Além de prover um contrato entre os Objetos, as instâncias de Interfaces são auto-gerenciadas, ou seja, a memória é liberada automaticamente pelo compilador.&lt;/p&gt;

&lt;p&gt;No Free Pascal, no entanto, podemos ter instâncias de Interfaces que não são auto-gerenciadas. Essas interfaces utilizam o modelo &lt;a href=&quot;https://www.freepascal.org/docs-html/prog/progsu37.html&quot;&gt;CORBA&lt;/a&gt; com a directiva &lt;code&gt;{$interfaces corba}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Porém, o &lt;em&gt;default&lt;/em&gt; de uso de Interfaces é o modelo COM, com auto-gerenciamento de memória através de um contador interno de referências à instância.&lt;/p&gt;

&lt;p&gt;Esse auto-gerenciamento tem um custo computacional de execução, mas pode ser extremamente minimizado com apenas uma pequena alteração no código.&lt;/p&gt;

&lt;p&gt;Entretanto, para você entender como essa pequena alteração irá afetar a performance do seu código, antes você precisa saber como o compilador faz o auto-gerenciamento de memória de instâncias de Interfaces.&lt;/p&gt;

&lt;h2 id=&quot;metodos-especiais&quot;&gt;Métodos Especiais&lt;/h2&gt;

&lt;p&gt;Todo Objeto que implementa uma Interface COM — &lt;code&gt;IUnknown&lt;/code&gt; — deve implementar 3 Métodos especiais que não fazem parte da Interface.&lt;/p&gt;

&lt;p&gt;Funciona assim:&lt;/p&gt;

&lt;p&gt;Quando criamos uma instância do tipo Interface, o compilador irá chamar um método especial do Objeto chamado &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown._addref.html&quot;&gt;_AddRef&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse método irá aumentar uma contagem de referência, toda vez que uma nova variável receber a mesma instância do Objeto.&lt;/p&gt;

&lt;p&gt;Da mesma forma, toda vez que uma variável sair do escopo de execução, o compilador irá chamar o método &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown._release.html&quot;&gt;_Release&lt;/a&gt; para decrementar a contagem.&lt;/p&gt;

&lt;p&gt;Quando a contagem de referência — o atributo &lt;code&gt;FRefCount: LongInt&lt;/code&gt; — chegar a zero, o destrutor do Objeto será executado e a memória será liberada.&lt;/p&gt;

&lt;p&gt;Esse mecanismo é muito, muito mais simples do que ter um &lt;em&gt;garbage collector&lt;/em&gt; sendo executado em paralelo, como é feito em outras linguagens.&lt;/p&gt;

&lt;p&gt;Existe mais um terceiro e último método chamado &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown.queryinterface.html&quot;&gt;QueryInterface&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse método é utilizado quando fazemos &lt;a href=&quot;/posts/nao-utilize-casting/&quot;&gt;&lt;em&gt;casting&lt;/em&gt;&lt;/a&gt; do Objeto para Interface utilizando a estrutura &lt;code&gt;Intf := Obj as IMyInterface;&lt;/code&gt; ou quando utilizamos a função &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/sysutils/supports.html&quot;&gt;Supports&lt;/a&gt; para determinar se uma instância implementa ou não uma determinada Interface.&lt;/p&gt;

&lt;p&gt;Todas as Classes que implementam uma ou mais Interfaces, devem ter esses 3 métodos implementados.&lt;/p&gt;

&lt;p&gt;Esse é o motivo de herdarmos quase todas as nossas Classes de &lt;code&gt;TInterfacedObject&lt;/code&gt;, pois ela já contém a implementação destes métodos para lidar com a contagem de referência.&lt;/p&gt;

&lt;p&gt;Implementamos esses métodos apenas para o compilador e é possível sabermos o momento no qual o compilador irá chamá-los, sobrecarregando o código com execuções além da implementação padrão dos Métodos do Objeto.&lt;/p&gt;

&lt;p&gt;Então, se conseguirmos evitar tais chamadas, nosso código terá mais performance pois ciclos de CPU serão poupados.&lt;/p&gt;

&lt;h2 id=&quot;sobrecarga&quot;&gt;Sobrecarga&lt;/h2&gt;

&lt;p&gt;Devido as chamadas automáticas de &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; em toda atribuição e saída de escopo das variáveis, muitos desenvolvedores acham que essa é uma &lt;em&gt;grande&lt;/em&gt; sobrecarga para o código.&lt;/p&gt;

&lt;p&gt;Na Engenharia nada é grátis, havendo sempre prós e contras.&lt;/p&gt;

&lt;p&gt;Se por um lado temos o auto-gerenciamento de memória para instâncias de Interfaces, por outro temos essa sobrecarga do incremento e decremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;Além disso, toda vez que &lt;code&gt;_Release&lt;/code&gt; for chamado, haverá uma checagem para saber se a contagem chegou a zero para que o destrutor do Objeto também seja chamado.&lt;/p&gt;

&lt;p&gt;Eu acredito que essa é uma sobrecarga &lt;em&gt;mínima&lt;/em&gt;, considerando todas as &lt;em&gt;vantagens&lt;/em&gt; que temos ao utilizar instâncias de Interfaces.&lt;/p&gt;

&lt;p&gt;Mas nem todos os desenvolvedores pensam da mesma forma.&lt;/p&gt;

&lt;p&gt;De fato, existem algoritmos que não podem se dar o luxo de perder ciclos de CPU fazendo operações de infraestrutura da linguagem — incremento/decremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;Entretanto, a linguagem Object Pascal nos dá uma “saída” bastante elegante para a diminuição de toda essa sobrecarga.&lt;/p&gt;

&lt;h2 id=&quot;argumentos-const&quot;&gt;Argumentos “const”&lt;/h2&gt;

&lt;p&gt;Sempre que uma instância for passada por parâmetro a outro Objeto através de um argumento, haverá o incremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;A menos que você utilize Argumentos “const”.&lt;/p&gt;

&lt;p&gt;Vamos chamá-los de “&lt;em&gt;ConstArgs&lt;/em&gt;”, para encurtar.&lt;/p&gt;

&lt;p&gt;Aqui está a definição, em tradução livre, de &lt;a href=&quot;https://www.freepascal.org/docs-html/ref/refsu67.html&quot;&gt;const&lt;/a&gt; na documentação do Free Pascal:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Especificar um parâmetro como Constante está dando ao compilador uma dica de que o conteúdo do parâmetro não será alterado pela rotina chamada. Isso permite que o compilador execute otimizações que não poderia fazer de outra forma, e também para executar determinadas verificações no código dentro da rotina: ou seja, pode proibir atribuições ao parâmetro. Além disso, um parâmetro const não pode ser transmitido para outra função que requer um parâmetro variável: o compilador pode verificar isso também. O principal uso para isso é reduzir o tamanho da pilha, portanto, melhorar o desempenho e ainda manter a semântica de passagem por valor…”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eles não falam nada sobre utilizar “const” para argumentos do tipo Interface, no entanto eu posso lhe afirmar que utilizá-los irá aumentar a performance do seu código.&lt;/p&gt;

&lt;p&gt;O motivo é simples: &lt;em&gt;ConstArgs&lt;/em&gt; não executam &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Isso quer dizer que o incremento/decremento do atributo de contagem de referência não irão ocorrer.&lt;/p&gt;

&lt;p&gt;A checagem se o contador interno chegou a zero também não irá existir no ASSEMBLY final gerado pelo compilador.&lt;/p&gt;

&lt;p&gt;Vou demostrar isso, começando com a unidade base de todos os exemplos:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/d7583833ddaf07df796321c95ee8faa8.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A &lt;code&gt;Unit1&lt;/code&gt; contém uma Interface e uma Classe que a implementa.&lt;/p&gt;

&lt;p&gt;Os Métodos &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram sobrescritos para termos o controle do que ocorre dentro deles quando o compilador chamá-los.&lt;/p&gt;

&lt;p&gt;Então vamos criar o primeiro programa de teste que utiliza a &lt;code&gt;Unit1&lt;/code&gt;:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/ac9932e2b0e5a3525fdf05223051d5c9.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Esse é um programa &lt;em&gt;CLI&lt;/em&gt; (&lt;em&gt;command-line&lt;/em&gt;) bem simples.&lt;/p&gt;

&lt;p&gt;É necessário setar a utilização do &lt;a href=&quot;http://wiki.freepascal.org/heaptrc&quot;&gt;&lt;em&gt;heaptrc&lt;/em&gt;&lt;/a&gt; no Lazarus para mostrar os vazamentos de memória (se houver) no final da execução do programa.&lt;/p&gt;

&lt;p&gt;Então, após a execução, no meu laptop a saída foi essa:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
_AddRef called
RefCount is 1
_AddRef called
RefCount is 2
Acting...
_Release called
_Release called
RefCount is 0
Destroing...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
64 memory blocks freed     : 1593/1720
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A execução foi bem sucedida, e não contém vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Porém, veja que &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram, ambos, chamados 2 vezes cada. Isso ocorre por quê, ao criar a instância em &lt;code&gt;A&lt;/code&gt;, há o incremento e ao passar essa instância para &lt;code&gt;Execute&lt;/code&gt;, há um novo incremento da contagem.&lt;/p&gt;

&lt;p&gt;Agora apenas altere a assinatura do procedimento, adicionando &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute(const A: IAction);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute novamente.&lt;/p&gt;

&lt;p&gt;Esse é o resultado por aqui:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
_AddRef called
RefCount is 1
Acting...
_Release called
RefCount is 0
Destroing...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
64 memory blocks freed     : 1593/1720
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A mesma memória foi consumida, mas &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram chamados apenas 1 vez cada.&lt;/p&gt;

&lt;p&gt;Isso se traduz em &lt;em&gt;mais&lt;/em&gt; performance ou &lt;em&gt;menos&lt;/em&gt; sobrecarga, dependendo do seu ponto de vista.&lt;/p&gt;

&lt;p&gt;Imagine se esse mesmo procedimento fosse chamado 100 vezes. Sem o “const” haveria mais de 100 chamadas aos Métodos especiais.&lt;/p&gt;

&lt;p&gt;Mas, se é tão simples eliminar essa sobrecarga apenas especificando o tipo do argumento, por quê nem todos os desenvolvedores utilizam essa técnica?&lt;/p&gt;

&lt;p&gt;Talvez seja apenas falta de conhecimento ou talvez eles tenham lido sobre problemas obscuros de vazamento de memória com o uso de &lt;em&gt;ConstArgs&lt;/em&gt; e Interfaces.&lt;/p&gt;

&lt;h2 id=&quot;problemas&quot;&gt;Argumentos e Interfaces&lt;/h2&gt;

&lt;p&gt;Há alguns artigos na Internet dizendo que temos que ter &lt;a href=&quot;https://pascal.today/2016/12/16/take-care-of-const-and-interface-parameters/&quot;&gt;cuidado&lt;/a&gt; ao utilizarmos &lt;em&gt;ConstArgs&lt;/em&gt; em conjunto com instâncias de Interfaces.&lt;/p&gt;

&lt;p&gt;Sim, &lt;em&gt;devemos&lt;/em&gt; ter cuidado.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O código realmente pode ficar intrincado e vazamentos de memória podem ocorrer&lt;/strong&gt; em lugares onde tudo parece estar correto.&lt;/p&gt;

&lt;p&gt;Para demonstrar vamos a outro exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/979c82ffe9288ec129b5792cfef0d9b0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;É o mesmo programa anterior, porém agora a instância de &lt;code&gt;TAction&lt;/code&gt; é criada “inline”.&lt;/p&gt;

&lt;p&gt;Após executar, esse é o resultado por aqui:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
Acting...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
63 memory blocks freed     : 1577/1704
1 unfreed memory blocks : 16
True heap size : 229376 (80 used in System startup)
True free heap : 229200
Should be : 229216
Call trace for block $01872E88 size 16
  $004015C7  main,  line 14 of C:/temp/project1.lpr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que os Métodos especiais não foram executados e há um vazamento de memória, o que não é nada bom.&lt;/p&gt;

&lt;p&gt;Mas se você retirar o “const” do procedimento, o vazamento é corrigido.&lt;/p&gt;

&lt;p&gt;Se o argumento não for um &lt;em&gt;ConstArgs&lt;/em&gt; ele poderá incrementar a contagem e não haverá vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Por isso há o mito de que “não devemos utilizar &lt;em&gt;ConstArgs&lt;/em&gt; com Interfaces” ou que devemos evitar seu uso.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Felizmente a solução para toda essa complexidade é muito simples&lt;/strong&gt;, bastando utilizar uma técnica que eu publiquei a quase dois anos atrás, na qual eu chamo de &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Altere &lt;code&gt;TAction&lt;/code&gt; adicionando o Método &lt;code&gt;New&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TAction = class(TInterfacedObject, IAction)
public
  class function New: IAction;
  // ...
end;

implementation

class function TAction.New: IAction;
begin
  Result := Create;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Altere também o programa, dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
  Execute(TAction.New);
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute e veja o resultado você mesmo.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Se você criar suas instâncias utilizando &lt;code&gt;New&lt;/code&gt; — um método da Classe — ao invés de chamar diretamente os &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt;, eu lhe asseguro que você não terá problemas de vazamento de memória, se a utilizar corretamente.&lt;/p&gt;

&lt;p&gt;Vimos nesse artigo que uma simples mudança no código pode gerar um ganho considerável de performance.&lt;/p&gt;

&lt;p&gt;Utilizando &lt;em&gt;ConstArgs&lt;/em&gt; em conjunto com a técnica chamada &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;, você poderá deixar seu código mais rápido e sem vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Dec 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/argumentos-const</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/argumentos-const</guid>
      </item>
    
      <item>
        <title>Herança de Formulário é para Iniciantes</title>
        <description>&lt;p&gt;Depois que você aprendeu como funciona a Herança de Formulários, pode esquecê-la.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-ken-treloar-346065.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Ken Treloar on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No início da minha carreira, a muitos anos atrás, alguém me mostrou a Herança de Formulário no Delphi.&lt;/p&gt;

&lt;p&gt;Mesmo em &lt;em&gt;design time&lt;/em&gt;, dois Formulários herdados estavam “sincronizados”.&lt;/p&gt;

&lt;p&gt;Ao alterar um componente de lugar (&lt;em&gt;Top&lt;/em&gt; / &lt;em&gt;Left&lt;/em&gt;) no Formulário 1, automaticamente também era alterado no outro Formulário 2 devido a Herança entre eles.&lt;/p&gt;

&lt;p&gt;E na época eu pensei: UAU!&lt;/p&gt;

&lt;p&gt;Como era rápido fazer um Formulário (simplório) de CRUD. Basta herdar e setar algumas propriedades e sobrescrever alguns Métodos.&lt;/p&gt;

&lt;p&gt;Acredito que essa é uma das &lt;em&gt;features&lt;/em&gt; mais utilizadas hoje em dia.&lt;/p&gt;

&lt;p&gt;Mas, o que tem de errado com isso?&lt;/p&gt;

&lt;h2 id=&quot;problemas&quot;&gt;Problemas&lt;/h2&gt;

&lt;p&gt;Utilizar Herança de Formulário é bom apenas para os &lt;em&gt;iniciantes&lt;/em&gt; na programação Orientada a Objetos e para o uso &lt;em&gt;superficial&lt;/em&gt; do Delphi ou Lazarus.&lt;/p&gt;

&lt;p&gt;Pode ser considerado “Ok” para criar aplicações de exemplo, ensinar sobre &lt;del&gt;como não utilizar&lt;/del&gt; a Herança simplificada e… talvez, apenas isso.&lt;/p&gt;

&lt;p&gt;Para aplicações realmente importantes, sugiro esquecer a Herança de Formulário por completo.&lt;/p&gt;

&lt;p&gt;Enquanto a &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;Herança de Classes é um mal&lt;/a&gt; que pode ser gerenciado ou mesmo utilizado de forma mais &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/&quot;&gt;apropriada&lt;/a&gt;, a Herança de Formulário acaba com todos os conceitos da verdadeira &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; é perdido&lt;/strong&gt; quando utilizamos Herança de Formulários, pois o desenvolvedor precisa ter conhecimento do comportamento interno do formulário-pai afim de conseguir fazer algo de útil no formulário-filho.&lt;/p&gt;

&lt;p&gt;Muitas vezes encontramos formulários contendo apenas Métodos protegidos ou &lt;a href=&quot;/posts/metodos-privados/&quot;&gt;privados&lt;/a&gt; sem nenhum comportamento público; eles vem do formulário-pai. E isso é muito estranho. Por quê teríamos uma Classe (Form) que, a primeira vista, não tem nenhum comportamento para o mundo externo?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A ordem de execução dos Métodos protegidos&lt;/strong&gt; que devem ser sobrescritos, devem ser de conhecimento do desenvolvedor, mais uma vez quebrando o encapsulamento.&lt;/p&gt;

&lt;p&gt;É necessário visualizar o código do formulário-pai afim de saber onde e em que momento tais métodos abstratos e protegidos são utilizados.&lt;/p&gt;

&lt;p&gt;É comum ver métodos sobrescritos que não chamam o Método herdado, “matando” o comportamento padrão da Classe ancestral quando o Método não é abstrato.&lt;/p&gt;

&lt;p&gt;Pedaços de código serão duplicados pois estão em métodos não acessíveis nos formulários-filhos.&lt;/p&gt;

&lt;p&gt;Uma bagunça.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Componentes herdados não podem ser excluídos&lt;/strong&gt;, o que resulta em mais bagunça e “código espaguete”.&lt;/p&gt;

&lt;p&gt;Como não é possível excluir componentes em formulários-filho, o desenvolvedor tem que habilitar/desabilitar ou torná-los visível/não-visível. No entanto tais componentes continuarão a serem criados no formulário…&lt;/p&gt;

&lt;p&gt;Criar formulários com componentes que não serão utilizados é realmente um desperdício de memória RAM.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualquer alteração no formulário-pai irá refletir nos formulários-filhos&lt;/strong&gt;, e isso quer dizer que você pode quebrar o sistema inteiro com pequenas modificações.&lt;/p&gt;

&lt;p&gt;Você poderia argumentar que mesmo se não utilizasse Herança, mas sim Composição de Objetos, um Objeto que fosse reaproveitado por todo o sistema também poderia quebrá-lo caso algo fosse indevidamente alterado no seu código.&lt;/p&gt;

&lt;p&gt;Correto. Mas a grande diferença é que é muito mais fácil alterar um código de apenas uma Classe &lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/&quot;&gt;pequena&lt;/a&gt; e sem dependências externas ou heranças de Classes-filhas, do que um código de Formulário onde toda lógica está contido nele além de ter a preocupação se alguma alteração irá impactar negativamente nos nos formulários-filhos.&lt;/p&gt;

&lt;h2 id=&quot;solucoes&quot;&gt;Soluções&lt;/h2&gt;

&lt;p&gt;Vejamos então algumas opções para a completa substituição da Herança de Formulário, utilizando outras técnicas mais Orientadas a Objetos, &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e limpas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Composição e &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração&lt;/a&gt; de Objetos&lt;/strong&gt; são as opções mais simples e corretas para substituir praticamente qualquer tipo de Herança.&lt;/p&gt;

&lt;p&gt;Você pode criar Classes intermediárias ou &lt;a href=&quot;/posts/classes-adaptadoras/&quot;&gt;adaptadoras&lt;/a&gt; que se comunicam entre si para instanciar Formulários complexos.&lt;/p&gt;

&lt;p&gt;Com o uso de pequenas Classes utilizadas como “interface de acesso” aos Formulários, você consegue instanciá-los, desacoplá-los entre si, instanciar &lt;em&gt;Frames&lt;/em&gt;, ler e escrever dados em componentes. Tudo em &lt;em&gt;runtime&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O uso de &lt;em&gt;Frames&lt;/em&gt; é uma ótima opção&lt;/strong&gt; para o uso de composição visual, visto que são mini-formulários embutidos em outros Formulários.&lt;/p&gt;

&lt;p&gt;Pense em como são construídas as páginas de um website. Não há herança, apenas &lt;em&gt;includes&lt;/em&gt; de “pedaços de código”: &lt;em&gt;Header&lt;/em&gt;, &lt;em&gt;Footer&lt;/em&gt;, &lt;em&gt;JavaScript&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Você pode utilizar o mesmo pensamento para o uso de &lt;em&gt;Frames&lt;/em&gt;. Pode criar um &lt;em&gt;Frame&lt;/em&gt; apenas com os botões de CRUD; outro com &lt;em&gt;Grids&lt;/em&gt;; outro para o &lt;em&gt;footer&lt;/em&gt; de todo formulário.&lt;/p&gt;

&lt;p&gt;Eu utilizo &lt;em&gt;Frames&lt;/em&gt; até mesmo sem pensar na reutilização…&lt;/p&gt;

&lt;p&gt;Explico. Imagine um Formulário com algumas abas utilizando um &lt;a href=&quot;http://wiki.lazarus.freepascal.org/TPageControl&quot;&gt;TPageControl&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Bem, não podemos ter nomes de componentes iguais num único Formulário, ou seja, se você definiu que um &lt;code&gt;TEdit&lt;/code&gt; se chama &lt;code&gt;NameEdit&lt;/code&gt; na aba 1, você não pode nomear outro &lt;code&gt;TEdit&lt;/code&gt; com o mesmo nome na aba 2, pois ambos pertencem ao mesmo Formulário.&lt;/p&gt;

&lt;p&gt;Você precisa acrescentar mais prefixos/sufixos na &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/&quot;&gt;nomenclatura&lt;/a&gt; e isso torna o código mais verboso e confuso, além do fato de que seu Formulário terá que lidar com todos os componentes de uma só vez.&lt;/p&gt;

&lt;p&gt;Em meus projetos, uma aba pode conter a instância de um &lt;em&gt;Frame&lt;/em&gt;, caso haja ações diferentes em cada aba.&lt;/p&gt;

&lt;p&gt;Por exemplo, se eu precisar adicionar uma barra de botões (ações) na aba 2, então essa aba será um &lt;em&gt;Frame&lt;/em&gt; com sua própria implementação, componentes de nomenclatura simples e ações específicas.&lt;/p&gt;

&lt;p&gt;Dentro de um &lt;em&gt;Frame&lt;/em&gt; eu não preciso me preocupar em lidar com um único código inchado que lida com todos os &lt;em&gt;widgets&lt;/em&gt; dentro de um Formulário.&lt;/p&gt;

&lt;p&gt;E se um &lt;em&gt;Frame&lt;/em&gt; precisar notificar o Formulário principal, isso pode ser feito através de &lt;a href=&quot;/eventos-e-objetos&quot;&gt;Eventos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Criar Componentes no Delphi/Lazarus é tão fácil&lt;/strong&gt; que se você precisar utilizar muito um comportamento, pode ser uma boa ideia criar um novo componente e disponibilizá-lo na IDE.&lt;/p&gt;

&lt;p&gt;Já vi muito isso em empresas, onde existem componentes genéricos que podem ser utilizados por qualquer sistema, mas também componentes específicos por projeto.&lt;/p&gt;

&lt;p&gt;Entretanto, apesar de manter um padrão de uso de componentes por toda a equipe, pode ser difícil manter todas as IDE’s do Delphi atualizadas após um novo &lt;em&gt;release&lt;/em&gt; desses componentes — no Lazarus essa tarefa seria mais fácil devido sua “não-instalação” e componentes “registrados” em apenas 1 arquivo XML, no entanto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O objetivo do artigo não é depreciar desenvolvedores que ainda utilizam Herança de Formulários, mas sim apresentar técnicas muito mais eficazes de construção, visando a manutenibilidade do código no longo prazo.&lt;/p&gt;

&lt;p&gt;Eu mesmo ainda trabalho em alguns projetos totalmente baseado em Herança de Formulários. Nesses projetos eu sou &lt;em&gt;obrigado&lt;/em&gt; a utilizar herança pois todo o &lt;em&gt;framework&lt;/em&gt; funciona a partir de alguns formulários base. No entanto, esses projetos estão longe de ter um código ideal.&lt;/p&gt;

&lt;p&gt;Mantenha seus projetos atuais, mas repense o uso de Herança de Formulários em projetos futuros.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/heranca-de-formulario-e-para-iniciantes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/heranca-de-formulario-e-para-iniciantes</guid>
      </item>
    
      <item>
        <title>Eliminando Métodos Privados</title>
        <description>&lt;p&gt;A utilização de Métodos Privados é um erro comum no &lt;em&gt;design&lt;/em&gt; do código.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-james-sutton-187816.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by James Sutton on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“Existe um pensamento que diz que todo Método Privado deveria ser, na verdade, a implementação de outro Objeto”&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu escrevi esse texto acima em outro &lt;a href=&quot;/posts/metodos-privados/&quot;&gt;artigo&lt;/a&gt; aqui no blog… e eu acho que faz muito sentido.&lt;/p&gt;

&lt;p&gt;No entanto, o artigo tentou demonstrar que os Métodos Privados não representam um mal no código e que podemos conviver com eles pacificamente.&lt;/p&gt;

&lt;p&gt;É verdade que eles não representam um &lt;em&gt;grande&lt;/em&gt; mal ao projeto. Existem tantos outros males &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;piores&lt;/a&gt; para nos preocuparmos no dia-a-dia que não damos muita importância aos Métodos Privados.&lt;/p&gt;

&lt;p&gt;Eu mesmo venho utilizando-os em meus projetos à muitos anos — tanto que já escrevi um artigo defendendo-os.&lt;/p&gt;

&lt;p&gt;Mas, toda vez que eu codifico um Método Privado eu tenho a sensação de que alguma coisa está &lt;em&gt;errada&lt;/em&gt;, mesmo quando eles &lt;em&gt;facilitam&lt;/em&gt; a minha vida.&lt;/p&gt;

&lt;h2 id=&quot;metodos-privados&quot;&gt;Métodos Privados&lt;/h2&gt;

&lt;p&gt;Você provavelmente sabe que Métodos Privados são utilizados somente pela Classe na qual eles foram implementados e nenhum Objeto externo tem acesso à eles.&lt;/p&gt;

&lt;p&gt;Praticamente, toda linguagem que suporta o paradigma da &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt; tem uma sintaxe para a codificação de Métodos Privados.&lt;/p&gt;

&lt;p&gt;É de uso comum.&lt;/p&gt;

&lt;p&gt;Todos nós utilizamos, diariamente.&lt;/p&gt;

&lt;p&gt;Mas, em teoria, a interface de um Objeto — seus Métodos Públicos — deveria ser suficiente para ele exercer o trabalho que lhe foi designado.&lt;/p&gt;

&lt;p&gt;Se o trabalho é complexo e o Objeto necessitar de “ajuda”, ele deveria delegar à outros Objetos e &lt;em&gt;não&lt;/em&gt; tentar fazer tudo “sozinho” utilizando Métodos Privados.&lt;/p&gt;

&lt;p&gt;No entanto, as linguagens dão suporte para escrevê-los.&lt;/p&gt;

&lt;p&gt;As linguagens diferenciam Métodos privados, protegidos e públicos.&lt;/p&gt;

&lt;p&gt;Então, entendemos que era correto utilizá-los e estamos fazendo isso desde então.&lt;/p&gt;

&lt;p&gt;Entretanto, se por um lado os Métodos Privados não representam um grande mal, por outro eles também não são o &lt;em&gt;ideal&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;facilitadores&quot;&gt;Facilitadores&lt;/h2&gt;

&lt;p&gt;Métodos Privados são apenas &lt;em&gt;facilitadores&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Eles são utilizados do mesmo jeito que a maioria das pessoas utilizam, por exemplo, a fita &lt;a href=&quot;https://pt.wikipedia.org/wiki/Silver_Tape&quot;&gt;Silver Tape®&lt;/a&gt;, ou seja, como uma &lt;em&gt;solução alternativa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se algo quebrou no seu carro durante uma viagem (uma mangueira arrebentou, algo rachou, vazamentos, etc) e você não tem tempo para fazer um reparo perfeito ou as ferramentas apropriadas, você improvisa.&lt;/p&gt;

&lt;p&gt;Você pode utilizar uma fita para manter as coisas no lugar na esperança de que, no futuro, você possa fazer o reparo do jeito correto.&lt;/p&gt;

&lt;p&gt;Infelizmente podemos nos esquecer desses reparos temporários e seguir adiante, já que a “solução alternativa” continua mantendo tudo funcionando “perfeitamente” — como a mangueira de esguicho de água do para-brisa do meu carro que rachou e está com uma fita a mais de 2 anos.&lt;/p&gt;

&lt;p&gt;Um Método Privado é algo localizado e sem muita importância por que está encapsulado numa Classe e pode ser alterado a qualquer momento (em teoria) sem efeitos colaterais.&lt;/p&gt;

&lt;p&gt;Eu utilizo pouco o esguicho de água do para-brisa e mesmo assim ele continua funcionando mas, mesmo se parar de funcionar, não vai por minha vida em risco… teoricamente. Não haverá efeitos colaterais se eu fizer o conserto agora ou mais tarde.&lt;/p&gt;

&lt;p&gt;Nota: Não me entenda mal. Eu faço a manutenção do meu carro quase que religiosamente, mas a prioridade sempre será o motor, fluídos e suspensão.&lt;/p&gt;

&lt;p&gt;Projetos de Software também tem prioridades nos dizendo para não “perder tempo” codificando outras Classes, quando é mais &lt;em&gt;rápido&lt;/em&gt; codificar Métodos Privados e resolver o problema da maneira mais “fácil”.&lt;/p&gt;

&lt;p&gt;Entretanto, sabemos que “mais fácil” não combina com &lt;em&gt;sustentabilidade&lt;/em&gt; no longo prazo.&lt;/p&gt;

&lt;h2 id=&quot;motivos&quot;&gt;Motivos&lt;/h2&gt;

&lt;p&gt;Há 9 meses atrás houve uma &lt;a href=&quot;http://objectpascalprogramming.com/posts/metodos-privados/#comment-3127567762&quot;&gt;discussão&lt;/a&gt; na área de comentários do blog sobre utilizar ou não Métodos Privados.&lt;/p&gt;

&lt;p&gt;Num dos comentários eu escrevi:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Minha opinião é que, como são Privados, não há nenhum impacto direto no código. Sempre posso modificá-los a qualquer momento.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;E isso é, de fato, verdade.&lt;/p&gt;

&lt;p&gt;Se algo é privado a Classe, você pode modificá-lo sem haver impactos externos, na teoria. Faz parte do conceito de &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; de toda linguagem OO. Se é privado, somente a Classe tem acesso — sem levar em conta algo chamado &lt;em&gt;Reflexion&lt;/em&gt; ou RTTI.&lt;/p&gt;

&lt;p&gt;Então, quais seriam os motivos para deixar de utilizar Métodos Privados?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ao introduzir Métodos Privados, você pode estar codificando de forma procedural ao invés de Orientada a Objetos.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Você pode estar introduzindo &lt;em&gt;funções procedurais&lt;/em&gt; ao invés de Métodos que implementam o comportamento da &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidade&lt;/a&gt; representada.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/bbdc509810890ea5724a94a021f16791.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Na Classe acima, o método &lt;code&gt;CleanName&lt;/code&gt; é apenas uma &lt;em&gt;função utilitária&lt;/em&gt;. A função não pertence ao contexto representado por um &lt;code&gt;Employee&lt;/code&gt; e por isso eu não a considero como um Método do Objeto.&lt;/p&gt;

&lt;p&gt;Um &lt;code&gt;Employee&lt;/code&gt; não “limpa” o próprio nome.&lt;/p&gt;

&lt;p&gt;Essa é a tendência ao utilizarmos Métodos Privados: Adicionar funções utilitárias, por quê é fácil, conveniente e “ninguém está vendo”.&lt;/p&gt;

&lt;p&gt;Os nomes dessas funções também tem a tendência de serem &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/#metodos&quot;&gt;nomes compostos&lt;/a&gt; que é mais um &lt;em&gt;indício&lt;/em&gt; mostrando que a função pode pertencer a &lt;em&gt;outro&lt;/em&gt; contexto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Métodos Privados também podem gerar &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/&quot;&gt;duplicação de código&lt;/a&gt;, escondendo &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamentos&lt;/a&gt; que poderiam ser compartilhados entre os Objetos mas, como são privados, não podem reutilizados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Veja mais um exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/a303d0bf83930fcf580aee818ee23a52.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O Método &lt;code&gt;SplitName&lt;/code&gt; — também um função utilitária — acima poderia ser reutilizado por outra Classe que também encapsula uma instância de &lt;code&gt;IName&lt;/code&gt;. Mas aqui a Classe &lt;code&gt;TEmployeeName&lt;/code&gt; tem sua própria implementação privada, não havendo outra maneira de reutilizar o mesmo algoritmo fora da Classe.&lt;/p&gt;

&lt;p&gt;Em outras palavras, caso você precisasse utilizar o mesmo algoritmo implementado em &lt;code&gt;SplitName&lt;/code&gt;, você teria que fazer uma cópia.&lt;/p&gt;

&lt;p&gt;Acredito que estes podem ser bons motivos para eliminarmos os Métodos Privados dos nossos projetos desde o início ou quando for possível fazer a refatoração.&lt;/p&gt;

&lt;h2 id=&quot;eliminando&quot;&gt;Eliminando&lt;/h2&gt;

&lt;p&gt;Acredito que podemos remover quaisquer Métodos Privados utilizando apenas Classes.&lt;/p&gt;

&lt;p&gt;As Classes podem ser &lt;em&gt;públicas&lt;/em&gt; (disponível a todo o sistema) e/ou &lt;a href=&quot;/classes-aninhadas&quot;&gt;Aninhadas&lt;/a&gt; a outras Classes.&lt;/p&gt;

&lt;p&gt;Talvez os exemplos acima podem não ter convencido você.&lt;/p&gt;

&lt;p&gt;Você poderia dizer que haverá casos em que os Métodos Privados fazem, sim, parte do mesmo contexto e por isso deveriam &lt;em&gt;existir&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por exemplo.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/8afe1f70a803556a59513fb2dff36e21.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A Classe &lt;code&gt;THttpClient&lt;/code&gt; não está completa, mas a parte que falta é irrelevante.&lt;/p&gt;

&lt;p&gt;Veja que há o Método &lt;code&gt;Send&lt;/code&gt; que é utilizado em 2 outros Métodos: &lt;code&gt;Get&lt;/code&gt; e &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, é possível substituir o Método &lt;code&gt;Send&lt;/code&gt; por uma Classe?&lt;/p&gt;

&lt;p&gt;Com certeza.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/3cda576e9e13ac25ee5b4005a3b47a1a.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;E a vantagem de fazer isso é que deixamos a Classe mais simples e compacta, removendo o comportamento privado para uma nova Classe; agora podemos reutilizar o código externamente; se quisermos decorar &lt;code&gt;THttpProtocol&lt;/code&gt; com outras Classes como Log, por exemplo, também podemos.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Após muito ponderar, cheguei a conclusão que prover uma sintaxe para codificar Métodos Privados é um &lt;em&gt;erro&lt;/em&gt; no &lt;em&gt;design&lt;/em&gt; da linguagem. Não só em Object Pascal, mas também em Java, C# e tantas outras.&lt;/p&gt;

&lt;p&gt;Considere, então, que o uso de Métodos Privados foi o primeiro nível de aprendizado para sabermos dividir código dentro de uma Classe, entendê-los e saber como utilizá-los de forma consciente, &lt;em&gt;facilitando&lt;/em&gt; a transição da Programação Procedural para a Orientada a Objetos.&lt;/p&gt;

&lt;p&gt;Sabemos que particularidades da linguagem nos fazem criar Métodos Privados intencionalmente como, por exemplo, Métodos que executam &lt;a href=&quot;/eventos-e-objetos&quot;&gt;eventos&lt;/a&gt; — o Método Privado irá verificar se um evento foi ou não &lt;a href=&quot;/posts/getters-e-setters/#setters&quot;&gt;setado&lt;/a&gt; — e tudo bem se o método é apenas uma implementação de &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#infraestrutura&quot;&gt;infraestrutura&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lembre-se também que, ao criar mais Classes públicas, ao invés de Métodos Privados, haverá mais código para documentar. No entanto, você poderá manter essas Classes “escondidas” do usuário final utilizando o conceito de &lt;a href=&quot;/api-unit&quot;&gt;API Unit&lt;/a&gt;, declarando na API apenas as Classes que você “permite” utilizar.&lt;/p&gt;

&lt;p&gt;Um código final com um mínimo de Métodos Privados pode representar um bom sinal de &lt;em&gt;design&lt;/em&gt; do código, com Classes &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e elegantes.&lt;/p&gt;

&lt;p&gt;Então, não codifique Métodos Privados, a não ser que haja uma real necessidade para fazê-lo. Evite-os.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/eliminando-metodos-privados</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/eliminando-metodos-privados</guid>
      </item>
    
      <item>
        <title>Classes Aninhadas</title>
        <description>&lt;p&gt;As Classes Aninhadas reduzem o número de Classes públicas, melhoram o encapsulamento, o polimorfismo local e a legibilidade do código.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-iorni-321845.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by iorni on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A maneira mais fácil (preguiçosa e errada) de reaproveitar código é utilizando &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse é o início do aprendizado sobre &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Como muito mais tempo, aprendemos que a &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração&lt;/a&gt; e Composição de Objetos é o &lt;em&gt;melhor&lt;/em&gt; caminho para &lt;em&gt;adicionar&lt;/em&gt; e &lt;em&gt;reaproveitar&lt;/em&gt; comportamento, respectivamente.&lt;/p&gt;

&lt;p&gt;Classes Aninhadas tem tudo haver com Decoração e Composição.&lt;/p&gt;

&lt;p&gt;Nesse artigo você irá aprender como utilizar Classes Aninhadas para melhorar o encapsulamento e polimorfismo, acrescentando comportamento específico e localizado, sem o uso de &lt;em&gt;“Class Helpers”&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;classes-aninhadas&quot;&gt;Classes Aninhadas&lt;/h2&gt;

&lt;p&gt;A linguagem Object Pascal, apesar de ser bem antiga, está em constante desenvolvimento.&lt;/p&gt;

&lt;p&gt;Mas, eu sou avesso a grandes mudanças na linguagem. Em qualquer linguagem.&lt;/p&gt;

&lt;p&gt;Também não sou a favor de acrescentar novas &lt;em&gt;features&lt;/em&gt; apenas por quê existem em &lt;em&gt;outras&lt;/em&gt; linguagens.&lt;/p&gt;

&lt;p&gt;Quanto mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; for uma linguagem, mais fácil será o entendimento do código.&lt;/p&gt;

&lt;p&gt;Na minha opinião, ao invés de acrescentar novas &lt;em&gt;features&lt;/em&gt; numa linguagem, os desenvolvedores deviam trabalhar em novas &lt;em&gt;Libraries&lt;/em&gt; que resolvem problemas específicos.&lt;/p&gt;

&lt;p&gt;No entanto, algumas &lt;em&gt;features&lt;/em&gt; realmente podem fazer a diferença, ou seja, tornar o código melhor e mais simples.&lt;/p&gt;

&lt;p&gt;O conceito de Classes Aninhadas é simples: Permitir a declaração de Classes dentro de Classes. Sejam elas privadas ou públicas.&lt;/p&gt;

&lt;p&gt;Veja um exemplo da sintaxe:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/96820c816ffa3e1eb5296a330e3a1cef.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, para declarar uma Classe &lt;code&gt;TBar&lt;/code&gt;, foi necessário fazer a referência a Classe &lt;code&gt;TFoo&lt;/code&gt;, primeiramente.&lt;/p&gt;

&lt;p&gt;Então, &lt;code&gt;TBar&lt;/code&gt; é uma Classe Aninhada em &lt;code&gt;TFoo&lt;/code&gt; ou, em outras palavras, &lt;code&gt;TBar&lt;/code&gt; está encapsulada em &lt;code&gt;TFoo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Acredito que para o compilador, uma Classe Aninhada é apenas outra qualquer. Não há penalidades no código. A primeira Classe da hierarquia &lt;em&gt;não&lt;/em&gt; irá criar Objetos maiores devido as Classes Aninhadas.&lt;/p&gt;

&lt;p&gt;Para nós, desenvolvedores, é apenas um &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;&lt;em&gt;Syntactic sugar&lt;/em&gt;&lt;/a&gt; que parece não valer muito a pena prestar atenção.&lt;/p&gt;

&lt;p&gt;No entanto, para um &lt;em&gt;design&lt;/em&gt; realmente &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt;, esta é uma &lt;em&gt;feature&lt;/em&gt; que proporciona uma &lt;em&gt;grande&lt;/em&gt; melhoria no código.&lt;/p&gt;

&lt;h2 id=&quot;redescobrindo&quot;&gt;Redescobrindo&lt;/h2&gt;

&lt;p&gt;O fato é que não faz tanto tampo que eu descobri que a linguagem Object Pascal tem suporte a Classes Aninhadas. Bem, talvez eu já tenha lido sobre isso já faz alguns anos, mas a verdade é que eu nunca tinha utilizado tal recurso em sistemas reais.&lt;/p&gt;

&lt;p&gt;Há 3 semanas atrás, esse conceito retornou a minha mente após receber um e-mail relacionado a uma nova &lt;em&gt;issue&lt;/em&gt; num sistema privado.&lt;/p&gt;

&lt;p&gt;Eu tinha que fazer uma manutenção no código e um dos requisitos dizia que uma parte do sistema deveria se comportar de maneira ligeiramente diferente da condição atual, mas por um curto período de tempo.&lt;/p&gt;

&lt;p&gt;O motivo era que um segundo sistema estava sendo alterado e, enquanto essa tarefa não estivesse concluída, o primeiro sistema deveria se comportar de acordo com o requisito citado.&lt;/p&gt;

&lt;p&gt;Como o sistema é privado, o requisito real é irrelevante.&lt;/p&gt;

&lt;p&gt;Mas, para que você entenda como as Classes Aninhadas me ajudaram a implementar o requisito de forma simples, clássica e seguindo os &lt;a href=&quot;lista-vip/&quot;&gt;princípios&lt;/a&gt; da Orientação a Objetos, vou apresentar uma forma bem simplificada do que deveria ser alterado no código para a solução da tarefa.&lt;/p&gt;

&lt;h2 id=&quot;problema&quot;&gt;O Problema&lt;/h2&gt;

&lt;p&gt;Imagine que você tenha uma Unit com algumas Classes.&lt;/p&gt;

&lt;p&gt;Essas Classes utilizam outras Classes de outras Units.&lt;/p&gt;

&lt;p&gt;Para implementar o requisito, uma dessas Classes deveria ser alterada. No entanto, a alteração era relacionada com a Composição de outra Classe — na verdade eram outras Classes, no plural, mas vamos manter simples.&lt;/p&gt;

&lt;p&gt;Então temos o seguinte:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A Classe &lt;code&gt;TFoo&lt;/code&gt; é a que temos que alterar. No entanto ela trabalha com uma instância de &lt;code&gt;TBar&lt;/code&gt; internamente — novamente, por motivos de simplificação, vamos esquecer que a instância de &lt;code&gt;TBar&lt;/code&gt; deveria ser &lt;a href=&quot;/injecao-de-dependencia&quot;&gt;injetada&lt;/a&gt; no &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtor&lt;/a&gt; da Classe &lt;code&gt;TFoo&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;A interação entre as Classes &lt;code&gt;TFoo&lt;/code&gt; e &lt;code&gt;TBar&lt;/code&gt; era o que deveria ser alterado para a conclusão do requisito. No entanto, todas as outras Classes pertencentes a mesma Unit de &lt;code&gt;TFoo&lt;/code&gt; deveriam continuar com o mesmo comportamento atual. Em outras palavras, a Classe &lt;code&gt;TBar&lt;/code&gt; deveria ser alterada &lt;em&gt;apenas&lt;/em&gt; na implementação (local) de &lt;code&gt;TFoo&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Temos várias maneiras de implementar isso, é claro.&lt;/p&gt;

&lt;p&gt;Antes, vamos &lt;a href=&quot;/posts/nomeando-unidades/&quot;&gt;nomear&lt;/a&gt; algumas coisas para facilitar o entendimento:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Acme.Foos.Clss&lt;/code&gt; -&amp;gt; é a Unit onde a Classe &lt;code&gt;TFoo&lt;/code&gt; está declarada;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Acme.Bars.Clss&lt;/code&gt; -&amp;gt; é a Unit onde a Classe &lt;code&gt;TBar&lt;/code&gt; está declarada;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Então, para implementar o requisito, nós poderíamos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementar uma nova Classe na Sessão de Interface da &lt;code&gt;Acme.Bars.Clss&lt;/code&gt; chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Implementar uma nova Classe na Sessão de Interface da &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Criar uma nova Unit &lt;code&gt;Acme.Bars.Ex.Clss&lt;/code&gt; e implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Implementação da unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O caminho a ser escolhido é quase infinito, porém essas seriam as opções mais comuns, considerando que não queremos fazer uma refatoração muito grande no código. Será uma alteração temporária, lembra?&lt;/p&gt;

&lt;p&gt;Infelizmente, existem problemas de &lt;em&gt;design&lt;/em&gt; com todas as opções acima.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementar a nova Classe &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Interface de &lt;code&gt;Acme.Bars.Clss&lt;/code&gt; ou &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; irá disponibilizar a nova Classe para todo o sistema. Como é uma Classe temporária, ela não deveria estar disponível… não dessa forma.&lt;/li&gt;
  &lt;li&gt;Criar uma nova Unit &lt;code&gt;Acme.Bars.Ex.Clss&lt;/code&gt; é ainda pior, pois depois de algum tempo a Unit deverá ser removida, havendo mais alterações no código.&lt;/li&gt;
  &lt;li&gt;Por fim, implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Implementação da unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; seria a opção mais viável. No entanto não teria sido um código elegante, pois essa nova Classe seria criada para apenas para um caso específico mas elas estaria disponível para a Unit inteira. Também tem o fato de que a Classe &lt;em&gt;deve&lt;/em&gt; ter um nome diferente (&lt;code&gt;TBar&lt;/code&gt; vs &lt;code&gt;TBarEx&lt;/code&gt;) — esse é um dos motivos de adicionarmos prefixos ou sufixos estranhos — para não haver conflito com todas as instâncias de &lt;code&gt;TBar&lt;/code&gt; que continuam sendo utilizadas por toda a Unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt;. O ideal seria continuar utilizando a nomenclatura &lt;code&gt;TBar&lt;/code&gt;, de acordo com o domínio. Mas, infelizmente, a técnica de &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclaração de Classes&lt;/a&gt; não seria possível, pois só queremos uma &lt;code&gt;TBar&lt;/code&gt; diferente em apenas um lugar na Unit.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Eu não escolhi nenhuma das possíveis soluções acima.&lt;/p&gt;

&lt;h2 id=&quot;solucionando&quot;&gt;A Solução&lt;/h2&gt;

&lt;p&gt;Após pensar por alguns minutos sobre como resolver o requisito, o conceito de Classes Aninhadas retornou a minha mente como a melhor escolha.&lt;/p&gt;

&lt;p&gt;A solução é tão simples que você já a conhece. Está no início desse artigo!&lt;/p&gt;

&lt;p&gt;Vou apenas adicionar mais código para deixar a implementação mais contextualizada:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/b292e33439d9867b2c8c92d8caba4a96.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Agora, em todos os métodos de &lt;code&gt;TFoo&lt;/code&gt; que for preciso decorar instâncias de &lt;code&gt;IBar&lt;/code&gt;, uma Classe de &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nomenclatura&lt;/a&gt; simples e &lt;em&gt;local&lt;/em&gt; poderá ser utilizada sem haver conflito de nomes na Unit.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TFoo&lt;/code&gt; tem sua própria implementação privada de &lt;code&gt;TBar&lt;/code&gt;. Nenhum outro código no sistema poderá utilizar essa implementação.&lt;/p&gt;

&lt;p&gt;É uma solução &lt;em&gt;local&lt;/em&gt;, sem &lt;em&gt;workarounds&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Espero que os exemplos não tenham sido muito abstratos. A ideia foi mostrar o potencial dessa simples &lt;em&gt;feature&lt;/em&gt; sem deixar o artigo muito longo.&lt;/p&gt;

&lt;p&gt;É uma solução simples e bastante elegante. Totalmente de acordo com os princípios da Orientação a Objetos, encapsulamento e polimorfismo.&lt;/p&gt;

&lt;p&gt;A nomenclatura das Classes é simples, mantendo a legibilidade do código.&lt;/p&gt;

&lt;p&gt;A linguagem Object Pascal continua a me surpreender, mesmo após mais de 16 anos que a utilizo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/classes-aninhadas</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/classes-aninhadas</guid>
      </item>
    
      <item>
        <title>API Unit: Tudo num só lugar</title>
        <description>&lt;p&gt;Uma única técnica que resolve muitos problemas.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-nordwood-themes-166423.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by NordWood Themes on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Quando você utiliza uma Classe muitas vezes, já deve ter memorizado em qual Unit a Classe foi implementada.&lt;/p&gt;

&lt;p&gt;Mas e se &lt;em&gt;Library&lt;/em&gt; (Lib) que você está utilizando é nova ou foi completamente remodelada?&lt;/p&gt;

&lt;p&gt;E se você está tentando fazer um trabalho que nunca fez antes?&lt;/p&gt;

&lt;p&gt;Como saber as Classes existentes na Lib?&lt;/p&gt;

&lt;p&gt;Há basicamente 3 opções:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Abrir todas as Units da Lib e ler o código;&lt;/li&gt;
  &lt;li&gt;Ler a documentação, se houver;&lt;/li&gt;
  &lt;li&gt;Abrir apenas uma Unit que contenha todas as Interfaces e Classes;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Esse artigo é sobre a última opção, que eu chamo de “API Unit”.&lt;/p&gt;

&lt;h2 id=&quot;api-unit&quot;&gt;API Unit&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;API Unit&lt;/em&gt; é um conceito em fase de experimentação.&lt;/p&gt;

&lt;p&gt;A ideia é simples: Disponibilizar ao desenvolvedor, todas as Interfaces e Classes de &lt;em&gt;uso público&lt;/em&gt; em apenas 1 Unit.&lt;/p&gt;

&lt;p&gt;Não estou dizendo que deveríamos codificar &lt;em&gt;tudo&lt;/em&gt; num único arquivo. Isso seria insano. Mas se houvesse uma maneira de continuarmos codificando em módulos mas, ao mesmo tempo, termos tudo disponível para uso em apenas 1 única Unit, não acha que seria interessante?&lt;/p&gt;

&lt;p&gt;Já vi projetos onde os autores utilizavam arquivos &lt;code&gt;*.inc&lt;/code&gt; para ir montando a “verdadeira” Unit — o FPC e Lazarus utilizam essa técnica — mas eu acho confuso de administrar, além de dificultar a leitura do código.&lt;/p&gt;

&lt;p&gt;Não fui por esse caminho e continuei pensando…&lt;/p&gt;

&lt;p&gt;Então, tive uma ideia que chamei de &lt;em&gt;API Unit&lt;/em&gt;, meio que “por acaso”, após a publicação desse &lt;a href=&quot;/nomeando-classes-em-libraries&quot;&gt;artigo&lt;/a&gt;. Eu estava pensando em outras possibilidades para nomear Interfaces e Classes, algo que já havia explicado em outro artigo.&lt;/p&gt;

&lt;p&gt;Por quê?&lt;/p&gt;

&lt;p&gt;Bem, a técnica de nomenclatura que expliquei anteriormente continua válida, porém pode haver Libs mais complexas com &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nomes de Classes&lt;/a&gt; bem especializadas. Esses nomes tem a tendência de serem maiores e adicionar o nome da Lib como prefixo — conforme explicado no &lt;a href=&quot;/nomeando-classes-em-libraries&quot;&gt;artigo&lt;/a&gt; — deixando o nome da Classe ainda mais verboso.&lt;/p&gt;

&lt;p&gt;A linguagem Object Pascal não tem uma sintaxe para “renomear” uma Unit dentro do código. Algo &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; de se fazer em linguagens como Python, C# e Lua, por exemplo. Nessas linguagens, após o &lt;em&gt;“import”&lt;/em&gt; do arquivo, o desenvolvedor pode escolher um &lt;em&gt;alias&lt;/em&gt; para a “unidade”, ou seja, ele pode renomear dinamicamente o arquivo que irá conter as Interfaces, Classes e todo o resto.&lt;/p&gt;

&lt;p&gt;Eu mesmo já &lt;a href=&quot;http://wiki.freepascal.org/Namespaces#The_.22uses.22_clause&quot;&gt;solicitei&lt;/a&gt; essa &lt;em&gt;feature&lt;/em&gt; para os desenvolvedores do &lt;a href=&quot;https://freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt;, porém o pedido foi ignorado devido haver outras prioridades.&lt;/p&gt;

&lt;p&gt;Como isso não é possível (hoje), voltei para os meus pensamentos.&lt;/p&gt;

&lt;p&gt;Seria possível utilizar a nomenclatura mais simples (nomes curtos para Units, Interfaces e Classes) sem haver colisão de nomes?&lt;/p&gt;

&lt;p&gt;Meus requisitos foram:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Classes com nomes curtos e simples;&lt;/li&gt;
  &lt;li&gt;Havendo colisão de nomes entre Classes, a Unit seria utilizada como prefixo;&lt;/li&gt;
  &lt;li&gt;Units devem ter o nome mais curto possível, porém legível e sem ambiguidades;&lt;/li&gt;
  &lt;li&gt;O usuário da Lib deveria ter o controle da nomenclatura utilizada em seus sistemas;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Vamos analisar cada item:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Classes com nomes curtos e simples&lt;/strong&gt; deveria ser a norma utilizada em &lt;em&gt;todos&lt;/em&gt; os sistemas. Mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; de ler, mas fácil de entender.&lt;/p&gt;

&lt;p&gt;Ao invés de escrevermos &lt;code&gt;TAcCar&lt;/code&gt; ou &lt;code&gt;TAcmeCar&lt;/code&gt;, iríamos utilizar apenas &lt;code&gt;TCar&lt;/code&gt;. Mas, conforme explicado no artigo sobre nomenclatura, há grandes possibilidades de haver uma colisão de nomes caso duas ou mais unidades tenham utilizado o mesmo identificador &lt;code&gt;TCar&lt;/code&gt; e isso nos leva ao segundo requisito.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Havendo colisão de nomes entre Classes, a Unit seria utilizada como prefixo&lt;/strong&gt; e o problema estaria resolvido. No entanto, é muito verboso declarar um método assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TDriver.Drive(
  ACar: Acme.Interfaces.Cars.ICar): IDriver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O argumento &lt;code&gt;ACar&lt;/code&gt; é um tipo de Interface declarado em alguma Lib externa chamada &lt;code&gt;Acme&lt;/code&gt;. E foi preciso prefixar a Interface &lt;code&gt;ICar&lt;/code&gt; por que o seu projeto, hipoteticamente, também tem uma interface com o mesmo nome em outra Unit.&lt;/p&gt;

&lt;p&gt;Imagine agora esse mesmo método com mais 4 argumentos, sendo cada um deles prefixado com a Unit. O método ficaria muito mais verboso e, talvez, difícil de entender.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Units devem ter o nome mais curto possível, porém legível e sem ambiguidades&lt;/strong&gt; mas a linguagem não nos dá essa opção. Se fosse possível criar um &lt;em&gt;alias&lt;/em&gt; no Object Pascal poderíamos fazer isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  Acme.Interfaces.Cars.ICar as Acme;

function TDriver.Drive(ACar: Acme.ICar): IDriver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse ponto você pode estar pensando que voltamos a utilizar a mesma &lt;a href=&quot;/nomeando-classes-em-libraries&quot;&gt;técnica&lt;/a&gt; anterior, ou seja, o nome da Lib é o prefixo.&lt;/p&gt;

&lt;p&gt;Ora, afinal o identificador &lt;code&gt;Acme.ICar&lt;/code&gt; não é tão diferente de &lt;code&gt;IAcmeCar&lt;/code&gt;, não é?&lt;/p&gt;

&lt;p&gt;Sim, é verdade, porém com o uso (hipotético) de &lt;em&gt;alias&lt;/em&gt; é o usuário que tem o controle de qual nome utilizar como prefixo em todo o projeto. Algo que lhe dá liberdade, fazendo muita diferença.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O usuário da Lib deveria ter o controle da nomenclatura utilizada em seus sistemas&lt;/strong&gt; e não deixar que a Lib “imponha” um nome que, muitas vezes, é ambíguo, mal escolhido, confuso, verboso ou completamente sem sentido.&lt;/p&gt;

&lt;p&gt;É claro que identificadores fixos como &lt;code&gt;IAcmeCar&lt;/code&gt; podem ser &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclarados&lt;/a&gt;, porém se houver muitas Classes e Interfaces, poderia ser uma tarefa bem dispendiosa.&lt;/p&gt;

&lt;p&gt;Então, o uso de &lt;em&gt;alias&lt;/em&gt; na linguagem Object Pascal seria uma solução inovadora, porém não a temos.&lt;/p&gt;

&lt;p&gt;E é aí que entra a ideia da &lt;em&gt;API Unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se todos os identificadores estivessem declarados em apenas uma única Unit, representando toda a Lib, poderíamos simular um &lt;em&gt;alias&lt;/em&gt; utilizando um arquivo físico.&lt;/p&gt;

&lt;p&gt;Veja &lt;a href=&quot;https://github.com/mdbs99/james/blob/d63a1b93e246012ffc49fa6ea86ad644ceef12f5/src/james.api.pas#L24&quot;&gt;aqui&lt;/a&gt; um bom exemplo do que é uma &lt;em&gt;API Unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;No &lt;em&gt;link&lt;/em&gt; acima podemos ver que todas as Interfaces e Classes da Lib estão declaradas (apenas um &lt;em&gt;alias&lt;/em&gt; para os identificadores em outras Unit ) em apenas uma única Unit e isso nos dá &lt;em&gt;grandes&lt;/em&gt; possibilidades que irei explicar mais adiante.&lt;/p&gt;

&lt;p&gt;No entanto, sempre haverá vantagens de desvantagens.&lt;/p&gt;

&lt;h2 id=&quot;desvantagens&quot;&gt;Desvantagens&lt;/h2&gt;

&lt;p&gt;Vou começar pelas desvantagens, pois as vantagens são bem maiores.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Você irá deixar o código do desenvolvedor da Lib um pouquinho mais verboso&lt;/strong&gt; por que, para cada Interface ou Classe existente, você terá que declarar um &lt;em&gt;alias&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por exemplo, veja nesse &lt;a href=&quot;https://github.com/mdbs99/james/blob/d63a1b93e246012ffc49fa6ea86ad644ceef12f5/src/james.data.clss.pas#L34-L52&quot;&gt;link&lt;/a&gt; que a Classe &lt;code&gt;TDataStream&lt;/code&gt; tem um &lt;em&gt;alias&lt;/em&gt; declarado como &lt;code&gt;TDataStreamAlias = TDataStream;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A princípio, o identificador &lt;code&gt;TDataStreamAlias&lt;/code&gt; não faz sentido para a Unit na qual ele foi declarado, mas será importante para montarmos a &lt;em&gt;API Unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Todas as Interfaces e Classes para os usuários devem estar numa única Unit&lt;/strong&gt; e isso é meio chato e talvez um pouco trabalhoso de se fazer.&lt;/p&gt;

&lt;p&gt;O desenvolvedor terá um pequeno retrabalho adicionando as Interfaces e Classes de outras Unit  na Unit de API. O desenvolvedor poderia até esquecer de fazer isso. No entanto se a Lib possuir testes automatizados, não haverá esquecimento, pois os próprios testes irão utilizar apenas a &lt;em&gt;API Unit&lt;/em&gt; e para testar uma Classe ela deve estar declarada lá.&lt;/p&gt;

&lt;h2 id=&quot;vantagens&quot;&gt;Vantagens&lt;/h2&gt;

&lt;p&gt;Agora vamos falar um pouco sobre as vantagens em utilizarmos essa simples técnica.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Se toda a Lib pode ser utilizada através de apenas 1 Unit&lt;/strong&gt; você pode criar um &lt;em&gt;alias&lt;/em&gt; apenas renomeando o arquivo original.&lt;/p&gt;

&lt;p&gt;Por exemplo. Se a Lib Acme do exemplo acima tivesse uma &lt;em&gt;API Unit&lt;/em&gt; ela poderia se chamar &lt;code&gt;Acme.API.pas&lt;/code&gt;. Mas se você não gostou do nome, se ele ainda é verboso ou se você já tem uma Unit com esse nome no seu projeto, bastaria renomear a Unit para, digamos, &lt;code&gt;LibAcme.pas&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, qualquer colisão de nome entre Interfaces e Classes poderia ser resolvida apenas adicionando o “novo” nome da Lib como, por exemplo, &lt;code&gt;LibAcme.ICar&lt;/code&gt;. Simples, curto, fácil de entender e totalmente sob o controle do usuário da Lib.&lt;/p&gt;

&lt;p&gt;Se o desenvolvedor da Lib quiser ser ainda mais “legal” com o usuário, ele poderia criar um &lt;code&gt;.inc&lt;/code&gt; com todos os identificadores e declarar a &lt;code&gt;Acme.API &lt;/code&gt;assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit Acme.API;

{$include api.inc}

end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Então o usuário nem mesmo precisaria renomear o arquivo original. Bastaria criar um novo arquivo, por exemplo &lt;code&gt;LibAcme.pas&lt;/code&gt;, no mesmo diretório e incluir a &lt;code&gt;api.inc&lt;/code&gt; no corpo da nova Unit.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Como é fácil renomear a Unit que contém a API&lt;/strong&gt; o desenvolvedor não precisaria mais se preocupar em adicionar prefixos de 2~3 letras em Interfaces e Classes afim de diminuir a colisão de nomes nos projetos que utilizam a Lib. Qualquer nome simples pode ser utilizado, pois qualquer conflito será &lt;em&gt;fácil&lt;/em&gt; de resolver adicionando a Unit quando for necessário.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O usuário não precisa memorizar as Units da Lib&lt;/strong&gt; pois tudo está num único só lugar. Simples e conveniente.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O desenvolvedor da Lib poderia incluir mais Interfaces e Classes&lt;/strong&gt; porém apenas para o uso “privado” da Lib sem que o usuário precise saber da existência desses novos artefatos. O usuário já estaria acostumado a utilizar apenas uma única Unit, então ele não iria ter “acesso” a outros identificadores que não estão listados lá. É claro que ele ainda poderia utilizar as Units reais da Lib, porém isso poderia ser informado na documentação que isso seria considerado um &lt;em&gt;“hack”&lt;/em&gt; ou quebra de &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; e o usuário estaria por conta própria.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ao definir um &lt;em&gt;alias&lt;/em&gt; para cada Interface ou Classe&lt;/strong&gt; — exemplo &lt;code&gt;TDataStreamAlias&lt;/code&gt;— não seria necessário &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclarar&lt;/a&gt; os identificadores na API utilizando as Units reais como prefixo.&lt;/p&gt;

&lt;p&gt;Compare as duas opções abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit James.API;

type
  {1} TDataStream = TDataStreamAlias;
  {2} TDataStream = James.Data.Clss.TDataStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Com certeza a primeira linha e menos verbosa.&lt;/p&gt;

&lt;p&gt;Esse é o motivo de haver esses identificadores que são apenas &lt;em&gt;alias&lt;/em&gt;. Além de ser menos verboso, o desenvolvedor poderia mover a &lt;code&gt;TDataStream&lt;/code&gt; para outra Unit e não precisaria alterar a API.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quando a API começar a ficar grande demais&lt;/strong&gt; será um sinal — ou um “cheiro” — de que a Lib pode estar fazendo coisas demais. Então a &lt;em&gt;API Unit&lt;/em&gt; é, também, uma restrição. Mas isso é bom. &lt;a href=&quot;/posts/menos-e-mais/&quot;&gt;Menos é mais&lt;/a&gt;, lembre-se disso.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Esse artigo tentou demostrar que utilizando apenas uma única técnica simples e um pouco mais trabalho, é possível melhorar muito a qualidade do código, resolvendo problemas de escopo, nomenclatura e legibilidade.&lt;/p&gt;

&lt;p&gt;Estou utilizando &lt;em&gt;API Unit&lt;/em&gt; em alguns projetos privados e &lt;em&gt;Open Sources&lt;/em&gt; (&lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;aqui&lt;/a&gt;) e a legibilidade tem melhorado.&lt;/p&gt;

&lt;p&gt;Penso em utilizar o mesmo conceito para delimitar API’s (módulos) em grandes sistemas, mas a &lt;a href=&quot;/posts/interfaces-e-a-referencia-circular-entre-objetos/&quot;&gt;referência circular&lt;/a&gt; entre Units pode ser um problema. Então o design do projeto tem que levar isso em conta desde o início.&lt;/p&gt;

&lt;p&gt;Se vai valer a pena… o tempo dirá.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Oct 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/api-unit</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/api-unit</guid>
      </item>
    
      <item>
        <title>Injeção de Dependência sem XML, Atributos/Anotações ou Frameworks</title>
        <description>&lt;p&gt;É possível utilizar a Injeção de Dependência na Orientação Objetos sem depender de características específicas da linguagem, Arquivos XML, Atributos/Anotações ou &lt;em&gt;Frameworks&lt;/em&gt;?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-vadim-sherbakov-36.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Vadim Sherbakov on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Injeção de Dependência&lt;/a&gt; ou apenas DI (em Inglês: &lt;em&gt;“Dependency Injection”&lt;/em&gt;) pode ser um assunto bem controverso que ainda geram muitas dúvidas entre desenvolvedores.&lt;/p&gt;

&lt;p&gt;Será que DI é algo complexo que exige um &lt;em&gt;framework&lt;/em&gt; para gerenciar as dependências entre Classes de um &lt;em&gt;software&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;É necessário um arquivo XML para que o desenvolvedor possa configurar tais dependências?&lt;/p&gt;

&lt;p&gt;Talvez possamos utilizar Atributos/Anotações para facilitar essas configurações?&lt;/p&gt;

&lt;p&gt;Como podemos utilizar o conceito de &lt;a href=&quot;https://en.wikipedia.org/wiki/Inversion_of_control&quot;&gt;IoC&lt;/a&gt; sem um &lt;em&gt;framework&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;O mercado tem várias maneiras de “injetar” alguma coisa, porém eu lhe digo: Injeção de Dependência é apenas passagem de parâmetro entre Objetos.&lt;/p&gt;

&lt;h2 id=&quot;artefatos&quot;&gt;Artefatos&lt;/h2&gt;

&lt;p&gt;Qualquer sistema &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt; que faça algo de útil, terá dependências entre suas Classes ou Módulos.&lt;/p&gt;

&lt;p&gt;Um Módulo/Classe &lt;code&gt;A&lt;/code&gt; que usa &lt;code&gt;B&lt;/code&gt; que usa &lt;code&gt;C&lt;/code&gt; (&lt;code&gt;A-&amp;gt;B-&amp;gt;C&lt;/code&gt;) estão conectados entre si.&lt;/p&gt;

&lt;p&gt;Sempre devemos minimizar essas dependências afim de facilitarmos a manutenção do código, porém é impossível não tê-las.&lt;/p&gt;

&lt;p&gt;Mesmo assim, o mercado resolveu criar todo tipo de “artefatos” como &lt;em&gt;frameworks&lt;/em&gt;, atributos/anotações ou configurações em arquivos XML, para “facilitar” a comunicação entre os Objetos, tornando “transparente” para o desenvolvedor as dependências existentes entre as Classes.&lt;/p&gt;

&lt;p&gt;Na minha opinião, eles trouxeram mais problemas e &lt;em&gt;complexidade&lt;/em&gt; do que uma real solução.&lt;/p&gt;

&lt;p&gt;Pense bem:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Um &lt;em&gt;Framework&lt;/em&gt; para Injeção de Dependência, deixa seu código &lt;em&gt;dependente&lt;/em&gt; do próprio &lt;em&gt;framework&lt;/em&gt; que gerencia as dependências!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Os Atributos/Anotações que informam quais atributos do Objeto devem ser inicializados “magicamente” utilizando &lt;em&gt;reflection/RTTI&lt;/em&gt; ou utilizando &lt;a href=&quot;https://en.wikipedia.org/wiki/Service_locator_pattern&quot;&gt;&lt;em&gt;Services Locators&lt;/em&gt;&lt;/a&gt;, retiram do Objeto seus &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt;, tornando-o &lt;em&gt;anêmico&lt;/em&gt; e &lt;em&gt;procedural&lt;/em&gt;, pois é preciso chamar &lt;a href=&quot;/posts/getters-e-setters/#setters&quot;&gt;&lt;em&gt;Setters&lt;/em&gt;&lt;/a&gt; para “configurar” o Objeto antes de fazer algo de útil com ele. Seu uso é totalmente desencorajado pois viola o &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; transformando o Objeto num &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/#objeto-nao-e-um-balde-de-funcoes-e-dados&quot;&gt;“saco de dados”&lt;/a&gt;, além de introduzir &lt;a href=&quot;http://blog.ploeh.dk/2011/05/24/DesignSmellTemporalCoupling/&quot;&gt;acoplamento temporal&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Arquivos XML de configuração que armazenam quais Classes serão utilizadas para instanciar tais &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt; é algo abominável: é estático, não segue o princípio &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY&lt;/a&gt;, e não tem checagem de sintaxe.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tais “soluções” criam, na verdade, outros problemas.&lt;/p&gt;

&lt;p&gt;Mas, e se fosse possível ter um código mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, sem XML, sem Atributos/Anotações ou mesmo sem &lt;em&gt;Frameworks&lt;/em&gt;, para trabalharmos com a Injeção de Dependência utilizando &lt;em&gt;somente&lt;/em&gt; Classes e Objetos, você iria continuar utilizando outros artefatos complexos?&lt;/p&gt;

&lt;p&gt;Vamos ver quais são os tipos de dependências mais utilizadas e então veremos se é possível termos soluções simples para cada uma delas.&lt;/p&gt;

&lt;h2 id=&quot;dependencia-por-construtor&quot;&gt;Dependência por Construtor&lt;/h2&gt;

&lt;p&gt;Dependência por Construtor é a maneira mais simples e eficaz de resolver dependências entre Objetos.&lt;/p&gt;

&lt;p&gt;Esse é o tipo de &lt;em&gt;dependência pura&lt;/em&gt; que é negligenciado por muitos desenvolvedores.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;THash.New(
  TFile.New(&#39;file.xml&#39;).Stream
).Calc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima a Classe &lt;code&gt;THash&lt;/code&gt; recebe um &lt;code&gt;Stream&lt;/code&gt; (dependência) no seu construtor. Obviamente o tipo do argumento é uma Interface (ex: &lt;code&gt;IStream&lt;/code&gt;) para que não haja uma dependência “física” entre as Classes.&lt;/p&gt;

&lt;p&gt;Não há &lt;em&gt;nenhum&lt;/em&gt; problema a ser solucionado aqui. Essa é a forma mais correta e eficaz para “injetar” uma dependência.&lt;/p&gt;

&lt;p&gt;Sempre tente utilizar construtores para passar as dependências para os Objetos. A única exigência é que os argumentos do construtor sejam do tipo Interface ao invés de Classes.&lt;/p&gt;

&lt;h2 id=&quot;dependencia-por-decoracao&quot;&gt;Dependência por Decoração&lt;/h2&gt;

&lt;p&gt;A utilização de bibliotecas (Libs) é muito útil para desenvolvermos mais rápido. Ao invés de criamos tudo que o software precisa, podemos delegar vários serviços às Libs especialistas no assunto. É como “contratar” consultores profissionais para cada especialidade.&lt;/p&gt;

&lt;p&gt;O “problema” é que essas Libs utilizam seus próprios Objetos. Bem, elas sabem o que fazem, porém há momentos que gostaríamos de “dizer” a essas Libs quais Objetos deveriam retornar em alguns momentos.&lt;/p&gt;

&lt;p&gt;Seria interessante se pudéssemos &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;decorar&lt;/a&gt; instâncias retornadas por Objetos pertencentes a Lib.&lt;/p&gt;

&lt;p&gt;Por exemplo. No código abaixo nós obtemos uma instância de um Objeto que representa um Atributo num arquivo XML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Attr := 
  TXMLPack.New(
    TFile.New(&#39;file.xml&#39;).Stream
  )
  .Node(&#39;/root&#39;)
  .Attrs
  .Item(&#39;id&#39;);
ShowMessage(Attr.Text);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que o desenvolvedor não tem controle sobre como a Lib irá instanciar esse Objeto internamente, pois primeiro &lt;code&gt;TXMLPack&lt;/code&gt; retorna outro Objeto em &lt;code&gt;Node()&lt;/code&gt; e então retorna uma lista &lt;code&gt;Attrs&lt;/code&gt; para então pesquisar e retornar a instância que queremos.&lt;/p&gt;

&lt;p&gt;É claro que podemos decorar qualquer instância retornada por qualquer Lib dentro do nosso próprio código, mas teríamos que fazer isso todas as vezes em todos os lugares.&lt;/p&gt;

&lt;p&gt;Por exemplo, se quiséssemos decorar instâncias de &lt;code&gt;TXMLAttribute&lt;/code&gt; (Lib) com a nossa Classe &lt;code&gt;TMyAttribute&lt;/code&gt;, teríamos que implementar dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node := TXMLPack.New(
  TFile.New(&#39;file.xml&#39;).Stream
)
.Node(&#39;/root&#39;);

// id attribute
IdAttr := 
  TMyAttribute.New(
    Node(&#39;/root&#39;).Attrs.Item(&#39;id&#39;)
  );

// name attribute
NameAttr := 
  TMyAttribute.New(
    Node(&#39;/root&#39;).Attrs.Item(&#39;name&#39;)
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja acima que foi preciso decorar cada instância (Atributos &lt;code&gt;id&lt;/code&gt; e &lt;code&gt;name&lt;/code&gt;) com a nossa Classe.&lt;/p&gt;

&lt;p&gt;Mas mesmo sendo um código &lt;em&gt;repetitivo&lt;/em&gt;, é &lt;em&gt;viável&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, se a Lib for desenvolvida para dar a opção ao desenvolvedor para decorar esses Objetos criados internamente, é provável que ela utilize o padrão &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_factory_pattern&quot;&gt;&lt;em&gt;Abstract Factory&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Essa seria uma opção simples para utilizar Injeção de Dependência de forma totalmente desacoplada e sem repetições.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ First we need to include a factory
  in some place of the code }
  
TXAttributeFactories.New
  .Add(
    // your own factory
    TMyAttributeFactory.New
  );

// ...  
  
{ Then, Lib&#39;s code will use these factories
  to decorate each new Attribute instance }
  
function TCAttributes.Item(AIndex: Integer): IXAttribute;
var
  A: TDOMNode;
begin
  A := FNode.Attributes.Item[AIndex];
  if not Assigned(A) then
    raise EXError.CreateFmt(
      &#39;Node not found on index %d.&#39;, [AIndex]
    );

  { At this point, factories instance will 
    find TMyAttributeFactory instance and it 
    will use to return a new instance, 
    wrapping TCAttribute instance }

  Result := 
    TXAttributeFactories.New
      .Decorate(
        TCAttribute.New(FNode, A)
      );
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código acima é do &lt;a href=&quot;https://github.com/mdbs99/xavier/blob/47240049ff594904a856320d0b6e4ed8c979529f/src/xavier.xml.fpc.pas#L179&quot;&gt;Projeto Xavier&lt;/a&gt;, porém a chamada à Classe &lt;code&gt;TXAttributeFactories&lt;/code&gt; é apenas uma simulação, exemplificando como a implementação poderia ser codificada.&lt;/p&gt;

&lt;p&gt;Veja que o método &lt;code&gt;Decorate(Attr: IXAttribute)&lt;/code&gt; recebe apenas uma instância já criada, ou seja, a fábrica não sabe como criar uma nova instância de &lt;code&gt;IXAttribute&lt;/code&gt;, ela apenas sabe como decorar uma instância já existente.&lt;/p&gt;

&lt;h2 id=&quot;dependencia-tardia&quot;&gt;Dependência Tardia&lt;/h2&gt;

&lt;p&gt;Chamo de dependência tardia quando um &lt;code&gt;Objeto A&lt;/code&gt; só precisa de uma instância &lt;code&gt;B&lt;/code&gt; num dado momento, dependendo de uma escolha do usuário ou evento externo. Em outras palavras, não sabemos se iremos precisar ou não da instância do &lt;code&gt;Objeto B&lt;/code&gt; quando estivermos compondo nossos Objetos para trabalhar numa determinada tarefa.&lt;/p&gt;

&lt;p&gt;Talvez esse tenha sido o grande problema que mais motivou a construção dos artefatos e &lt;em&gt;frameworks&lt;/em&gt; já citados.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo:&lt;/p&gt;

&lt;p&gt;Suponha que o &lt;code&gt;Objeto A&lt;/code&gt; receba uma conexão com um SGBD através de seu construtor e em um dos seus métodos é instanciado um &lt;code&gt;Objeto B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A instância de &lt;code&gt;B&lt;/code&gt; também precisa da conexão com o SGBD, então basta passarmos no construtor de &lt;code&gt;B&lt;/code&gt; a conexão já recebida no &lt;code&gt;Objeto A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então &lt;code&gt;B&lt;/code&gt;, em um de seus métodos, instancia e retorna um &lt;code&gt;Objeto C&lt;/code&gt; e, nesse caso, &lt;code&gt;C&lt;/code&gt; não precisa de uma conexão. No seu construtor não há nenhum argumento desse tipo.&lt;/p&gt;

&lt;p&gt;O programa continua e agora essa instância de &lt;code&gt;C&lt;/code&gt; precisa instanciar um &lt;code&gt;Objeto D&lt;/code&gt;. Esse último Objeto, tem métodos que retornam outros Objetos, porém para instanciá-los uma conexão ao SGBD é necessária… mas nesse ponto não temos esse Objeto da conexão.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A (conection)
  B (conection)
    C ()
      D ()
        E (conection ?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse é o &lt;em&gt;grande&lt;/em&gt; problema.&lt;/p&gt;

&lt;p&gt;Onde o &lt;code&gt;Objeto D&lt;/code&gt; iria conseguir uma conexão ao SGBD para utilizar como argumento na criação de outros Objetos que necessitam de tal argumento?&lt;/p&gt;

&lt;p&gt;Nas linguagens Funcionais, existe o conceito de &lt;a href=&quot;https://pt.wikipedia.org/wiki/Currying&quot;&gt;Currying&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ao invés de termos funções que recebem N parâmetros, haverá funções com apenas 1 parâmetro que chamará outra função, e outra, e mais outra…&lt;/p&gt;

&lt;p&gt;Esse vídeo explica o conceito:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/ZasXwtTRkio&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;No entanto, pode ser um conceito difícil de entender pra quem é acostumando com linguagens imperativas.&lt;/p&gt;

&lt;p&gt;Bem, não temos &lt;em&gt;Currying&lt;/em&gt; nas linguagens Orientadas a Objetos, mas temos &lt;em&gt;Classes&lt;/em&gt; e Objetos.&lt;/p&gt;

&lt;p&gt;Então, utilizando apenas Classes e Objetos, como podemos fazer a Injeção de Dependência e obter argumentos onde e quando for preciso?&lt;/p&gt;

&lt;p&gt;A resposta é a mesma: &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_factory_pattern&quot;&gt;&lt;em&gt;Abstract Factory&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, ao invés de apenas decorar uma instância, a fábrica iria criar uma nova do início.&lt;/p&gt;

&lt;p&gt;Essas fábricas teriam mais métodos, possivelmente métodos com as mesmas assinaturas dos construtores e &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Métodos New&lt;/a&gt; já existente na Classe original.&lt;/p&gt;

&lt;p&gt;No exemplo anterior, o método &lt;code&gt;Decorate(...)&lt;/code&gt; foi utilizado para decorar uma instância já existente. Aqui, sugiro utilizar a nomenclatura &lt;code&gt;Make(...)&lt;/code&gt; que irá criar uma nova instância.&lt;/p&gt;

&lt;p&gt;Esse tipo de fábrica seria muito mais utilizado em aplicações do que em Libs, no entanto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Injeção de Dependência é &lt;a href=&quot;http://blog.ploeh.dk/2017/01/27/dependency-injection-is-passing-an-argument/&quot;&gt;passagem de parâmetro&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Vimos nesse artigo algumas possíveis opções para resolver os tipos de Dependência mais comuns.&lt;/p&gt;

&lt;p&gt;Vimos que não é necessário &lt;em&gt;frameworks&lt;/em&gt; complexos ou qualquer outro artefato além de Classes e Objetos simples para utilizarmos Injeção de Dependência na sua forma mais pura.&lt;/p&gt;

&lt;p&gt;Infelizmente o espaço de um único artigo não é suficiente para implementarmos uma solução completa.&lt;/p&gt;

&lt;p&gt;Seja simples. Utilize Classes e respeite seus Objetos sem quebrar o encapsulamento.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/injecao-de-dependencia</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/injecao-de-dependencia</guid>
      </item>
    
      <item>
        <title>Nomeando Classes em Libraries</title>
        <description>&lt;p&gt;Veja nesse artigo algumas ideias que você deveria considerar ao nomear suas Classes em projetos do tipo Library.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-marcel-strauss-334864.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Marcel Strauß on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Uma Library ou Lib, para encurtar, é definida na &lt;a href=&quot;https://en.wikipedia.org/wiki/Library_(computing)&quot;&gt;Wikipedia&lt;/a&gt; como “uma coleção de subprogramas utilizados no desenvolvimento de software”.&lt;/p&gt;

&lt;p&gt;Eu gosto mais da próxima definição: “Uma Lib é também uma coleção de implementações de &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamento&lt;/a&gt;”.&lt;/p&gt;

&lt;p&gt;Não pense numa Lib somente em termos de arquivos dll/so. Vamos aumentar esse conceito. Pense em Libs como dll/so, pacotes de software ou até mesmo um programa. Pense em termos de definição de comportamento especializado.&lt;/p&gt;

&lt;p&gt;Uma Lib é — ou deveria ser — um especialista em um assunto, dentro de um contexto bem definido.&lt;/p&gt;

&lt;p&gt;Eu diria que é (quase) a mesma definição do Objeto.&lt;/p&gt;

&lt;p&gt;No entanto, enquanto há Objetos tão simples com apenas um método, uma Lib parece mais como uma composição de muitos Objetos, trabalhando colaborativamente entre si, fazendo emergir um comportamento especializado.&lt;/p&gt;

&lt;p&gt;Os Objetos são como peças intercambiáveis. Podem ser simples ou complexos através do uso da composição.&lt;/p&gt;

&lt;p&gt;Uma Lib, eu acredito, é uma personificação de alguma entidade especializada.&lt;/p&gt;

&lt;p&gt;E toda entidade precisa ter um nome.&lt;/p&gt;

&lt;h2 id=&quot;lib&quot;&gt;Nomeando uma Lib&lt;/h2&gt;

&lt;p&gt;Há muitos anos eu já publicava alguns pequenos projetos no &lt;a href=&quot;https://sourceforge.net/&quot;&gt;SourceForge&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A maioria desses projetos eram pequenos pacotes de componentes para Delphi mas, apesar de ter tido alguns pouquíssimos colaboradores, tais projetos nunca foram relevantes para a comunidade.&lt;/p&gt;

&lt;p&gt;Bem, eu sabia quase nada sobre OpenSource e também não tinha muita experiência em desenvolvimento, então utilizei isso apenas como um aprendizado.&lt;/p&gt;

&lt;p&gt;Na época eu nomeava meus pacotes de componentes com nomes abstratos. Eles não representavam uma entidade especializada. Eram apenas arquivos agrupados num pacote. Um bom nome não era relevante naquela época — eu pensava.&lt;/p&gt;

&lt;p&gt;Anos se passaram.&lt;/p&gt;

&lt;p&gt;Então, eu aprendi mais sobre &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt; e &lt;a href=&quot;https://en.wikipedia.org/wiki/Semantics&quot;&gt;semântica&lt;/a&gt; e como é importante utilizar bons nomes nos identificadores no código.&lt;/p&gt;

&lt;p&gt;Dizem que &lt;em&gt;nomear coisas e invalidar cache&lt;/em&gt; são as duas coisas mais difíceis de fazer na computação. E é verdade.&lt;/p&gt;

&lt;p&gt;Nomear coisas é difícil. Nunca fica perfeito. Escolhemos um nome pensando ser a melhor opção e daqui a duas horas estamos refatorando e renomeando…&lt;/p&gt;

&lt;p&gt;É quase uma &lt;em&gt;arte&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Muitas vezes demora mais tempo para descobrirmos que um nome não foi bem escolhido.&lt;/p&gt;

&lt;p&gt;Há pouco mais de 5 anos atrás eu publiquei um projeto OpenSource chamado &lt;a href=&quot;https://github.com/mdbs99/greyhound&quot;&gt;Greyhound&lt;/a&gt;, mas muitos não sabem qual o motivo da escolha desse nome.&lt;/p&gt;

&lt;p&gt;Aqui está a explicação: Enquanto a &lt;em&gt;Cheetah&lt;/em&gt; (símbolo do Free Pascal) é o animal terrestre mais rápido, &lt;em&gt;Greyhound&lt;/em&gt; é a raça mais rápida entre cães.&lt;/p&gt;

&lt;p&gt;E o que esse nome tem haver com um projeto que abstrai entidades de um Banco de Dados? — você pode estar pensando.&lt;/p&gt;

&lt;p&gt;É, concordo com você que esse nome não foi uma boa escolha.&lt;/p&gt;

&lt;p&gt;Mas ainda acho que é um nome bem interessante. Talvez para uma Lib que trabalhe com &lt;em&gt;stream&lt;/em&gt; de dados ou um novo sistema operacional. Talvez algo relacionado a velocidade? Não sei.&lt;/p&gt;

&lt;p&gt;Pode não ter sido a melhor escolha para o meu projeto, mas por causa dele eu passei a utilizar nomes cada vez mais comuns.&lt;/p&gt;

&lt;p&gt;Hoje em dia todos os meus projetos (privados) ganham nomes próprios comuns. Alguns desses nomes provocam sorrisos em reuniões sempre que são pronunciados. Não devido ao nome em si, mas devido a relação do nome com o sistema que ele representa.&lt;/p&gt;

&lt;p&gt;Eu também levei essa nomenclatura para o mundo OpenSource através das minhas Libs mais recentes: &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James&lt;/a&gt; e &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;Xavier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Se esses são bons nomes ou não, você decide.&lt;/p&gt;

&lt;p&gt;O aprendizado aqui é que bons nomes podem fazer a diferença pois o nome não será utilizado apenas na URL do seu projeto, mas sim em (quase) todas as Classes.&lt;/p&gt;

&lt;h2 id=&quot;classes&quot;&gt;Nomeando Classes&lt;/h2&gt;

&lt;p&gt;Na época do SourceForge minhas Classes tinham minhas iniciais “MD” como prefixo ou qualquer outras “duas letras” abstratas.&lt;/p&gt;

&lt;p&gt;Prefixos. Vemos essa prática ainda hoje em dia para diminuir a colisão de nomes entre classes similares. Exemplo: &lt;code&gt;TAbStream&lt;/code&gt; vs &lt;code&gt;TCdStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Essa prática é visto até mesmo em grandes &lt;em&gt;frameworks&lt;/em&gt; e outros ecosistemas como Java e C#.&lt;/p&gt;

&lt;p&gt;Por quê?&lt;/p&gt;

&lt;p&gt;Bem, precisamos diferenciar a classe padrão &lt;code&gt;TStream&lt;/code&gt; da sua &lt;code&gt;TMyStream&lt;/code&gt;, por exemplo.&lt;/p&gt;

&lt;p&gt;Poderíamos utilizar a Unidade como prefixo, mas ninguém gosta de escrever o nome totalmente qualificado como &lt;code&gt;acme.streams.TStream&lt;/code&gt; sempre que tiver que usar a Classe &lt;code&gt;TStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então o prefixo &lt;code&gt;My&lt;/code&gt;, nesse caso, faz diferença.&lt;/p&gt;

&lt;p&gt;No entanto, um grande problema é que não controlamos os prefixos que são utilizados em projetos ao redor do mundo. Eu quero dizer, por exemplo, que se você escolhe &lt;code&gt;Ab&lt;/code&gt; como prefixo de suas Classes, é bem possível que exista alguma outra Lib que já utiliza esse prefixo — e tem, chama-se &lt;a href=&quot;https://github.com/TurboPack/Abbrevia&quot;&gt;Abbrevia&lt;/a&gt; e eu a utilizo.&lt;/p&gt;

&lt;p&gt;O prefixo &lt;code&gt;Ab&lt;/code&gt; deixa os identificadores pequenos — o que é bom — porém a ambiguidade continua existindo, visto que, por serem apenas 2 letras, a probabilidade é que outro desenvolvedor já tenha escolhido esse mesmo prefixo.&lt;/p&gt;

&lt;p&gt;E esse não é o maior problema.&lt;/p&gt;

&lt;p&gt;É comum utilizarmos prefixos em grandes sistemas, compostos de muitos módulos, representando implementações diferentes para um mesmo conceito. Então se um desses prefixos for &lt;code&gt;Ab&lt;/code&gt; e já estiver sendo utilizado dentro de um grande sistema — imagine que esse prefixo faz todo o sentido para o sistema da empresa, podendo representar uma área, setor ou algo bem importante — a ambiguidade é ainda pior, visto que poderia confundir o desenvolvedor: “Essa é uma Classe da empresa ou da Lib?”.&lt;/p&gt;

&lt;p&gt;É claro que basta posicionarmos o mouse em cima do identificador para vermos um &lt;em&gt;hint&lt;/em&gt; com a informação de qual unidade ele pertence. Mas, e se você já utiliza o mesmo nome como &lt;code&gt;TAbStream&lt;/code&gt; (exemplo dado acima) dentro um grande sistema? Você muda o identificador que faz mais sentido para empresa para não conflitar com o identificador da Lib ou &lt;a href=&quot;/redeclarando-classes&quot;&gt;redefine&lt;/a&gt; todas as Classes da Lib?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Nomear coisas e invalidar cache são as duas tarefas mais difíceis na computação.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Acredito que muitos desenvolvedores nem sequer pensam nesses conflitos.&lt;/p&gt;

&lt;p&gt;“Ei! O código está funcionando, é o que importa”, eles dizem.&lt;/p&gt;

&lt;p&gt;Bem, existem bons profissionais, outros nem tanto.&lt;/p&gt;

&lt;p&gt;E como resolver esse impasse?&lt;/p&gt;

&lt;p&gt;Como ter identificadores curtos, porém com uma boa semântica?&lt;/p&gt;

&lt;p&gt;Como diminuir ou (quase) acabar com conflitos de nomenclatura?&lt;/p&gt;

&lt;p&gt;Minha única resposta é: Não use prefixos abstratos em Classes, use um &lt;em&gt;nome&lt;/em&gt; de verdade.&lt;/p&gt;

&lt;p&gt;O primeiro passo é escolher um bom nome: Simples, memorável e que represente um &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contexto&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;contextualizando&quot;&gt;Contextualizando&lt;/h2&gt;

&lt;p&gt;Um contexto encapsula uma possível implementação para um determinado problema.&lt;/p&gt;

&lt;p&gt;Ao invés de utilizar &lt;code&gt;TAbStream&lt;/code&gt;, você utilizaria &lt;code&gt;TAbbreviaStream&lt;/code&gt;, por exemplo — eu não sei se tal Classe realmente existe nessa Lib.&lt;/p&gt;

&lt;p&gt;Não parece muito, mas essa pequena alteração pode fazer uma grande diferença em médios a grandes sistemas.&lt;/p&gt;

&lt;p&gt;Ao invés de termos apenas 2 letras abstratas, temos um nome que identifica um contexto.&lt;/p&gt;

&lt;p&gt;Esse contexto é o mesmo que dizer: “Essa é a implementação de Abbrevia para representar um &lt;em&gt;Stream&lt;/em&gt;” — essa seria a “tradução” ao vermos a Classe &lt;code&gt;TAbbreviaStream&lt;/code&gt; declarada no código.&lt;/p&gt;

&lt;p&gt;É muito menos provável que outra Lib, com a mesma especialidade, utilize o mesmo nome. A probabilidade diminui ao utilizarmos mais letras, concorda?&lt;/p&gt;

&lt;p&gt;Além disso, é muito menos provável que você utilize nomes assim para representar contextos (área, setor ou algo bem importante) dentro de um sistema da empresa.&lt;/p&gt;

&lt;p&gt;Esse foi o tipo de refatoração que fiz a poucos dias no projeto &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;Xavier&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Uma Lib é um especialista em determinado assunto. Dar um nome memorável, apropriado e curto a sua Lib irá facilitar tanto a identificação das Classes quando o uso da mesma.&lt;/p&gt;

&lt;p&gt;Evite o uso de prefixos abstratos. Eles não eliminam a ambiguidade e podem tornar as coisas ainda mais confusas, caso você tenha outros pacotes que, por ventura, utilize o mesmo prefixo.&lt;/p&gt;

&lt;p&gt;Escolha nomes simples, de fácil memorização, curtos o suficiente, que tenham alguma relação ou que personifique a entidade especializada.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Oct 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/nomeando-classes-em-libraries</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/nomeando-classes-em-libraries</guid>
      </item>
    
  </channel>
</rss>
