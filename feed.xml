<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Free Pascal Macros</title>
        <description>&lt;p&gt;Uma linguagem simples e com um design elegante como Object Pascal não necessitaria de suporte a macros como existem em C/C++. No entanto, Free Pascal as tem. Devemos utilizá-las?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/remi-jacquaint-441559-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Rémi Jacquaint on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O uso de &lt;a href=&quot;https://en.wikipedia.org/wiki/Macro_(computer_science)&quot;&gt;macros&lt;/a&gt; já existe no Free Pascal faz tempo, porém nunca havia pensando utilizar tal feature.&lt;/p&gt;

&lt;p&gt;Se você é leitor assíduo do blog já deve ter percebido que eu prefiro ter um bom design e consistência no código do que utilizar “hacks” para escrever menos, porém com a perda da legibilidade e da manutenibilidade.&lt;/p&gt;

&lt;p&gt;Na minha opinião, macros são &lt;em&gt;hacks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bem, talvez a maioria…&lt;/p&gt;

&lt;p&gt;Não acho que que o suporte a macros não tenha sido implementado com o objetivo de melhorar o design e legibilidade do código.&lt;/p&gt;

&lt;p&gt;No entanto, acredito que podemos tirar proveito dessa feature.&lt;/p&gt;

&lt;h2 id=&quot;macros&quot;&gt;Macros&lt;/h2&gt;

&lt;p&gt;No código Pascal podemos definir macros que serão pré-processadas pelo compilador. Esse processamento irá gerar um resultado, que será como uma constante. Mas, essa constante pode representar uma expressão, um algorítimo, uma unidade, etc.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{$macro on}
{$define VALUE := A+B}

function Sum(A, B: Integer): Integer;
begin
  Result := VALUE;
end;

function Concat(const A, B: string): string;
begin
  Result := VALUE;
end;
{ TForm1 }

procedure TForm1.Button1Click(Sender: TObject);
begin
  ShowMessage(Sum(1,2).ToString); // 3
  ShowMessage(Concat(&#39;A&#39;,&#39;B&#39;));   // &#39;AB&#39;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A primeira coisa a se fazer é ativar o uso de macros utilizando a diretiva &lt;code&gt;{$macro on}&lt;/code&gt;, pois macros não são ativadas por padrão. Outra maneira de ativá-as para todas as unidades é passando o argumento &lt;code&gt;-Sm&lt;/code&gt; para o compilador.&lt;/p&gt;

&lt;p&gt;O exemplo acima não faz muito sentido, pois para se fazer uma soma não é necessário o uso de macros. No entanto, serviu para lhe mostrar o que é possível fazer com elas.&lt;/p&gt;

&lt;p&gt;Repare que &lt;code&gt;A&lt;/code&gt; e &lt;code&gt;B&lt;/code&gt; são definidos na macro como 2 identificadores que ainda não existem. Esses identificadores virão do contexto onde as macros serão chamadas, ou seja, as funções &lt;code&gt;Sum&lt;/code&gt; e &lt;code&gt;Concat&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para a macro, não importa o tipo de &lt;code&gt;A&lt;/code&gt; e &lt;code&gt;B&lt;/code&gt;. Então, elas funcionam como &lt;em&gt;Generics&lt;/em&gt;, o que já é bem legal.&lt;/p&gt;

&lt;p&gt;Mas &lt;em&gt;Generics&lt;/em&gt; são muito mais poderosos do que isso, então não pense em macros como substitutos aos Generics.&lt;/p&gt;

&lt;p&gt;Vamos a outro exemplo onde Generics não ajudam em nada:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{$macro on}
{$ifdef debug}
  {$define foo := foo.debug}
{$else}
  {$define foo := foo.run}
{$endif}

uses
  foo;
begin
  foo.SomeFunc;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo acima, há um teste se a diretiva &lt;code&gt;debug&lt;/code&gt; foi definida. Se for verdadeiro, definimos uma macro &lt;code&gt;foo&lt;/code&gt; com o nome da unidade &lt;code&gt;foo.debug&lt;/code&gt;, senão definimos &lt;code&gt;foo&lt;/code&gt; como &lt;code&gt;foo.run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Repare que na cláusula &lt;code&gt;uses&lt;/code&gt; há somente &lt;code&gt;foo&lt;/code&gt;. Imagine agora por as diretivas em outro lugar, talvez arquivos &lt;code&gt;.inc&lt;/code&gt;, e teremos uma unidade com o código limpo que irá utilizar as classes corretas dependendo da diretiva escolhida.&lt;/p&gt;

&lt;p&gt;Bem legal, não é?&lt;/p&gt;

&lt;p&gt;Entretanto, isso também não foi o que mais me chamou atenção no uso das macros. Pois, para fazer o mesmo que no exemplo acima, não é preciso macros. Basta você ter unidades como o mesmo nome, porém em diretórios diferentes, e passar o path correspondente ao compilador dependendo se há ou não a diretiva &lt;code&gt;debug&lt;/code&gt;. O Lazarus IDE lhe dá essa opção.&lt;/p&gt;

&lt;p&gt;Se há outras alternativas na própria linguagem para o uso de macros, por quê então utilizá-las?&lt;/p&gt;

&lt;h2 id=&quot;alias&quot;&gt;Unit Alias&lt;/h2&gt;

&lt;p&gt;Faz muito tempo que solicitei a implementação de uma nova sintaxe à equipe Free Pascal para ser possível &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclarar&lt;/a&gt; uma unidade diretamente no código. A linguagem C# tem isso, assim como Python.&lt;/p&gt;

&lt;p&gt;A razão para esse pedido é poder declarar unidades com nomes longos no código, mas dar-lhes um apelido curto para servir de prefixo a algumas classes que tem nomes iguais em unidades diferentes.&lt;/p&gt;

&lt;p&gt;Então pensei numa alternativa que chamei de &lt;a href=&quot;/api-unit&quot;&gt;API Unit&lt;/a&gt;. As vantagens e desvantagens estão no artigo.&lt;/p&gt;

&lt;p&gt;Infelizmente essa ideia não se mostrou muito eficaz para projetos com muitas unidades, já que é necessário redeclarar todas as unidades, suas classes e interfaces em um único arquivo.&lt;/p&gt;

&lt;p&gt;Mas com macros, tudo muda.&lt;/p&gt;

&lt;p&gt;Hipoteticamente, vamos supor que as unidades &lt;code&gt;Windows&lt;/code&gt; e &lt;code&gt;Graphics&lt;/code&gt; pertencem ao namespace &lt;code&gt;FPC.RTL.&lt;/code&gt;, ou seja, um “nome longo”.&lt;/p&gt;

&lt;p&gt;Então, minha proposta (antiga) seria utilizar essa sintaxe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  FPC.RTL.Windows as Win,
  FPC.RTL.Graphics as Graph;
var
  B1: Win.TBitmap;
  B2: Graph.TBitmap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eu não estou me referindo aqui o uso de namespaces do Delphi — que já foi implementado no Free Pascal — onde poderíamos definir um &lt;code&gt;NS=&quot;FPC.RTL&quot;&lt;/code&gt; e declarar apenas &lt;code&gt;Windows&lt;/code&gt; e &lt;code&gt;Graphics&lt;/code&gt; respectivamente.&lt;/p&gt;

&lt;p&gt;Não é isso.&lt;/p&gt;

&lt;p&gt;Utilizando essa sintaxe, teríamos o &lt;em&gt;controle local&lt;/em&gt; sobre a nomenclatura das unidades.&lt;/p&gt;

&lt;p&gt;Quando solicitei isso na época, eu pensava que iria exigir mudanças no parser da linguagem, que daria muito trabalho, etc.&lt;/p&gt;

&lt;p&gt;Não era prioridade.&lt;/p&gt;

&lt;p&gt;Porém, veja que com o uso de macros, bastaria o compilador substituir os &lt;code&gt;uses&lt;/code&gt; acima, que utiliza a palavra reservada &lt;code&gt;as&lt;/code&gt;, pelo código abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  {$macro on}
  FPC.RTL.Windows,
  {$define Win := FPC.RTL.Windows}
  FPC.RTL.Graphics;
  {$define Graph := FPC.RTL.Graphics}
var
  B1: Win.TBitmap;
  B2: Graph.TBitmap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E então eu poderia “renomear” as unidades com nomes longos como &lt;code&gt;Acme.SysFoo.Finances.Billing.Utils.Classes&lt;/code&gt; para apenas &lt;code&gt;Billing&lt;/code&gt;. Porém, em outra unidade, eu poderia renomear para &lt;code&gt;Utils&lt;/code&gt; se assim o desejasse.&lt;/p&gt;

&lt;p&gt;Teríamos a possibilidade de definir um apelido local (por unidade) a cada unidade. Perfeito.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A resposta a pergunta inicial é, sim. O uso de macros, quando bem utilizado, pode melhorar muito a legibilidade e design do código.&lt;/p&gt;

&lt;p&gt;Não temos (ainda?) a sintaxe com o uso de &lt;code&gt;as&lt;/code&gt;, que seria apenas uma &lt;em&gt;syntax sugar&lt;/em&gt; para o uso de macros, porém já podemos renomear unidades localmente. O que é um grande avanço, na minha opinião.&lt;/p&gt;

&lt;p&gt;O único contra que eu vejo é que, infelizmente, essa feature não existe no Delphi… por enquanto?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jun 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpc-macros</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpc-macros</guid>
      </item>
    
      <item>
        <title>fpWeb: Verificando Vazamentos de Memória</title>
        <description>&lt;p&gt;A linguagem Object Pascal, assim como C ou C++, não possui &lt;em&gt;Garbage Collector&lt;/em&gt; para liberar os objetos e recursos da memória automaticamente. Pode ser difícil ter 100% de certeza que todos os objetos estão sendo liberados (manualmente) pelo código. Mas, se algum objeto não for liberado, ocorrerá um vazamento de memória.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-steve-johnson-548294-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Steve Johnson on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Quando utilizamos a linguagem Object Pascal precisamos nos preocupar com &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#vazamentos-de-memoria&quot;&gt;vazamentos de memória&lt;/a&gt;, até mesmo nos sistemas mais simples.&lt;/p&gt;

&lt;p&gt;Vazamentos de memória podem ser ainda mais prejudiciais em sistemas Web comparado com sistemas Desktop. Se uma aplicação Desktop tem vazamentos de memória, em algum momento o usuário poderá fechar a aplicação e todo o vazamento será recuperado pelo Sistema Operacional. Mas em aplicações Web, onde podem haver múltiplas requisições por segundo enquanto o servidor mantém em memória cópias do executável (FastCGI), tais vazamentos poderiam diminuir drasticamente com os recursos do servidor.&lt;/p&gt;

&lt;p&gt;No &lt;a href=&quot;/fpweb-hello&quot;&gt;artigo anterior&lt;/a&gt; fizemos um programa simples que responde “Hello!” quando uma determinada URL  acessada.&lt;/p&gt;

&lt;p&gt;Como não há vazamentos de memória nesse programa, teremos que simulá-lo, alterando o método &lt;code&gt;HandleRequest&lt;/code&gt; conforme abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure THelloRoute.HandleRequest(
  ARequest: TRequest; AResponse: TResponse);
begin
  TStringList.Create;
  AResponse.Content := &#39;Hello!&#39;;
  AResponse.SendResponse;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mesmo após compilar o programa com o &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/heaptrc/usage.html&quot;&gt;HeapTrc&lt;/a&gt; habilitado, iniciá-lo e executá-lo utilizando o browser, não será possível ver o vazamento — diferentemente de aplicações Desktop que, ao término do programa, mostra um “relatório” sobre a memória &lt;em&gt;utilizada vs. liberada&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para ser possível ver o relatório, você tem que finalizar a aplicação apropriadamente. O problema é que, mesmo após finalizada a requisição pelo browser, ela continua em execução aguardando mais e mais requisições.&lt;/p&gt;

&lt;p&gt;Felizmente, há uma maneira de ver o relatório do HeapTrc, alterando o código conforme a seguir:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/90b319e7bcf5d37383c1083179b69546.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, foi introduzido um procedimento &lt;code&gt;TerminateCall&lt;/code&gt;, algumas configurações do &lt;code&gt;heaptrc&lt;/code&gt; e a inclusão de uma nova rota &lt;code&gt;/quit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compile e execute a aplicação novamente. Depois, faça uma requisição a URL &lt;code&gt;/hello&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, aponte seu browser para fazer uma requisição a URL &lt;code&gt;/quit&lt;/code&gt;. Nesse momento você verá que a janela da aplicação foi finalizada.&lt;/p&gt;

&lt;p&gt;Finalmente, abra o arquivo &lt;code&gt;log.txt&lt;/code&gt;, localizado no mesmo diretório do executável, para visualizar todos os vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Jun 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpweb-memleak</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpweb-memleak</guid>
      </item>
    
      <item>
        <title>Construindo uma Aplicação Básica com fpWeb</title>
        <description>&lt;p&gt;As vezes, tudo que precisamos é uma aplicação “Alô Mundo”.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-rawpixel-296622-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by rawpixel on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Neste artigo você verá como preparar seu ambiente Lazarus para o desenvolvimento Web com fpWeb.&lt;/p&gt;

&lt;p&gt;Eu estou utilizando a versão mais atual e revisada do Lazarus 1.8.5,  &lt;a href=&quot;https://svn.freepascal.org/svn/lazarus/branches/fixes_1_8&quot;&gt;fixes_1_8&lt;/a&gt;, revisão 58049.&lt;/p&gt;

&lt;p&gt;Para o compilador, também estou utilizando a versão mais atual e revisada do FPC 3.0.5, &lt;a href=&quot;https://svn.freepascal.org/svn/fpc/branches/fixes_3_0&quot;&gt;fixes_3_0&lt;/a&gt;, revisão 38970.&lt;/p&gt;

&lt;p&gt;O artigo presume que você já tem o FPC e Lazarus instalados e funcionando no seu computador.&lt;/p&gt;

&lt;h2 id=&quot;instalando&quot;&gt;Instalando fpWeb&lt;/h2&gt;

&lt;p&gt;A primeira instalação a ser realizada será a do pacote &lt;code&gt;lazwebextra&lt;/code&gt;. Esse pacote adiciona opções para a criação de novos projetos do tipo Web como CGI Application, FastCGI Application e outros.&lt;/p&gt;

&lt;p&gt;Esse pacote não é obrigatório, mas facilita a criação de novos projetos. No entanto, se você não quiser instalá-lo, ainda poderá criar uma aplicação console simples e ir alterando manualmente o código conforme for lendo o artigo.&lt;/p&gt;

&lt;p&gt;Para prosseguir com a instalação, abra o menu &lt;code&gt;Package&amp;gt;Install/Uninstall Packages&lt;/code&gt; e localize o pacote &lt;code&gt;lazwebextra&lt;/code&gt; no box “Available for installation”.&lt;/p&gt;

&lt;p&gt;Na figura abaixo, o pacote é mostrado no box esquerdo, pois já foi instalado no meu computador.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/laz-install-lazwebextra.jpg&quot; alt=&quot;Install/Uninstall Packages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Clique em “Save e Rebuild IDE”.&lt;/p&gt;

&lt;p&gt;Se tudo deu certo, você poderá seguir para o próximo passo, ou seja, o início da construção de um sistema Web simples.&lt;/p&gt;

&lt;h2 id=&quot;desenvolvimento&quot;&gt;Desenvolvimento&lt;/h2&gt;

&lt;p&gt;Após a instalação do pacote de integração com a IDE, você estará habilitado a construir aplicativos Web utilizando o fpWeb framework.&lt;/p&gt;

&lt;p&gt;Abra o menu &lt;code&gt;File&amp;gt;New&lt;/code&gt; e escolha a opção “FastCGI Application”.&lt;/p&gt;

&lt;p&gt;Apesar de escolhermos essa opção, não iremos criar uma aplicação FastCGI que precisará ser executada em algum servidor Web como Apache ou Microsoft IIS. Ao invés disso, iremos criar um executável Standalone que irá responder as requisições do browser sem a necessidade de existir um servidor.&lt;/p&gt;

&lt;p&gt;Após clicar nessa opção, um novo projeto será criado.&lt;/p&gt;

&lt;p&gt;Infelizmente, nessa versão do Lazarus eles ainda mantém a versão antiga do fpWeb como padrão, ou seja, aquela baseada no modelo Web Broker. No entanto, queremos utilizar a &lt;a href=&quot;/fpweb&quot;&gt;nova&lt;/a&gt; versão e para isso precisaremos fazer algumas modificações manuais.&lt;/p&gt;

&lt;p&gt;Feche a &lt;code&gt;Unit1&lt;/code&gt; sem salvar e remova-a do projeto (&lt;code&gt;lpr&lt;/code&gt;). Salve o projeto, escolhendo um nome — eu digitei &lt;code&gt;hello.lpr&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program hello;

{$mode objfpc}{$H+}

uses
 fpFCGI;

begin
  Application.Title := &#39;Hello World&#39;;
  { Uncomment the port setting here if you want to run the
    FastCGI application stand-alone (e.g. for NGINX) }
  // Application.Port:=2015; // For example
  Application.Initialize;
  Application.Run;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por enquanto esse é todo o projeto. Ele ainda não faz nada de útil. É necessário criar alguma rota que execute alguma ação.&lt;/p&gt;

&lt;p&gt;Como iremos criar uma aplicação Standalone, precisaremos substituir a seção &lt;code&gt;uses&lt;/code&gt; com outras unidades e também definir a porta de acesso que estará em execução quando acessarmos &lt;code&gt;localhost&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program hello;

{$mode objfpc}{$H+}

uses
  SysUtils, httpdefs, httproute, fphttpapp;

begin
  Application.Title := &#39;Hello World&#39;;
  Application.Port := 8080;
  Application.Initialize;
  Application.Run;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As duas unidades mais importantes são &lt;code&gt;httproute&lt;/code&gt;, que define os objetos relacionados às rotas e &lt;code&gt;fphttpapp&lt;/code&gt;, que substitui o tipo de projeto de FastCGI para Standalone.&lt;/p&gt;

&lt;p&gt;Feito isso é necessário definir ao menos uma rota para executar alguma ação.&lt;/p&gt;

&lt;p&gt;A maneira mais fácil é implementar uma nova classe, tendo como base a &lt;code&gt;TRouteObject&lt;/code&gt;, padrão do fpWeb. Essa nova classe deverá sobrescrever o método &lt;code&gt;HandleRequest&lt;/code&gt; e retornar algo como resposta.&lt;/p&gt;

&lt;p&gt;Vamos criar uma nova classe chamada &lt;code&gt;THelloRoute&lt;/code&gt;, implementando o método &lt;code&gt;HandleRequest&lt;/code&gt; da forma mais simples possível. Depois, é necessário registrar essa rota em algum lugar, antes da aplicação realmente iniciar — você poderá utilizar as seções &lt;code&gt;initialization&lt;/code&gt; de cada nova unidade que você criar, porém aqui, para manter simples, basta registrar a rota antes de &lt;code&gt;Application.Run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Abaixo pode-se ver o programa completo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program hello;

{$mode objfpc}{$H+}

uses
  SysUtils, httpdefs, httproute, fphttpapp;

type
  THelloRoute = class(TRouteObject)
  public
    procedure HandleRequest(
      ARequest: TRequest; AResponse: TResponse); override;
  end;

{ THelloRoute }

procedure THelloRoute.HandleRequest(
  ARequest: TRequest; AResponse: TResponse);
begin
  AResponse.Content := &#39;Hello!&#39;;
  AResponse.SendResponse;
end;

begin
  HTTPRouter.RegisterRoute(&#39;/hello&#39;, rmAll, THelloRoute);
  Application.Title := &#39;Hello World&#39;;
  Application.Port := 8080;
  Application.Initialize;
  Application.Run;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora execute a aplicação diretamente pela IDE.&lt;/p&gt;

&lt;p&gt;Depois, abra algum browser se sua preferência e digite: &lt;a href=&quot;http://localhost:8080/hello&quot;&gt;http://localhost:8080/hello&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Se tudo deu certo, você estará vendo “Hello!” como resposta.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Esse artigo mostrou como criar uma aplicação Web simples que pode ser executada e testada sem a necessidade de um servidor Web.&lt;/p&gt;

&lt;p&gt;Tenha em mente que “todo esse trabalho” só será feito uma vez. Após criar um projeto de “template”, bastará copiar/colar e renomear o projeto. Todo o restante do trabalho será criando novas unidades e rotas relacionadas às suas regras de negócio.&lt;/p&gt;

&lt;p&gt;Até a data de publicação desse artigo não havia documentação sobre esse novo estilo de desenvolvimento utilizando o fpWeb framework. Então, talvez esse seja um dos primeiros artigos a explicar essa nova tecnologia.&lt;/p&gt;

&lt;p&gt;Espero que você tenha ficado motivado a pesquisar mais a respeito sobre desenvolvimento Web com Free Pascal e Lazarus.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Jun 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpweb-hello</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpweb-hello</guid>
      </item>
    
      <item>
        <title>Desenvolvimento Web com fpWeb Framework</title>
        <description>&lt;p&gt;Durante anos, o desenvolvimento Web no Delphi e Lazarus sempre seguiram o antigo padrão Web Broker.
Felizmente, estamos vivendo uma nova fase no ambiente Object Pascal.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-maik-jonietz-535261-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Maik Jonietz on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A tecnologia Web Broker foi apresentada no &lt;a href=&quot;https://en.wikipedia.org/wiki/Delphi_(IDE)#Borland_Delphi_3&quot;&gt;Delphi 3&lt;/a&gt; em 1997 e desde esse tempo não houve muitas melhorias. Pelo menos, não na parte do &lt;em&gt;arquitetura&lt;/em&gt; das aplicações.&lt;/p&gt;

&lt;p&gt;O Web Broker é um sistema baseado em Web Modules. Cada Web Module pode ter uma lista de Actions, e cada Action corresponde a uma URL onde você define um &lt;em&gt;evento&lt;/em&gt; que será executado.&lt;/p&gt;

&lt;p&gt;Eu venho construindo aplicações Web em Object Pascal desde os tempos do Delphi 4~5. Essas aplicações sempre tiveram uma boa performance quando utilizávamos o padrão &lt;a href=&quot;https://pt.wikipedia.org/wiki/ISAPI&quot;&gt;ISAPI&lt;/a&gt;. Entretanto, a arquitetura estava longe de ser a ideal. Na minha opinião, tentaram utilizar a abordagem RAD em um contexto não-RAD. Funcionava, e ainda funciona, mas não era “empolgante” desenvolver tais aplicações.&lt;/p&gt;

&lt;h2 id=&quot;fpweb&quot;&gt;fpWeb Framework&lt;/h2&gt;

&lt;p&gt;A implementação atual do fpWeb — framework Web disponível no Free Pascal 3.0.4 — é bem diferente. Eles mantiveram a compatibilidade com o estilo Web Broker antigo, caso você ainda precise dele para sistemas legados, mas nos deram a possibilidade de utilizar um sistema de &lt;em&gt;rotas&lt;/em&gt; muito melhor além de podermos compilar nossas aplicações utilizando diferentes tipos de modelos como Standalone, CGI ou FastCGI.&lt;/p&gt;

&lt;h2 id=&quot;rotas&quot;&gt;Rotas&lt;/h2&gt;

&lt;p&gt;Com o novo sistema de rotas não é mais necessário utilizar Web Modules e eventos, basta registrar uma classe ou mesmo uma simples procedure para representar uma ação quando uma determinada URL for acessada.&lt;/p&gt;

&lt;p&gt;Além disso, não estamos mais presos às URLs com o padrão &lt;code&gt;/module/action&lt;/code&gt; utilizados no padrão Web Broker. No novo sistema, você pode definir e registrar suas URLs do jeito que quiser.&lt;/p&gt;

&lt;p&gt;Exemplo. Através da &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;, você pode definir uma classe que irá responder a uma determinada URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TMyHandler = Class(TRouteObject)
public
  procedure HandleRequest(
    ARequest: TRequest; AResponse: TResponse); override;
end;

initialization
  HTTPRouter.RegisterRoute(
    &#39;/my/route/in/action&#39;, rmAll, TMyHandler
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A classe &lt;code&gt;TRouteObject&lt;/code&gt; faz parte da fpWeb. Utilize essa classe como base para suas classes. É possível utilizar desde uma simples procedure ou até mesmo uma classe que implemente &lt;code&gt;IRouteInterface&lt;/code&gt;. Mas, na minha opinião, a melhor opção é utilizar apenas classes por ser o método mais simples e organizado para codificar as rotas.&lt;/p&gt;

&lt;h2 id=&quot;padroes&quot;&gt;Standalone, CGI ou FastCGI&lt;/h2&gt;

&lt;p&gt;A depuração de aplicações Web nunca foi fácil. Uma aplicação ISAPI, por exemplo, é executada no formato multi thread e depurar uma aplicação nesse formato é um desafio.&lt;/p&gt;

&lt;p&gt;A fpWeb facilita o desenvolvimento e depuração. Através de &lt;a href=&quot;/diretivas-de-compilacao&quot;&gt;diretivas de compilação&lt;/a&gt;, você pode determinar o tipo de modelo a ser desenvolvido. Por exemplo, você poderia determinar que o modelo Standalone será escolhido se o depurador estiver ativado.&lt;/p&gt;

&lt;p&gt;Exemplo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{$ifdef STANDALONE}
  fphttpapp,
{$endif}
{$ifdef FCGI}
  fpfcgi,
{$endif}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Standalone é uma aplicação que não precisa de um serviço Apache ou IIS. O próprio executável se registra numa porta (escolhida pelo desenvolvedor) para responder a requisições HTTP. É possível utilizar esse modelo até mesmo em produção — pense em vários serviços sendo executados localmente numa única máquina se comunicando entre si, mas que também podem responder a requisições na rede.&lt;/p&gt;

&lt;p&gt;Sendo uma aplicação que não necessita de um servidor Web, é possível depurar facilmente utilizando &lt;em&gt;breakpoints&lt;/em&gt; da mesma forma que fazemos em aplicações Desktop.&lt;/p&gt;

&lt;p&gt;No entanto, se você tem um servidor Web, a forma mais simples de fazer o deploy para um Apache ou IIS é o formato CGI. Nesse formato o servidor Web irá executar e instanciar sua aplicação a cada requisição feita pelo usuário de forma isolada e segura. É um ótimo modelo para aplicações simples, no entanto não é o mais performático.&lt;/p&gt;

&lt;p&gt;Finalmente, o padrão FastCGI une o que há de melhor do modelo ISAPI (multi thread, cache, inicialização rápida) com a segurança do CGI (processos isolados). Para aplicações que realmente necessitam de performance, esse deve ser o padrão a ser escolhido.&lt;/p&gt;

&lt;p&gt;Servidores Web permitem muitas configurações para o modelo FastCGI como o número de instâncias que ficarão ativas, quando elas serão desativadas por falta de requisições, etc.&lt;/p&gt;

&lt;p&gt;E não pense em apenas servidores Linux. Eu mesmo mantenho algumas aplicações FastCGI em servidores Windows funcionando 24h/dia, sem parar.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O framework fpWeb vem facilitando muito o desenvolvimento Web em aplicações Object Pascal com Free Pascal e Lazarus.&lt;/p&gt;

&lt;p&gt;É um framework simples, bem testado e utilizado em produção a muitos anos pela comunidade.&lt;/p&gt;

&lt;p&gt;Com o uso de diretivas de compilação fica fácil alternar entre modelos de aplicações, facilitando muito o desenvolvimento e depuração do código.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 May 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpweb</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpweb</guid>
      </item>
    
      <item>
        <title>Encapsulamento</title>
        <description>&lt;p&gt;O Encapsulamento é um dos pilares da Orientação a Objetos. Mas você sabe o que realmente significa esse conceito?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-erwan-hesry-166245-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Erwan Hesry on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;De acordo com o dicionário, Encapsulamento significa: colocar ou encerrar em cápsula; capsular.&lt;/p&gt;

&lt;p&gt;Uma cápsula não pode — ou não deveria — ser quebrada. O mundo externo ao objeto não pode saber o que há em seu interior a menos que o objeto queira lhes dizer “com suas próprias palavras”, ou seja, através de métodos que retornam informações mas não necessariamente seu &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O mundo externo só deve conhecer os métodos públicos de um objeto. Seus métodos públicos representam sua Interface para fazer o que ele deve fazer. Qualquer método ou atributo interno ao objeto é de propriedade dele e de mais ninguém.&lt;/p&gt;

&lt;p&gt;Atributos e &lt;a href=&quot;/eliminando-metodos-privados&quot;&gt;métodos privados&lt;/a&gt; estão encapsulados no objeto e nunca deveriam ser acessados externamente.&lt;/p&gt;

&lt;p&gt;Essa é a teoria.&lt;/p&gt;

&lt;h2 id=&quot;codigo&quot;&gt;Encapsulamento pelo Código&lt;/h2&gt;

&lt;p&gt;Toda a &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt; é sobre encapsulamento e envio de mensagens.&lt;/p&gt;

&lt;p&gt;Infelizmente, ambos os conceitos não são implementados perfeitamente em Object Pascal ou em nenhuma outra linguagem &lt;i&gt;mainstream&lt;/i&gt; do mercado como Java e C#.&lt;/p&gt;

&lt;p&gt;E isso gera muitas dúvidas.&lt;/p&gt;

&lt;p&gt;Vamos falar sobre Encapsulamento e tentar expandir nossas mentes além do código, além dos conceitos pré-concebidos e do básico.&lt;/p&gt;

&lt;p&gt;O que é estar encapsulado? Essa pergunta parece tola, mas veremos que depende do ponto de vista do observador para respondê-la.&lt;/p&gt;

&lt;p&gt;Por exemplo. Um atributo privado está encapsulado no objeto e não pode ser acessado pelo mundo externo, certo?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFoo = class
  private
     FValue: Integer;
  public
     function GetValue: Integer;
  end;

function TFoo.GetValue: Integer;
begin
  Result := FValue;
end;

procedure TMainForm.ExecButton(Sender: TObject);
var
  F: TFoo;
begin
  F := TFoo.Create;
  ShowMessage(F.GetValue.ToString);
  F.Free;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, o mundo externo representado pela instância de  &lt;code&gt;TMainForm&lt;/code&gt; consegue acessar o atributo privado da instância da classe &lt;code&gt;TFoo&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Não, você diria.&lt;/p&gt;

&lt;p&gt;O atributo privado está sendo acessado por um método público que o “protege”. Além disso, como o atributo é &lt;a href=&quot;/posts/tipos-primitivos-nos-argumentos/&quot;&gt;primitivo&lt;/a&gt;, ele não é passado por referência. Então, o mundo externo não pode nem mesmo alterá-lo.&lt;/p&gt;

&lt;p&gt;Está correto.&lt;/p&gt;

&lt;p&gt;Então, vamos alterar um pouco o código.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFoo = class
  private
     FValue: TDataValue;
  public
     function GetValue: TDataValue;
  end;

function TFoo.GetValue: TDataValue;
begin
  Result := FValue;
end;

procedure TMainForm.ExecButton(Sender: TObject);
var
  F: TFoo;
begin
  F := TFoo.Create;
  F.GetValue.Free;
  F.Free;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora &lt;code&gt;GetValue&lt;/code&gt; retorna uma instância de objeto.&lt;/p&gt;

&lt;p&gt;É possível criar o objeto &lt;code&gt;F&lt;/code&gt;, acessar (indiretamente) seu atributo privado e destruí-lo chamando &lt;code&gt;Free&lt;/code&gt;, pois&lt;code&gt;GetValue&lt;/code&gt; retornar a referência direta do atributo.&lt;/p&gt;

&lt;p&gt;Ora, o atributo não é público! Não temos um &lt;a href=&quot;/posts/getters-e-setters/&quot;&gt;setter&lt;/a&gt; para ele e, mesmo assim, o “mundo externo” consegue destruí-lo? Ele não deveria ser intocável externamente?&lt;/p&gt;

&lt;p&gt;Vejamos agora:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFoo = class
  public
     Value: TDataValue;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nessa versão a classe &lt;code&gt;TFoo&lt;/code&gt; tem um atributo público &lt;code&gt;Value&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se o mundo externo acessar esse atributo, estaríamos quebrando o encapsulamento do objeto?&lt;/p&gt;

&lt;p&gt;Na verdade, não.&lt;/p&gt;

&lt;p&gt;Não há nada encapsulado no objeto e, portanto, por definição não há nenhuma quebra de encapsulamento!&lt;/p&gt;

&lt;p&gt;Talvez a linguagem não devesse permitir que atributos fossem públicos, mas esse seria um debate para outro artigo.&lt;/p&gt;

&lt;p&gt;Quer outro exemplo? Imagine que &lt;code&gt;GetValue&lt;/code&gt; agora é &lt;i&gt;privado&lt;/i&gt;. Imagine uma outra classe chamada &lt;code&gt;TBar&lt;/code&gt; com essa definição:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TDataValueFunc = function: TDataValue of object; 

  TBar = class
  private
     FFunc: TDataValueFunc;
  public
     constructor Create(Func: TDataValueFunc);
     function Data: TDataValue;
  end;

function TBar.Data: TDataValue;
begin
  Result := FFunc;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E o (novo) construtor de &lt;code&gt;TFoo&lt;/code&gt; seria assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;constructor TFoo.Create;
begin
  FBar := TBar.Create(@GetValue);
  FBar.Data;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Não estaria &lt;code&gt;TBar.Data&lt;/code&gt; executando um código privado de &lt;code&gt;TFoo&lt;/code&gt;, mesmo que indiretamente? Um objeto “acessando” um método privado de outro objeto. Seria essa uma quebra de encapsulamento?&lt;/p&gt;

&lt;p&gt;O que eu estou tentando lhe mostrar é que não é apenas o código puramente técnico que irá definir um bom nível de encapsulamento no seu projeto.&lt;/p&gt;

&lt;p&gt;É necessário que você pense em encapsulamento no nível de design do projeto e não apenas na implementação técnica das classes.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Vimos que a linguagem Object Pascal permite-nos acessar atributos e 
métodos privados, mesmo que indiretamente.&lt;/p&gt;

&lt;p&gt;O mesmo pode ser feito em outras linguagens consideradas “mais” Orientadas a Objetos.&lt;/p&gt;

&lt;p&gt;Então, discutir sobre encapsulamento no nível puramente técnico da linguagem é perda de tempo. Seria muito difícil — mas não impossível — implementar um código onde todos os atributos privados não fossem acessados, de alguma maneira, pelo mundo externo sem perder performance ou complicar o modelo de classes apenas para afirmar que os atributos estão protegidos e intocados.&lt;/p&gt;

&lt;p&gt;No mundo real, sistemas devem ter boa performance e serem simples de manutenção.&lt;/p&gt;

&lt;p&gt;É melhor quebrar algumas regras e deixar as coisas &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; do que ser purista e não ter nenhum benefício real.&lt;/p&gt;

&lt;p&gt;Finalmente, o conceito de Encapsulamento na Orientação Objetos é mais sobre como projetar a comunicação entre os objetos e módulos utilizando o mínimo necessário ao invés de se preocupar unicamente com a sintaxe utilizada.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 16 Apr 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/encapsulamento</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/encapsulamento</guid>
      </item>
    
      <item>
        <title>Classes Amigas</title>
        <description>&lt;p&gt;Classes Amigas tem acesso ao estado (privado) de seus objetos. Apesar dessa prática ser entendida por muitos desenvolvedores como uma quebra do encapsulamento, na verdade ela pode até aprimorá-lo.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-ben-white-178537-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Ben White on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Classes Amigas existem na linguagem C++ a muito tempo, assim como na linguagem Object Pascal.&lt;/p&gt;

&lt;p&gt;Enquanto na linguagem C++ é necessária uma sintaxe específica, em Object Pascal basta declararmos as classes na mesma unit para que elas sejam “amigas”. E não importa se elas fazem parte ou não de uma hierarquia de herança.&lt;/p&gt;

&lt;p&gt;Eu conheço alguns desenvolvedores que não lidam muito bem com isso. Para eles, o que é privado nunca deveria ser acessado por outra instância além do próprio objeto.&lt;/p&gt;

&lt;p&gt;Eles estão certos.&lt;/p&gt;

&lt;p&gt;Mas essa é uma regra geral. Precisamos saber quando “quebrar” as regras, se isso for aumentar a &lt;i&gt;qualidade&lt;/i&gt; do software.&lt;/p&gt;

&lt;p&gt;Eu também fui contra a essa &lt;i&gt;feature by design&lt;/i&gt; por muito tempo. A muitos anos atrás eu declarava as classes em units separadas, mesmo que seus objetos existissem apenas para “conversar” entre si, ou seja, mesmo que tais objetos fossem bem “íntimos”.&lt;/p&gt;

&lt;p&gt;A fim de seguir a “regra de ouro” do encapsulamento, eu declarava tais classes em units separadas pensando que eu estava desenvolvendo mais Orientado a Objetos &lt;i&gt;protegendo&lt;/i&gt; seus estados.&lt;/p&gt;

&lt;p&gt;Mas, ao mesmo tempo, eu declarava as propriedades de acesso — também conhecidos com &lt;a href=&quot;/posts/getters-e-setters/&quot;&gt;Get/Set&lt;/a&gt; — para que o estado desses objetos pudessem ser acessados por alguma instância de &lt;i&gt;fora&lt;/i&gt;!&lt;/p&gt;

&lt;p&gt;E isso não faz sentido.&lt;/p&gt;

&lt;p&gt;Eu estava escrevendo e complicando mais o código, sem ganhar nenhum benefício, já que toda essa “proteção”, na verdade, não existia.&lt;/p&gt;

&lt;p&gt;Então, eu voltei a rever esse conceito das Classes Amigas.&lt;/p&gt;

&lt;p&gt;Eu diria que Classes Amigas enfraquecem o encapsulamento local (na unit) afim de &lt;i&gt;fortalecer&lt;/i&gt; o encapsulamento global (por todo o projeto).&lt;/p&gt;

&lt;p&gt;Ainda assim, é claro, isso irá depender de alguns fatores. Utilizá-las é mais uma exceção à regra e deve ser muito bem pensado afim de obter mais prós do que contras.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo: Imagine que você tem uma classe que representa um livro. Na interface da classe desse livro nós só queremos ter o básico que, no nosso exemplo, irá conter métodos para retornar o título, autor e ISBN.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IBook = interface
    function Title: string;
    function Author: string;
    function ISBN: string;
  end;
  
  TBook = class(TInterfacedObject, IBook)
  private
    FDoc: IXMLDocument;
  public
    constructor Create(const Doc: IXMLDocument);
    function Title: string;
    function Author: string;
    function ISBN: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Temos uma interface &lt;code&gt;IBook&lt;/code&gt; e também uma classe que a implementa.&lt;/p&gt;

&lt;p&gt;O código é bem simples e de fácil entendimento.&lt;/p&gt;

&lt;p&gt;A classe &lt;code&gt;TBook&lt;/code&gt; recebe uma instância de &lt;code&gt;IXMLDocument&lt;/code&gt; proveniente de algum lugar. Não importa.&lt;/p&gt;

&lt;p&gt;Esse objeto XML possui toda a informação referente a um livro.&lt;/p&gt;

&lt;p&gt;Hoje, apenas os 3 atributos estariam contidos no XML mas tenha em mente que ele pode ser alterado. Poderíamos adicionar mais nós de informação futuramente, se assim o desejarmos.&lt;/p&gt;

&lt;p&gt;Internamente a classe &lt;code&gt;TBook&lt;/code&gt; irá fazer o parser do XML, retornando suas informações através dos respectivos métodos.&lt;/p&gt;

&lt;p&gt;Imaginemos que tudo funciona bem por meses e muitas outras classes podem ter implementado a mesma interface &lt;code&gt;IBook&lt;/code&gt;. Por exemplo, &lt;code&gt;TDbBook&lt;/code&gt;, &lt;code&gt;TEmptyBook&lt;/code&gt;, &lt;code&gt;TNullBook&lt;/code&gt;, &lt;code&gt;TJSONBook&lt;/code&gt;, &lt;code&gt;TXMLBook&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;Então, uma nova regra de negócio é solicitada: é necessário saber o &lt;i&gt;título original&lt;/i&gt; e o &lt;i&gt;ano de publicação&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;Se alterarmos a interface atual, teremos que implementar os novos métodos em todas as classes que a implementam. Isso é bastante trabalho e pode não ser uma boa ideia.&lt;/p&gt;

&lt;p&gt;Outra opção é implementar uma nova classe, especializando &lt;code&gt;IXMLDocument&lt;/code&gt; como uma interface para ser implementada por uma &lt;a href=&quot;/posts/classes-de-dados/&quot;&gt;classe de dados&lt;/a&gt;. Por exemplo, &lt;code&gt;IBookData&lt;/code&gt;. Todo o código de parser que antes estava contido em &lt;code&gt;TBook&lt;/code&gt;, deverá ser migrado para a nova classe, refatorando não só &lt;code&gt;TBook&lt;/code&gt; mas também todas as outras implementações de &lt;code&gt;IBook&lt;/code&gt; que, porventura, tenham o construtor parecido. Isso também é bastante trabalho, talvez mais trabalho do que a primeira opção.&lt;/p&gt;

&lt;p&gt;A outra opção (mas pode haver muitas) é utilizar Classes Amigas criando apenas o necessário sem alterar nenhuma outra classe, escrevendo menos e de forma mais simples.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  ICompletedBook = interface(IBook)
    function OriginalTitle: string;
    function Year: Integer;
  end;
  
  TCompletedBook = class(TBook, ICompletedBook)
  public
    function OriginalTitle: string;
    function Year: Integer;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora temos uma nova interface e uma nova classe que a implementa. Ambos utilizando &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;, pois ambas são muito íntimas dos seus predecessores.&lt;/p&gt;

&lt;p&gt;Dentro dos métodos da classe &lt;code&gt;TCompletedBook&lt;/code&gt;, será necessário ter acesso ao atributo privado de &lt;code&gt;TBook&lt;/code&gt; denominado &lt;code&gt;FDoc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Entretanto, se ambas as classes são amigas, ou seja, declaradas na mesma unit, não haverá problemas para fazer isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  function TCompletedBook.OriginalTitle: string;
  begin
    Result := FDoc.Node(&#39;original-title&#39;).AsString;
  end;

  function TCompletedBook.Year: Integer;
  begin
    Result := FDoc.Node(&#39;year&#39;).AsInteger;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O atributo &lt;code&gt;FDoc&lt;/code&gt; é acessível, mesmo sendo privado.&lt;/p&gt;

&lt;p&gt;Você poderia pensar em alterar a visibilidade desse atributo para &lt;code&gt;protected&lt;/code&gt; e deixar que até mesmo o código de outros usuários possam herdar de &lt;code&gt;TBook&lt;/code&gt;, mas isso seria um erro.&lt;/p&gt;

&lt;p&gt;Ao tornar os atributos acessíveis para qualquer classe, você &lt;i&gt;enfraquece&lt;/i&gt; o encapsulamento global e pode perder o controle do código. Seria muito mais difícil fazer alguma alteração em &lt;code&gt;TBook&lt;/code&gt; pois não há como saber, com certeza, quem está utilizando os atributos privados.&lt;/p&gt;

&lt;p&gt;Finalmente, ao utilizar o modelo de Classes Amigas, você sabe quais classes deverão ser alteradas se houver alguma refatoração, pois todas elas estarão declaradas na mesma unit, obrigatoriamente.&lt;/p&gt;

&lt;p&gt;Suas classes serão &lt;a href=&quot;/posts/menos-e-mais/&quot;&gt;menores&lt;/a&gt; e mais simples.&lt;/p&gt;

&lt;p&gt;Há seres humanos que são mais ligados intimamente a uns do que outros — mesmo todos sendo provenientes da mesma “classe” — que sabem seus gostos, desejos e segredos mais íntimos.&lt;/p&gt;

&lt;p&gt;A mesma lógica pode também ser aplicada a apenas algumas classes onde seus objetos são mais amigos, concedendo acesso irrestrito uns aos outros, mas bloqueando esse acesso ao mundo exterior.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Apr 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/classes-amigas</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/classes-amigas</guid>
      </item>
    
      <item>
        <title>A Declaração WITH-DO Perfeita</title>
        <description>&lt;p&gt;A utilização do WITH-DO pode deixar o código mais simples de ler, pois haverá menos declarações, atribuições e inicializações de variáveis. No entanto, a sintaxe atual não é perfeita. Dependendo do seu uso, o benefício pode ser o inverso.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-alex-wong-17993-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Alex wong on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A declaração WITH-DO &lt;a href=&quot;/posts/a-declaracao-with-do-e-do-mal/&quot;&gt;pode ser utilizada&lt;/a&gt; mas sua sintaxe não é perfeita.&lt;/p&gt;

&lt;p&gt;Vai depender muito do design do seu código para que você possa utilizar o WITH-DO sem problemas.&lt;/p&gt;

&lt;p&gt;Por exemplo. Classes com muitos atributos ou métodos poderá aumentar a probabilidade de haver alguma &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;colisão de nomes&lt;/a&gt; entre outras classes e/ou variáveis locais.&lt;/p&gt;

&lt;p&gt;Esse artigo é a minha proposta para melhorar a sintaxe do WITH-DO nos compiladores Object Pascal.&lt;/p&gt;

&lt;h2 id=&quot;sintaxe&quot;&gt;A Sintaxe Perfeita&lt;/h2&gt;

&lt;p&gt;O grande problema ao utilizarmos WITH-DO é a ambiguidade que ele pode trazer ao código.&lt;/p&gt;

&lt;p&gt;Considere o código abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
   TFoo = class
      X: Integer;
   end;

procedure Execute;
var
  X: Integer;
begin
  with TFoo.Create do
  try
     X := 10;
  finally
     Free;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A linha &lt;code&gt;X := 10;&lt;/code&gt; atribui 10 ao atributo de &lt;code&gt;TFoo&lt;/code&gt; ou a variável local &lt;code&gt;X&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Outro problema é o seguinte: se renomearmos &lt;code&gt;TFoo.X&lt;/code&gt; para &lt;code&gt;TFoo.Z&lt;/code&gt; poderíamos esperar um erro de compilação, no entanto o código iria continuar funcionando devido ao compilador localizar o identificador &lt;code&gt;X&lt;/code&gt; como uma variável local.&lt;/p&gt;

&lt;p&gt;A ambiguidade pode ser ainda maior quando utilizamos múltiplas instancias na declaração WITH-DO, como a seguir:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with TFoo.Create, TBar.Create do
try
  X := 10;
  Z := 20;
finally
  Free; // belongs to TFoo or TBar?
  Free; // belongs to TFoo or TBar?
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse são apenas alguns casos do uso irrestrito do WITH-DO. E, por essas e outras razões, que muitos desenvolvedores consideram o WITH-DO um mal no código.&lt;/p&gt;

&lt;p&gt;No entanto, o que não está correto não é seu uso, mas sua sintaxe.&lt;/p&gt;

&lt;p&gt;Na minha opinião, seria muito melhor se a sintaxe fosse algo parecido com o exemplo abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  with F =: TFoo.New, B =: TBar.New do
  begin
    F.Execute;
    B.Execute;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No código acima não há variáveis declaradas explicitamente, no entanto as instâncias são referenciadas por algum tipo de &lt;i&gt;alias&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;Afim de diferenciar essa nova sintaxe, para não haver ambiguidades com a sintaxe já existente de atribuição, escolhi utilizar uma “atribuição invertida” neste formato “&lt;code&gt;=:&lt;/code&gt;”.&lt;/p&gt;

&lt;p&gt;Alguns puristas do Pascal iriam dizer que o código acima não é muito “Pascalish” por quê tudo no Pascal deve ser explicitamente declarado antes e, neste caso, as variáveis não foram declaradas previamente. Eu concordo. Porém acho que deveríamos considerar essa exceção.&lt;/p&gt;

&lt;p&gt;A sintaxe para a captura de exceções, por exemplo, tem (quase) a &lt;i&gt;mesma&lt;/i&gt; sintaxe proposta qui e todos convivem bem com isso.&lt;/p&gt;

&lt;p&gt;Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
var
  X: Integer;
begin
  try
     X := 10 / 0;
  except
    on E: EDivByZero do
       ShowMessage(E.Message);
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A variável &lt;code&gt;E&lt;/code&gt; não foi previamente declarada na seção de variáveis locais. Isso vai contra a filosofia Pascal, onde devemos declarar tudo antes de utilizar. Mas, tudo bem. Essa é uma exceção a regra que é bem vinda.&lt;/p&gt;

&lt;p&gt;Voltando ao primeiro exemplo, você pode ter sentido falta às chamadas aos destrutores das instâncias. Bem, eu utilizei a &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;função New&lt;/a&gt; justamente para não haver essa necessidade — considerando que esses métodos retornam uma instância de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;interface&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mas se você não quiser utilizar essa técnica, basta reescrever assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with F =: TFoo.Create, B =: TBar.Create do
try
  F.Execute;
  B.Execute;
finally
  F.Free;
  B.Free;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Na linguagem C# eles tem a declaração &lt;code&gt;using&lt;/code&gt; que é bem parecido com o que estou propondo — a criação de &lt;i&gt;alias&lt;/i&gt; para as instâncias. No entanto, lá o objetivo é o compilador chamar o método &lt;code&gt;Dispose&lt;/code&gt; de cada instância no fim do bloco, independentemente se houver ou não uma exceção. Para que essa “mágica” aconteça, a instância deve implementar a interface &lt;code&gt;IDisposable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Eu acho essa abordagem desnecessária para o Pascal — no entanto, possível — pois o código fica mais explicito com o uso do &lt;code&gt;try-finally&lt;/code&gt; se você não estiver utilizando instâncias de interfaces.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Acredito que o uso de WITH-DO proposto aqui iria nos ajudar a implementar um código mais simples.&lt;/p&gt;

&lt;p&gt;A nova sintaxe com a atribuição invertida não iria entrar em conflito com a sintaxe atual.&lt;/p&gt;

&lt;p&gt;Poderíamos criar blocos de código independentes dentro de métodos. Visto que, no exemplos acima, as variáveis &lt;code&gt;F&lt;/code&gt; e &lt;code&gt;B&lt;/code&gt; só poderiam ser utilizadas dentro do WITH-DO e não em todo o escopo do método.&lt;/p&gt;

&lt;p&gt;Só iríamos declarar variáveis “globais ao método” na sessão de variáveis locais ao método, mas todas as outras instâncias seriam inicializadas em blocos WITH-DO para restringir ainda mais o escopo e visibilidade às variáveis.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/a-declaracao-with-do-perfeita</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/a-declaracao-with-do-perfeita</guid>
      </item>
    
      <item>
        <title>A função Supports pode ser traiçoeira</title>
        <description>&lt;p&gt;Quando você se acostuma a utilizar somente instancias de interfaces, pode ser difícil entender alguns erros em tempo de execução, utilizando instâncias de classes com suporte a interfaces.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-michal-parzuchowski-224092-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Michał Parzuchowski on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Você pode desenvolver seu projeto do zero, utilizando apenas &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;instâncias de interfaces&lt;/a&gt;, e (quase) tudo estará sob seu controle.&lt;/p&gt;

&lt;p&gt;Entretanto, há muitos projetos onde só iremos fazer algum tipo de manutenção. Esses projetos podem não utilizar o conceito de interfaces como explicado em vários artigos desse blog. Nesses casos, é necessário codificar de forma que mantenha o código legado funcionando, ao mesmo tempo que introduzimos boas práticas de &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Em tais projetos, é comum vermos variáveis declaradas como tipo de alguma classe ao invés de alguma interface.&lt;/p&gt;

&lt;p&gt;Isso quer dizer que haverá chamadas aos métodos &lt;code&gt;Free&lt;/code&gt; de cada instância, por todo o código.&lt;/p&gt;

&lt;p&gt;E não há nada de errado com isso. Essa é uma das características da linguagem Object Pascal que a torna muito eficiente para projetos de alta &lt;a href=&quot;/argumentos-const&quot;&gt;performance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, como já foi dito muitas vezes aqui nesse blog, o uso de instâncias de interfaces pode trazer muitos benefícios quando utilizada apropriadamente.&lt;/p&gt;

&lt;p&gt;Os benefícios, entretanto, podem ser ofuscados pelo não funcionamento correto do código ao utilizarmos instâncias de classes junto com interfaces.&lt;/p&gt;

&lt;p&gt;Veja o código abaixo e, antes de compilar e executar o programa no seu computador, tente descobrir se há algo errado:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program Project1;

uses
  SysUtils;

type
  IBar = interface
  [&#39;{C22FB8F4-1EC6-42C4-81E4-F2A52CC52258}&#39;]
  end;

  TBar = class(TInterfacedObject, IBar)
  end;

var
  Bar: TBar;
begin
  Bar := TBar.Create;
  try
    if Supports(Bar, IBar) then
      Writeln(&#39;Bar supports...&#39;);
  finally
    Bar.Free;
  end;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código compila?&lt;/p&gt;

&lt;p&gt;O código possui &lt;i&gt;memory leaks&lt;/i&gt;?&lt;/p&gt;

&lt;p&gt;O código irá lançar algum &lt;i&gt;Access Violation&lt;/i&gt; (AV)?&lt;/p&gt;

&lt;p&gt;Pense por um minuto…&lt;/p&gt;

&lt;p&gt;Bem, eu posso lhe afirmar que o código compila sem erros mas há um grande problema de &lt;i&gt;design&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;A lógica geral está correta. Temos uma instância de classe chamada &lt;code&gt;Bar&lt;/code&gt;; depois, checamos se essa instância suporta ou implementa a interface &lt;code&gt;IBar&lt;/code&gt; utilizando a função &lt;code&gt;Supports()&lt;/code&gt; da &lt;code&gt;SysUtils&lt;/code&gt;; então, imprimimos algo na tela em caso afirmativo; finalmente, a instância &lt;i&gt;deveria&lt;/i&gt; ser destruída utilizando &lt;code&gt;Bar.Free&lt;/code&gt;, visto que é uma instância de classe e não de interface. Certo?&lt;/p&gt;

&lt;p&gt;Errado.&lt;/p&gt;

&lt;p&gt;Você irá receber um &lt;i&gt;AV&lt;/i&gt; quando o compilador tentar destruir o objeto na linha &lt;code&gt;Bar.Free&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;E por quê isso ocorre?&lt;/p&gt;

&lt;p&gt;Estamos utilizando uma das implementações da função &lt;code&gt;Supports()&lt;/code&gt; — há alguns &lt;i&gt;overloads&lt;/i&gt; — que retorna apenas um &lt;code&gt;boolean&lt;/code&gt; para dizer ao programa se determinada instância suporta ou não uma determinada interface.&lt;/p&gt;

&lt;p&gt;Ao fazer isso, &lt;code&gt;Supports()&lt;/code&gt; irá obter uma instância de &lt;code&gt;IBar&lt;/code&gt;, extraída da variável &lt;code&gt;Bar&lt;/code&gt;. Isso irá alterar a contagem de referência e após o retorno da função, a instância &lt;code&gt;Bar&lt;/code&gt; será destruída… antes de chegar na linha &lt;code&gt;Bar.Free&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;Na minha opinião, isso é um &lt;i&gt;erro&lt;/i&gt; mesmo sendo &lt;i&gt;&lt;a href=&quot;http://docwiki.embarcadero.com/Libraries/XE2/en/System.SysUtils.Supports&quot;&gt;by design&lt;/a&gt;&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;Delphi e FPC funcionam da mesma forma.&lt;/p&gt;

&lt;p&gt;Então, como consertar o código?&lt;/p&gt;

&lt;p&gt;Basta alterar o tipo da variável para &lt;code&gt;Bar: IBar&lt;/code&gt;. Ao fazer isso, o compilador irá lhe dizer que não é mais necessário chamar &lt;code&gt;Bar.Free&lt;/code&gt;. Remova também essa linha e, consequentemente, a construção &lt;code&gt;try-finally&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  Bar: IBar;
begin
  Bar := TBar.Create;
  if Supports(Bar, IBar) then
    Writeln(&#39;Bar supports...&#39;);
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Após fazer isso, compile e execute novamente o programa.&lt;/p&gt;

&lt;p&gt;Utilizando FPC 3.0.4 com &lt;code&gt;-gl&lt;/code&gt; habilitado, eu vejo a saída abaixo, sem nenhum &lt;i&gt;memory leak&lt;/i&gt; ou erros:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
Bar supports...
Heap dump by heaptrc unit
48 memory blocks allocated : 1189/1296
48 memory blocks freed     : 1189/1296
0 unfreed memory blocks : 0
True heap size : 163840 (80 used in System startup)
True free heap : 163760
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muito cuidado ao utilizar instâncias de classes com suporte a interfaces e contagem de referência.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Mar 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/supports-traicoeira</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/supports-traicoeira</guid>
      </item>
    
      <item>
        <title>Assertions é uma boa prática</title>
        <description>&lt;p&gt;Assertions auxiliam o programador no desenvolvimento e depuração do código, sendo a primeira linha de defesa contra bugs.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-andrew-ruiz-394426-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Andrew Ruiz on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Quando estamos desenvolvendo, é comum executar o programa várias vezes, digitar alguma entrada de dados “falsa”, e seguir adiante, afim de testar outras funcionalidades.&lt;/p&gt;

&lt;p&gt;Assim, vamos construindo um protótipo.&lt;/p&gt;

&lt;p&gt;Um protótipo pode ser codificado muito rapidamente, sendo comum codificarmos várias funcionalidades apenas para visualizarmos como seria o sistema real.&lt;/p&gt;

&lt;p&gt;Como um protótipo pode ser alterado inúmeras vezes, vários bugs podem aparecer.&lt;/p&gt;

&lt;p&gt;Aqui entram as &lt;a href=&quot;https://www.freepascal.org/docs-html/3.0.2/rtl/system/assert.html&quot;&gt;Assertions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;De acordo com a &lt;a href=&quot;https://en.wikipedia.org/wiki/Assertion_(software_development)&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In computer programming, an assertion is a statement that a predicate (Boolean-valued function, i.e. a true–false expression) is expected to always be true at that point in the code. If an assertion evaluates to false at run time, an assertion failure results, which typically causes the program to crash, or to throw an assertion exception.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Então, uma Assertion sempre deve ser verdadeira ou uma exceção &lt;code&gt;EAssertionFailed&lt;/code&gt; será gerada e o sistema será abortado, retornando o código &lt;code&gt;227&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;No entanto, se a unit &lt;code&gt;SysUtils&lt;/code&gt; for declarada em algum lugar do código, é possível verificar mais informações da exceção como a linha e a unit onde o erro foi gerado, além da &lt;i&gt;mensagem&lt;/i&gt; opcional que o desenvolvedor pode utilizar para cada Assertion.&lt;/p&gt;

&lt;p&gt;Uma Assertion funciona dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TForm1.Button1Click(Sender: TObject);
var
  I: Integer;
begin
  I := 0;
  Assert(I = 1, &#39;The I variable is not 1&#39;);
  ShowMessage(I.ToString);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No código acima, temos um &lt;code&gt;Form&lt;/code&gt; com um botão. No evento desse botão o Assert irá verificar se a variável &lt;code&gt;I&lt;/code&gt; é igual a &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O resultado será falso e uma exceção será gerada.&lt;/p&gt;

&lt;p&gt;Na minha IDE eu vejo essa mensagem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The I variable is not 1 (unit1.pas, line 34).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eu compilei o projeto &lt;i&gt;sem&lt;/i&gt; informações de &lt;i&gt;debugger&lt;/i&gt;. Mesmo assim, é possível ver a linha onde a validação ocorreu, tornando muito útil o uso de Assert para identificar onde e por quê um erro ocorreu.&lt;/p&gt;

&lt;p&gt;Entretanto, as Assertions não deve ser utilizadas em produção. Suas informações técnicas só deveriam ser vistas por programadores, não usuários finais.&lt;/p&gt;

&lt;p&gt;Por esse motivo nós &lt;b&gt;devemos&lt;/b&gt; desabilitar as Assertions quando fizermos o &lt;i&gt;deploy&lt;/i&gt; do sistema para o usuário final.&lt;/p&gt;

&lt;p&gt;Para desabilitar Assertions, o compilador tem uma diretiva de compilação global.&lt;/p&gt;

&lt;p&gt;Há duas opções:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ASSERTIONS ON/OFF (long form)
$C +/- (short form)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mas isso pode ser definido diretamente na IDE, na sessão de debugger nas  opções do projeto, sem haver necessidade de escrever uma linha de código.&lt;/p&gt;

&lt;p&gt;Quando as Assertions estão desabilitadas, as verificações não são executadas. Isso libera o sistema de todo &lt;i&gt;overhead&lt;/i&gt; das verificações no produto final.&lt;/p&gt;

&lt;p&gt;Finalmente, Assertions não substituem Testes de Unidade ou Teste de Integração, sendo apenas mais um tipo de ferramenta para testar o código na fase de desenvolvimento.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Mar 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/assertions</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/assertions</guid>
      </item>
    
      <item>
        <title>Construtores Virtuais</title>
        <description>&lt;p&gt;A linguagem Object Pascal possui uma feature que não existe em nenhuma outra linguagem &lt;i&gt;mainstream&lt;/i&gt; do mercado.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-eddie-kopp-264813-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Eddie Kopp on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Construtores Virtuais permitem a criação customizada de novas instâncias sem a necessidade do uso de classes de fábricas.&lt;/p&gt;

&lt;p&gt;É possível que desenvolvedores Object Pascal ao redor do mundo utilizem essa feature diariamente mesmo sem saber que só é possível utilizá-la na linguagem Object Pascal.&lt;/p&gt;

&lt;p&gt;Toda classe possui um ou mais &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt; no qual são responsáveis por instanciar um novo objeto.&lt;/p&gt;

&lt;p&gt;Entretanto, ter um construtor virtual &lt;a href=&quot;https://stackoverflow.com/questions/3651354/in-net-can-a-class-have-virtual-constructor&quot;&gt;não é comum&lt;/a&gt; em outras linguagens.&lt;/p&gt;

&lt;p&gt;Diferentemente das demais linguagens, os construtores na linguagem Object Pascal são como métodos “marcados” para serem construtores. Um fato sobre isso é que, em Object Pascal, podemos dar o nome que quisermos aos construtores — mesmo que o padrão de nomenclatura recomendado e utilizado seja &lt;code&gt;Create&lt;/code&gt; — e como os métodos podem ser &lt;i&gt;virtuais&lt;/i&gt;, assim também são os construtores.&lt;/p&gt;

&lt;p&gt;Mas, qual é a grande vantagem de utilizá-los?&lt;/p&gt;

&lt;h2 id=&quot;construtores&quot;&gt;Construtores Virtuais&lt;/h2&gt;

&lt;p&gt;Na documentação sobre &lt;em&gt;Factory and Repository patterns&lt;/em&gt; do framework &lt;a href=&quot;https://synopse.info/files/html/Synopse%20mORMot%20Framework%20SAD%201.18.html#TITLE_600&quot;&gt;Synopse mORMot&lt;/a&gt; você encontrará o seguinte texto:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In fact, Delphi is ahead of Java or C#, since it allows virtual constructors to be defined. Those virtual constructors are in fact a clean and efficient way of implementing a Factory, and also fulfill SOLID principles, especially the Liskov Substitution Principle: the parent class define an abstract constructor on which you rely, but the implementation will take place in the overridden constructor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No texto acima, eu sugiro apenas alterarmos a palavra “Delphi” por “Object Pascal”, visto que essa é uma feature da linguagem Object Pascal e não apenas da implementação do Delphi.&lt;/p&gt;

&lt;p&gt;Na maioria das linguagens, o padrão Factory é implementado através de métodos (estáticos, abstratos ou virtuais) das classes e não através dos construtores. Esse é um dos motivos para o autor afirmar que o Delphi (Object Pascal) está a frente de C# e Java nesse quesito. Eu concordo.&lt;/p&gt;

&lt;p&gt;Em Object Pascal podemos criar uma fábrica de objetos onde o tipo da classe original é a própria fábrica.&lt;/p&gt;

&lt;p&gt;Pense no modelo clássico implementado em várias linguagens. Por exemplo, teríamos uma entidade principal &lt;code&gt;TFoo&lt;/code&gt; e uma fábrica &lt;code&gt;TFooFactory&lt;/code&gt;,  que retorna classes-filhas da entidade principal. É importante lembrar que &lt;code&gt;TFoo&lt;/code&gt; deveria &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;implementar alguma Interface&lt;/a&gt; relacionada ao domínio, porém isso é irrelevante para o entendimento do problema.&lt;/p&gt;

&lt;p&gt;O código principal iria utilizar a fábrica para ter instâncias de &lt;code&gt;TFoo&lt;/code&gt;. A fábrica, no entanto, poderia retornar instâncias de novas classes-filhas, herdadas de &lt;code&gt;TFoo&lt;/code&gt; e isso seria transparente para o código principal. Essa é uma das features que queremos ao utilizarmos uma fábrica.&lt;/p&gt;

&lt;p&gt;Mas, primeiro teríamos que criar a fábrica para que ela retornasse as instâncias que realmente necessitamos.&lt;/p&gt;

&lt;p&gt;Em Object Pascal não precisamos de uma classe específica para ser a fábrica de objetos. Nós podemos ter variáveis/argumentos do tipo classe e, dessa maneira, podemos passar diretamente a classe que deve ser utilizada para criar a instância; sem intermediários.&lt;/p&gt;

&lt;p&gt;Imagine que temos uma simples library (lib) que soma 2 números. Essa lib tem uma classe &lt;i&gt;default&lt;/i&gt; para fazer a soma, mas ela permite que a classe seja customizada, lembrando muito o &lt;a href=&quot;https://en.wikipedia.org/wiki/Strategy_pattern&quot;&gt;padrão Strategy&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/0294f260c0d44b7c8b7f9a78df7662c1.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No exemplo acima temos a classe &lt;code&gt;TLibCalc&lt;/code&gt; que representa a lib. No construtor podemos customizar a classe que representa o algoritmo da soma, caso contrário a lib irá utilizar a classe &lt;code&gt;TSum&lt;/code&gt; padrão.&lt;/p&gt;

&lt;p&gt;A classe &lt;code&gt;TSum&lt;/code&gt; é simples. Ela soma dois inteiros. Mas repare que seu construtor é &lt;code&gt;virtual&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O próximo passo é criar um programa de teste.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/8589ff42e90b1311aa3f4b5bab2b7d16.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A saída do programa será: &lt;code&gt;Result is 8&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se tudo estiver funcionando por aí, vamos aos próximos passos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;criar nossa própria classe para somar 2 números&lt;/li&gt;
  &lt;li&gt;alterar o programa, customizando a lib&lt;/li&gt;
&lt;/ol&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/e364be559715b056463868d849e681ef.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima foi implementado uma nova classe &lt;code&gt;TMySum&lt;/code&gt; e inicializamos a lib &lt;code&gt;TLibCalc.Create(TMySum);&lt;/code&gt; com essa classe.&lt;/p&gt;

&lt;p&gt;Execute o programa e veja o resultado.&lt;/p&gt;

&lt;p&gt;Não foi necessária nenhuma fábrica. Nenhum “registro de classes” também foi necessário. Implementamos um padrão utilizando apenas classes simples da linguagem.&lt;/p&gt;

&lt;p&gt;Finalmente, a linguagem Object Pascal é tão simples que bastou utilizarmos uma &lt;i&gt;instância de classe&lt;/i&gt; contendo &lt;i&gt;construtores virtuais&lt;/i&gt; para instanciar a classe correta.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Em Object Pascal não é necessário termos fábricas; a classe customizada é a própria fábrica.&lt;/p&gt;

&lt;p&gt;Até onde eu sei, não existe essa feature em nenhuma linguagem &lt;i&gt;mainstream&lt;/i&gt;, apenas em Object Pascal.&lt;/p&gt;

&lt;p&gt;Com essa feature não é necessário criar classes de fábrica apenas para inicializar nossos verdadeiros objetos. Teremos menos classes, menos objetos, menos métodos, menos uso de memória, mais eficiência e &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/construtores-virtuais</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/construtores-virtuais</guid>
      </item>
    
  </channel>
</rss>
