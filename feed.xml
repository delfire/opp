<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Não Culpe o Código Alheio</title>
        <description>&lt;p&gt;Você fez entrevista numa grande empresa e foi contratado como
Desenvolvedor Senior.&lt;/p&gt;

&lt;p&gt;No primeiro dia que lhe dão acesso ao código para corrigir
uma pequena falha, você olha o código e pensa:&lt;/p&gt;

&lt;p&gt;Mas que P#$@[Piiiiii] é essa?!&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1466784828399-9a9921e8bdfd.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;O código é uma &lt;em&gt;bagunça&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Não há divisão lógica entre camadas.&lt;/p&gt;

&lt;p&gt;A equipe diz que o código é Orientado a Objetos, mas não há verdadeiros
&lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tudo parece ser global, pois não parece haver nenhum tipo de
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;Encapsulamento&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;e-agora&quot;&gt;E agora?&lt;/h2&gt;

&lt;p&gt;Normalmente, o primeiro sentimento é culpar o último
programador que trabalhou no código.&lt;/p&gt;

&lt;p&gt;Você pensa:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Eu não faria assim!”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“O que estávam pensando quando codificaram isso aqui?”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Será que alguém aqui sabe o que é normalização das tabelas,
padronição do código, separação de camadas, responsabilidade
única…?”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Culpar é &lt;em&gt;fácil&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Culpar sem nem ao menos saber o histórico do projeto, as 
motivações envolvidas e os responsáveis pelo projeto é ainda
mais fácil.&lt;/p&gt;

&lt;p&gt;Mas, não cometa essa &lt;em&gt;injustiça&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Não pense que somente o último programador é o &lt;em&gt;total&lt;/em&gt; responsável
por toda essa bagunça, pois tem grandes chances dele apenas 
ter seguindo ordens!&lt;/p&gt;

&lt;p&gt;Sim, é verdade.&lt;/p&gt;

&lt;p&gt;Claro que isso não exime os programadores da culpa.&lt;/p&gt;

&lt;h2 id=&quot;voce-tambem-e-culpado&quot;&gt;Você também é culpado&lt;/h2&gt;

&lt;p&gt;Se &lt;em&gt;você&lt;/em&gt; constrói algo, também é &lt;em&gt;responsabilidade&lt;/em&gt; sua que seja 
feito da forma &lt;em&gt;correta&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se você não concorda com a atitude de seus superiores, procure
outro emprego.&lt;/p&gt;

&lt;p&gt;É isso aí! Esse é o correto a se fazer.&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;pt&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;@ job interview:&lt;br /&gt;- We need responsible people. Are you of the kind?&lt;br /&gt;- Absolutely. At my last gig I was always responsible when shit happened&lt;/p&gt;&amp;mdash; Bruno Borges (@brunoborges) &lt;a href=&quot;https://twitter.com/brunoborges/status/792277126695096320&quot;&gt;29 de outubro de 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;Mas infelizmente a vida não é fácil.
E para a maioria das pessoas, a vida pode ser &lt;em&gt;extremamente&lt;/em&gt; difícil.&lt;/p&gt;

&lt;p&gt;Procurar outro emprego demanda tempo. Então a maioria “vai levando a vida”.
Vai “empurrando pra frente” até onde der pra chegar.
E essa atitude impacta diretamente nos projetos que essas 
pessoas estão envolvidas.&lt;/p&gt;

&lt;p&gt;Muitas vezes esses programadores até tentam fazer o certo,
mas gerentes de projetos inexperientes dizem para fazer de 
outra maneira:&lt;/p&gt;

&lt;p&gt;Mais &lt;em&gt;rápido&lt;/em&gt;, mais &lt;em&gt;barato&lt;/em&gt;, mais… sem lógica! Mais um projeto 
que irá &lt;em&gt;fracassar&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;E isso é extremamente desmotivamente.&lt;/p&gt;

&lt;p&gt;Então, quando tudo já está uma bagunça e você não tem voz
de decisão para fazer o certo… nada mais importa.&lt;/p&gt;

&lt;p&gt;E assim o código vira uma bagunça.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Quando chegar numa nova empresa, assuma o código.&lt;/p&gt;

&lt;p&gt;Diga que precisa de um tempo para entender tudo.&lt;/p&gt;

&lt;p&gt;Não aponte culpados. Ao invés disso, mostre à empresa algumas &lt;em&gt;soluções&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;E quando alguém apontar um erro no código, não diga que a culpa não é sua 
só porque o código já estava ali antes de você chegar.&lt;/p&gt;

&lt;p&gt;Se você &lt;em&gt;assumiu&lt;/em&gt; o código, agora ele é &lt;em&gt;seu&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/nao-culpe-o-codigo-alheio/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/nao-culpe-o-codigo-alheio/</guid>
      </item>
    
      <item>
        <title>Unidades Limítrofes</title>
        <description>&lt;p&gt;A maioria dos sistemas utilizam componentes ou &lt;em&gt;libraries&lt;/em&gt;
de terceiros. Seria perda de tempo codificar cada peça de 
código específica e necessária ao total funcionamento do 
sistema, já que existem ótimas opções mundo afora, que já fazem 
o trabalho específico que queremos implementar.&lt;/p&gt;

&lt;p&gt;Mas é prudente utilizar tais &lt;em&gt;peças de código&lt;/em&gt; sem nos 
preocuparmos sobre a manutenibilidade, dependências e 
encapsulamento?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1465447142348-e9952c393450.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Utilizar grupos de &lt;em&gt;componentes&lt;/em&gt; ou &lt;em&gt;libraries&lt;/em&gt; de terceiros 
com funcionalidades diversas é ótimo, pois nos fazem ganhar 
tempo na codificação.&lt;/p&gt;

&lt;p&gt;Vou me referir a ambos os grupos como &lt;strong&gt;peças de código&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Muitas peças já estão prontas para uso. Sejam elas &lt;em&gt;Open Source&lt;/em&gt;
ou comercial, não importa.&lt;/p&gt;

&lt;p&gt;Cada uma dessas peças foram projetadas e codificadas utilizando
estilos e paradigmas diferentes. Cada projeto utilizou um &lt;em&gt;caminho&lt;/em&gt;
diferente para implementar e resolver o problema que motivou o
desenvolvimento da peça.&lt;/p&gt;

&lt;p&gt;Não há um único caminho certo a percorrer, porém uns são menos 
difícies que outros.&lt;/p&gt;

&lt;p&gt;Seu projeto tem seu próprio caminho e &lt;em&gt;estilo&lt;/em&gt; — ou o estilo da
empresa na qual você trabalha. Isso &lt;em&gt;precisa&lt;/em&gt; ser respeitado.&lt;/p&gt;

&lt;p&gt;Todas as peças intercambiáveis no seu projeto, que são utilizadas em 
muitas camadas comuns, devem seguir o mesmo estilo de codificação.&lt;/p&gt;

&lt;p&gt;Esse artigo irá ressaltar os &lt;em&gt;cuidados&lt;/em&gt; que devemos tomar ao utilizarmos
peças que não foram “feitas em casa” dentro dos nossos projetos.&lt;/p&gt;

&lt;h2 id=&quot;encapsulamento&quot;&gt;Encapsulamento&lt;/h2&gt;
&lt;p&gt;Um dos pilares da Orientação a Objetos é o
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;Encapsulamento&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Não estou me referindo apenas ao Encapsulamento que as Classes podem 
promover, mas sim a qualquer tipo de &lt;em&gt;cápsula&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Uma Função ou Método encapsula variáveis.&lt;/p&gt;

&lt;p&gt;Classes encasulam Estado e Comportamento.&lt;/p&gt;

&lt;p&gt;Unidades (módulos) encapsulam um conjunto de Classes que 
implementam as Regras de Negócio do nosso sistema.&lt;/p&gt;

&lt;p&gt;Unidades também podem encapsular todo um conjunto de peças de 
terceiros, para facilitar ou &lt;em&gt;adaptar&lt;/em&gt; o uso das mesmas dentro 
do nosso projeto.&lt;/p&gt;

&lt;p&gt;Essas Unidades são chamadas de &lt;em&gt;Unidades Limítrofes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo. Imagine um sistema para controlar um Hotel. Eu não conheço
tais Regras de Negócio, mas você pode imaginar cadastros, controle de
preços, quartos vagos, quartos ocupados e muitas outras.&lt;/p&gt;

&lt;p&gt;Nesse mesmo sistema, no entanto, você necessita de uma conexão HTTP, para
enviar arquivos, baixar uma nova versão do próprio sistema, atualizar
dados, etc.&lt;/p&gt;

&lt;p&gt;O protocolo HTTP não faz parte das Regras de Negócio, concorda?&lt;/p&gt;

&lt;p&gt;Não precisamos desenvolver Classes para fazer essa comunicação. Já temos
isso pronto na Internet, sendo a maioria &lt;em&gt;Open Source&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ótimo, vamos baixar um componente ou &lt;em&gt;library&lt;/em&gt; e pronto!&lt;/p&gt;

&lt;p&gt;Aqui eu alerto para um problema: &lt;strong&gt;Dependência&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Quando você adiciona um código de terceiro ao seu projeto, automaticamente
você fica &lt;em&gt;dependende&lt;/em&gt; desse código.&lt;/p&gt;

&lt;h2 id=&quot;componentes-de-terceiros&quot;&gt;Componentes de terceiros&lt;/h2&gt;

&lt;p&gt;Existem algumas ótimas opções de implementação do protocolo HTTP 
em Object Pascal. Mas, mesmo que a opção seja ótima e muitos usuários
já utilizam, não quer dizer que o componente terá um ótimo suporte, 
que sempre estará sendo atualizado ou que o mantenedor nunca irá desistir
do projeto.&lt;/p&gt;

&lt;p&gt;Pelo contrário. Você já deve ter visto componentes “morrerem” porque
o mantenedor não quer mais atualizar ou porque não faz mais sentido
em continuar o projeto, caso tenha outras opções melhores.&lt;/p&gt;

&lt;p&gt;E aí, o que fazer?&lt;/p&gt;

&lt;p&gt;Se o seu código utiliza tal componente em inúmeros lugares, você está 
com um grande problema nas mãos.&lt;/p&gt;

&lt;p&gt;Você não encapsulou essa tecnologia (HTTP) e agora há Unidades de
terceiros por todo o seu projeto, utilizando dezenas de Classes,
constantes e variáveis.&lt;/p&gt;

&lt;p&gt;Se você, no entanto, utilizasse apropriadamente as &lt;strong&gt;Unidades Limítrofes&lt;/strong&gt;,
encapsulando tudo relacionado a HTTP em Módulos a parte, não teria esse 
tipo de problema.&lt;/p&gt;

&lt;h2 id=&quot;unidades-limitrofes&quot;&gt;Unidades Limítrofes&lt;/h2&gt;

&lt;p&gt;Límitrofe &lt;a href=&quot;https://pt.wiktionary.org/wiki/lim%C3%ADtrofe&quot;&gt;significa&lt;/a&gt;
“&lt;em&gt;que se situa ou que vive nos limites de uma extensão, 
de uma região etc.; que tem limites comuns&lt;/em&gt;”.&lt;/p&gt;

&lt;p&gt;A fronteira entre dois sistemas ou módulos. O limite entre Contextos.&lt;/p&gt;

&lt;p&gt;Sempre que possível, temos que encapsular &lt;em&gt;todas&lt;/em&gt; as peças que
não tem relação &lt;em&gt;direta&lt;/em&gt; com as Regras de Negócio do seu sistema.&lt;/p&gt;

&lt;p&gt;A maneira de fazer isso é implementar novas Unidades no seu projeto
apenas para adaptar as peças de terceiros que serão utilizadas.&lt;/p&gt;

&lt;p&gt;Há duas opções quando você for implementar essas novas Unidades. Essas
opções também podem trabalhar em conjunto. São elas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Redefinição de tipos&lt;/li&gt;
  &lt;li&gt;Definição de novas Interfaces e Classes&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;redefinicao-de-tipos&quot;&gt;Redefinição de Tipos&lt;/h2&gt;

&lt;p&gt;Redefinir ou renomear um tipo é algo trivial no Object Pascal.&lt;/p&gt;

&lt;p&gt;Imagine que você baixou um componente para comunicação HTTP. 
A Unidade que contém a Classe que você quer utilizar chama-se
&lt;code&gt;FastHTTP.pas&lt;/code&gt; e a Classe foi implementada como &lt;code&gt;TftHttpClient&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Queremos encapsular essa Classe numa Unidade Limítrofe, para que 
nosso sistema só enxergue a nossa Unidade, que daremos o nome de &lt;code&gt;AcmeWebHttp.pas&lt;/code&gt;, 
e a nova Classe terá o nome &lt;code&gt;TWebHttp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então temos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit AcmeWebHttp;

interface

uses
  FastHTTP;
  
type
  TWebHttp = FastHTTP.TftHttpClient;
  
implementation

end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora &lt;code&gt;TWebHttp&lt;/code&gt; é apenas um atalho — &lt;em&gt;alias&lt;/em&gt; — para a verdadeira
Classe que implementa o protocolo HTTP.&lt;/p&gt;

&lt;p&gt;Todo o restante do sistema irá utilizar apenas &lt;code&gt;TWebHttp&lt;/code&gt; como se
essa Classe fosse a responsável por fazer o trabalho.&lt;/p&gt;

&lt;p&gt;Esse é um encapsulamento &lt;strong&gt;simples&lt;/strong&gt;. Ele só deve ser utilizado para 
coisas simples, pontuais, que não são utilizados em muitas partes do 
sistema.&lt;/p&gt;

&lt;p&gt;Essa técnica também pode ser utilizada para “concentrar” Classes e
constantes numa mesma Unidade. Mas, por algum motivo, não funciona
com tipos enumerados.&lt;/p&gt;

&lt;h2 id=&quot;novas-definicoes&quot;&gt;Definição de novas Interfaces e Classes&lt;/h2&gt;

&lt;p&gt;Para componentes mais complexos ou que são utilizados por todo o
sistema, o correto é implementarmos um encapsulamento através 
de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Componentes costumam ter &lt;em&gt;inúmeros&lt;/em&gt; Métodos e Propriedades mas, 
na maioria das vezes, você não necessita de todas essas opções.&lt;/p&gt;

&lt;p&gt;Implemente Interfaces apenas com os Métodos que fazem sentido
dentro do seu projeto e crie uma ou mais Classes que irão implementar
essa Interface.&lt;/p&gt;

&lt;p&gt;Pelo menos uma dessas novas Classes terá encapsulado
o componente real, ou seja, a Classe &lt;code&gt;TftHttpClient&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo. Se você só necessita de um Método para apontar para uma
URL e retornar seu conteúdo, você poderia implementar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit AcmeWebHttp;

interface

uses
  FastHTTP,
  AcmeData;
  
type
  IWebHttp = interface
    function Get(const URL: string): IDataStream;
  end;
  
  TWebHttp = class sealed(TInterfacedObject, IWebHttp)
  private
    FOrigin: TftHttpClient;
  public
    function Get(const URL: string): IDataStream;
  end;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por todo o sistema seu uso será simples, utilizando somente a Interface
&lt;code&gt;IWebHttp&lt;/code&gt; que, nesse exemplo, só tem um único Método.&lt;/p&gt;

&lt;p&gt;Essa é a forma que eu utilizo e que &lt;em&gt;recomendo&lt;/em&gt; que você faça.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A utilização de Unidades Limítrofes nos dá a capacidade de substituir
&lt;em&gt;todas&lt;/em&gt; as peças de terceiros em nosso sistema de forma simples, num &lt;em&gt;único
lugar&lt;/em&gt; e que irá refletir globalmente em todo o código. Isso facilita a
&lt;em&gt;manutenibilidade&lt;/em&gt; do código.&lt;/p&gt;

&lt;p&gt;Outro ganho com essa técnica é que mantemos o mesmo estilo de nomenclatura
de Classes e Unidades por todo o sistema, visto que podemos renomear ou
redefinir qualquer peça externa ao projeto.&lt;/p&gt;

&lt;p&gt;Não é algo difícil de se fazer. Dá trabalho, mas os &lt;em&gt;benefícios&lt;/em&gt; como diminuição
de dependências externas, encapsulamento e estilo de codificação, valem 
muito a pena no longo prazo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/unidades-limitrofes/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/unidades-limitrofes/</guid>
      </item>
    
      <item>
        <title>Funções Aninhadas</title>
        <description>&lt;p&gt;Se você tem um Método coeso, que trabalha em apenas uma única 
tarefa, mas mesmo assim o código parece complicado, dificultando
o entendimento e a manutenção… já pensou em refatorar o código
utilizando Funções Aninhadas?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1476411890462-80309823db3b.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Nested_function&quot;&gt;Funções Aninhadas&lt;/a&gt;
é algo que não existe em todas as linguagens.
A linguagem Pascal tem e acho que devemos aproveitar essa &lt;em&gt;feature&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Funções Aninhadas nada mais são do que funções declaradas dentro de
outras funções ou Métodos.&lt;/p&gt;

&lt;p&gt;Esse artigo irá mostrar os motivos e vantagens ao utilizarmos Funções 
Aninhadas, assim como algumas regras que devemos seguir ao utilizá-las.&lt;/p&gt;

&lt;h2 id=&quot;motivos&quot;&gt;Motivos&lt;/h2&gt;

&lt;p&gt;Funções Aninhadas é uma opção bem melhor do que 
&lt;a href=&quot;/posts/linhas-em-branco-no-metodo-e-mal-cheiro/&quot;&gt;pular linhas&lt;/a&gt;
dentro da implementação de um Método com o intuito de separar blocos
de código.&lt;/p&gt;

&lt;p&gt;Cada função já define um bloco, com a vantagem de ser &lt;strong&gt;reutilizável&lt;/strong&gt; em
outra parte do Método.&lt;/p&gt;

&lt;p&gt;Funções Aninhadas tem um conceito muito próximo da Programação Orientada a 
Objetos (leia esse 
&lt;a href=&quot;http://blog.synopse.info/post/2012/05/20/Recursive-calls-and-private-objects&quot;&gt;artigo&lt;/a&gt;
).
Um Método que contém Funções Aninhadas é como se fosse uma implementação
de uma &lt;em&gt;Classe Anônima&lt;/em&gt;. As variáveis locais serão como &lt;em&gt;atributos&lt;/em&gt; e as 
Funções Aninhadas serão como &lt;em&gt;Métodos privados&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Funções Aninhadas facilitam a correta utilização do
&lt;a href=&quot;/posts/a-declaracao-with-do-e-do-mal/&quot;&gt;&lt;em&gt;WITH&lt;/em&gt;&lt;/a&gt;
quando a implementação do Método é complexa ou quando o código utiliza
composição com muitos Objetos.
Dividir o código em pequenas funções, diminuirá as chances de haver &lt;strong&gt;conflitos&lt;/strong&gt;
entre identificadores que utilizam o &lt;em&gt;WITH&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Resumindo: Funções Aninhadas deixam o código melhor organizado, fácil de ler 
e alterar.&lt;/p&gt;

&lt;h2 id=&quot;regras&quot;&gt;Regras de Uso&lt;/h2&gt;

&lt;p&gt;Qualquer &lt;em&gt;feature&lt;/em&gt; utilizada de forma indiscriminada poderá ser um
potencial problema no futuro, ao invés de uma solução — o mesmo ocorre com 
o uso indiscriminado do &lt;em&gt;WITH&lt;/em&gt; por programadores que não sabem exatamente o
que estão fazendo.&lt;/p&gt;

&lt;p&gt;Precisamos de &lt;strong&gt;regras&lt;/strong&gt; e &lt;strong&gt;disciplina&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Abaixo algumas regras que você deve levar em conta.&lt;/p&gt;

&lt;h3 id=&quot;regra1&quot;&gt;Regra 1: Não utilize mais do que 3 Funções Aninhadas&lt;/h3&gt;

&lt;p&gt;É uma regra óbvia.
Se você tem muitas Funções Aninhadas dentro e um único Método, 
é bem provável que ele esteja fazendo &lt;strong&gt;coisas demais&lt;/strong&gt;.
Pense na refatoração e decomposição em outros Métodos ou mesmo
na criação de uma nova Classe.&lt;/p&gt;

&lt;p&gt;Existem pouquíssimas exceções a essa regra.&lt;/p&gt;

&lt;h3 id=&quot;regra2&quot;&gt;Regra 2: Evite compartilhar as Variáveis Locais&lt;/h3&gt;

&lt;p&gt;Falei acima que um Método com Funções Aninhadas é como uma Classe
Anônima, contendo Métodos privados e atributos. 
No entanto, sabemos que não são verdadeiras Classes.&lt;/p&gt;

&lt;p&gt;É melhor que você isole cada Função Aninhada com suas próprias 
variáveis e argumentos, ou seja, &lt;strong&gt;evite&lt;/strong&gt; compartilhar as variáveis
locais do Método com as Funções Aninhadas.&lt;/p&gt;

&lt;p&gt;Essa disciplina na codificação irá ajudá-lo na &lt;em&gt;extração&lt;/em&gt; e 
&lt;em&gt;refatoração&lt;/em&gt; das Funções Aninhadas, se for o caso, para criar outros 
Métodos com o mínimo de impacto possível.&lt;/p&gt;

&lt;p&gt;Ao invés de utilizar a variável local do Método, passe
a referência como argumento da função, mantendo-as &lt;strong&gt;isoladas&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Existem poucas exceções a esta regra. Por exemplo.
Se todas as Funções Aninhadas trabalham sempre com
os mesmos Objetos (variáveis locais) do Método, é mais fácil 
compartilhar as variáveis — ou refatorar criando uma nova Classe —
do que ficar repassando-as às funções. Utilize o bom senso.&lt;/p&gt;

&lt;h3 id=&quot;regra3&quot;&gt;Regra 3: Apenas 1 Nível de Funções&lt;/h3&gt;

&lt;p&gt;Não complique. Use &lt;em&gt;apenas&lt;/em&gt; um “nível” de Funções Aninhadas. Se
você tiver utilizando mais de um nível, é provável que a função
de “nível 2” deveria ser um Método.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Refatore&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Após a refatoração do código, o “nível 2” de Funções Aninhadas
passaria a ser o “nível 1” no novo Método criado.&lt;/p&gt;

&lt;p&gt;Sem exceções aqui!&lt;/p&gt;

&lt;h3 id=&quot;regra4&quot;&gt;Regra 4: Menos é Mais&lt;/h3&gt;

&lt;p&gt;Cada função deve implementar apenas uma &lt;strong&gt;única&lt;/strong&gt; responsabilidade.&lt;/p&gt;

&lt;p&gt;Essa é uma regra geral para codificar Métodos e Funções.&lt;/p&gt;

&lt;p&gt;Sem exceções.&lt;/p&gt;

&lt;h2 id=&quot;exemplos&quot;&gt;Exemplos&lt;/h2&gt;

&lt;p&gt;Funções Aninhadas podem ser utilizadas em qualquer tipo de Objeto.&lt;/p&gt;

&lt;p&gt;Objetos que lidam com XML, por exemplo, onde é necessário trabalhar
com recursividade e validações sempre são bons candidatos.&lt;/p&gt;

&lt;p&gt;Mas meu uso pessoal de Funções Aninhadas é, na maioria das vezes, 
utilizada no código de &lt;em&gt;Forms&lt;/em&gt;.
O motivo é simples: É natural para o usuário clicar em apenas um
botão e o sistema fazer &lt;em&gt;inúmeras&lt;/em&gt; tarefas. Para o usuário é
irrelevante se foi preciso 1 ou 20 Objetos para concluir a tarefa.
O usuário acha que apenas uma tarefa foi executada quando, na 
verdade, &lt;strong&gt;inúmeros Objetos&lt;/strong&gt; podem ter tido participação para executar
o serviço.&lt;/p&gt;

&lt;p&gt;Então, abaixo temos alguns exemplos do que eu considero um &lt;em&gt;bom&lt;/em&gt; uso
de Funções Aninhadas.&lt;/p&gt;

&lt;p&gt;Observação: Podem haver erros de sintaxe, visto que eu estou escrevendo
o código diretamente no editor do artigo sem compilar.&lt;/p&gt;

&lt;h3 id=&quot;exemplo1&quot;&gt;Exemplo 1: Pergunte, Faça o Serviço&lt;/h3&gt;

&lt;p&gt;Em alguns formulários temos que questionar o usuário sobre
qual caminho o sistema deve tomar.
Esses questionamentos, com mensagens &lt;em&gt;strings&lt;/em&gt;, podem 
diminuir a legibilidade do código.&lt;/p&gt;

&lt;p&gt;Somado isso com o uso &lt;em&gt;errado&lt;/em&gt; do &lt;em&gt;WITH&lt;/em&gt;, o código &lt;em&gt;não&lt;/em&gt; fica 
elegante. Veja:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TMainForm.DeleteButtonClick(Sender: TObject);
begin
  with TUserQuestion.New(
    Format(
      &#39;Você tem %d registros para excluir.&#39; + #13
      &#39;Esse processo pode demorar.&#39; + #13
      &#39;Confirma a execução?&#39;, [
        DataSet.RecordCount
      ]
    )
  ) do
  begin
    Show;
    if Confirmed then
    begin
      ExecuteProcessOne;
      ExecuteProcessTwo;
      TUserInformation.New(&#39;Processo concluído.&#39;).Show;
    end;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo eu utilizei Classes de Mensagens ao usuário.
Não precisamos de sua implementação para entender o que está 
ocorrendo aqui. No entanto o código pode parecer um pouco confuso
para alguns programadores “não iniciados” no uso do &lt;em&gt;WITH&lt;/em&gt;.
Por exemplo. O Método &lt;code&gt;Show&lt;/code&gt; após o primeiro &lt;code&gt;begin&lt;/code&gt;, pertence ao
Formulário ou a instância de &lt;code&gt;TUserQuestion&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Também temos a mensagem em texto com quebra de linha e parâmetros
concatenados. As vezes essas mensagens são maiores. O código fica 
uma bagunça.&lt;/p&gt;

&lt;p&gt;Vamos refatorar esse código utilizando Funções Aninhadas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TMainForm.DeleteButtonClick(Sender: TObject);

  function Question(Total: Integer): IUserQuestion;
  begin
    Result :=
      TUserQuestion.New(
        Format(
          &#39;Você tem %d registros para excluir.&#39; + #13
          &#39;Esse processo pode demorar.&#39; + #13
          &#39;Confirma a execução?&#39;, [
            Total
          ]
        )
      ).Show;
  end;

begin
  if Question(DataSet.RecordCount).Confirmed then
  begin
    ExecuteProcessOne;
    ExecuteProcessTwo;
    TUserInformation.New(&#39;Processo concluído.&#39;).Show;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mais simples?&lt;/p&gt;

&lt;p&gt;Sim, optei por retirar o &lt;em&gt;WITH&lt;/em&gt;, porque é mais simples dessa forma,
nesse exemplo.
Mas ele poderia ser utilizado caso o programador necessitasse de 
mais alguma informação da instância &lt;code&gt;IUserQuestion&lt;/code&gt;, criada e retornada
através da função &lt;code&gt;Question&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo. Você pode fazer uma pergunta ao usuário onde ele deve digitar 
um valor. Nesse caso você precisa validar o retorno (&lt;code&gt;Confirmed&lt;/code&gt;) e 
mostrar o valor digitado (&lt;code&gt;Value&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with TUserInput.New(&#39;Digite o valor&#39;) do
begin
  if Confirmed then
    TUserInformation.New(
      &#39;Valor digitado: &#39; + Value.AsString
    )
    .Show;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare, também, que a função &lt;code&gt;Question&lt;/code&gt; não tem mais dependência
com o Objeto que vem do Formulário, &lt;code&gt;DataSet.RecordCount&lt;/code&gt;. A função
agora está &lt;strong&gt;isolada&lt;/strong&gt;. Isso quer dizer que se você precisar dessa
função em mais de um lugar, pode extraí-la, criar um novo Método e 
passar o argumento na sua chamada.&lt;/p&gt;

&lt;h3 id=&quot;exemplo2&quot;&gt;Exemplo 2: Clicou no “Botão Mágico” que Faz tudo&lt;/h3&gt;

&lt;p&gt;Imagine um Formulário que, ao clique de um botão, o sistema:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Faz validações das informações desejadas&lt;/li&gt;
  &lt;li&gt;Pergunta ao usuário se deve continuar&lt;/li&gt;
  &lt;li&gt;Salva as informações no banco de dados&lt;/li&gt;
  &lt;li&gt;Envia um e-mail notificando alguém&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Claro que você terá uma Classe para cada uma dessas funções (certo?).
Você não deve implementar tudo isso dentro de um evento num botão.&lt;/p&gt;

&lt;p&gt;Por outro lado, a implementação mais &lt;strong&gt;correta&lt;/strong&gt; seria separar essas ações
em outras camadas, outras Classes, sem instanciar tais Classes específicas
dentro do Formulário.&lt;/p&gt;

&lt;p&gt;Infelizmente nem sempre temos tempo para fazer o 100% correto. Mas que 
tal fazer 80% correto para depois, quando tivermos mais tempo, refatorar
com tranquilidade o código?&lt;/p&gt;

&lt;p&gt;Aqui as Funções Aninhadas nos ajudam novamente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TMainForm.ConfirmButtonClick(Sender: TObject);

  function Checked: Boolean;
  begin
    Result := False;
    //if EmailEdit.Text &amp;lt;&amp;gt; &#39;&#39; then
    // Exit;
    //...
    Result := True;
  end;
  
  function Question: IUserQuestion;
  begin
    Result := 
      TUserQuestion.New(&#39;Confirma a operação?&#39;).Show;
  end;
  
  procedure Save;
  begin
    // persistência...
  end;
  
  procedure SendEmail;
  begin
    // envia um e-mail...
  end;

begin
  if Checked then
    if Question.Confirmed then
    begin
      Save;
      SendMail;
    end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tenha em mente que isso é apenas um exemplo.&lt;/p&gt;

&lt;p&gt;Todas as Funções Aninhadas devem seguir o bom senso e ter 
&lt;strong&gt;poucas linhas&lt;/strong&gt;. Caso contrário, &lt;em&gt;refatore&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Haverá muitas dependências entre o Formulário e todas essas Classes 
especialistas. Mas nem sempre
precisamos abstrair em camadas. Pode ser um pequeno Formulário de um
pequeno sistema, onde não haveria problemas em ter essas dependências.&lt;/p&gt;

&lt;p&gt;Mesmo assim o código está &lt;em&gt;limpo&lt;/em&gt; e &lt;em&gt;elegante&lt;/em&gt;, com fácil manutenção.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Funções Aninhadas nos ajudam a codificar de forma mais simples e elegante.&lt;/p&gt;

&lt;p&gt;É um dos caminhos para “seguir em frente” sem muitas preocupações com 
o &lt;strong&gt;purismo&lt;/strong&gt; da Orientação a Objetos — devido a falta de tempo — mas sem deixar
cair a qualidade do código no longo prazo.&lt;/p&gt;

&lt;p&gt;Utilize-as com sabedoria.&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/funcoes-aninhadas/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/funcoes-aninhadas/</guid>
      </item>
    
      <item>
        <title>Interfaces, Delegação, Problemas e Soluções</title>
        <description>&lt;p&gt;Delegação de Implementação através da composição de
Objetos é uma &lt;em&gt;feature&lt;/em&gt; incrível, só disponível na
Linguagem &lt;em&gt;Object Pascal&lt;/em&gt;, porém existem alguns 
problemas intrínsecos no uso dessa tecnologia.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1474406716381-8399fe67fbcf.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/&quot;&gt;artigo anterior&lt;/a&gt;
escrevi sobre a Delegação de Implementação de Interfaces, 
utilizando a Composição de Objetos.&lt;/p&gt;

&lt;p&gt;É uma &lt;em&gt;feature&lt;/em&gt; bem legal.&lt;/p&gt;

&lt;p&gt;Infelizmente existem algumas armadilhas quando trabalhamos
com Interfaces e sua liberação automática de memória.&lt;/p&gt;

&lt;p&gt;A Delegação utilizando Objetos também possui armadilhas que,
se não forem verificadas, podem arruinar seu projeto devido
aos vazamentos de memória que essa prática pode causar.&lt;/p&gt;

&lt;p&gt;Nesse artigo vou lhe mostrar os problemas e propor soluções.&lt;/p&gt;

&lt;h2 id=&quot;vazamentos-de-memoria&quot;&gt;Vazamentos de memória&lt;/h2&gt;

&lt;p&gt;A Linguagem Object Pascal nos dá a possibilidade de trabalharmos
utilizando variáveis do tipo Interface. Essas são liberadas
automaticamente, pelo compilador, quando saem do escopo de execução
na qual elas foram criadas.&lt;/p&gt;

&lt;p&gt;Essa facilidade nos traz alguns problemas ou cria 
condições para problemas como, por exemplo, a 
&lt;a href=&quot;/posts/interfaces-e-a-referencia-circular-entre-objetos/&quot;&gt;referência circular&lt;/a&gt;
e a &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;não existência de uma variável&lt;/a&gt;
na construção de um Objeto.&lt;/p&gt;

&lt;p&gt;Esse são alguns dos inúmeros equívocos na implementação que geram
os tão temidos vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Outro problema grave tem haver com a 
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;hierarquia de herança&lt;/a&gt; 
que você irá utilizar nas Classes que irão gerar Objetos que 
implementam Interfaces por delegação.&lt;/p&gt;

&lt;h2 id=&quot;contador-de-referencias&quot;&gt;Contador de Referências&lt;/h2&gt;

&lt;p&gt;Vou ser justo e dizer que o problema, em si, não é especificamente sobre
herança, mas como você implementa os Métodos especiais que são utilizados
pelo compilador para fazer a liberação da memória automaticamente.&lt;/p&gt;

&lt;p&gt;São eles: &lt;code&gt;QueryInterface&lt;/code&gt;, &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Esses são Métodos especiais que são utilizados para 
implementar um Contador de Referências. 
Eles servem para incrementar e decrementar um contador 
de referência da instância e, com isso, ter o controle para saber 
quando liberar o Objeto da memória.&lt;/p&gt;

&lt;p&gt;Ao utilizarmos Interfaces, somos obrigados a implementar esses 3 Métodos
— a não ser que utilizemos Interfaces CORBA, que não tem contagem de
referência e nem liberação automática da memória.&lt;/p&gt;

&lt;p&gt;Então utizamos a herança de alguma Classe que já implemente esses Métodos.&lt;/p&gt;

&lt;p&gt;E aqui começam os problemas.&lt;/p&gt;

&lt;h2 id=&quot;problemas&quot;&gt;Problemas&lt;/h2&gt;

&lt;p&gt;Como eu não utilizo mais herança de Classes eu não preciso pensar sobre
hierarquias de Classes e todas as suas complexidades. 
Todas as minhas Classes herdam de &lt;code&gt;TInterfacedObject&lt;/code&gt;, pois essa Classe
já implementa os 3 Métodos apropriadamente.&lt;/p&gt;

&lt;p&gt;Mas para programadores que ainda utilizam
&lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;
esse pode ser o primeiro problema a enfrentar.&lt;/p&gt;

&lt;p&gt;Exemplo. Você vai desenhando toda a sua hierarquia de Classes, “perfeitamente” e 
descobre que Cão não pode herdar de Mamífero porque você quer utilizar Interfaces
com contagem de referência… então Cão herda de &lt;code&gt;TInterfacedObject&lt;/code&gt; — 
quebrando a hierarquia — ou você é obrigado a copiar/colar o código 
de &lt;code&gt;TInterfacedObject&lt;/code&gt; dentro da sua Classe — o que também é abominável.&lt;/p&gt;

&lt;p&gt;Como eu dizia, todas as minhas Classes herdam de &lt;code&gt;TInterfacedObject&lt;/code&gt;.
Sendo assim, as Classes que serão utilizadas para delegar a implementação
das Interfaces, também serão filhas de &lt;code&gt;TInterfacedObject&lt;/code&gt; e… BUM! 
Temos vazamento de memória.&lt;/p&gt;

&lt;p&gt;Pois é. As Classes delegadas não podem herdar de &lt;code&gt;TInterfacedObject&lt;/code&gt;
se eu quiser instanciar a Classe principal como uma Interface.&lt;/p&gt;

&lt;p&gt;Confuso? Eu também fiquei.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-1&quot;&gt;Exemplo 1&lt;/h3&gt;

&lt;p&gt;Vamos utilizar o exemplo do
&lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/&quot;&gt;artigo anterior&lt;/a&gt;
para explicar onde iríamos ter problemas com vazamento de memória.&lt;/p&gt;

&lt;p&gt;A Classe final ficou assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  TTheClient = class(TInterfacedObject, IFinances, IAccess)
  private
    FFinances: IFinances;
    FAccess: IAccess;
    property Finances: IFinances read FFinances implements IFinances;
    property Access: IAccess read FAccess implements IAccess;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E os &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#como-utilizar-a-delegacao&quot;&gt;exemplos&lt;/a&gt;
de implementação utilizando delegação foram as Classes &lt;code&gt;TSimpleFinances&lt;/code&gt; 
e &lt;code&gt;TSimpleAccess&lt;/code&gt;. Ambas herdando de &lt;code&gt;TInterfacedObject&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  TSimpleFinances = class(TInterfacedObject, IFinances)
  public
    construtor ...
    function Current: Currency;
    function AsString: string;
  end;
  
  TSimpleAccess = class(TInterfacedObject, IAccess)
  public
    construtor ...
    function List: IDataList;
    function AsString: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Devido os atributos &lt;code&gt;FFinances&lt;/code&gt; e &lt;code&gt;FAccess&lt;/code&gt; forem do tipo Interface, haverá
vazamentos de memória se estanciarmos &lt;code&gt;TTheClient&lt;/code&gt; como sendo representante
de alguma das Interfaces que ele implementa (por delegação).&lt;/p&gt;

&lt;p&gt;Isso ocorre porque o compilador irá instanciar 2 Objetos — &lt;code&gt;TTheClient&lt;/code&gt;
e o Objeto delegado que implementa a Interface — mas no nosso código
só teremos a referência a um Objeto.
A princípio tudo deveria funcionar, já que também temos a referência ao
Objeto delegado através do atributo privado, mas não é assim que funciona.&lt;/p&gt;

&lt;p&gt;Há dois problemas no código acima, se considerarmos a utilização normal de 
instâncias com contagem de referência:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Propriedades e atributos delegados não podem ser Interfaces;&lt;/li&gt;
  &lt;li&gt;Objetos delegados não devem ter &lt;code&gt;TInterfacedObject&lt;/code&gt; como herança.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Então a Classe final &lt;code&gt;TTheClient&lt;/code&gt; tem um problema.&lt;/p&gt;

&lt;p&gt;Vamos ao um exemplo mais completo.&lt;/p&gt;

&lt;h3 id=&quot;exemplo-2&quot;&gt;Exemplo 2&lt;/h3&gt;

&lt;p&gt;O exemplo abaixo foi submetido à lista de discussão oficial do FreePascal com
o título “&lt;em&gt;A serious Memleak using delegates/implements…&lt;/em&gt;” no dia 5 de Outubro, 
o que gerou alguma polêmica por lá.&lt;/p&gt;

&lt;p&gt;Se você não faz parte da lista, pode ler as mensagens dessa &lt;em&gt;thread&lt;/em&gt; 
&lt;a href=&quot;https://www.mail-archive.com/fpc-pascal@lists.freepascal.org/msg43835.html&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program Project1;

{$mode objfpc}{$H+}

uses
  Classes, SysUtils;

type
  IValue = interface
    function AsString: string;
  end;

  TIntegerValue = class(TInterfacedObject, IValue)
  private
    FValue: Integer;
  public
    constructor Create(Value: Integer);
    destructor Destroy; override;
    function AsString: string;
  end;

  TMyApp = class(TInterfacedObject, IValue)
  private
    FValue: IValue;
  public
    constructor Create(Value: Integer);
    destructor Destroy; override;
    property Value: IValue read FValue implements IValue;
  end;

{ TIntegerValue }

constructor TIntegerValue.Create(Value: Integer);
begin
  inherited Create;
  FValue := Value;
  WriteLn(&#39;TIntegerValue.Create&#39;);
end;

destructor TIntegerValue.Destroy;
begin
  WriteLn(&#39;TIntegerValue.Destroy&#39;);
  inherited Destroy;
end;

function TIntegerValue.AsString: string;
begin
  Result := &#39;Number is &#39; + IntToStr(FValue);
end;

{ TMyApp }

constructor TMyApp.Create(Value: Integer);
begin
  inherited Create;
  FValue := TIntegerValue.Create(Value);
  WriteLn(&#39;TMyApp.Create&#39;);
end;

destructor TMyApp.Destroy;
begin
  WriteLn(&#39;TMyApp.Destroy&#39;);
  inherited Destroy;
end;

// Program

procedure ExecuteIntegerValue;
var
  V: IValue;
begin
  WriteLn;
  WriteLn(&#39;IntegerValue:&#39;);
  V := TIntegerValue.Create(5);
  WriteLn(V.AsString);
end;

procedure ExecuteMyApp;
var
  App: TMyApp;
begin
  WriteLn;
  WriteLn(&#39;MyApp:&#39;);
  App := TMyApp.Create(10);
  try
    WriteLn(App.Value.AsString);
  finally
    App.Free;
  end;
end;

procedure ExecuteMyAppAsInterface;
var
  V: IValue;
begin
  WriteLn;
  WriteLn(&#39;MyAppAsInterface:&#39;);
  V := TMyApp.Create(20);
  WriteLn(V.AsString);
end;

begin
  ExecuteIntegerValue;
  ExecuteMyApp;
  ExecuteMyAppAsInterface;
  ReadLn;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O programa acima compila sem nenhum erro utilizando o FreePascal ou Delphi.
No entanto, se habilitarmos a saída de verificação de vazamentos
de memória (chama-se &lt;a href=&quot;http://www.freepascal.org/docs-html/rtl/heaptrc/usage.html&quot;&gt;Heaptrc&lt;/a&gt; no FreePascal)
podemos ver que o término do programa não foi elegante como deveria:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;W:\temp&amp;gt;project1.exe

IntegerValue:
TIntegerValue.Create
Number is 5
TIntegerValue.Destroy

MyApp:
TIntegerValue.Create
TMyApp.Create
Number is 10
TMyApp.Destroy
TIntegerValue.Destroy

MyAppAsInterface:
TIntegerValue.Create
TMyApp.Create
Number is 20

Heap dump by heaptrc unit
83 memory blocks allocated : 2017/2200
81 memory blocks freed     : 1981/2160
2 unfreed memory blocks : 36
True heap size : 229376 (80 used in System startup)
True free heap : 229104
Should be : 229128
Call trace for block $01812928 size 20
  $004017DA  TMYAPP__CREATE,  line 59 of W:/temp/project1.lpr
  $00401B82  EXECUTEMYAPPASINTERFACE,  line 101 of W:/temp/project1.lpr
  $00401C08  main,  line 108 of W:/temp/project1.lpr
Call trace for block $018128C8 size 16
  $00401B82  EXECUTEMYAPPASINTERFACE,  line 101 of W:/temp/project1.lpr
  $00401C08  main,  line 108 of W:/temp/project1.lpr

W:\temp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O problema de vazamento de memória ocorre somente na chamada à função &lt;code&gt;MyAppAsInterface&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ao vermos isso a primeira impressão é: Delegação de Implementação não funciona.&lt;/p&gt;

&lt;p&gt;Bem, funciona sim. Não é tão elegante como eu gostaria que fosse, mas ao
menos é contornável.&lt;/p&gt;

&lt;h2 id=&quot;solucoes&quot;&gt;Soluções&lt;/h2&gt;

&lt;p&gt;A partir de agora, a Classe que você sempre deverá se lembrar, depois da 
&lt;code&gt;TInterfacedObject&lt;/code&gt;, será a Classe &lt;code&gt;TAggregatedObject&lt;/code&gt;. 
Ambas existem no FreePascal e também no Delphi.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TAggregatedObject&lt;/code&gt; também implementa os 3 métodos especiais, mas
é uma implementação diferente da utilizada em &lt;code&gt;TInterfacedObject&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Essa Classe deverá ser utilizada para implementar Objetos que são utilizados
na Delegação de Implementação utilizando a sintaxe “&lt;em&gt;implements&lt;/em&gt;”.&lt;/p&gt;

&lt;p&gt;Em &lt;a href=&quot;http://www.freepascal.org/docs-html/rtl/system/taggregatedobject.html&quot;&gt;poucas palavras&lt;/a&gt;, 
os Objetos de &lt;code&gt;TAggregatedObject&lt;/code&gt; delegam a contagem de 
referência ao “Objeto controlador”, ou seja, delegam seus próprios “tempos de vida”
ao Objeto externo que implementa as Interfaces.&lt;/p&gt;

&lt;p&gt;Primeiro vamos implementar uma nova Classe que herda de &lt;code&gt;TAggregatedObject&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TDelegatedIntegerValue = class(TAggregatedObject, IValue)
private
  FValue: Integer;
public
  constructor Create(AController: IInterface; Value: Integer);
  destructor Destroy; override;
  function AsString: string;
end;

{ TDelegatedIntegerValue }

constructor TDelegatedIntegerValue.Create(AController: IInterface;
  Value: Integer);
begin
  inherited Create(AController);
  FValue := Value;
  WriteLn(&#39;TDelegatedIntegerValue.Create&#39;);
end;

destructor TDelegatedIntegerValue.Destroy;
begin
  WriteLn(&#39;TDelegatedIntegerValue.Destroy&#39;);
  inherited Destroy;
end;

function TDelegatedIntegerValue.AsString: string;
begin
  Result := &#39;Number is &#39; + IntToStr(FValue);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Infelizmente também teremos que alterar a definição da Classe &lt;code&gt;TMyApp&lt;/code&gt;,
redefinindo a propriedade e atributo para um tipo concreto de Classe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TMyApp = class(TInterfacedObject, IValue)
private
  FValue: TDelegatedIntegerValue;
public
  constructor Create(Value: Integer);
  destructor Destroy; override;
  property Value: TDelegatedIntegerValue read FValue implements IValue;
end;

{ TMyApp }

constructor TMyApp.Create(Value: Integer);
begin
  inherited Create;
  FValue := TDelegatedIntegerValue.Create(Self, Value);
  WriteLn(&#39;TMyApp.Create&#39;);
end;

destructor TMyApp.Destroy;
begin
  FValue.Free;
  WriteLn(&#39;TMyApp.Destroy&#39;);
  inherited Destroy;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ao criamos a instância &lt;code&gt;FValue&lt;/code&gt;, um dos argumentos do construtor
da Classe &lt;code&gt;TDelegatedIntegerValue&lt;/code&gt; é o &lt;em&gt;Controller&lt;/em&gt; que irá controlar
o tempo de vida da instância que, nesse caso, é a instância (&lt;em&gt;Self&lt;/em&gt;)
de &lt;code&gt;TMyApp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Após compilar e executar novamente a aplicação, podemos ver um novo resultado:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe

IntegerValue:
TIntegerValue.Create
Number is 5
TIntegerValue.Destroy

MyApp:
TDelegatedIntegerValue.Create
TMyApp.Create
Number is 10
TDelegatedIntegerValue.Destroy
TMyApp.Destroy

MyAppAsInterface:
TDelegatedIntegerValue.Create
TMyApp.Create
Number is 20
TDelegatedIntegerValue.Destroy
TMyApp.Destroy

Heap dump by heaptrc unit
83 memory blocks allocated : 2009/2184
83 memory blocks freed     : 2009/2184
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528

c:\temp&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Os &lt;em&gt;designers&lt;/em&gt; da linguagem foram muito infelizes ao criarem “métodos especiais”
para liberação de memória. Isso é algo difícil de explicar para programadores
não-Pascal. É até um pouco vergonhoso…&lt;/p&gt;

&lt;p&gt;Poderiam ter criado uma Interface especial que só pelo fato de dizer que sua
a Classe à implementa, o compilador poderia fazer sua mágica.&lt;/p&gt;

&lt;p&gt;Felizmente há possíveis soluções para contornar esse erro no &lt;em&gt;design&lt;/em&gt;, mas se 
pudessemos utilizar propriedades de Objetos delegados como sendo do 
tipo Interface, como sugeri no artigo anterior, seria quase perfeito. Poderíamos
utilizar Injeção de Dependência através dos construtores dos Objetos, inicializando
as instâncias delegadas, que seriam do tipo Interface.&lt;/p&gt;

&lt;p&gt;Com a implementação atual, até podemos utilizar a Injeção de Dependência, 
mas os argumentos deverão ser do tipo Classe e não Interface — isso na maioria dos
casos normais onde queremos utilizar a contagem de referência — 
então o polimorfismo iria ficar por conta da herança de Classes, o que não é muito bem
vindo devido aos problemas já relatados em artigos anteriores.&lt;/p&gt;

&lt;p&gt;O jeito é instanciar as Classes delegadas internamente. O que não é um real problema.&lt;/p&gt;

&lt;p&gt;Se formos pensar bem, todos os métodos de Implementação das Interfaces deveriam ser 
implementas dentro do Objeto, quando não utilizamos Delegação. Então não estaríamos 
perdendo muito, apenas estamos deixando de ganhar mais.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/interfaces-delegacao-problemas-solucoes/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/interfaces-delegacao-problemas-solucoes/</guid>
      </item>
    
      <item>
        <title>Delegação de Implementação de Interfaces</title>
        <description>&lt;p&gt;Existe uma bela &lt;em&gt;feature&lt;/em&gt; na linguagem &lt;em&gt;Object Pascal&lt;/em&gt;
que nem todos sabem que existem. Aqueles que sabem pouco
utilizam e, talvez, não tenham percebido o potencial dessa 
&lt;em&gt;feature&lt;/em&gt; para a implementação da Orientação a Objetos
numa linguagem de programação.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1451650645557-62193a7bed6a.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A bela &lt;em&gt;feature&lt;/em&gt; que existe no &lt;em&gt;Object Pascal&lt;/em&gt; e que — até onde
eu sei — não existe em nenhuma outra linguagem de programação chama-se
&lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Seattle/en/Using_Implements_for_Delegation&quot;&gt;Delegation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Java não tem.&lt;/p&gt;

&lt;p&gt;Ruby não tem.&lt;/p&gt;

&lt;p&gt;C# não tem.&lt;/p&gt;

&lt;p&gt;Os engenheiros da linguagem C# utilizaram a mesma nomenclatura 
para implementar o que nós — Programadores &lt;em&gt;Object Pascal&lt;/em&gt; — 
damos o nome de Eventos. 
Um ponteiro para um Método é uma implementação para um Evento, 
mas em C# eles deram o nome de
&lt;a href=&quot;https://msdn.microsoft.com/library/900fyy8e.aspx&quot;&gt;&lt;em&gt;delegates&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Você verá porque essa &lt;em&gt;feature&lt;/em&gt; é tão importante para implementarmos
um Objeto da forma mais fiel possível a 
&lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidade real&lt;/a&gt;
que ele representa.&lt;/p&gt;

&lt;p&gt;Verá que é possível escrever menos e ainda deixar o código mais 
flexível para implementações de &lt;strong&gt;comportamentos dinâmicos&lt;/strong&gt;, 
utilizando a composição de Objetos.&lt;/p&gt;

&lt;h2 id=&quot;delegation--implements&quot;&gt;Delegation / Implements&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Delegation&lt;/em&gt; no &lt;em&gt;Object Pascal&lt;/em&gt; também pode ser conhecido pela
palavra &lt;em&gt;Implements&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ambas as nomenclaturas estão corretas.
Sendo &lt;em&gt;delegation&lt;/em&gt; a técnica e &lt;em&gt;implements&lt;/em&gt; a palavra-reservada
que a implementa.&lt;/p&gt;

&lt;p&gt;Essa &lt;em&gt;feature&lt;/em&gt; existe na linguagem &lt;em&gt;Object Pascal&lt;/em&gt; desde sempre e
seu objetivo é a &lt;strong&gt;delegação de implementação de Interfaces, 
utilizando Composição de Objetos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A anos atrás eu só codificava utilizando o 
&lt;a href=&quot;/posts/procedural-e-facil-orientado-a-objetos-e-dificil/&quot;&gt;paradigma Procedural&lt;/a&gt;
então eu apenas ignorava essa &lt;em&gt;feature&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas antes de começarmos a utilizar &lt;em&gt;Delegation&lt;/em&gt;, precisamos pensar
em Contextos.&lt;/p&gt;

&lt;h2 id=&quot;contextos&quot;&gt;Contextos&lt;/h2&gt;

&lt;p&gt;Já falei muito sobre Contextos em &lt;a href=&quot;/archive/&quot;&gt;artigos anteriores&lt;/a&gt;.
Um &lt;em&gt;software&lt;/em&gt; deve ser codificado utilizando Contextos. Cada Contexto
é um agrupamento de ideias, Classes, Objetos, Regras de Negócio, etc.&lt;/p&gt;

&lt;p&gt;No &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-driven_design&quot;&gt;DDD&lt;/a&gt; 
dá-se o nome de 
&lt;a href=&quot;http://martinfowler.com/bliki/BoundedContext.html&quot;&gt;Bounded Context&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bounded Context é um conceito muito importante do DDD e pode ser a 
solução para a boa modelagem do seu domínio. Bounded Context é um 
conceito tão importante quanto o entendimento da separação de 
responsabilidades das camadas do DDD. — Google search&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em termos práticos, isso quer dizer o seguinte:&lt;/p&gt;

&lt;p&gt;Imagine que você tem uma Entidade &lt;code&gt;Client&lt;/code&gt;. Um &lt;code&gt;Client&lt;/code&gt; teria Regras de
Negócio de acessos mas também teria Regras de Negócio sobre suas Finanças,
considerando um sistema hipotético.&lt;/p&gt;

&lt;p&gt;Se cada Classe deve
&lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/&quot;&gt;representar apenas uma responsabilidade&lt;/a&gt;,
como construir um Objeto que A) tenha Regras de Acesso e B) tenha Regras de Finanças ao mesmo tempo?&lt;/p&gt;

&lt;p&gt;Por agora, a resposta é: Você &lt;strong&gt;não&lt;/strong&gt; deve fazer isso.&lt;/p&gt;

&lt;p&gt;Por quê não?&lt;/p&gt;

&lt;p&gt;Bem, se você tem uma Interface &lt;code&gt;IFinances&lt;/code&gt; e outra &lt;code&gt;IAccess&lt;/code&gt;, por exemplo,
e tivesse que implementar os métodos de ambas numa única Classe, você 
estaria quebrando a regra de &lt;strong&gt;Implementar apenas uma Responsabilidade&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A Classe ficaria “inchada”. Métodos demais. Responsabilidades demais.&lt;/p&gt;

&lt;p&gt;Se daqui a algumas semanas tivesse que acrescentar outras regras, ou seja,
implementar outra Interface… imagine onde isso iria parar! 
A manutenção ficaria extremamente comprometida.&lt;/p&gt;

&lt;p&gt;A maneira mais eficaz e segura é implementar Classes diferentes para
cada Contexto, mas que representem a mesma Entidade.&lt;/p&gt;

&lt;p&gt;Utilizando o exemplo acima teríamos que implementar as Classes:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;TClientFinances (IFinances)&lt;/li&gt;
  &lt;li&gt;TClientAccess (IAccess)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ambas as Classes representam um &lt;code&gt;Client&lt;/code&gt;, porém em Contextos diferentes,
com Métodos diferentes.&lt;/p&gt;

&lt;p&gt;E esse tipo de implementação funciona em qualquer linguagem com suporte a
Orientação a Objetos.&lt;/p&gt;

&lt;p&gt;Eu gosto disso. Gosto de ter soluções simples que funcionam em (quase)
qualquer linguagem, sem precisar utilizar &lt;em&gt;features&lt;/em&gt; específicas de
cada linguagem.&lt;/p&gt;

&lt;p&gt;No entanto…&lt;/p&gt;

&lt;p&gt;Nem todo Objeto é tão simples. Há casos em que Objetos mais complexos
podem simplificar o código, pois se a complexidade está dentro do Objeto
mas seu uso é simples, então vale a pena, certo?&lt;/p&gt;

&lt;p&gt;Então digamos que gostaríamos de ter um Objeto que representasse
&lt;code&gt;Finances&lt;/code&gt; mas também &lt;code&gt;Access&lt;/code&gt;, por algum motivo, mas sem quebrar a 
regra da responsabilidade única.&lt;/p&gt;

&lt;h2 id=&quot;o-problema&quot;&gt;O Problema&lt;/h2&gt;

&lt;p&gt;Vou definir alguns Métodos simples para ambas as Interfaces.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IFinances = interface
    function Current: Currency; // total no banco
    function AsString: string;
  end;
  
  IAccess = interface
    function List: IDataList; // lista de acessos
    function AsString: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se tivéssemos uma Classe que implementa ambas as Interfaces, 
teríamos algo como:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  TSuperClient = class(TInterfacedObject, IFinances, IAccess)
  public
    function Current: Currency;
    function List: IDataList;
    function IFinances.AsString: string;
    function IAccess.AsString: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que com apenas duas Interfaces simples já temos 4 métodos
que não são nada coesos numa única Classe. Ainda tem o fato de 
ambas as Classes possuirem Métodos iguais, então, se for preciso
representar as Interfaces como &lt;code&gt;String&lt;/code&gt;, é necessário definir um
prefixo com o nome da Interface.&lt;/p&gt;

&lt;h2 id=&quot;como-utilizar-a-delegacao&quot;&gt;Como utilizar a Delegação&lt;/h2&gt;

&lt;p&gt;Para utilizarmos &lt;em&gt;Delegation&lt;/em&gt;, primeiro precisamos definir os
reais Objetos que representam as Interfaces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TSimpleFinances = class(TInterfacedObject, IFinances)
  public
    construtor ...
    function Current: Currency;
    function AsString: string;
  end;
  
  TSimpleAccess = class(TInterfacedObject, IAccess)
  public
    construtor ...
    function List: IDataList;
    function AsString: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essas são Classes que implementam, de forma genérica, as Interfaces 
acima.&lt;/p&gt;

&lt;p&gt;Agora podemos implementar uma Classe que represente um &lt;code&gt;Client&lt;/code&gt;
dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  TTheClient = class(TInterfacedObject, IFinances, IAccess)
  private
    FFinances: IFinances;
    FAccess: IAccess;
    property Finances: IFinances read FFinances implements IFinances;
    property Access: IAccess read FAccess implements IAccess;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja agora que &lt;code&gt;TTheClient&lt;/code&gt; não implementa mais os Métodos de ambas as
Interfaces, ele &lt;strong&gt;delega&lt;/strong&gt; para outras Classes, especialistas no assunto!&lt;/p&gt;

&lt;p&gt;No entanto &lt;code&gt;TTheClient&lt;/code&gt; pode ser 
&lt;a href=&quot;/posts/interfaces-em-todo-lugar/#interfaces-sao-contratos&quot;&gt;contratado&lt;/a&gt;
para trabalhar em qualquer especialidade definida pelas Interfaces que ele 
implementa (por delegação).&lt;/p&gt;

&lt;p&gt;Veja que ambas as propriedades são privadas. Sim. Você irá trabalhar com 
&lt;code&gt;TTheClient&lt;/code&gt; instanciando um tipo de Interface. Você não deve trabalhar com 
a Classe diretamente. Sempre trabalhe com o(s) tipo(s) da(s) Interface(s) 
que a Classe representa.&lt;/p&gt;

&lt;p&gt;As possibilidades de evolução do código com essa técnica são muitas. Por exemplo.
Agora que temos a Classe genérica (simples) &lt;code&gt;TSimpleFinances&lt;/code&gt;, ela pode ser 
reutilizada por outras Classes, similares a &lt;code&gt;TTheClient&lt;/code&gt;, apenas definindo 
uma propriedade. Essas Classes deverão possuir construtores que as inicialize
de acordo com as Classes que as consome. Por exemplo, &lt;code&gt;TSimpleFinances&lt;/code&gt; poderia
ser inicializa com o &lt;code&gt;ID&lt;/code&gt; do Client ou algum outro identificador.&lt;/p&gt;

&lt;p&gt;Outra possibilidade: A Classe &lt;code&gt;TTheClient&lt;/code&gt; pode ter em seu construtor um argumento do
tipo &lt;code&gt;IFinances&lt;/code&gt;, indicando que ela pode ser inicializada com qualquer tipo de
Classe que implemente &lt;code&gt;IFinances&lt;/code&gt;, inicializando, assim, o atributo &lt;code&gt;FFinances&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Conseguimos fazer isso em &lt;em&gt;Object Pascal&lt;/em&gt;, mas parece que a maioria prefere
definir Classes com 30 métodos do tipo Getter/Setter ou adicionam 40 Métodos numa
Classe do tipo &lt;code&gt;TDataModule&lt;/code&gt; e acham que estão programando Orientado a Objetos e
reutilizando código.&lt;/p&gt;

&lt;p&gt;Temos as ferramentas para programar melhor, mas é preciso olhar “fora da caixa”.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Oct 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/delegacao-de-implementacao-de-interfaces/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/delegacao-de-implementacao-de-interfaces/</guid>
      </item>
    
      <item>
        <title>Linhas em Branco no Método é um Mal Cheiro no Código</title>
        <description>&lt;p&gt;Pular linhas dentro de um Método é um “mal cheiro”
no código. Significa que você está fazendo coisas 
demais num único Método.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1417309807426-472e833fa5d0.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O que significa mal cheiro no código?&lt;/p&gt;

&lt;p&gt;Um &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_smell&quot;&gt;mal cheiro&lt;/a&gt;,
se refere a qualquer sintoma no código-fonte 
de um programa que possivelmente indica um problema 
mais profundo.&lt;/p&gt;

&lt;p&gt;Eu já falei sobre isso
&lt;a href=&quot;/posts/pensando-em-objetos/#exemplo-1&quot;&gt;aqui&lt;/a&gt;
e nesse artigo vou abordar melhor esse assunto.&lt;/p&gt;

&lt;p&gt;Você irá entender porque não devemos utilizar 
linhas em branco dentro de Métodos.&lt;/p&gt;

&lt;h2 id=&quot;blocos-de-cdigo&quot;&gt;Blocos de Código&lt;/h2&gt;

&lt;p&gt;Por que muitos programadores ainda utilizam linhas em
branco dentro de Métodos?&lt;/p&gt;

&lt;p&gt;Simples. Eles estão separando o código de um Método
em blocos. E isso é, errado.&lt;/p&gt;

&lt;p&gt;Eu mesmo fiz isso por anos.&lt;/p&gt;

&lt;p&gt;Algumas vezes eu conseguia enxergar esse mal cheiro, então 
refatorava — criando outros Métodos — e seguia a vida.&lt;/p&gt;

&lt;p&gt;Mas na maioria das vezes eu pensava que estava “organizando o código”.
Tornando mais legível, mas “limpo”… não era verdade.&lt;/p&gt;

&lt;p&gt;Quando li esse
&lt;a href=&quot;http://www.yegor256.com/2014/11/03/empty-line-code-smell.html&quot;&gt;artigo&lt;/a&gt;
eu percebi que sempre houve algo de errado quando eu
utiliza linhas em branco.&lt;/p&gt;

&lt;p&gt;Quando existem linhas em branco dentro do Método,
significa que &lt;strong&gt;o Método está fazendo coisas demais&lt;/strong&gt;.
Um único grande procedimento, separado por com blocos 
de código…&lt;/p&gt;

&lt;p&gt;Desde então eu não codifico mais dessa forma.&lt;/p&gt;

&lt;h2 id=&quot;nao-seja-leviano&quot;&gt;Não basta retirar as Linhas em Branco&lt;/h2&gt;

&lt;p&gt;Você entendeu o problema e agora quer abrir seu editor
e começar a remover as linhas em branco… apenas remover
as linhas.&lt;/p&gt;

&lt;p&gt;Não seja leviano.&lt;/p&gt;

&lt;p&gt;Não basta abrir seu editor e começar a remover toda
linha em branco que encontrar dentro dos Métodos.&lt;/p&gt;

&lt;p&gt;Não!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A linha em branco não é o problema em si. 
Ela só indica que há um problema&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Apenas retirar essas linhas não vai sanar o problema.&lt;/p&gt;

&lt;p&gt;O que temos que fazer é &lt;strong&gt;refatorar&lt;/strong&gt; o código,
para depois removê-las.&lt;/p&gt;

&lt;h2 id=&quot;refatorando&quot;&gt;Refatorando&lt;/h2&gt;

&lt;p&gt;Se você realmente entendeu o conceito, não irá mais utilizar
linhas em branco dentro de Métodos de agora em diante.&lt;/p&gt;

&lt;p&gt;Certo?&lt;/p&gt;

&lt;p&gt;Mas você pode ir além. Você pode querer refatorar todo tipo
de código antigo ou fazer uma refatoração &lt;em&gt;on demand&lt;/em&gt;:
Refatorar apenas se encontrar Métodos com linhas em branco.&lt;/p&gt;

&lt;p&gt;Você pode seguir esses passos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Encontre um Método;&lt;/li&gt;
  &lt;li&gt;Verifique se há linhas em branco separando blocos;&lt;/li&gt;
  &lt;li&gt;Para cada bloco, extrair o código criando um novo Método;&lt;/li&gt;
  &lt;li&gt;Faça a chamada do novo Método no mesmo lugar que extraiu
  o código;&lt;/li&gt;
  &lt;li&gt;Repita o processo enquanto for necessário.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Parece besteira, mas não é.&lt;/p&gt;

&lt;p&gt;Escrever código qualquer um faz. Mas escrever um &lt;strong&gt;bom&lt;/strong&gt; código, 
no entanto, não é pra qualquer um. É necessário pensar no
longo prazo, no acoplamento, na coesão, no &lt;em&gt;design&lt;/em&gt;, deixar 
as coisas simples… é Engenharia, mas também Arte.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E a verdadeira Arte está nos detalhes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Sep 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/linhas-em-branco-no-metodo-e-mal-cheiro/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/linhas-em-branco-no-metodo-e-mal-cheiro/</guid>
      </item>
    
      <item>
        <title>A declaração WITH-DO é do Mal?</title>
        <description>&lt;p&gt;Muita gente odeia utilizar a construção WITH-DO do Pascal.
Dizem que é difícil de ler o código, introduz &lt;em&gt;bugs&lt;/em&gt;… 
esqueçam que WITH-DO existe! Eles dizem.&lt;/p&gt;

&lt;p&gt;Mas será que WITH-DO é mesmo do mal ou esses programadores é 
que não sabem utilizá-lo no momento certo?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-8bc72ed7.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Se você não sabe o que é WITH-DO, 
&lt;a href=&quot;http://www.freepascal.org/docs-html/ref/refsu63.html&quot;&gt;aqui&lt;/a&gt;
está uma boa explicação técnica.&lt;/p&gt;

&lt;p&gt;Então você define um &lt;strong&gt;bloco&lt;/strong&gt; ou &lt;strong&gt;contexto&lt;/strong&gt; e pode acessar os 
métodos e atributos de um Objeto sem a referência explícita à uma 
variável.&lt;/p&gt;

&lt;p&gt;A primeira vista parece que o objetivo é escrever menos e,
como bem sabemos, a maioria dos programadores são preguiçosos.&lt;/p&gt;

&lt;p&gt;Eu utilizo WITH-DO. Muito. E é claro, também quero escrever menos.&lt;/p&gt;

&lt;p&gt;Mas tento escrever menos da maneira correta. Não para poupar &lt;em&gt;bytes&lt;/em&gt;,
mas para deixar o código &lt;strong&gt;mais legível&lt;/strong&gt;, &lt;strong&gt;menos verboso&lt;/strong&gt; e 
&lt;strong&gt;menos acoplado&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ao longo de muitos anos utilizando WITH-DO eu posso contar 
nos dedos de apenas uma mão a quantidade de problemas que já 
tive ao utilizar essa construção, ou seja, acho que seu uso vale
a pena.&lt;/p&gt;

&lt;p&gt;Nesse artigo você aprenderá a utilizar a declaração WITH-DO.&lt;/p&gt;

&lt;h2 id=&quot;imperativo&quot;&gt;Imperativo&lt;/h2&gt;

&lt;p&gt;Creio que o &lt;strong&gt;mal&lt;/strong&gt; que WITH-DO nos traz é devido ao seu uso 100%
&lt;a href=&quot;https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa&quot;&gt;imperativo&lt;/a&gt;,
sem nenhum contexto determinando onde começa ou termina seu uso.&lt;/p&gt;

&lt;p&gt;Veja &lt;a href=&quot;http://forum.lazarus.freepascal.org/index.php?topic=32889.0&quot;&gt;aqui&lt;/a&gt; 
um exemplo de mal uso da declaração WITH-DO, postado no fórum 
do Lazarus.&lt;/p&gt;

&lt;p&gt;Vou replicar o código abaixo, caso o &lt;em&gt;link&lt;/em&gt; não esteja mais
disponível:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try
  btnOK.Enabled:=False;
  with datamodule.qryRegister do begin
    datamodule.connection.AutoCommit:=True;
    datamodule.connection.StartTransaction;
    SQL.Clear;
    SQL.Text:=
      &#39;INSERT INTO table VALUES (:name, :sex, :dateofbirth, :maritalstatus)&#39;;
    ParamByName(&#39;name&#39;).AsString:=teName.Text;
    ParamByName(&#39;sex&#39;).AsInteger:=cbSex.ItemIndex;
    ParamByName(&#39;dateofbirth&#39;).AsDate:=StrToDate(teDateOfBirth.Text);
    ParamByName(&#39;maritalstatus&#39;).AsInteger:=cbMaritalStatus.ItemIndex;          
    SQL.Clear;
    SQL.Text:=&#39;SELECT LAST_INSERT_ID() AS iddb FROM table&#39;;
    Open;
    idUser:=FieldByName(&#39;iddb&#39;).AsInteger;
    ExecSQL;
    Close;        
    try
      datamodule.connection.Commit;
      clearFields;
    except
      datamodule.connection.Rollback;
      ShowMessage(&#39;Error&#39;);
    end;
end; //with ends statement
except
  ShowMessage(&#39;Error: no connection to the database&#39;);
end;
bntOK.Enabled:=True;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O que é questionado nesse &lt;em&gt;post&lt;/em&gt; é irrelevante.&lt;/p&gt;

&lt;p&gt;Apenas analisem o código e vejam como o autor está utilizando
o WITH-DO:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Ele inicia uma transação;&lt;/li&gt;
  &lt;li&gt;Configura uma cláusula SQL;&lt;/li&gt;
  &lt;li&gt;Passa parâmetros;&lt;/li&gt;
  &lt;li&gt;Limpa a &lt;em&gt;query&lt;/em&gt;(?)&lt;/li&gt;
  &lt;li&gt;Executa a &lt;em&gt;query&lt;/em&gt;;&lt;/li&gt;
  &lt;li&gt;Commit… ClearFields…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;É um código totalmente procedural, imperativo e confuso!&lt;/p&gt;

&lt;p&gt;É muito difícil saber o que está sendo utilizado pelo 
WITH-DO e o que não está, concorda?&lt;/p&gt;

&lt;p&gt;Nesses casos, quando há ambiguidade entre métodos utilizados
pelo WITH-DO que não deveriam ser utilizados, alguns programadores
culpam o WITH-DO quando, na verdade, deveriam culpar a si mesmos
por escrever um código dessa maneira.&lt;/p&gt;

&lt;p&gt;Essa é uma maneira imperativa de codificação. Procedural.
Um código altamente acoplado que, realmente, não deveria utilizar
WITH-DO porque só piora as coisas.&lt;/p&gt;

&lt;h2 id=&quot;declarativo&quot;&gt;Declarativo&lt;/h2&gt;

&lt;p&gt;A codificação declarativa é utilizada nas linguagens funcionais.
Também é utilizada, por exemplo, quando codificamos SQL.&lt;/p&gt;

&lt;p&gt;Na codificação declarativa você define &lt;strong&gt;o que fazer&lt;/strong&gt;, mas não se
importa &lt;strong&gt;como será feito&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM Clients ORDER BY name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando escrevemos o código SQL acima, não nos preocupamos como o
SGBD irá trazer o resultado; quais índices; quais tuplas. Apenas
queremos o resultado o mais rápido possível.&lt;/p&gt;

&lt;p&gt;Assim deve ser a codificação 
&lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientada a Objetos&lt;/a&gt;,
onde os Objetos
&lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;pensam e tomam as próprias decisões&lt;/a&gt;,
sem que tenha um “controlador” informando &lt;strong&gt;como fazer&lt;/strong&gt; linha a linha.&lt;/p&gt;

&lt;p&gt;E o que isso tem haver com o uso do WITH-DO?&lt;/p&gt;

&lt;p&gt;Bem, o WITH-DO nos ajuda a transformar um código procedural em algo mais
declarativo, mais Orientado a Objetos.&lt;/p&gt;

&lt;p&gt;Um código mais Orientado a Objetos é mais &lt;strong&gt;legível&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Um código com menos declarações de variáveis, é menos &lt;strong&gt;verboso&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;E se você não declara variáveis de tipos específicos, automaticamente
seu código é &lt;strong&gt;menos acoplado&lt;/strong&gt;, com menos usos de Units para determinar
os tipos das variáveis.&lt;/p&gt;

&lt;p&gt;Vou lhe mostrar como.&lt;/p&gt;

&lt;p&gt;Vamos pegar o mesmo código procedural acima e reescrever utilizando
WITH-DO.&lt;/p&gt;

&lt;p&gt;Esse código será apenas &lt;strong&gt;um pouco mais&lt;/strong&gt; Orientado a Objetos, com
uma melhor legibilidade que o primeiro:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try
  btnOK.Enabled := False;
  with TDatabase.Instance.StartTransaction do
  try
    with 
      TQuery.New(
        &#39;INSERT INTO table VALUES (&#39; +
        &#39;  :name, :sex, :dateofbirth, :maritalstatus)&#39;
      )
    do
    begin
      Params
        .Add(&#39;name&#39;, ftString, teName.Text)
        .Add(&#39;sex&#39;, ftInteger, cbSex.ItemIndex)
        .Add(&#39;dateofbirth&#39;, ftDateTime, StrToDate(teDateOfBirth.Text))
        .Add(&#39;maritalstatus&#39;, ftInteger, cbMaritalStatus.ItemIndex)
      Execute;
    end;
    idUser := 
      TQuery.New(&#39;SELECT LAST_INSERT_ID() AS iddb FROM table&#39;)
        .Open
        .Field(&#39;iddb&#39;).AsInteger;
    Commit;
  except
    Rollback;
    raise;
  end;
except
  ShowMessage(&#39;Error: no connection to the database&#39;);
end;
bntOK.Enabled:=True;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;O código continua ruim, porém melhor.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Há muita coisa acontecendo num único método.&lt;/p&gt;

&lt;p&gt;Não deveríamos parar a refatoração agora.
Cada execução deveria estar num método a parte…&lt;/p&gt;

&lt;p&gt;No entanto o objetivo é mostrar o uso do WITH-DO e 
acho que dá pra ver a diferença, certo?&lt;/p&gt;

&lt;p&gt;Ao todo são apenas 2 declarações de WITH-DO. Cada declaração tem 
um &lt;strong&gt;contexto&lt;/strong&gt; bem definido por &lt;em&gt;TRY-EXCEPT&lt;/em&gt; ou &lt;em&gt;BEGIN-END&lt;/em&gt;. 
Não há ambiguidade.&lt;/p&gt;

&lt;p&gt;A declaração &lt;code&gt;TDatabase.Instance.StartTransaction&lt;/code&gt; irá retornar um
Objeto do tipo &lt;code&gt;ITransaction&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A declaração &lt;code&gt;TQuery.New&lt;/code&gt; irá retornar um Objeto do tipo &lt;code&gt;IQuery&lt;/code&gt;, 
através do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O código ficou mais legível.&lt;/p&gt;

&lt;p&gt;Não há declarações de variáveis.&lt;/p&gt;

&lt;p&gt;Não há variáveis globais como existe no código procedural — 
&lt;code&gt;datamodule.qryRegister&lt;/code&gt; é um Objeto global que, possivelmente, é 
reutilizado em toda a aplicação, sendo um &lt;em&gt;design&lt;/em&gt; muito errado, 
não &lt;em&gt;thread-safe&lt;/em&gt; e gerador de problemas.&lt;/p&gt;

&lt;h2 id=&quot;orientado-a-objetos&quot;&gt;Orientado a Objetos&lt;/h2&gt;

&lt;p&gt;A declaração WITH-DO nos ajuda a escrever um código mais simples e elegante.
Mas sejamos sinceros. Utilizamos WITH-DO para produzirmos código
procedural. E não tem nada de errado nisso, visto que é quase
impossível codificar 100% Orientado a Objetos em linguagens que
são imperativas.&lt;/p&gt;

&lt;p&gt;Uma vez que WITH-DO define uma variável implícita, o programador
pode chamar os &lt;strong&gt;métodos na sequência&lt;/strong&gt;, linha a linha.&lt;/p&gt;

&lt;p&gt;O uso de WITH-DO deixa o código melhor, mas se dá pra codificar
Orientado a Objetos, é o que devemos fazer.&lt;/p&gt;

&lt;p&gt;Então vou reescrever o código.&lt;/p&gt;

&lt;p&gt;Não há espaço aqui para a definição das Classes utilizadas
no exemplo.&lt;/p&gt;

&lt;p&gt;Qualquer dúvida, basta postar nos comentários.&lt;/p&gt;

&lt;p&gt;Abaixo um hipotético código &lt;strong&gt;declarativo&lt;/strong&gt; e &lt;strong&gt;Orientado a Objetos&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;btnOK.Enabled := False;
try
  idUser :=  
    TDatabase.Instance.Transaction(
      TTasks.New
        .Add(
          TQueryTask.New(
            &#39;INSERT INTO table VALUES (&#39; +
            &#39;  :name, :sex, :dateofbirth, :maritalstatus)&#39;,
            TDataParams.New
              .Add(&#39;name&#39;, ftString, teName.Text)
              .Add(&#39;sex&#39;, ftInteger, cbSex.ItemIndex)
              .Add(&#39;dateofbirth&#39;, ftDateTime, teDateOfBirth.Text)
              .Add(&#39;maritalstatus&#39;, ftInteger, cbMaritalStatus.ItemIndex)
          )
        )
        .Add(
          TQueryTask.New(&#39;SELECT LAST_INSERT_ID() AS iddb FROM table&#39;)            
        )
    )
    .Results
    .Get(&#39;iddb&#39;).AsInteger;
finally      
  bntOK.Enabled := True;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O que está ocorrendo aqui?&lt;/p&gt;

&lt;p&gt;Bem, temos &lt;code&gt;TQueryTask&lt;/code&gt; que implementa &lt;code&gt;ITask&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Temos uma lista de &lt;em&gt;tasks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A lista é passada para &lt;code&gt;Transaction&lt;/code&gt; que, internamente, irá executar
cada &lt;em&gt;task&lt;/em&gt; — chamando o método &lt;code&gt;Execute&lt;/code&gt; que não está explícito no
código — dentro de uma transação.&lt;/p&gt;

&lt;p&gt;Por fim &lt;code&gt;Transaction&lt;/code&gt; tem um método &lt;code&gt;Results&lt;/code&gt; que pode ser do tipo
&lt;code&gt;IDataParams&lt;/code&gt; e através de &lt;code&gt;Get&lt;/code&gt; é retornado um valor.&lt;/p&gt;

&lt;p&gt;O que acontece dentro desses Objetos é de responsabilidade deles.
O programador é apenas o &lt;strong&gt;orquestrador&lt;/strong&gt; dessa comunicação.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Na minha opinião WITH-DO pode e deve ser utilizado.&lt;/p&gt;

&lt;p&gt;Muita gente deseja cada vez mais &lt;em&gt;features&lt;/em&gt; para a linguagem
Object Pascal. Mas será que já sabemos utilizar, de forma eficaz,
tudo o que já temos nessa &lt;strong&gt;elegante linguagem&lt;/strong&gt; chamada Object Pascal?&lt;/p&gt;

&lt;p&gt;Até onde eu sei, essa &lt;em&gt;feature&lt;/em&gt; não existe em nenhuma outra linguagem.&lt;/p&gt;

&lt;p&gt;Apenas nós temos o WITH-DO!&lt;/p&gt;

&lt;p&gt;Mas será que sou o único que usa e aprecia essa &lt;em&gt;feature&lt;/em&gt;? :)&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Sep 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/a-declaracao-with-do-e-do-mal/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/a-declaracao-with-do-e-do-mal/</guid>
      </item>
    
      <item>
        <title>Procedural é fácil, Orientado a Objetos é difícil</title>
        <description>&lt;p&gt;Por que ainda temos discussões sobre a Programação Procedural ser mais fácil do que a Programação Orientada a Objetos? É claro que Programar no paradigma Procedural é mais fácil.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1470208564179-dd5b52a0d010.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Você olha para um código com 5 instâncias de Objetos, agumentos de Construtores, consumo de memória, polimorfismo e pensa:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eu poderia fazer a mesma coisa com 10 linhas de código Procedural.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A performance — você diria — poderia ser melhor, iria consumir menos memória e, claro, é muito mais fácil codificar.&lt;/p&gt;

&lt;p&gt;Eu concordo… em parte.&lt;/p&gt;

&lt;p&gt;Então por que escolher a &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Por que fazer da maneira “mais difícil”?&lt;/p&gt;

&lt;p&gt;Por que criar um &lt;a href=&quot;https://en.wikipedia.org/wiki/Overhead_(computing)&quot;&gt;&lt;em&gt;overhead&lt;/em&gt;&lt;/a&gt; “desnecessário”?&lt;/p&gt;

&lt;iframe src=&quot;https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Fobjectpascalprogramming%2Fposts%2F316968578655967&amp;amp;width=500&quot; width=&quot;500&quot; height=&quot;180&quot; style=&quot;border:none;overflow:hidden&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; allowtransparency=&quot;true&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Se pensarmos apenas no &lt;em&gt;overhead&lt;/em&gt; que traz a Orientação a Objetos, vamos então codificar nossos sistemas em apenas um único arquivo, usando &lt;em&gt;GO TO&lt;/em&gt; e código ASSEMBLY.&lt;/p&gt;

&lt;p&gt;Orientação a Objetos é sobre &lt;strong&gt;manutenabilidade&lt;/strong&gt; no longo prazo.&lt;/p&gt;

&lt;p&gt;É sobre não pensar como um controlador ou CPU, mas como &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidades&lt;/a&gt; auto-suficientes que &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;pensam e tomam decisões&lt;/a&gt; por conta própria.&lt;/p&gt;

&lt;p&gt;Não é sobre estar certo ou errado, fazer diagramas bonitos ou porque fica legal por no Currículo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Orientação a Objetos é sobre resolver um problema de forma sustentável.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Por isso escolhemos desenvolver seguindo esse paradigma.&lt;/p&gt;

&lt;p&gt;Em 1 hora é possível fazer muita coisa de forma Procedural, enquanto na Orientação a Objetos podemos ficar 1 hora apenas tentando identificar o melhor &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nome para uma Classe&lt;/a&gt;, quais são as &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidades&lt;/a&gt; que fazem parte do problema, quais os Contextos…&lt;/p&gt;

&lt;p&gt;E se eu lhe dissesse que podemos ficar “apenas” &lt;a href=&quot;/posts/pensando-em-objetos/&quot;&gt;pensando&lt;/a&gt; por 1 ou 2 semanas, sem escrever nenhuma linha de código?&lt;/p&gt;

&lt;p&gt;É verdade, acontece.&lt;/p&gt;

&lt;p&gt;Não adianta fazer um sistema rapidamente se seu código não é &lt;strong&gt;sustentável&lt;/strong&gt; no longo prazo.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Softwares&lt;/em&gt; sempre &lt;strong&gt;mudam&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Orientação a Objetos é sobre organização.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nós passamos a maior parte do tempo não codificando novas &lt;em&gt;features&lt;/em&gt;, mas sim lendo e tentando entender o código.&lt;/p&gt;

&lt;p&gt;De que adianta ter um código de execução mais rápida em 100 ms se daqui a um mês ninguém sabe como alterá-lo?&lt;/p&gt;

&lt;p&gt;Orientação a Objetos não é mais difícil de codificar, é apenas é mais trabalhoso.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mas vale a pena.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Por que no fim você irá trabalhar menos.&lt;/p&gt;

&lt;p&gt;Talvez com um pouco mais de código, é verdade, mas terá menos &lt;em&gt;bugs&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Menos &lt;em&gt;debugging&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Menos problemas.&lt;/p&gt;

&lt;p&gt;Orientação a Objetos agrega &lt;strong&gt;qualidade&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;E qualidade, é o que mais importa.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Sep 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/procedural-e-facil-orientado-a-objetos-e-dificil/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/procedural-e-facil-orientado-a-objetos-e-dificil/</guid>
      </item>
    
      <item>
        <title>Microservices com Delphi — Parte Final</title>
        <description>&lt;p&gt;Uma arquitetura que utiliza Microservices tem seus prós e contras como qualquer outra tecnologia. Será que essa arquitetura foi uma boa escolha para o projeto?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1454023989775-79520f04322c.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No &lt;a href=&quot;/posts/microservices-delphi-parte-3/&quot;&gt;artigo anterior&lt;/a&gt; eu lhe mostrei como codificar uma Classe de Negócio para fazer a comunicação com um Microservice utilizando todo o arcabouço apresentado na primeira parte dessa série.&lt;/p&gt;

&lt;p&gt;Nesse artigo você irá ver:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Tratamento de Exceções&lt;/strong&gt;: Quando algo dá errado nos Microservices ou na comunicação com eles;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Links&lt;/strong&gt;: Separei alguns artigos interessantes sobre o assunto;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;tratamento-de-excecoes&quot;&gt;Tratamento de Exceções&lt;/h2&gt;

&lt;p&gt;Todo &lt;em&gt;software&lt;/em&gt; precisa tratar erros e exceções, e é claro que estamos fazendo isso.&lt;/p&gt;

&lt;p&gt;Na Unit &lt;a href=&quot;/posts/microservices-delphi-parte-2/#unit-microservicesa&quot;&gt;AcmeMicroServiceA.pas&lt;/a&gt; o tratamento de exceções é feito no método &lt;code&gt;TMicroServiceClient.Send&lt;/code&gt;, verificando o &lt;code&gt;Code&lt;/code&gt; de retorno do protocolo HTTP.&lt;/p&gt;

&lt;p&gt;Se houver erro, definimos um protocolo privado que descreve como a mensagem para o &lt;em&gt;Client&lt;/em&gt; deve ser. Nada mais é do que um XML com &lt;em&gt;nodes&lt;/em&gt; específicos que descrevem o erro ou exceção.&lt;/p&gt;

&lt;p&gt;Abaixo o código modificado que trata erros e exceções. O código em produção é um pouco mais elaborado, no entanto acredito que com esse exemplo você irá entender como o tratamento ocorre no projeto real.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TMicroServiceClient.Send(
  const Content: string): IMicroServiceResponse;
begin
  with Response(Content) do
  begin
    Result := TMicroServiceResponse.New(
      Code,
      TXMLFactory.New(&#39;ISO-8859-1&#39;, Stream).Document
    );
    case Code of
      // BAD REQUEST
      400..499:
        raise EMicroService.Create(
          Result
            .XML
            .DocumentElement
            .ChildNodes[&#39;UserMessage&#39;].Text
        );
      // SERVER ERROR
      500..510:
        raise EMicroService.Create(
          Result
            .XML
            .DocumentElement
            .ChildNodes[&#39;DevMessage&#39;].Text
        );
    end;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que para cada tipo de erro/exceção, um &lt;em&gt;node&lt;/em&gt; (ou &lt;em&gt;nodes&lt;/em&gt;) específico é utilizado para obter a informação.&lt;/p&gt;

&lt;p&gt;No &lt;em&gt;Client&lt;/em&gt; Delphi, o &lt;code&gt;Code&lt;/code&gt; também é acessível através da Interface &lt;code&gt;IMicroServiceResponse&lt;/code&gt;, então o &lt;em&gt;Client&lt;/em&gt; pode tomar decisões específicas para casos que não gerem uma exceção.&lt;/p&gt;

&lt;p&gt;Veja &lt;a href=&quot;http://www.restapitutorial.com/httpstatuscodes.html&quot;&gt;aqui&lt;/a&gt; uma lista de &lt;em&gt;HTTP Status Codes&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;

&lt;p&gt;Separei alguns links interessantes de artigos e vídeos que serviram de inspiração para escrever essa série, assim como foram fontes de informações para o projeto.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.infoq.com/br/presentations/vantagens-e-desvantagens-de-uma-arquitetura-microservices&quot;&gt;Vantagens e desvantagens de uma arquitetura microservices: uma abordagem rica em exemplos&lt;/a&gt; é uma apresentação em vídeo de quase 1 hora que fala sobre os prós e contras em utilizar essa arquitetura. O autor fala sobre &lt;a href=&quot;http://www.martinfowler.com/bliki/StranglerApplication.html&quot;&gt;Strangler Application&lt;/a&gt; que é o mesmo princípio que estamos utilizando no projeto.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.infoq.com/br/articles/seven-uservices-antipatterns&quot;&gt;Sete antipadrões para microservices&lt;/a&gt; alerta sobre algumas coisas que devem ser evitadas, na opinião do autor, quando utilizamos a arquitetura de Microservices.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://medium.com/@mwhitt.w/preventing-tight-data-coupling-between-microservices-df30e1e24311#.wl6r7hcfz&quot;&gt;Preventing Tight Data Coupling Between Microservices&lt;/a&gt; é um artigo em Inglês interessante sobre acoplamento de dados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://medium.com/@skamille/microservices-real-architectural-patterns-68bd83bbb6cd#.hrsdvq3rj&quot;&gt;Microservices: Real Architectural Patterns&lt;/a&gt; é outro artigo em Inglês que fala sobre arquitetura e CRUD.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A escolha pela arquitetura de Microservices está sendo satisfatória.&lt;/p&gt;

&lt;p&gt;Microservices são como &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;instâncias de Objetos&lt;/a&gt; pela rede.&lt;/p&gt;

&lt;p&gt;Assim como Objetos, cada Microservice deve implementar apenas &lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/&quot;&gt;uma única responsabilidade&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Quando falamos sobre Microservices, WebServices, Multi-camadas, protocolos… tudo isso parece muito complicado. Mas se você souber como as coisas funcionam, poderá remover tudo que é &lt;strong&gt;desnecessário&lt;/strong&gt; para o &lt;strong&gt;seu negócio&lt;/strong&gt; e se concentrar apenas no &lt;strong&gt;essencial&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Você não precisa implementar &lt;strong&gt;tudo&lt;/strong&gt; o que dizem para implementar. Utilize tecnologias que fazem sentido para seu negócio e comece simples.&lt;/p&gt;

&lt;p&gt;A migração está longe de estar concluída. O sistema tem poucos meses, mas apenas poucos dias de trabalho &lt;em&gt;full time&lt;/em&gt; na codificação e integração dos Microservices.&lt;/p&gt;

&lt;p&gt;Por enquanto estamos indo bem.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Aug 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/microservices-delphi-parte-final/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/microservices-delphi-parte-final/</guid>
      </item>
    
      <item>
        <title>Microservices com Delphi — Parte 3</title>
        <description>&lt;p&gt;Podemos utilizar diretamente uma instância de &lt;code&gt;TMicroServiceClient&lt;/code&gt;, passar um XML como parâmetro e obter a resposta. Mas isso não seria o ideal. Devemos ter Classes de Negócio, com suas próprias Regras e entrada/saída de informações.&lt;/p&gt;

&lt;p&gt;Vamos codificar uma Classe de Negócio, que construa seu próprio XML e utilize, internamente, uma instância do &lt;em&gt;Client&lt;/em&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1448932223592-d1fc686e76ea.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No &lt;a href=&quot;/posts/microservices-delphi-parte-2/&quot;&gt;artigo anterior&lt;/a&gt; eu escrevi sobre o Módulo MicroService e Localização de Serviços.&lt;/p&gt;

&lt;p&gt;Nesse artigo você irá aprender a codificar uma Classe de Negócio que irá consumir um Microservice, utilizando o Módulo já apresentado ateriormente.&lt;/p&gt;

&lt;p&gt;Também aprenderá como transformar XML em dados tabulares para apresentá-los numa &lt;em&gt;Grid&lt;/em&gt;, por exemplo.&lt;/p&gt;

&lt;h2 id=&quot;classe-txmlfactory&quot;&gt;Classe TXMLFactory&lt;/h2&gt;

&lt;p&gt;Uma instância de &lt;code&gt;TXMLFactory&lt;/code&gt; é utilizada no &lt;em&gt;Client&lt;/em&gt;, especificamente no método &lt;code&gt;TMicroServiceClient.Send&lt;/code&gt;, que não foi abordada no artigo anterior.&lt;/p&gt;

&lt;p&gt;É uma Classe simples mas importante, utilizada tanto para montar tanto o XML de envio como o de retorno.&lt;/p&gt;

&lt;p&gt;O Delphi 7 não trabalha com &lt;em&gt;encode&lt;/em&gt; &lt;code&gt;UTF-8&lt;/code&gt; por padrão mas os Microservices em Java trabalham no formato &lt;code&gt;UTF-8&lt;/code&gt;. Então o &lt;em&gt;Client&lt;/em&gt; deve fazer todas as solicitações nesse formato.&lt;/p&gt;

&lt;p&gt;O resultado, no entanto, é convertido para &lt;code&gt;ISO-8859-1&lt;/code&gt; — que é o formato que estou utilizando no Delphi 7 — antes dos dados serem disponibilizados para o resto da aplicação.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TXMLFactory&lt;/code&gt; facilita o envio e retorno.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TXMLFactory = class(TInterfacedObject, IXMLFactory)
  private
    FEncoding: string;
    FStream: IDataStream;
  public
    constructor Create(const Encoding: string; Stream: IDataStream); reintroduce;
    class function New(const Encoding: string; Stream: IDataStream): IXMLFactory; overload;
    class function New(const Encoding: string): IXMLFactory; overload;
    class function New: IXMLFactory; overload;
    function Document: IXMLDocument;
  end;

{ TXMLFactory }

constructor TXMLFactory.Create(const Encoding: string; Stream: IDataStream);
begin
  inherited Create;
  FEncoding := Encoding;
  FStream := Stream;
end;

class function TXMLFactory.New(const Encoding: string;
  Stream: IDataStream): IXMLFactory;
begin
  Result := Create(Encoding, Stream);
end;

class function TXMLFactory.New(const Encoding: string): IXMLFactory;
begin
  Result := New(Encoding, TDataStream.New);
end;

class function TXMLFactory.New: IXMLFactory;
begin
  Result := New(&#39;UTF-8&#39;);
end;

function TXMLFactory.Document: IXMLDocument;
var
  Buf: TMemoryStream;
begin
  Result := TXMLDocument.Create(nil);
  Buf := TMemoryStream.Create;
  try
    Result.Options := [];
    Result.Active := True;
    Result.Version := &#39;1.0&#39;;
    if FStream.Size &amp;gt; 0 then
    begin
      FStream.Save(Buf);
      Result.LoadFromStream(Buf);
    end;
    Result.Encoding := FEncoding;
  finally
    Buf.Free;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;consumindo-um-servico&quot;&gt;Consumindo um Serviço&lt;/h2&gt;

&lt;p&gt;Nesse projeto eu defini que todo consumo de qualquer Microservice será feito através de Classes de Negócio. Então poderei ter o mesmo número de Classes correspondende ao número de Microservices ou até mais, pois uma Classe de Negócio poderia fazer uso de mais de um Microservice.&lt;/p&gt;

&lt;p&gt;Iremos implementar uma Classe de Negócio simples e hipotética, visto que não poderia disponibilizar o código real do sistema quando se trata do negócio da empresa.&lt;/p&gt;

&lt;p&gt;A Classe proposta é a &lt;code&gt;TFaturasService&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A instância dessa Classe irá receber um parâmetro do tipo &lt;code&gt;IDataUId&lt;/code&gt; — uma classe que encapsula um &lt;em&gt;GUID&lt;/em&gt; — para retornar os dados de uma Fatura.&lt;/p&gt;

&lt;p&gt;Segue sua implementação abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFaturasService = class(TInterfacedObject, IMicroServiceAction)
  private
    FUId: IDataUId;
  public
    constructor Create(UId: IDataUId); reintroduce;
    class function New(UId: IDataUId): IMicroServiceAction;
    function Act: IMicroServiceResponse;
  end;

{ TFaturasService }

constructor TFaturasService.Create(UId: IDataUId);
begin
  inherited Create;
  FUId := UId;
end;

class function TFaturasService.New(
  UId: IDataUId): IMicroServiceAction;
begin
  Result := Create(UId);
end;

function TFaturasService.Act: IMicroServiceResponse;

  function XML: IXMLDocument;
  begin
    Result := TXMLFactory.New.Document;
    with Result.AddChild(&#39;Params&#39;) do
    begin
      AddChild(&#39;uid&#39;).Text := FUId.AsString;
      AddChild(&#39;active&#39;).Text := &#39;True&#39;;
    end;
  end;

begin
  Result :=
    TMicroServiceClient.New(
      TMicroServiceParams.New(
        &#39;financ:faturas-service&#39;
      )
      .Find
    )
    .Send(XML)
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;passo-a-passo&quot;&gt;O código passo-a-passo&lt;/h3&gt;

&lt;p&gt;Vamos entender o código juntos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;TFaturasService&lt;/code&gt; é uma Classe de Negócio que implementa &lt;code&gt;IMicroServiceAction&lt;/code&gt; (veja &lt;a href=&quot;/posts/microservices-delphi-parte-2/#introducao&quot;&gt;aqui&lt;/a&gt;);&lt;/li&gt;
  &lt;li&gt;O Objeto &lt;code&gt;TXMLFactory&lt;/code&gt; é utilizado para gerar o XML de envio;&lt;/li&gt;
  &lt;li&gt;O Objeto &lt;code&gt;TMicroServiceParams&lt;/code&gt; localiza o serviço através do seu &lt;code&gt;name&lt;/code&gt; (único) e traz as informações em forma de parâmetros;&lt;/li&gt;
  &lt;li&gt;O Objeto &lt;code&gt;TMicroServiceClient&lt;/code&gt; envia o XML de envio e retorna uma instância de &lt;code&gt;IMicroServiceResponse&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;O objeto retornado contém um &lt;code&gt;XML: IXMLDocument&lt;/code&gt; que é a resposta do Microservice codificado em Java;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;E é isso.&lt;/p&gt;

&lt;p&gt;Uma implementação completa de um serviço.&lt;/p&gt;

&lt;p&gt;Se você esperava algo mais complexo, sinto decepcioná-lo, pois a implementação é tão simples quanto isso. :)&lt;/p&gt;

&lt;h3 id=&quot;utilizando-a-classe&quot;&gt;Utilizando a Classe de Negócio&lt;/h3&gt;

&lt;p&gt;Uma vez que a Classe de Negócio foi implementada, poderá ser utilizada em muitas partes do sistema sem haver duplicação de código; não precisará montar o mesmo XML em vários lugares; não precisará passar os mesmos parâmetros para o &lt;em&gt;Client&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Então, como utilizar a nova Classe no nosso código?&lt;/p&gt;

&lt;p&gt;Aqui está um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TForm1.FillData;
begin
  TXMLClientDataSetAdapter.New(
    FModule.FaturaClient,
    TFaturasService.New(FUId).Act.XML
  )
  .Adapt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No Delphi 7 utilizamos &lt;code&gt;TClientDataSet&lt;/code&gt; para manter os dados tabulares (linhas e colunas) em memória, exibir numa &lt;em&gt;Grid&lt;/em&gt; ou em qualquer outro &lt;em&gt;widget&lt;/em&gt;. Mas os dados dos Microservices vem no formato de XML. Esses dados precisam ser convertidos para um formato tabular.&lt;/p&gt;

&lt;p&gt;Para isso temos uma outra Classe responsável por fazer essa conversão da forma mais genérica possível.&lt;/p&gt;

&lt;p&gt;Essa Classe é a &lt;code&gt;TXMLClientDataSetAdapter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ela recebe 2 parâmetros:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Uma instância de um &lt;code&gt;TClientDataSet&lt;/code&gt;, que no exemplo está em um &lt;code&gt;TDataModule&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Uma instância de &lt;code&gt;IXMLDocument&lt;/code&gt;, que é obtido através da chamada &lt;code&gt;Act.XML&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Então executamos o método &lt;code&gt;Adapt&lt;/code&gt; e pronto, temos um XML convertido em dados tabulares.&lt;/p&gt;

&lt;p&gt;Será que o código da Classe &lt;code&gt;TXMLClientDataSetAdapter&lt;/code&gt; é complexo?&lt;/p&gt;

&lt;p&gt;Não. É tão simples quanto a implementação da Classe de Negócio.&lt;/p&gt;

&lt;p&gt;Veja a implementação do método &lt;code&gt;Adapt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TXMLClientDataSetAdapter.Adapt: IDataAdapter;
var
  I: Integer;
  Field: TField;
begin
  Result := Self;
  if not Assigned(FSource) then
    Exit;
  FDest.DisableControls;
  try
    while Assigned(FSource) do
    begin
      FDest.Append;
      for I := 0 to FSource.ChildNodes.Count -1 do
      begin
        with FSource.ChildNodes[I] do
        begin
          Field := FDest.FindField(NodeName);
          if Assigned(Field) and (Text &amp;lt;&amp;gt; &#39;&#39;) then
            Field.Value := Text;
        end;
      end;
      FSource := FSource.NextSibling;
    end;
  finally
    FDest.First;
    FDest.EnableControls;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ele adapta o XML para o formato tabular e no fim temos uma instância de &lt;code&gt;TClientDataSet&lt;/code&gt; com os dados provenientes do XML.&lt;/p&gt;

&lt;h2 id=&quot;ser-um-substituto-ao-datasnap&quot;&gt;Será um substituto ao &lt;em&gt;DataSnap&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;Eu ainda não terminei essa série, porém já recebi alguns e-mails de alguns leitores perguntando se é possível utilizar essa solução como um substituto ao &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Seattle/en/Developing_DataSnap_Applications&quot;&gt;&lt;em&gt;Delphi DataSnap&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Minha resposta é que o &lt;em&gt;DataSnap&lt;/em&gt; tem muito, muito código implementado com inúmeras facilidades para os desenvolvedores. Então não é um substituto — e mesmo se esse fosse o objetivo, estaríamos muito longe de concluí-lo.&lt;/p&gt;

&lt;p&gt;É melhor ou pior?&lt;/p&gt;

&lt;p&gt;Depende do tipo do projeto.&lt;/p&gt;

&lt;p&gt;Nesse projeto a versão do Delphi é a 7. A empresa não quer mais investir no Delphi e vai substituí-lo, aos poucos, por Java ou mesmo C#. Então não haveria motivos em utilizar &lt;em&gt;DataSnap&lt;/em&gt;, visto que a linguagem irá mudar no futuro.&lt;/p&gt;

&lt;h2 id=&quot;desvantagens-by-design&quot;&gt;Desvantagens &lt;em&gt;by design&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;É claro que há desvantagens na solução proposta. Sempre há desvantagens.&lt;/p&gt;

&lt;p&gt;Uma grande desvantagem é que novas informações não são, necessariamente, visíveis automaticamente quando há alterações nos Microservices.&lt;/p&gt;

&lt;p&gt;Por exemplo.&lt;/p&gt;

&lt;p&gt;Caso o Microservice acima enviasse uma nova informação chamada “status”, ela não iria aparecer automaticamente numa &lt;em&gt;Grid&lt;/em&gt; do Delphi. Esse campo teria que ser incluso, manualmente, no &lt;em&gt;ClientDataSet&lt;/em&gt; que fosse receber os dados.&lt;/p&gt;

&lt;p&gt;O que eu quero dizer é que a aplicação Delphi não se adapta automaticamente as mudanças dos Microservices. É possível fazer, porém exigiria muito mais tempo de desenvolvimento.&lt;/p&gt;

&lt;p&gt;A solução é simples porque estamos utilizando a premissa &lt;a href=&quot;https://en.wikipedia.org/wiki/Convention_over_configuration&quot;&gt;&lt;em&gt;Convention over configuration&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Se há dados, então eles estarão no formato XML;&lt;/li&gt;
  &lt;li&gt;Os &lt;em&gt;fields&lt;/em&gt; de um &lt;em&gt;ClientDataSet&lt;/em&gt; devem ter o mesmo nome dos &lt;em&gt;fields&lt;/em&gt; que são esperados nos Microservices e vice-versa;&lt;/li&gt;
  &lt;li&gt;Utilizamos os mesmos formatos para Data, Hora e Números decimais.&lt;/li&gt;
  &lt;li&gt;Etc.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Apesar de não vermos isso como desvantagens, não deixa de ler uma limitação.&lt;/p&gt;

&lt;h2 id=&quot;no-proximo-artigo&quot;&gt;No próximo artigo…&lt;/h2&gt;

&lt;p&gt;Você acabou de ver uma implementação simples, &lt;em&gt;“made in home”&lt;/em&gt;, para trabalhar com interoperabilidade entre sistemas distintos utilizando Microservices que nada mais são do que requisições HTTP enviando e recebendo XML.&lt;/p&gt;

&lt;p&gt;Finalizaremos essa série no &lt;a href=&quot;/posts/microservices-delphi-parte-final/&quot;&gt;próximo artigo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Aug 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/microservices-delphi-parte-3/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/microservices-delphi-parte-3/</guid>
      </item>
    
  </channel>
</rss>
