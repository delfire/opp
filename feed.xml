<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Desenvolvimento Web com fpWeb Framework</title>
        <description>&lt;p&gt;Durante anos, o desenvolvimento Web no Delphi e Lazarus sempre seguiram o antigo padrão Web Broker.
Felizmente, estamos vivendo uma nova fase no ambiente Object Pascal.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-maik-jonietz-535261-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Maik Jonietz on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A tecnologia Web Broker foi apresentada no &lt;a href=&quot;https://en.wikipedia.org/wiki/Delphi_(IDE)#Borland_Delphi_3&quot;&gt;Delphi 3&lt;/a&gt; em 1997 e desde esse tempo não houve muitas melhorias. Pelo menos, não na parte do &lt;em&gt;arquitetura&lt;/em&gt; das aplicações.&lt;/p&gt;

&lt;p&gt;O Web Broker é um sistema baseado em Web Modules. Cada Web Module pode ter uma lista de Actions, e cada Action corresponde a uma URL onde você define um &lt;em&gt;evento&lt;/em&gt; que será executado.&lt;/p&gt;

&lt;p&gt;Eu venho construindo aplicações Web em Object Pascal desde os tempos do Delphi 4~5. Essas aplicações sempre tiveram uma boa performance quando utilizávamos o padrão &lt;a href=&quot;https://pt.wikipedia.org/wiki/ISAPI&quot;&gt;ISAPI&lt;/a&gt;. Entretanto, a arquitetura estava longe de ser a ideal. Na minha opinião, tentaram utilizar a abordagem RAD em um contexto não-RAD. Funcionava, e ainda funciona, mas não era “empolgante” desenvolver tais aplicações.&lt;/p&gt;

&lt;h2 id=&quot;fpweb&quot;&gt;fpWeb Framework&lt;/h2&gt;

&lt;p&gt;A implementação atual do fpWeb — framework Web disponível no Free Pascal 3.0.4 — é bem diferente. Eles mantiveram a compatibilidade com o estilo Web Broker antigo, caso você ainda precise dele para sistemas legados, mas nos deram a possibilidade de utilizar um sistema de &lt;em&gt;rotas&lt;/em&gt; muito melhor além de podermos compilar nossas aplicações utilizando diferentes tipos de modelos como Standalone, CGI ou FastCGI.&lt;/p&gt;

&lt;h2 id=&quot;rotas&quot;&gt;Rotas&lt;/h2&gt;

&lt;p&gt;Com o novo sistema de rotas não é mais necessário utilizar Web Modules e eventos, basta registrar uma classe ou mesmo uma simples procedure para representar uma ação quando uma determinada URL for acessada.&lt;/p&gt;

&lt;p&gt;Além disso, não estamos mais presos às URLs com o padrão &lt;code&gt;/module/action&lt;/code&gt; utilizados no padrão Web Broker. No novo sistema, você pode definir e registrar suas URLs do jeito que quiser.&lt;/p&gt;

&lt;p&gt;Exemplo. Através da &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;, você pode definir uma classe que irá responder a uma determinada URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TMyHandler = Class(TRouteObject)
public
  procedure HandleRequest(
    ARequest: TRequest; AResponse: TResponse); override;
end;

initialization
  HTTPRouter.RegisterRoute(
    &#39;/my/route/in/action&#39;, rmAll, TMyHandler
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A classe &lt;code&gt;TRouteObject&lt;/code&gt; faz parte da fpWeb. Utilize essa classe como base para suas classes. É possível utilizar desde uma simples procedure ou até mesmo uma classe que implemente &lt;code&gt;IRouteInterface&lt;/code&gt;. Mas, na minha opinião, a melhor opção é utilizar apenas classes por ser o método mais simples e organizado para codificar as rotas.&lt;/p&gt;

&lt;h2 id=&quot;padroes&quot;&gt;Standalone, CGI ou FastCGI&lt;/h2&gt;

&lt;p&gt;A depuração de aplicações Web nunca foi fácil. Uma aplicação ISAPI, por exemplo, é executada no formato multi thread e depurar uma aplicação nesse formato é um desafio.&lt;/p&gt;

&lt;p&gt;A fpWeb facilita o desenvolvimento e depuração. Através de &lt;a href=&quot;/diretivas-de-compilacao&quot;&gt;diretivas de compilação&lt;/a&gt;, você pode determinar o tipo de modelo a ser desenvolvido. Por exemplo, você poderia determinar que o modelo Standalone será escolhido se o depurador estiver ativado.&lt;/p&gt;

&lt;p&gt;Exemplo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{$ifdef STANDALONE}
  fphttpapp,
{$endif}
{$ifdef FCGI}
  fpfcgi,
{$endif}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Standalone é uma aplicação que não precisa de um serviço Apache ou IIS. O próprio executável se registra numa porta (escolhida pelo desenvolvedor) para responder a requisições HTTP. É possível utilizar esse modelo até mesmo em produção — pense em vários serviços sendo executados localmente numa única máquina se comunicando entre si, mas que também podem responder a requisições na rede.&lt;/p&gt;

&lt;p&gt;Sendo uma aplicação que não necessita de um servidor Web, é possível depurar facilmente utilizando &lt;em&gt;breakpoints&lt;/em&gt; da mesma forma que fazemos em aplicações Desktop.&lt;/p&gt;

&lt;p&gt;No entanto, se você tem um servidor Web, a forma mais simples de fazer o deploy para um Apache ou IIS é o formato CGI. Nesse formato o servidor Web irá executar e instanciar sua aplicação a cada requisição feita pelo usuário de forma isolada e segura. É um ótimo modelo para aplicações simples, no entanto não é o mais performático.&lt;/p&gt;

&lt;p&gt;Finalmente, o padrão FastCGI une o que há de melhor do modelo ISAPI (multi thread, cache, inicialização rápida) com a segurança do CGI (processos isolados). Para aplicações que realmente necessitam de performance, esse deve ser o padrão a ser escolhido.&lt;/p&gt;

&lt;p&gt;Servidores Web permitem muitas configurações para o modelo FastCGI como o número de instâncias que ficarão ativas, quando elas serão desativadas por falta de requisições, etc.&lt;/p&gt;

&lt;p&gt;E não pense em apenas servidores Linux. Eu mesmo mantenho algumas aplicações FastCGI em servidores Windows funcionando 24h/dia, sem parar.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O framework fpWeb vem facilitando muito o desenvolvimento Web em aplicações Object Pascal com Free Pascal e Lazarus.&lt;/p&gt;

&lt;p&gt;É um framework simples, bem testado e utilizado em produção a muitos anos pela comunidade.&lt;/p&gt;

&lt;p&gt;Com o uso de diretivas de compilação fica fácil alternar entre modelos de aplicações, facilitando muito o desenvolvimento e depuração do código.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 May 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/fpweb</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/fpweb</guid>
      </item>
    
      <item>
        <title>Encapsulamento</title>
        <description>&lt;p&gt;O Encapsulamento é um dos pilares da Orientação a Objetos. Mas você sabe o que realmente significa esse conceito?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-erwan-hesry-166245-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Erwan Hesry on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;De acordo com o dicionário, Encapsulamento significa: colocar ou encerrar em cápsula; capsular.&lt;/p&gt;

&lt;p&gt;Uma cápsula não pode — ou não deveria — ser quebrada. O mundo externo ao objeto não pode saber o que há em seu interior a menos que o objeto queira lhes dizer “com suas próprias palavras”, ou seja, através de métodos que retornam informações mas não necessariamente seu &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O mundo externo só deve conhecer os métodos públicos de um objeto. Seus métodos públicos representam sua Interface para fazer o que ele deve fazer. Qualquer método ou atributo interno ao objeto é de propriedade dele e de mais ninguém.&lt;/p&gt;

&lt;p&gt;Atributos e &lt;a href=&quot;/eliminando-metodos-privados&quot;&gt;métodos privados&lt;/a&gt; estão encapsulados no objeto e nunca deveriam ser acessados externamente.&lt;/p&gt;

&lt;p&gt;Essa é a teoria.&lt;/p&gt;

&lt;h2 id=&quot;codigo&quot;&gt;Encapsulamento pelo Código&lt;/h2&gt;

&lt;p&gt;Toda a &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt; é sobre encapsulamento e envio de mensagens.&lt;/p&gt;

&lt;p&gt;Infelizmente, ambos os conceitos não são implementados perfeitamente em Object Pascal ou em nenhuma outra linguagem &lt;i&gt;mainstream&lt;/i&gt; do mercado como Java e C#.&lt;/p&gt;

&lt;p&gt;E isso gera muitas dúvidas.&lt;/p&gt;

&lt;p&gt;Vamos falar sobre Encapsulamento e tentar expandir nossas mentes além do código, além dos conceitos pré-concebidos e do básico.&lt;/p&gt;

&lt;p&gt;O que é estar encapsulado? Essa pergunta parece tola, mas veremos que depende do ponto de vista do observador para respondê-la.&lt;/p&gt;

&lt;p&gt;Por exemplo. Um atributo privado está encapsulado no objeto e não pode ser acessado pelo mundo externo, certo?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFoo = class
  private
     FValue: Integer;
  public
     function GetValue: Integer;
  end;

function TFoo.GetValue: Integer;
begin
  Result := FValue;
end;

procedure TMainForm.ExecButton(Sender: TObject);
var
  F: TFoo;
begin
  F := TFoo.Create;
  ShowMessage(F.GetValue.ToString);
  F.Free;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, o mundo externo representado pela instância de  &lt;code&gt;TMainForm&lt;/code&gt; consegue acessar o atributo privado da instância da classe &lt;code&gt;TFoo&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Não, você diria.&lt;/p&gt;

&lt;p&gt;O atributo privado está sendo acessado por um método público que o “protege”. Além disso, como o atributo é &lt;a href=&quot;/posts/tipos-primitivos-nos-argumentos/&quot;&gt;primitivo&lt;/a&gt;, ele não é passado por referência. Então, o mundo externo não pode nem mesmo alterá-lo.&lt;/p&gt;

&lt;p&gt;Está correto.&lt;/p&gt;

&lt;p&gt;Então, vamos alterar um pouco o código.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFoo = class
  private
     FValue: TDataValue;
  public
     function GetValue: TDataValue;
  end;

function TFoo.GetValue: TDataValue;
begin
  Result := FValue;
end;

procedure TMainForm.ExecButton(Sender: TObject);
var
  F: TFoo;
begin
  F := TFoo.Create;
  F.GetValue.Free;
  F.Free;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora &lt;code&gt;GetValue&lt;/code&gt; retorna uma instância de objeto.&lt;/p&gt;

&lt;p&gt;É possível criar o objeto &lt;code&gt;F&lt;/code&gt;, acessar (indiretamente) seu atributo privado e destruí-lo chamando &lt;code&gt;Free&lt;/code&gt;, pois&lt;code&gt;GetValue&lt;/code&gt; retornar a referência direta do atributo.&lt;/p&gt;

&lt;p&gt;Ora, o atributo não é público! Não temos um &lt;a href=&quot;/posts/getters-e-setters/&quot;&gt;setter&lt;/a&gt; para ele e, mesmo assim, o “mundo externo” consegue destruí-lo? Ele não deveria ser intocável externamente?&lt;/p&gt;

&lt;p&gt;Vejamos agora:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFoo = class
  public
     Value: TDataValue;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nessa versão a classe &lt;code&gt;TFoo&lt;/code&gt; tem um atributo público &lt;code&gt;Value&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se o mundo externo acessar esse atributo, estaríamos quebrando o encapsulamento do objeto?&lt;/p&gt;

&lt;p&gt;Na verdade, não.&lt;/p&gt;

&lt;p&gt;Não há nada encapsulado no objeto e, portanto, por definição não há nenhuma quebra de encapsulamento!&lt;/p&gt;

&lt;p&gt;Talvez a linguagem não devesse permitir que atributos fossem públicos, mas esse seria um debate para outro artigo.&lt;/p&gt;

&lt;p&gt;Quer outro exemplo? Imagine que &lt;code&gt;GetValue&lt;/code&gt; agora é &lt;i&gt;privado&lt;/i&gt;. Imagine uma outra classe chamada &lt;code&gt;TBar&lt;/code&gt; com essa definição:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TDataValueFunc = function: TDataValue of object; 

  TBar = class
  private
     FFunc: TDataValueFunc;
  public
     constructor Create(Func: TDataValueFunc);
     function Data: TDataValue;
  end;

function TBar.Data: TDataValue;
begin
  Result := FFunc;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E o (novo) construtor de &lt;code&gt;TFoo&lt;/code&gt; seria assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;constructor TFoo.Create;
begin
  FBar := TBar.Create(@GetValue);
  FBar.Data;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Não estaria &lt;code&gt;TBar.Data&lt;/code&gt; executando um código privado de &lt;code&gt;TFoo&lt;/code&gt;, mesmo que indiretamente? Um objeto “acessando” um método privado de outro objeto. Seria essa uma quebra de encapsulamento?&lt;/p&gt;

&lt;p&gt;O que eu estou tentando lhe mostrar é que não é apenas o código puramente técnico que irá definir um bom nível de encapsulamento no seu projeto.&lt;/p&gt;

&lt;p&gt;É necessário que você pense em encapsulamento no nível de design do projeto e não apenas na implementação técnica das classes.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Vimos que a linguagem Object Pascal permite-nos acessar atributos e 
métodos privados, mesmo que indiretamente.&lt;/p&gt;

&lt;p&gt;O mesmo pode ser feito em outras linguagens consideradas “mais” Orientadas a Objetos.&lt;/p&gt;

&lt;p&gt;Então, discutir sobre encapsulamento no nível puramente técnico da linguagem é perda de tempo. Seria muito difícil — mas não impossível — implementar um código onde todos os atributos privados não fossem acessados, de alguma maneira, pelo mundo externo sem perder performance ou complicar o modelo de classes apenas para afirmar que os atributos estão protegidos e intocados.&lt;/p&gt;

&lt;p&gt;No mundo real, sistemas devem ter boa performance e serem simples de manutenção.&lt;/p&gt;

&lt;p&gt;É melhor quebrar algumas regras e deixar as coisas &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; do que ser purista e não ter nenhum benefício real.&lt;/p&gt;

&lt;p&gt;Finalmente, o conceito de Encapsulamento na Orientação Objetos é mais sobre como projetar a comunicação entre os objetos e módulos utilizando o mínimo necessário ao invés de se preocupar unicamente com a sintaxe utilizada.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 16 Apr 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/encapsulamento</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/encapsulamento</guid>
      </item>
    
      <item>
        <title>Classes Amigas</title>
        <description>&lt;p&gt;Classes Amigas tem acesso ao estado (privado) de seus objetos. Apesar dessa prática ser entendida por muitos desenvolvedores como uma quebra do encapsulamento, na verdade ela pode até aprimorá-lo.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-ben-white-178537-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Ben White on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Classes Amigas existem na linguagem C++ a muito tempo, assim como na linguagem Object Pascal.&lt;/p&gt;

&lt;p&gt;Enquanto na linguagem C++ é necessária uma sintaxe específica, em Object Pascal basta declararmos as classes na mesma unit para que elas sejam “amigas”. E não importa se elas fazem parte ou não de uma hierarquia de herança.&lt;/p&gt;

&lt;p&gt;Eu conheço alguns desenvolvedores que não lidam muito bem com isso. Para eles, o que é privado nunca deveria ser acessado por outra instância além do próprio objeto.&lt;/p&gt;

&lt;p&gt;Eles estão certos.&lt;/p&gt;

&lt;p&gt;Mas essa é uma regra geral. Precisamos saber quando “quebrar” as regras, se isso for aumentar a &lt;i&gt;qualidade&lt;/i&gt; do software.&lt;/p&gt;

&lt;p&gt;Eu também fui contra a essa &lt;i&gt;feature by design&lt;/i&gt; por muito tempo. A muitos anos atrás eu declarava as classes em units separadas, mesmo que seus objetos existissem apenas para “conversar” entre si, ou seja, mesmo que tais objetos fossem bem “íntimos”.&lt;/p&gt;

&lt;p&gt;A fim de seguir a “regra de ouro” do encapsulamento, eu declarava tais classes em units separadas pensando que eu estava desenvolvendo mais Orientado a Objetos &lt;i&gt;protegendo&lt;/i&gt; seus estados.&lt;/p&gt;

&lt;p&gt;Mas, ao mesmo tempo, eu declarava as propriedades de acesso — também conhecidos com &lt;a href=&quot;/posts/getters-e-setters/&quot;&gt;Get/Set&lt;/a&gt; — para que o estado desses objetos pudessem ser acessados por alguma instância de &lt;i&gt;fora&lt;/i&gt;!&lt;/p&gt;

&lt;p&gt;E isso não faz sentido.&lt;/p&gt;

&lt;p&gt;Eu estava escrevendo e complicando mais o código, sem ganhar nenhum benefício, já que toda essa “proteção”, na verdade, não existia.&lt;/p&gt;

&lt;p&gt;Então, eu voltei a rever esse conceito das Classes Amigas.&lt;/p&gt;

&lt;p&gt;Eu diria que Classes Amigas enfraquecem o encapsulamento local (na unit) afim de &lt;i&gt;fortalecer&lt;/i&gt; o encapsulamento global (por todo o projeto).&lt;/p&gt;

&lt;p&gt;Ainda assim, é claro, isso irá depender de alguns fatores. Utilizá-las é mais uma exceção à regra e deve ser muito bem pensado afim de obter mais prós do que contras.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo: Imagine que você tem uma classe que representa um livro. Na interface da classe desse livro nós só queremos ter o básico que, no nosso exemplo, irá conter métodos para retornar o título, autor e ISBN.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IBook = interface
    function Title: string;
    function Author: string;
    function ISBN: string;
  end;
  
  TBook = class(TInterfacedObject, IBook)
  private
    FDoc: IXMLDocument;
  public
    constructor Create(const Doc: IXMLDocument);
    function Title: string;
    function Author: string;
    function ISBN: string;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Temos uma interface &lt;code&gt;IBook&lt;/code&gt; e também uma classe que a implementa.&lt;/p&gt;

&lt;p&gt;O código é bem simples e de fácil entendimento.&lt;/p&gt;

&lt;p&gt;A classe &lt;code&gt;TBook&lt;/code&gt; recebe uma instância de &lt;code&gt;IXMLDocument&lt;/code&gt; proveniente de algum lugar. Não importa.&lt;/p&gt;

&lt;p&gt;Esse objeto XML possui toda a informação referente a um livro.&lt;/p&gt;

&lt;p&gt;Hoje, apenas os 3 atributos estariam contidos no XML mas tenha em mente que ele pode ser alterado. Poderíamos adicionar mais nós de informação futuramente, se assim o desejarmos.&lt;/p&gt;

&lt;p&gt;Internamente a classe &lt;code&gt;TBook&lt;/code&gt; irá fazer o parser do XML, retornando suas informações através dos respectivos métodos.&lt;/p&gt;

&lt;p&gt;Imaginemos que tudo funciona bem por meses e muitas outras classes podem ter implementado a mesma interface &lt;code&gt;IBook&lt;/code&gt;. Por exemplo, &lt;code&gt;TDbBook&lt;/code&gt;, &lt;code&gt;TEmptyBook&lt;/code&gt;, &lt;code&gt;TNullBook&lt;/code&gt;, &lt;code&gt;TJSONBook&lt;/code&gt;, &lt;code&gt;TXMLBook&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;Então, uma nova regra de negócio é solicitada: é necessário saber o &lt;i&gt;título original&lt;/i&gt; e o &lt;i&gt;ano de publicação&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;Se alterarmos a interface atual, teremos que implementar os novos métodos em todas as classes que a implementam. Isso é bastante trabalho e pode não ser uma boa ideia.&lt;/p&gt;

&lt;p&gt;Outra opção é implementar uma nova classe, especializando &lt;code&gt;IXMLDocument&lt;/code&gt; como uma interface para ser implementada por uma &lt;a href=&quot;/posts/classes-de-dados/&quot;&gt;classe de dados&lt;/a&gt;. Por exemplo, &lt;code&gt;IBookData&lt;/code&gt;. Todo o código de parser que antes estava contido em &lt;code&gt;TBook&lt;/code&gt;, deverá ser migrado para a nova classe, refatorando não só &lt;code&gt;TBook&lt;/code&gt; mas também todas as outras implementações de &lt;code&gt;IBook&lt;/code&gt; que, porventura, tenham o construtor parecido. Isso também é bastante trabalho, talvez mais trabalho do que a primeira opção.&lt;/p&gt;

&lt;p&gt;A outra opção (mas pode haver muitas) é utilizar Classes Amigas criando apenas o necessário sem alterar nenhuma outra classe, escrevendo menos e de forma mais simples.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  ICompletedBook = interface(IBook)
    function OriginalTitle: string;
    function Year: Integer;
  end;
  
  TCompletedBook = class(TBook, ICompletedBook)
  public
    function OriginalTitle: string;
    function Year: Integer;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora temos uma nova interface e uma nova classe que a implementa. Ambos utilizando &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;, pois ambas são muito íntimas dos seus predecessores.&lt;/p&gt;

&lt;p&gt;Dentro dos métodos da classe &lt;code&gt;TCompletedBook&lt;/code&gt;, será necessário ter acesso ao atributo privado de &lt;code&gt;TBook&lt;/code&gt; denominado &lt;code&gt;FDoc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Entretanto, se ambas as classes são amigas, ou seja, declaradas na mesma unit, não haverá problemas para fazer isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  function TCompletedBook.OriginalTitle: string;
  begin
    Result := FDoc.Node(&#39;original-title&#39;).AsString;
  end;

  function TCompletedBook.Year: Integer;
  begin
    Result := FDoc.Node(&#39;year&#39;).AsInteger;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O atributo &lt;code&gt;FDoc&lt;/code&gt; é acessível, mesmo sendo privado.&lt;/p&gt;

&lt;p&gt;Você poderia pensar em alterar a visibilidade desse atributo para &lt;code&gt;protected&lt;/code&gt; e deixar que até mesmo o código de outros usuários possam herdar de &lt;code&gt;TBook&lt;/code&gt;, mas isso seria um erro.&lt;/p&gt;

&lt;p&gt;Ao tornar os atributos acessíveis para qualquer classe, você &lt;i&gt;enfraquece&lt;/i&gt; o encapsulamento global e pode perder o controle do código. Seria muito mais difícil fazer alguma alteração em &lt;code&gt;TBook&lt;/code&gt; pois não há como saber, com certeza, quem está utilizando os atributos privados.&lt;/p&gt;

&lt;p&gt;Finalmente, ao utilizar o modelo de Classes Amigas, você sabe quais classes deverão ser alteradas se houver alguma refatoração, pois todas elas estarão declaradas na mesma unit, obrigatoriamente.&lt;/p&gt;

&lt;p&gt;Suas classes serão &lt;a href=&quot;/posts/menos-e-mais/&quot;&gt;menores&lt;/a&gt; e mais simples.&lt;/p&gt;

&lt;p&gt;Há seres humanos que são mais ligados intimamente a uns do que outros — mesmo todos sendo provenientes da mesma “classe” — que sabem seus gostos, desejos e segredos mais íntimos.&lt;/p&gt;

&lt;p&gt;A mesma lógica pode também ser aplicada a apenas algumas classes onde seus objetos são mais amigos, concedendo acesso irrestrito uns aos outros, mas bloqueando esse acesso ao mundo exterior.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Apr 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/classes-amigas</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/classes-amigas</guid>
      </item>
    
      <item>
        <title>A Declaração WITH-DO Perfeita</title>
        <description>&lt;p&gt;A utilização do WITH-DO pode deixar o código mais simples de ler, pois haverá menos declarações, atribuições e inicializações de variáveis. No entanto, a sintaxe atual não é perfeita. Dependendo do seu uso, o benefício pode ser o inverso.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-alex-wong-17993-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Alex wong on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A declaração WITH-DO &lt;a href=&quot;/posts/a-declaracao-with-do-e-do-mal/&quot;&gt;pode ser utilizada&lt;/a&gt; mas sua sintaxe não é perfeita.&lt;/p&gt;

&lt;p&gt;Vai depender muito do design do seu código para que você possa utilizar o WITH-DO sem problemas.&lt;/p&gt;

&lt;p&gt;Por exemplo. Classes com muitos atributos ou métodos poderá aumentar a probabilidade de haver alguma &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;colisão de nomes&lt;/a&gt; entre outras classes e/ou variáveis locais.&lt;/p&gt;

&lt;p&gt;Esse artigo é a minha proposta para melhorar a sintaxe do WITH-DO nos compiladores Object Pascal.&lt;/p&gt;

&lt;h2 id=&quot;sintaxe&quot;&gt;A Sintaxe Perfeita&lt;/h2&gt;

&lt;p&gt;O grande problema ao utilizarmos WITH-DO é a ambiguidade que ele pode trazer ao código.&lt;/p&gt;

&lt;p&gt;Considere o código abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
   TFoo = class
      X: Integer;
   end;

procedure Execute;
var
  X: Integer;
begin
  with TFoo.Create do
  try
     X := 10;
  finally
     Free;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A linha &lt;code&gt;X := 10;&lt;/code&gt; atribui 10 ao atributo de &lt;code&gt;TFoo&lt;/code&gt; ou a variável local &lt;code&gt;X&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Outro problema é o seguinte: se renomearmos &lt;code&gt;TFoo.X&lt;/code&gt; para &lt;code&gt;TFoo.Z&lt;/code&gt; poderíamos esperar um erro de compilação, no entanto o código iria continuar funcionando devido ao compilador localizar o identificador &lt;code&gt;X&lt;/code&gt; como uma variável local.&lt;/p&gt;

&lt;p&gt;A ambiguidade pode ser ainda maior quando utilizamos múltiplas instancias na declaração WITH-DO, como a seguir:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with TFoo.Create, TBar.Create do
try
  X := 10;
  Z := 20;
finally
  Free; // belongs to TFoo or TBar?
  Free; // belongs to TFoo or TBar?
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse são apenas alguns casos do uso irrestrito do WITH-DO. E, por essas e outras razões, que muitos desenvolvedores consideram o WITH-DO um mal no código.&lt;/p&gt;

&lt;p&gt;No entanto, o que não está correto não é seu uso, mas sua sintaxe.&lt;/p&gt;

&lt;p&gt;Na minha opinião, seria muito melhor se a sintaxe fosse algo parecido com o exemplo abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  with F =: TFoo.New, B =: TBar.New do
  begin
    F.Execute;
    B.Execute;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No código acima não há variáveis declaradas explicitamente, no entanto as instâncias são referenciadas por algum tipo de &lt;i&gt;alias&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;Afim de diferenciar essa nova sintaxe, para não haver ambiguidades com a sintaxe já existente de atribuição, escolhi utilizar uma “atribuição invertida” neste formato “&lt;code&gt;=:&lt;/code&gt;”.&lt;/p&gt;

&lt;p&gt;Alguns puristas do Pascal iriam dizer que o código acima não é muito “Pascalish” por quê tudo no Pascal deve ser explicitamente declarado antes e, neste caso, as variáveis não foram declaradas previamente. Eu concordo. Porém acho que deveríamos considerar essa exceção.&lt;/p&gt;

&lt;p&gt;A sintaxe para a captura de exceções, por exemplo, tem (quase) a &lt;i&gt;mesma&lt;/i&gt; sintaxe proposta qui e todos convivem bem com isso.&lt;/p&gt;

&lt;p&gt;Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
var
  X: Integer;
begin
  try
     X := 10 / 0;
  except
    on E: EDivByZero do
       ShowMessage(E.Message);
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A variável &lt;code&gt;E&lt;/code&gt; não foi previamente declarada na seção de variáveis locais. Isso vai contra a filosofia Pascal, onde devemos declarar tudo antes de utilizar. Mas, tudo bem. Essa é uma exceção a regra que é bem vinda.&lt;/p&gt;

&lt;p&gt;Voltando ao primeiro exemplo, você pode ter sentido falta às chamadas aos destrutores das instâncias. Bem, eu utilizei a &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;função New&lt;/a&gt; justamente para não haver essa necessidade — considerando que esses métodos retornam uma instância de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;interface&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mas se você não quiser utilizar essa técnica, basta reescrever assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;with F =: TFoo.Create, B =: TBar.Create do
try
  F.Execute;
  B.Execute;
finally
  F.Free;
  B.Free;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Na linguagem C# eles tem a declaração &lt;code&gt;using&lt;/code&gt; que é bem parecido com o que estou propondo — a criação de &lt;i&gt;alias&lt;/i&gt; para as instâncias. No entanto, lá o objetivo é o compilador chamar o método &lt;code&gt;Dispose&lt;/code&gt; de cada instância no fim do bloco, independentemente se houver ou não uma exceção. Para que essa “mágica” aconteça, a instância deve implementar a interface &lt;code&gt;IDisposable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Eu acho essa abordagem desnecessária para o Pascal — no entanto, possível — pois o código fica mais explicito com o uso do &lt;code&gt;try-finally&lt;/code&gt; se você não estiver utilizando instâncias de interfaces.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Acredito que o uso de WITH-DO proposto aqui iria nos ajudar a implementar um código mais simples.&lt;/p&gt;

&lt;p&gt;A nova sintaxe com a atribuição invertida não iria entrar em conflito com a sintaxe atual.&lt;/p&gt;

&lt;p&gt;Poderíamos criar blocos de código independentes dentro de métodos. Visto que, no exemplos acima, as variáveis &lt;code&gt;F&lt;/code&gt; e &lt;code&gt;B&lt;/code&gt; só poderiam ser utilizadas dentro do WITH-DO e não em todo o escopo do método.&lt;/p&gt;

&lt;p&gt;Só iríamos declarar variáveis “globais ao método” na sessão de variáveis locais ao método, mas todas as outras instâncias seriam inicializadas em blocos WITH-DO para restringir ainda mais o escopo e visibilidade às variáveis.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/a-declaracao-with-do-perfeita</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/a-declaracao-with-do-perfeita</guid>
      </item>
    
      <item>
        <title>A função Supports pode ser traiçoeira</title>
        <description>&lt;p&gt;Quando você se acostuma a utilizar somente instancias de interfaces, pode ser difícil entender alguns erros em tempo de execução, utilizando instâncias de classes com suporte a interfaces.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-michal-parzuchowski-224092-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Michał Parzuchowski on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Você pode desenvolver seu projeto do zero, utilizando apenas &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;instâncias de interfaces&lt;/a&gt;, e (quase) tudo estará sob seu controle.&lt;/p&gt;

&lt;p&gt;Entretanto, há muitos projetos onde só iremos fazer algum tipo de manutenção. Esses projetos podem não utilizar o conceito de interfaces como explicado em vários artigos desse blog. Nesses casos, é necessário codificar de forma que mantenha o código legado funcionando, ao mesmo tempo que introduzimos boas práticas de &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Em tais projetos, é comum vermos variáveis declaradas como tipo de alguma classe ao invés de alguma interface.&lt;/p&gt;

&lt;p&gt;Isso quer dizer que haverá chamadas aos métodos &lt;code&gt;Free&lt;/code&gt; de cada instância, por todo o código.&lt;/p&gt;

&lt;p&gt;E não há nada de errado com isso. Essa é uma das características da linguagem Object Pascal que a torna muito eficiente para projetos de alta &lt;a href=&quot;/argumentos-const&quot;&gt;performance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, como já foi dito muitas vezes aqui nesse blog, o uso de instâncias de interfaces pode trazer muitos benefícios quando utilizada apropriadamente.&lt;/p&gt;

&lt;p&gt;Os benefícios, entretanto, podem ser ofuscados pelo não funcionamento correto do código ao utilizarmos instâncias de classes junto com interfaces.&lt;/p&gt;

&lt;p&gt;Veja o código abaixo e, antes de compilar e executar o programa no seu computador, tente descobrir se há algo errado:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;program Project1;

uses
  SysUtils;

type
  IBar = interface
  [&#39;{C22FB8F4-1EC6-42C4-81E4-F2A52CC52258}&#39;]
  end;

  TBar = class(TInterfacedObject, IBar)
  end;

var
  Bar: TBar;
begin
  Bar := TBar.Create;
  try
    if Supports(Bar, IBar) then
      Writeln(&#39;Bar supports...&#39;);
  finally
    Bar.Free;
  end;
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código compila?&lt;/p&gt;

&lt;p&gt;O código possui &lt;i&gt;memory leaks&lt;/i&gt;?&lt;/p&gt;

&lt;p&gt;O código irá lançar algum &lt;i&gt;Access Violation&lt;/i&gt; (AV)?&lt;/p&gt;

&lt;p&gt;Pense por um minuto…&lt;/p&gt;

&lt;p&gt;Bem, eu posso lhe afirmar que o código compila sem erros mas há um grande problema de &lt;i&gt;design&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;A lógica geral está correta. Temos uma instância de classe chamada &lt;code&gt;Bar&lt;/code&gt;; depois, checamos se essa instância suporta ou implementa a interface &lt;code&gt;IBar&lt;/code&gt; utilizando a função &lt;code&gt;Supports()&lt;/code&gt; da &lt;code&gt;SysUtils&lt;/code&gt;; então, imprimimos algo na tela em caso afirmativo; finalmente, a instância &lt;i&gt;deveria&lt;/i&gt; ser destruída utilizando &lt;code&gt;Bar.Free&lt;/code&gt;, visto que é uma instância de classe e não de interface. Certo?&lt;/p&gt;

&lt;p&gt;Errado.&lt;/p&gt;

&lt;p&gt;Você irá receber um &lt;i&gt;AV&lt;/i&gt; quando o compilador tentar destruir o objeto na linha &lt;code&gt;Bar.Free&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;E por quê isso ocorre?&lt;/p&gt;

&lt;p&gt;Estamos utilizando uma das implementações da função &lt;code&gt;Supports()&lt;/code&gt; — há alguns &lt;i&gt;overloads&lt;/i&gt; — que retorna apenas um &lt;code&gt;boolean&lt;/code&gt; para dizer ao programa se determinada instância suporta ou não uma determinada interface.&lt;/p&gt;

&lt;p&gt;Ao fazer isso, &lt;code&gt;Supports()&lt;/code&gt; irá obter uma instância de &lt;code&gt;IBar&lt;/code&gt;, extraída da variável &lt;code&gt;Bar&lt;/code&gt;. Isso irá alterar a contagem de referência e após o retorno da função, a instância &lt;code&gt;Bar&lt;/code&gt; será destruída… antes de chegar na linha &lt;code&gt;Bar.Free&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;Na minha opinião, isso é um &lt;i&gt;erro&lt;/i&gt; mesmo sendo &lt;i&gt;&lt;a href=&quot;http://docwiki.embarcadero.com/Libraries/XE2/en/System.SysUtils.Supports&quot;&gt;by design&lt;/a&gt;&lt;/i&gt;.&lt;/p&gt;

&lt;p&gt;Delphi e FPC funcionam da mesma forma.&lt;/p&gt;

&lt;p&gt;Então, como consertar o código?&lt;/p&gt;

&lt;p&gt;Basta alterar o tipo da variável para &lt;code&gt;Bar: IBar&lt;/code&gt;. Ao fazer isso, o compilador irá lhe dizer que não é mais necessário chamar &lt;code&gt;Bar.Free&lt;/code&gt;. Remova também essa linha e, consequentemente, a construção &lt;code&gt;try-finally&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  Bar: IBar;
begin
  Bar := TBar.Create;
  if Supports(Bar, IBar) then
    Writeln(&#39;Bar supports...&#39;);
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Após fazer isso, compile e execute novamente o programa.&lt;/p&gt;

&lt;p&gt;Utilizando FPC 3.0.4 com &lt;code&gt;-gl&lt;/code&gt; habilitado, eu vejo a saída abaixo, sem nenhum &lt;i&gt;memory leak&lt;/i&gt; ou erros:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
Bar supports...
Heap dump by heaptrc unit
48 memory blocks allocated : 1189/1296
48 memory blocks freed     : 1189/1296
0 unfreed memory blocks : 0
True heap size : 163840 (80 used in System startup)
True free heap : 163760
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muito cuidado ao utilizar instâncias de classes com suporte a interfaces e contagem de referência.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Mar 2018 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/supports-traicoeira</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/supports-traicoeira</guid>
      </item>
    
      <item>
        <title>Assertions é uma boa prática</title>
        <description>&lt;p&gt;Assertions auxiliam o programador no desenvolvimento e depuração do código, sendo a primeira linha de defesa contra bugs.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-andrew-ruiz-394426-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Andrew Ruiz on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Quando estamos desenvolvendo, é comum executar o programa várias vezes, digitar alguma entrada de dados “falsa”, e seguir adiante, afim de testar outras funcionalidades.&lt;/p&gt;

&lt;p&gt;Assim, vamos construindo um protótipo.&lt;/p&gt;

&lt;p&gt;Um protótipo pode ser codificado muito rapidamente, sendo comum codificarmos várias funcionalidades apenas para visualizarmos como seria o sistema real.&lt;/p&gt;

&lt;p&gt;Como um protótipo pode ser alterado inúmeras vezes, vários bugs podem aparecer.&lt;/p&gt;

&lt;p&gt;Aqui entram as &lt;a href=&quot;https://www.freepascal.org/docs-html/3.0.2/rtl/system/assert.html&quot;&gt;Assertions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;De acordo com a &lt;a href=&quot;https://en.wikipedia.org/wiki/Assertion_(software_development)&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In computer programming, an assertion is a statement that a predicate (Boolean-valued function, i.e. a true–false expression) is expected to always be true at that point in the code. If an assertion evaluates to false at run time, an assertion failure results, which typically causes the program to crash, or to throw an assertion exception.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Então, uma Assertion sempre deve ser verdadeira ou uma exceção &lt;code&gt;EAssertionFailed&lt;/code&gt; será gerada e o sistema será abortado, retornando o código &lt;code&gt;227&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;No entanto, se a unit &lt;code&gt;SysUtils&lt;/code&gt; for declarada em algum lugar do código, é possível verificar mais informações da exceção como a linha e a unit onde o erro foi gerado, além da &lt;i&gt;mensagem&lt;/i&gt; opcional que o desenvolvedor pode utilizar para cada Assertion.&lt;/p&gt;

&lt;p&gt;Uma Assertion funciona dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TForm1.Button1Click(Sender: TObject);
var
  I: Integer;
begin
  I := 0;
  Assert(I = 1, &#39;The I variable is not 1&#39;);
  ShowMessage(I.ToString);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No código acima, temos um &lt;code&gt;Form&lt;/code&gt; com um botão. No evento desse botão o Assert irá verificar se a variável &lt;code&gt;I&lt;/code&gt; é igual a &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O resultado será falso e uma exceção será gerada.&lt;/p&gt;

&lt;p&gt;Na minha IDE eu vejo essa mensagem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The I variable is not 1 (unit1.pas, line 34).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eu compilei o projeto &lt;i&gt;sem&lt;/i&gt; informações de &lt;i&gt;debugger&lt;/i&gt;. Mesmo assim, é possível ver a linha onde a validação ocorreu, tornando muito útil o uso de Assert para identificar onde e por quê um erro ocorreu.&lt;/p&gt;

&lt;p&gt;Entretanto, as Assertions não deve ser utilizadas em produção. Suas informações técnicas só deveriam ser vistas por programadores, não usuários finais.&lt;/p&gt;

&lt;p&gt;Por esse motivo nós &lt;b&gt;devemos&lt;/b&gt; desabilitar as Assertions quando fizermos o &lt;i&gt;deploy&lt;/i&gt; do sistema para o usuário final.&lt;/p&gt;

&lt;p&gt;Para desabilitar Assertions, o compilador tem uma diretiva de compilação global.&lt;/p&gt;

&lt;p&gt;Há duas opções:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ASSERTIONS ON/OFF (long form)
$C +/- (short form)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mas isso pode ser definido diretamente na IDE, na sessão de debugger nas  opções do projeto, sem haver necessidade de escrever uma linha de código.&lt;/p&gt;

&lt;p&gt;Quando as Assertions estão desabilitadas, as verificações não são executadas. Isso libera o sistema de todo &lt;i&gt;overhead&lt;/i&gt; das verificações no produto final.&lt;/p&gt;

&lt;p&gt;Finalmente, Assertions não substituem Testes de Unidade ou Teste de Integração, sendo apenas mais um tipo de ferramenta para testar o código na fase de desenvolvimento.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Mar 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/assertions</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/assertions</guid>
      </item>
    
      <item>
        <title>Construtores Virtuais</title>
        <description>&lt;p&gt;A linguagem Object Pascal possui uma feature que não existe em nenhuma outra linguagem &lt;i&gt;mainstream&lt;/i&gt; do mercado.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-eddie-kopp-264813-unsplash.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Eddie Kopp on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Construtores Virtuais permitem a criação customizada de novas instâncias sem a necessidade do uso de classes de fábricas.&lt;/p&gt;

&lt;p&gt;É possível que desenvolvedores Object Pascal ao redor do mundo utilizem essa feature diariamente mesmo sem saber que só é possível utilizá-la na linguagem Object Pascal.&lt;/p&gt;

&lt;p&gt;Toda classe possui um ou mais &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt; no qual são responsáveis por instanciar um novo objeto.&lt;/p&gt;

&lt;p&gt;Entretanto, ter um construtor virtual &lt;a href=&quot;https://stackoverflow.com/questions/3651354/in-net-can-a-class-have-virtual-constructor&quot;&gt;não é comum&lt;/a&gt; em outras linguagens.&lt;/p&gt;

&lt;p&gt;Diferentemente das demais linguagens, os construtores na linguagem Object Pascal são como métodos “marcados” para serem construtores. Um fato sobre isso é que, em Object Pascal, podemos dar o nome que quisermos aos construtores — mesmo que o padrão de nomenclatura recomendado e utilizado seja &lt;code&gt;Create&lt;/code&gt; — e como os métodos podem ser &lt;i&gt;virtuais&lt;/i&gt;, assim também são os construtores.&lt;/p&gt;

&lt;p&gt;Mas, qual é a grande vantagem de utilizá-los?&lt;/p&gt;

&lt;h2 id=&quot;construtores&quot;&gt;Construtores Virtuais&lt;/h2&gt;

&lt;p&gt;Na documentação sobre &lt;em&gt;Factory and Repository patterns&lt;/em&gt; do framework &lt;a href=&quot;https://synopse.info/files/html/Synopse%20mORMot%20Framework%20SAD%201.18.html#TITLE_600&quot;&gt;Synopse mORMot&lt;/a&gt; você encontrará o seguinte texto:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In fact, Delphi is ahead of Java or C#, since it allows virtual constructors to be defined. Those virtual constructors are in fact a clean and efficient way of implementing a Factory, and also fulfill SOLID principles, especially the Liskov Substitution Principle: the parent class define an abstract constructor on which you rely, but the implementation will take place in the overridden constructor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No texto acima, eu sugiro apenas alterarmos a palavra “Delphi” por “Object Pascal”, visto que essa é uma feature da linguagem Object Pascal e não apenas da implementação do Delphi.&lt;/p&gt;

&lt;p&gt;Na maioria das linguagens, o padrão Factory é implementado através de métodos (estáticos, abstratos ou virtuais) das classes e não através dos construtores. Esse é um dos motivos para o autor afirmar que o Delphi (Object Pascal) está a frente de C# e Java nesse quesito. Eu concordo.&lt;/p&gt;

&lt;p&gt;Em Object Pascal podemos criar uma fábrica de objetos onde o tipo da classe original é a própria fábrica.&lt;/p&gt;

&lt;p&gt;Pense no modelo clássico implementado em várias linguagens. Por exemplo, teríamos uma entidade principal &lt;code&gt;TFoo&lt;/code&gt; e uma fábrica &lt;code&gt;TFooFactory&lt;/code&gt;,  que retorna classes-filhas da entidade principal. É importante lembrar que &lt;code&gt;TFoo&lt;/code&gt; deveria &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;implementar alguma Interface&lt;/a&gt; relacionada ao domínio, porém isso é irrelevante para o entendimento do problema.&lt;/p&gt;

&lt;p&gt;O código principal iria utilizar a fábrica para ter instâncias de &lt;code&gt;TFoo&lt;/code&gt;. A fábrica, no entanto, poderia retornar instâncias de novas classes-filhas, herdadas de &lt;code&gt;TFoo&lt;/code&gt; e isso seria transparente para o código principal. Essa é uma das features que queremos ao utilizarmos uma fábrica.&lt;/p&gt;

&lt;p&gt;Mas, primeiro teríamos que criar a fábrica para que ela retornasse as instâncias que realmente necessitamos.&lt;/p&gt;

&lt;p&gt;Em Object Pascal não precisamos de uma classe específica para ser a fábrica de objetos. Nós podemos ter variáveis/argumentos do tipo classe e, dessa maneira, podemos passar diretamente a classe que deve ser utilizada para criar a instância; sem intermediários.&lt;/p&gt;

&lt;p&gt;Imagine que temos uma simples library (lib) que soma 2 números. Essa lib tem uma classe &lt;i&gt;default&lt;/i&gt; para fazer a soma, mas ela permite que a classe seja customizada, lembrando muito o &lt;a href=&quot;https://en.wikipedia.org/wiki/Strategy_pattern&quot;&gt;padrão Strategy&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/0294f260c0d44b7c8b7f9a78df7662c1.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No exemplo acima temos a classe &lt;code&gt;TLibCalc&lt;/code&gt; que representa a lib. No construtor podemos customizar a classe que representa o algoritmo da soma, caso contrário a lib irá utilizar a classe &lt;code&gt;TSum&lt;/code&gt; padrão.&lt;/p&gt;

&lt;p&gt;A classe &lt;code&gt;TSum&lt;/code&gt; é simples. Ela soma dois inteiros. Mas repare que seu construtor é &lt;code&gt;virtual&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O próximo passo é criar um programa de teste.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/8589ff42e90b1311aa3f4b5bab2b7d16.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A saída do programa será: &lt;code&gt;Result is 8&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Se tudo estiver funcionando por aí, vamos aos próximos passos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;criar nossa própria classe para somar 2 números&lt;/li&gt;
  &lt;li&gt;alterar o programa, customizando a lib&lt;/li&gt;
&lt;/ol&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/e364be559715b056463868d849e681ef.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima foi implementado uma nova classe &lt;code&gt;TMySum&lt;/code&gt; e inicializamos a lib &lt;code&gt;TLibCalc.Create(TMySum);&lt;/code&gt; com essa classe.&lt;/p&gt;

&lt;p&gt;Execute o programa e veja o resultado.&lt;/p&gt;

&lt;p&gt;Não foi necessária nenhuma fábrica. Nenhum “registro de classes” também foi necessário. Implementamos um padrão utilizando apenas classes simples da linguagem.&lt;/p&gt;

&lt;p&gt;Finalmente, a linguagem Object Pascal é tão simples que bastou utilizarmos uma &lt;i&gt;instância de classe&lt;/i&gt; contendo &lt;i&gt;construtores virtuais&lt;/i&gt; para instanciar a classe correta.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Em Object Pascal não é necessário termos fábricas; a classe customizada é a própria fábrica.&lt;/p&gt;

&lt;p&gt;Até onde eu sei, não existe essa feature em nenhuma linguagem &lt;i&gt;mainstream&lt;/i&gt;, apenas em Object Pascal.&lt;/p&gt;

&lt;p&gt;Com essa feature não é necessário criar classes de fábrica apenas para inicializar nossos verdadeiros objetos. Teremos menos classes, menos objetos, menos métodos, menos uso de memória, mais eficiência e &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/construtores-virtuais</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/construtores-virtuais</guid>
      </item>
    
      <item>
        <title>Listas Genéricas, sem Generics</title>
        <description>&lt;p&gt;É possível utilizarmos listas genéricas, com checagem de tipo, mas sem o uso da sintaxe com &lt;em&gt;Generics&lt;/em&gt;?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-john-murzaku-269690.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by John Murzaku on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Muitos programadores adoram utilizar novas &lt;em&gt;features&lt;/em&gt; dos compiladores. Uma dessas “novidades” — bem, já faz alguns anos — é o uso de Generics.&lt;/p&gt;

&lt;p&gt;Com Generics é possível, por exemplo, termos listas genéricas que podem ser utilizados com qualquer tipo de classe ou interface. Generics possuem uma “checagem estática” de tipo, tanto para armazenamento como para a recuperação dos itens da lista.&lt;/p&gt;

&lt;p&gt;Ao invés de termos as “velhas” listas de ponteiros, fazendo &lt;em&gt;casting&lt;/em&gt; dos objetos quando acessamos seus itens, hoje, utilizando Generics, podemos utilizar classes de listas já existentes na VCL/LCL para instanciar e manter uma lista de objetos que irão trabalhar com os tipos já definidos no nosso código.&lt;/p&gt;

&lt;p&gt;Na declaração de uma variável de uma lista genérica, informamos o &lt;em&gt;tipo&lt;/em&gt; dos itens que irão compor a lista e o compilador faz o resto do trabalho.&lt;/p&gt;

&lt;p&gt;Esse artigo não irá abordar as vantagens e desvantagens no uso de Generics. Ao invés disso, irei apenas mostrar como &lt;em&gt;simular&lt;/em&gt; uma lista genérica utilizando Object Pascal “clássico”.&lt;/p&gt;

&lt;p&gt;Por quê isso é relevante?&lt;/p&gt;

&lt;p&gt;Existem alguns motivos como, por exemplo, estar trabalhando com código legado numa versão do compilador sem suporte a Generics; almejar uma melhor performance, mesmo utilizando objetos; manter projetos (libs e frameworks) que podem ser utilizados desde os compiladores mais antigos até a versão mais atual.&lt;/p&gt;

&lt;p&gt;O problema de termos uma lista genérica, sem o uso de Generics, é o &lt;em&gt;casting&lt;/em&gt; que precisaríamos fazer todas as vezes que recuperarmos os itens da lista.&lt;/p&gt;

&lt;p&gt;O mesmo &lt;em&gt;casting&lt;/em&gt; seria &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/&quot;&gt;replicado&lt;/a&gt; várias vezes, em todos os pontos que fossem necessário recuperar os objetos.&lt;/p&gt;

&lt;p&gt;Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  Contnrs;

type
  TFoo = class
    Name: string;
  end;

procedure TForm1.Button1Click(Sender: TObject);
var
  F: TFoo;
  OL: TObjectList;
begin
  OL := TObjectList.Create(True);
  try
    F := TFoo.Create;
    F.Name := &#39;Bar&#39;;
    OL.Add(F);
    ShowMessage(
      (OL.Items[0] as TFoo).Name // &amp;lt;&amp;lt;&amp;lt; casting
    );
  finally
    OL.Free;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código acima utiliza a classe &lt;code&gt;TObjectList&lt;/code&gt; da unit &lt;code&gt;Contnrs&lt;/code&gt;. Essa classe trabalha com itens de objetos. Em seu construtor, um argumento &lt;code&gt;boolean&lt;/code&gt; indica que os objetos serão automaticamente liberados quando a lista for destruída.&lt;/p&gt;

&lt;p&gt;Funciona. Mas, o inconveniente é termos que fazer o casting na chamada de &lt;code&gt;Items[]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, é possível não utilizar casting, mesmo sem o uso de Generics. Para tal, vamos utilizar apenas classes simples e sintaxe clássica de Object Pascal.&lt;/p&gt;

&lt;p&gt;Primeiro, precisamos codificar nossa própria lista de objetos, &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/#classes-de-suporte&quot;&gt;sem herdar diretamente de classes de infraestrutura&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TMyObjects = class
  private
    FList: TObjectList;
  public
    constructor Create;
    destructor Destroy; override;
    function Add(Obj: TObject): TMyObjects;
    function Get(Index: Integer): TObject;
    function Count: Integer;
end;

{ TMyObjects }

constructor TMyObjects.Create;
begin
  FList := TObjectList.Create(True);
end;

destructor TMyObjects.Destroy;
begin
  FList.Free;
  inherited;
end;

function TMyObjects.Add(Obj: TObject): TMyObjects;
begin
  Result := Self;
  FList.Add(Obj);
end;

function TMyObjects.Get(Index: Integer): TObject;
begin
  Result := FList.Items[Index];
end;

function TMyObjects.Count: Integer;
begin
  Result := FList.Count;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A classe &lt;code&gt;TMyObjects&lt;/code&gt; poderá ser utilizada para armazenar qualquer tipo de instância de &lt;code&gt;TObject&lt;/code&gt;. Mas, o inconveniente ainda permanece, pois ao utilizar &lt;code&gt;Get(Index)&lt;/code&gt; o casting será necessário.&lt;/p&gt;

&lt;p&gt;Segundo, a solução mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; é utilizarmos &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança de classe&lt;/a&gt; e &lt;em&gt;reintroduzir&lt;/em&gt; o método que recupera os objetos, utilizando uma nova assinatura.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFooObjects = class(TMyObjects)
  public
    function Get(Index: Integer): TFoo; reintroduce;
  end;

{ TFooObjects }

function TFooObjects.Get(Index: Integer): TFoo;
begin
  Result := inherited Get(Index) as TFoo;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A nova classe &lt;code&gt;TFooObjects&lt;/code&gt; tem uma nova assinatura de &lt;code&gt;Get()&lt;/code&gt;. Isso quer dizer que quando o desenvolvedor utilizar o &lt;em&gt;code-completion&lt;/em&gt; da IDE, apenas essa “versão” do &lt;code&gt;Get(Index: Integer): TFoo&lt;/code&gt; será exibida.&lt;/p&gt;

&lt;p&gt;Então, podemos alterar o código de teste anterior para utilizar a nova classe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TForm1.Button1Click(Sender: TObject);
var
  F: TFoo;
  OL: TFooObjects;
begin
  OL := TFooObjects.Create;
  try
    F := TFoo.Create;
    F.Name := &#39;Bar&#39;;
    OL.Add(F);
    ShowMessage(OL.Get(0).Name);
  finally
    OL.Free;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sem casting, limpo e mais “elegante” do que utilizar Generics.&lt;/p&gt;

&lt;p&gt;A mesma técnica deve ser utilizada para o método &lt;code&gt;Add(Obj)&lt;/code&gt; afim de certificarmos que apenas instâncias de &lt;code&gt;TFoo&lt;/code&gt; serão armazenadas.&lt;/p&gt;

&lt;p&gt;A classe &lt;code&gt;TMyObjects&lt;/code&gt; foi codificada apenas uma vez e poderá ser reutilizada como base para várias outras classes.&lt;/p&gt;

&lt;p&gt;Entretanto, alguns desenvolvedores poderão sugerir que tivemos que implementar “muito” código para ter a mesma funcionalidade que a sintaxe de Generics já nos dá. Bem, isso depende do ponto de vista. Além dos motivos sugeridos nesse artigo, o &lt;em&gt;não&lt;/em&gt; uso de Generics pode fazer muito sentido quando estamos trabalhando na Camada de Negócio, onde o código deve representar as Regras de Negócio do cliente. Uma classe “inchada” com dezenas de métodos de manipulação de itens na lista pode não representar fielmente, por exemplo, uma “lista de produtos” do cliente.&lt;/p&gt;

&lt;p&gt;Finalmente, é você quem vai decidir sobre os &lt;em&gt;trade-offs&lt;/em&gt; envolvidos no design do seu código. Mas, sempre tenha em mente que nem tudo que é &lt;em&gt;antigo&lt;/em&gt; será pior que o mais &lt;em&gt;novo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/listas-genericas-sem-generics</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/listas-genericas-sem-generics</guid>
      </item>
    
      <item>
        <title>Namespaces Inteligentes</title>
        <description>&lt;p&gt;Na minha opinião, a implementação atual de Namespaces no Delphi poderia ser muito mais inteligente, simples e sem ambiguidades.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-fervent-jan-121249.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Fervent Jan on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A linguagem Pascal foi criada com o conceito de Namespace desde o início chamado &lt;em&gt;Units&lt;/em&gt;. As Unidades agrupam os identificadores, variáveis, tipos, classes…tudo que faz parte de um mesmo contexto.&lt;/p&gt;

&lt;p&gt;No entanto, hoje em dia nós, desenvolvedores Object Pascal, ganhamos uma definição diferente para Unit e Namespace.&lt;/p&gt;

&lt;p&gt;Talvez, devido a influência de outras linguagens “mais modernas”, ter apenas Unidades não parece ser mais suficiente para a modularização de sistemas.&lt;/p&gt;

&lt;p&gt;Concordo que ainda há espaço para melhorias no conceito das Unidades, porém a implementação proposta pela Embarcadero é suficiente para, agora, dizermos que a linguagem foi atualizada e que Namespaces é uma evolução?&lt;/p&gt;

&lt;h1 id=&quot;atual&quot;&gt;Namespaces Atual&lt;/h1&gt;

&lt;p&gt;A partir do Delphi 2007~2009 a Embarcadero implementou o “novo” conceito chamado &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Using_Namespaces_with_Delphi&quot;&gt;Namespace&lt;/a&gt;, onde é possível termos nomes de Unidades pontilhadas, como já existem em algumas outras linguagens.&lt;/p&gt;

&lt;p&gt;Além da questão estética para termos &lt;a href=&quot;/posts/nomeando-unidades/&quot;&gt;nomes de arquivos&lt;/a&gt; mais legíveis, esse conceito permite que o compilador localize as Unidades declaradas no código não apenas por seu nome, mas também levando em consideração o Namespace (prefixo) da Unidade.&lt;/p&gt;

&lt;p&gt;Segundo a Embarcadero, um Namespace é um &lt;a href=&quot;/posts/datamodule-e-apenas-um-container/&quot;&gt;container&lt;/a&gt; de Unidades.&lt;/p&gt;

&lt;p&gt;Nesse &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Using_Namespaces_with_Delphi&quot;&gt;link&lt;/a&gt;
oficial diz que &lt;em&gt;“Namespaces fornece uma maneira de organizar identificadores e tipos, e são utilizados para desambiguar tipos com o mesmo nome”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas já temos isso com as Unidades então, qual é a grande atualização?&lt;/p&gt;

&lt;p&gt;O documento segue dizendo: &lt;em&gt;“Desde que eles são um container para Unidades Delphi, os Namespaces também podem ser utilizados para diferenciação de unidades com o mesmo nome, que residem em pacotes diferentes”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Aqui parece haver uma vantagem. O texto afirma que podemos ter pacotes distintos porém cada um deles contendo Unidades com o mesmo nome e mesmo assim poderíamos utilizar tais pacotes em um mesmo projeto — algo que não seria possível sem essa &lt;em&gt;feature&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Enquanto eu escrevo esse artigo, tomando uma xícara quente de café na Starbucks, não tenho disponível uma versão atual do Delphi para fazer esse teste, mas eu acredito que funcione desde que eu utilize o Namespace do Pacote para referenciar todas as Unidades dele no meu projeto.&lt;/p&gt;

&lt;p&gt;Meu entendimento é esse:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Existe um Pacote chamado &lt;code&gt;Acme.Xpto.MyPack&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Dentro desse pacote existe as Unidades &lt;code&gt;Foo.pas&lt;/code&gt; e &lt;code&gt;Bar.pas&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;No meu projeto eu desejo utilizar as Unidades do Pacote, então eu preciso declara-las como &lt;code&gt;Acme.Xpto.Foo&lt;/code&gt; e &lt;code&gt;Acme.Xpto.Bar&lt;/code&gt; respectivamente.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Se eu tenho que escrever as Unidades de forma totalmente qualificada, qual é a grande vantagem? Não seria mais simples todas as Unidades do Pacote já serem totalmente qualificadas?&lt;/p&gt;

&lt;p&gt;De fato, é possível não escrever os Namespaces, em alguns casos.&lt;/p&gt;

&lt;p&gt;É possível, por exemplo, declarar a Unidade &lt;code&gt;Dialogs&lt;/code&gt; no código do seu projeto mas a referência real será &lt;code&gt;Vcl.Dialogs&lt;/code&gt; ou &lt;code&gt;FMX.Dialogs&lt;/code&gt;, bastando definir um parâmetro para o compilador. Parece ser uma &lt;em&gt;feature&lt;/em&gt; interessante mas, e se eu quisesse utilizar ambas as Unidades no mesmo projeto, como o compilador iria saber qual &lt;code&gt;Dialogs&lt;/code&gt; utilizar? Será que uma das Unidades deveria ser totalmente qualificada enquanto a outra não? Se assim for, é uma solução &lt;em&gt;inconsistente&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Talvez, o Objetivo da implementação padrão serviu apenas aos interesses da Embarcadero para o uso da VCL/FMX ao invés de ser realmente uma nova &lt;em&gt;feature&lt;/em&gt; para o desenvolvedor.&lt;/p&gt;

&lt;p&gt;Namespaces, na minha opinião, deveriam ser implementados de outra forma.&lt;/p&gt;

&lt;h2 id=&quot;problema&quot;&gt;O Problema&lt;/h2&gt;

&lt;p&gt;Uma Unidade já agrupa, de forma inequívoca, um identificador. Sempre tivemos isso na linguagem Object Pascal mas muitos acham que esse conceito só apareceu em linguagens mais recentes.&lt;/p&gt;

&lt;p&gt;Porém, hoje em dia eu posso ver uma referência a &lt;code&gt;Dialogs&lt;/code&gt; no código e não ter certeza se é da VCL ou qualquer outra Lib que utiliza Namespaces. É necessário verificar as configurações do compilador.&lt;/p&gt;

&lt;p&gt;Olhar “só” o código não é mais suficiente.&lt;/p&gt;

&lt;p&gt;Outro problema existe com o uso de Libs externas. Não sabemos, previamente, quais nomes de Unidades serão utilizadas pelos programadores ao redor do mundo. Esse é o motivo pelo qual sempre utilizamos prefixos (2~3 letras) nos nomes da Unidades/Classes para simular um Namespace único.&lt;/p&gt;

&lt;p&gt;Incrivelmente, essa pratica tem sido suficiente para a maioria dos casos. Pelo menos, para a maioria dos projetos Open Source mais conhecidos como Zeos(Z), RX, Indy(Id), JEDI(Jc) ou Synopse mORMot(Syn). Parece haver um certo “cavalheirismo” entre programadores em não utilizar os prefixos “já em uso” na comunidade Open Source.&lt;/p&gt;

&lt;p&gt;No Java, eles resolveram esse problema de forma mais simples: Utilize a URL da empresa/projeto como um Namespace para cada projeto.&lt;/p&gt;

&lt;p&gt;E é só isso. Não há ambiguidades, pois não há URL iguais.&lt;/p&gt;

&lt;p&gt;Então, bastaria fazermos o mesmo em Object Pascal. O mesmo que a comunidade de Java fez. Basta utilizar o maior nome possível para uma Unidade. Não haverá ambiguidade. Não haverá conflito. Não é necessário implementar nada no compilador.&lt;/p&gt;

&lt;p&gt;Resolvido?&lt;/p&gt;

&lt;p&gt;Em teoria sim. No entanto a implementação atual do Namespaces clama em dizer que é muito mais quem um nome único (veremos mais sobre isso abaixo).&lt;/p&gt;

&lt;p&gt;Além disso, Object Pascal não é assim, tão verboso. Gostamos de nomes simples e de fácil memorização. Podemos programar utilizando um editor simples de texto. Em Java, por exemplo, é necessário haver uma IDE inteligente para ter o mínimo de eficiência na codificação, visto que a IDE incluí automaticamente as “unidades” que serão importadas, além de fazer uma tonelada de checagens.&lt;/p&gt;

&lt;p&gt;Bem, se vamos alterar ou melhorar o conceito de Unidades, por quê não fazer isso de forma inteligente, ainda mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, eficaz e sem os problemas de ambiguidades na utilização dos Namespaces atuais?&lt;/p&gt;

&lt;p&gt;Podemos sugerir algumas ideias.&lt;/p&gt;

&lt;h2 id=&quot;desejavel&quot;&gt;Namespaces Desejável&lt;/h2&gt;

&lt;p&gt;Então, qual seria o &lt;em&gt;nirvana&lt;/em&gt; da implementação de Namespaces no Delphi e Lazarus?&lt;/p&gt;

&lt;p&gt;Eu posso lhe dizer minhas ideias (atuais) e no fim veremos se você concorda.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespaces deveriam ser únicos e explícitos no código&lt;/strong&gt;, sem ambiguidades.&lt;/p&gt;

&lt;p&gt;É &lt;em&gt;errado&lt;/em&gt; e anti-Pascal ter uma Unidade que não está 100% explícita no código sobre o que ela representa ou se há ambiguidades sobre o que ela representa.&lt;/p&gt;

&lt;p&gt;Isso quer dizer que &lt;code&gt;Dialogs&lt;/code&gt; &lt;em&gt;não&lt;/em&gt; pode representar, ora &lt;code&gt;FMX.Dialogs&lt;/code&gt;, ora &lt;code&gt;Vcl.Dialogs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mesmo que eles possam ser configuráveis, eles deveriam ser únicos no código para não haver ambiguidades.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespaces deveriam ser dinâmicos&lt;/strong&gt;, porém explícitos no código.&lt;/p&gt;

&lt;p&gt;Ser dinâmico implica em configuração. Então, a ideia de definirmos Namespaces como argumentos do compilador é boa, porém sua implementação atual não foi bem executada.&lt;/p&gt;

&lt;p&gt;Sim, Namespaces deveriam ser definidos &lt;em&gt;por&lt;/em&gt; Pacote, porém o &lt;em&gt;erro&lt;/em&gt; é defini-los utilizando os nomes dos Pacotes.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;configuração&lt;/em&gt; deveria ser local.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespaces deveriam ser locais&lt;/strong&gt;, ou seja, cada projeto implementa os Namespaces de acordo com a nomenclatura que desejar.&lt;/p&gt;

&lt;p&gt;Na minha opinião, ao adicionar um Pacote ao meu projeto, eu poderia (ou deveria) definir um Namespace para ele. É o mesmo que dizer que todas as Unidades do Pacotes seriam “renomeadas” com o novo prefixo — muito similar com a solução atual — porém sem ambiguidades.&lt;/p&gt;

&lt;p&gt;Imagine 2 Pacotes: &lt;code&gt;FooPack&lt;/code&gt; e &lt;code&gt;BarPack&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Os desenvolvedores de ambos não deveriam se importar sobre Namespaces. Cada Pacote está bem definido em seus próprios contextos locais, sem se preocupar com o mundo afora. Não importa se os projetos que irão utilizá-los serão pequenos ou gigantescos com inúmeras dependências de vários outros Pacotes. Isso deveria ser irrelevante para os autores de Pacotes.&lt;/p&gt;

&lt;p&gt;Cabe a cada Projeto definir o Namespace para cada Pacote, se assim o desejar.&lt;/p&gt;

&lt;p&gt;Por exemplo, se ambos os Pacotes tem uma Unidade chamada &lt;code&gt;Utils&lt;/code&gt;, nos iríamos referenciá-las como &lt;code&gt;Foo.Utils&lt;/code&gt; e &lt;code&gt;Bar.Utils&lt;/code&gt; dentro do código do Projeto.&lt;/p&gt;

&lt;p&gt;Essa foram escolhas óbvias. Mas ou invés de &lt;code&gt;Foo.Utils&lt;/code&gt; e &lt;code&gt;Bar.Utils&lt;/code&gt; poderiam ser &lt;code&gt;FoPack.Utils&lt;/code&gt; e &lt;code&gt;BrPack.Utils&lt;/code&gt;, respectivamente. O mais importante aqui é que estas são &lt;em&gt;escolhas do Projeto&lt;/em&gt;, do usuário do Pacote, não daqueles que criaram os Pacotes.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;É necessário uma implementação mais moderna do conceito de Namespace, porém sem perder as características originais do Object Pascal.&lt;/p&gt;

&lt;p&gt;Tudo na linguagem é previamente declarado, exatamente para não haver ambiguidades. Unidades devem ser únicas em todo o projeto. Não importa se elas estão na VCL/LCL, RTL, Libs, etc. Não deveriam haver ambiguidades.&lt;/p&gt;

&lt;p&gt;Tudo é ou deveria ser explícito no código. Deixar o compilador decidir se um identificador corresponde a X ou a Y em tempo de execução, não me parece ser algo tão explícito.&lt;/p&gt;

&lt;p&gt;Finalmente, as ideias propostas nesse artigo tem a finalidade e o desejo de melhorar a linguagem Object Pascal e não depreciar as escolhas de &lt;em&gt;design&lt;/em&gt; dos desenvolvedores da linguagem e do compilador.&lt;/p&gt;

&lt;p&gt;Esses são meus pensamentos… Você concorda?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/namespaces-inteligentes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/namespaces-inteligentes</guid>
      </item>
    
      <item>
        <title>Interfaces COM vs. CORBA</title>
        <description>&lt;p&gt;Existem dois tipos de Interfaces no Free Pascal definidos como COM e CORBA. No Delphi temos apenas o tipo COM. Mas será que existem vantagens ao utilizar o tipo CORBA?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-hermes-rivera-265372.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Hermes Rivera on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No Delphi, quando definimos que um Objeto é do tipo Interface, quer dizer que (por padrão) ele será a liberado automaticamente da memória pelo compilador quando a variável sair do escopo e sua &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#contador-de-referencias&quot;&gt;contagem de referência&lt;/a&gt; chegar a zero.&lt;/p&gt;

&lt;p&gt;Para utilizar essa &lt;em&gt;feature&lt;/em&gt;, basta implementar sua Classe herdando de &lt;code&gt;TInterfacedObject&lt;/code&gt;, afim de utilizar a implementação padrão para Interfaces COM.&lt;/p&gt;

&lt;p&gt;Se você não quiser utilizar &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;, terá que implementar os &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#contador-de-referencias&quot;&gt;3-métodos&lt;/a&gt; obrigatórios para toda Classe que implementa Interfaces COM e isso realmente pode parecer estranho para programadores que estão vindo de outras linguagens.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Por quê eu deveria implementar métodos que não estão definidos na Interface?”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Realmente, não parece fazer muito sentido.&lt;/p&gt;

&lt;h2 id=&quot;corba&quot;&gt;CORBA&lt;/h2&gt;

&lt;p&gt;No Free Pascal você tem uma escolha. Pode-se utilizar Interfaces COM ou CORBA. O primeiro tipo se comporta do mesmo jeito que no Delphi. Tem contagem de referência e liberação automática de memória, enquanto o tipo CORBA é exatamente o contrário. Esse tipo não tem contagem de referência e, por isso, não tem a ajuda do compilador para liberar a memória automaticamente. Cabe ao programador liberar os Objetos utilizando seus respectivos destrutores.&lt;/p&gt;

&lt;p&gt;Também não é possível liberar uma instância apenas atribuindo &lt;code&gt;nil&lt;/code&gt;. É necessário que se tenha a instância de uma Classe ou que a Interface tenha algum método que possa ser utilizado como destrutor, por exemplo, &lt;code&gt;Free&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IFoo = interface
    procedure Execute;
    procedure Free;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O tipo CORBA não exige do programador a implementação “obscura” de métodos de &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#infraestrutura&quot;&gt;infraestrutura&lt;/a&gt; além do que está declarado na Interface. Apenas os métodos das Interfaces devem ser implementados nas Classes. Essa é uma vantagem em relação ao tipo COM.&lt;/p&gt;

&lt;p&gt;Então, se você estiver desenvolvendo utilizando Free Pascal e não quer trabalhar com contagem de referência, utilizar CORBA pode ser uma boa opção.  Sua sintaxe e &lt;em&gt;design&lt;/em&gt; “limpos” não obrigam o programador a implementar os 3-métodos padrões de COM.&lt;/p&gt;

&lt;p&gt;Entretanto, lembre-se que todas as Interfaces dentro da mesma Unit terão o mesmo tipo, seja COM ou CORBA.&lt;/p&gt;

&lt;h2 id=&quot;com&quot;&gt;COM&lt;/h2&gt;

&lt;p&gt;Muitos programadores não gostam de utilizar o tipo COM devido aos problemas com referência de Objetos. Mesmo que a &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;solução&lt;/a&gt; seja simples para resolvê-los.&lt;/p&gt;

&lt;p&gt;Enquanto o tipo CORBA pode ter um &lt;em&gt;design&lt;/em&gt; mais simples, o tipo COM é mais &lt;em&gt;customizável&lt;/em&gt; pois pode ser implementado sem contagem de referência. Basta implementarmos os 3-métodos obrigatórios sem incrementar a contagem.&lt;/p&gt;

&lt;p&gt;Pessoalmente, sempre prefiro utilizar o tipo COM e a contagem de referência para a liberação automática dos objetos na memória. Entretanto, se eu quiser que apenas algumas Classes não tenham a contagem de referência, basta sobrescrever os métodos necessários para ter o mesmo comportamento das Classes que implementam Interfaces CORBA.&lt;/p&gt;

&lt;p&gt;Considero isso uma &lt;em&gt;grande&lt;/em&gt; vantagem!&lt;/p&gt;

&lt;p&gt;Por exemplo. Posso ter uma única Interface mas com implementações distintas em Classes diferentes, utilizando ou não a contagem de referência.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Minha conclusão é que o tipo COM é &lt;em&gt;melhor&lt;/em&gt; do que CORBA por quê podemos implementar os dois tipos de comportamentos (com ou sem contagem de referência), enquanto com CORBA implementamos apenas um comportamento.&lt;/p&gt;

&lt;p&gt;O comportamento deve estar nas Classes, não nas Interfaces ou diretivas de compilação.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/com-vs-corba</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/com-vs-corba</guid>
      </item>
    
  </channel>
</rss>
