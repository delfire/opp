<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Interfaces COM vs. CORBA</title>
        <description>&lt;p&gt;Existem dois tipos de Interfaces no Free Pascal definidos como COM e CORBA. No Delphi temos apenas o tipo COM. Mas será que existem vantagens ao utilizar o tipo CORBA?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-hermes-rivera-265372.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Hermes Rivera on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No Delphi, quando definimos que um Objeto é do tipo Interface, quer dizer que (por padrão) ele será a liberado automaticamente da memória pelo compilador quando a variável sair do escopo e sua &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#contador-de-referencias&quot;&gt;contagem de referência&lt;/a&gt; chegar a zero.&lt;/p&gt;

&lt;p&gt;Para utilizar essa &lt;em&gt;feature&lt;/em&gt;, basta implementar sua Classe herdando de &lt;code&gt;TInterfacedObject&lt;/code&gt;, afim de utilizar a implementação padrão para Interfaces COM.&lt;/p&gt;

&lt;p&gt;Se você não quiser utilizar &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;, terá que implementar os &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#contador-de-referencias&quot;&gt;3-métodos&lt;/a&gt; obrigatórios para toda Classe que implementa Interfaces COM e isso realmente pode parecer estranho para programadores que estão vindo de outras linguagens.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Por quê eu deveria implementar métodos que não estão definidos na Interface?”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Realmente, não parece fazer muito sentido.&lt;/p&gt;

&lt;h2 id=&quot;corba&quot;&gt;CORBA&lt;/h2&gt;

&lt;p&gt;No Free Pascal você tem uma escolha. Pode-se utilizar Interfaces COM ou CORBA. O primeiro tipo se comporta do mesmo jeito que no Delphi. Tem contagem de referência e liberação automática de memória, enquanto o tipo CORBA é exatamente o contrário. Esse tipo não tem contagem de referência e, por isso, não tem a ajuda do compilador para liberar a memória automaticamente. Cabe ao programador liberar os Objetos utilizando seus respectivos destrutores.&lt;/p&gt;

&lt;p&gt;Também não é possível liberar uma instância apenas atribuindo &lt;code&gt;nil&lt;/code&gt;. É necessário que se tenha a instância de uma Classe ou que a Interface tenha algum método que possa ser utilizado como destrutor, por exemplo, &lt;code&gt;Free&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IFoo = interface
    procedure Execute;
    procedure Free;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O tipo CORBA não exige do programador a implementação “obscura” de métodos de &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#infraestrutura&quot;&gt;infraestrutura&lt;/a&gt; além do que está declarado na Interface. Apenas os métodos das Interfaces devem ser implementados nas Classes. Essa é uma vantagem em relação ao tipo COM.&lt;/p&gt;

&lt;p&gt;Então, se você estiver desenvolvendo utilizando Free Pascal e não quer trabalhar com contagem de referência, utilizar CORBA pode ser uma boa opção.  Sua sintaxe e &lt;em&gt;design&lt;/em&gt; “limpos” não obrigam o programador a implementar os 3-métodos padrões de COM.&lt;/p&gt;

&lt;p&gt;Entretanto, lembre-se que todas as Interfaces dentro da mesma Unit terão o mesmo tipo, seja COM ou CORBA.&lt;/p&gt;

&lt;h2 id=&quot;com&quot;&gt;COM&lt;/h2&gt;

&lt;p&gt;Muitos programadores não gostam de utilizar o tipo COM devido aos problemas com referência de Objetos. Mesmo que a &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;solução&lt;/a&gt; seja simples para resolvê-los.&lt;/p&gt;

&lt;p&gt;Enquanto o tipo CORBA pode ter um &lt;em&gt;design&lt;/em&gt; mais simples, o tipo COM é mais &lt;em&gt;customizável&lt;/em&gt; pois pode ser implementado sem contagem de referência. Basta implementarmos os 3-métodos obrigatórios sem incrementar a contagem.&lt;/p&gt;

&lt;p&gt;Pessoalmente, sempre prefiro utilizar o tipo COM e a contagem de referência para a liberação automática dos objetos na memória. Entretanto, se eu quiser que apenas algumas Classes não tenham a contagem de referência, basta sobrescrever os métodos necessários para ter o mesmo comportamento das Classes que implementam Interfaces CORBA.&lt;/p&gt;

&lt;p&gt;Considero isso uma &lt;em&gt;grande&lt;/em&gt; vantagem!&lt;/p&gt;

&lt;p&gt;Por exemplo. Posso ter uma única Interface mas com implementações distintas em Classes diferentes, utilizando ou não a contagem de referência.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Minha conclusão é que o tipo COM é &lt;em&gt;melhor&lt;/em&gt; do que CORBA por quê podemos implementar os dois tipos de comportamentos (com ou sem contagem de referência), enquanto com CORBA implementamos apenas um comportamento.&lt;/p&gt;

&lt;p&gt;O comportamento deve estar nas Classes, não nas Interfaces ou diretivas de compilação.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/com-vs-corba</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/com-vs-corba</guid>
      </item>
    
      <item>
        <title>Versões Antigas dos Compiladores</title>
        <description>&lt;p&gt;A primeira versão do Delphi data de 1995, após o Turbo Pascal,enquanto o compilador Free Pascal é de 1993.&lt;/p&gt;

&lt;p&gt;Estamos em 2018 agora. Será que vale a pena manter seu código executando nas versões antigas do compilador?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-danielle-macinnes-222441.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Danielle MacInnes on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Talvez não valha a pena manter o código dos seus projetos funcionando nas versões antigas, uma vez que você tenha conseguido migrar todo o código-fonte para uma versão mais nova. No entanto, suas bibliotecas — especialmente as públicas, Open Source — poderiam (ou deveriam?) continuar compilando nas versões mais antigas dos compiladores.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O primeiro motivo&lt;/strong&gt; é bem simples. &lt;em&gt;Compatibilidade&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas por quê isso é importante?&lt;/p&gt;

&lt;p&gt;Trabalho profissionalmente com o Delphi desde sua versão 4 e um dos critérios que me fizeram continuar na ferramenta foi a retrocompatibilidade. Um código que executava na versão anterior, continuava executando na versão mais nova.&lt;/p&gt;

&lt;p&gt;Lembro das palestras e encontros proporcionados pela antiga Borland, onde o palestrante abria aquele “Projeto dos Peixinhos” feito no Delphi 1~2 e ele continuava compilando normalmente, sem alterações, na versão mais nova.&lt;/p&gt;

&lt;p&gt;É difícil ver esse nível de comprometimento com o usuário/desenvolvedor hoje em dia. Quantos frameworks a Microsoft já criou e matou na plataforma .NET? Temos que ficar correndo como “ratos” atrás do próximo “queijo sofisticado” para fazer o mesmo tipo de projeto que já estávamos fazendo a 20 anos atrás? Tenho certeza que não.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O segundo motivo&lt;/strong&gt; é proporcionar mais &lt;em&gt;opções&lt;/em&gt; de bibliotecas à comunidade Object Pascal.&lt;/p&gt;

&lt;p&gt;Hoje em dia a linguagem se tornou um (pequeno) nicho. Enquanto nascem “centenas” de frameworks JavaScript todos os dias, não vemos o mesmo empenho na comunidade Pascal. Então, é importante manter o código legado funcionando para manter os desenvolvedores fieis a linguagem. Senão eles irão procurar alternativas lá fora. Melhor ainda, seria se tivéssemos mais opções a escolher, no entanto.&lt;/p&gt;

&lt;p&gt;Eu já publiquei algumas bibliotecas Open Source a alguns anos, mas agora elas não existem mais. Não valiam a pena. Eram só “brinquedos”. Elas deveriam mesmo desaparecer. No entanto existem bibliotecas que fizeram e ainda fazem muita diferença no desenvolvimento hoje como a RX e JEDI. Acredito que essas bibliotecas não compilem utilizando versões antigas, no entanto elas foram atualizadas, o que já é um grande mérito para seus mantenedores.&lt;/p&gt;

&lt;p&gt;Existem ainda alguns &lt;em&gt;ninjas&lt;/em&gt; do Object Pascal que mantém uma &lt;em&gt;única&lt;/em&gt; base de código desde o Delphi 6 até o Delphi 10.2 Tokyo, compilando também no FPC 2.7.1/3.1.1 em diante. Me refiro ao framework &lt;a href=&quot;https://synopse.info/fossil/wiki?name=SQLite3+Framework&quot;&gt;mORMot&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mORMot é o estado-da-arte&lt;/strong&gt; dentre todos os projetos Object Pascal que conheço. Com uma &lt;em&gt;única&lt;/em&gt; base de código e sintaxe “old-school”, sem generics, sem classes anônimas, sem métodos anônimos, sem n.a.m.e.s.p.a.c.e.s, ou seja, “apenas” com Classes, Interfaces e funções, o autor Arnaud Bouchez e colaboradores foram capazes de criar e manter ao longo dos anos, um framework Client-Server ORM/ODM SOA MVC completo, quase sem dependências externas, com performance &lt;em&gt;superior&lt;/em&gt; as soluções &lt;em&gt;modernas&lt;/em&gt; como Node.js.&lt;/p&gt;

&lt;p&gt;Isso prova que &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt; e arquitetura bem feita são muito mais importantes que novas &lt;em&gt;features&lt;/em&gt; na linguagem, novos componentes, nova IDE…&lt;/p&gt;

&lt;p&gt;A alguns anos eu voltei a publicar projetos Open Source, com uma nova abordagem e profissionalismo. Mas quando vejo projetos como o mORMot, tenho a plena convicção do quanto eu ainda tenho que aprender.&lt;/p&gt;

&lt;p&gt;Hoje utilizo FPC/Lazarus mais do que Delphi. Comecei a migrar meus sistemas e bibliotecas privadas para a “plataforma concorrente” a alguns anos. Nessa época o Lazarus era um “brinquedo” mas, felizmente, continuei a utilizá-lo e hoje o Lazarus é tão bom quanto o Delphi — talvez melhor. No entanto, o &lt;em&gt;Delphi 7&lt;/em&gt; ainda faz parte do meu dia-a-dia. Então, vale a pena fazer bibliotecas para essa versão? Talvez.&lt;/p&gt;

&lt;p&gt;Saber que as mesmas bibliotecas que eu sempre utilizei foram sendo atualizadas ao londo de todos esses anos, é um conforto. Não precisarei reescrever meus sistemas… pelo menos enquanto mantermos a linguagem viva.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/versoes-antigas-dos-compiladores</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/versoes-antigas-dos-compiladores</guid>
      </item>
    
      <item>
        <title>Objetos Complexos</title>
        <description>&lt;p&gt;Um Objeto não é apenas uma instância de uma Classe. Ele pode conter instâncias (quase) infinitas de diferentes Classes combinadas.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-chuttersnap-378918.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by chuttersnap on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;No mundo real convivemos constantemente com Objetos (humanos, animais, plantas, coisas, etc) que possuem todo tipo de &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamento&lt;/a&gt; especializado. Alguns desses Objetos — talvez a maioria — fazem coisas demais, ou seja, eles agregam muitas funcionalidades num único “corpo”. Eles são &lt;em&gt;complexos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Quando tentamos abstrair e implementar um &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Objeto ou Entidade&lt;/a&gt; no &lt;em&gt;software&lt;/em&gt;, utilizando uma linguagem de programação em conjunto com o paradigma da Orientação a Objetos, uma dúvida comum em quase todos os desenvolvedores iniciantes — ou mesmo experientes — é tentar identificar quais métodos irão ser implementados na Classe, baseado apenas no comportamento “final” do Objeto ou Entidade do mundo real.&lt;/p&gt;

&lt;p&gt;O comportamento final ao que me refiro é como vemos um Objeto e suas funcionalidades sem considerar as partes que os compõem. Vemos um Objeto como um &lt;em&gt;todo&lt;/em&gt; e não como uma soma das partes.&lt;/p&gt;

&lt;p&gt;Esse é um grande equívoco no desenvolvimento de software.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo. Como representamos um &lt;em&gt;Carro&lt;/em&gt; utilizando a &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;O primeiro passo seria determinar o nível de abstração dos comportamentos que precisamos implementar ou descartar. Em outras palavras, é necessário saber os requisitos do sistema para sabermos o que é realmente necessário.  Se a cor do carro é irrelevante para os requisitos do usuário dentro do &lt;em&gt;software&lt;/em&gt;, então não há necessidade de implementarmos. É necessário saber se a carroceria utiliza fibra de carbono ou alumínio? Se o carro é 4x4, sua velocidade máxima, quantidade de airbags, tipo de roda? Se nada disso for importante, descartamos. Então, o mais fácil a fazer é pensarmos no que é &lt;em&gt;necessário&lt;/em&gt;, pois é quase certo que qualquer Objeto implementado não irá representar uma entidade completamente, ou seja, com todo comportamento que a entidade possui no mundo real.&lt;/p&gt;

&lt;p&gt;Após termos o comportamento necessário já definido, o próximo passo é pensar na estrutura da Classe.&lt;/p&gt;

&lt;p&gt;É aqui, neste momento, que a grande maioria dos desenvolvedores utiliza o paradigma procedural, porém pensam que estão programando Orientado a Objetos apenas por quê estão utilizando Classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TCar = class
  public
    procedure Run;
    procedure Brake;
    function CheckBrakeFluid: Boolean;
    function CheckOil: Boolean;
    function CheckWater: Boolean;
    procedure LockDoors;
    procedure UnlockDoors;
    procedure StartEngine;
    procedure StopEngine;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Classe acima mostra de forma simples os comportamentos necessários que foram solicitados, hipoteticamente, nos requisitos do usuário. Mas será esse é o design &lt;em&gt;correto&lt;/em&gt; para representar um carro dentro do &lt;em&gt;software&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Apesar das funcionalidades estarem bem evidentes e com &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/&quot;&gt;nomes de métodos&lt;/a&gt; bem “explicativos”, essa é uma implementação totalmente equivocada.&lt;/p&gt;

&lt;p&gt;Um carro não &lt;em&gt;corre&lt;/em&gt;. É o motor que gira e, através de mecanismos e engrenagens, passa energia para as rodas fazendo o carro se mover através do atrito dos pneus com o asfalto.&lt;/p&gt;

&lt;p&gt;Um carro não &lt;em&gt;freia&lt;/em&gt;. É o motorista que através de um pedal, em conjunto com cabos ou mesmo eletrônica, envia um comando às pinças de freio. Essas, em conjunto com os discos de freio, fazem o carro parar.&lt;/p&gt;

&lt;p&gt;Um carro não faz &lt;em&gt;checagens&lt;/em&gt; de fluídos. Existem sensores específicos para fazer essa leitura a cada segundo ou microssegundo.&lt;/p&gt;

&lt;p&gt;Fica claro aqui, que não devemos ver a entidade como um todo, mas sim pensar nas partes específicas que a compõe. No entanto, não devemos especializar demais para não complicarmos o modelo desnecessariamente.&lt;/p&gt;

&lt;p&gt;Vamos reescrever a Classe acima.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TBrakes = class(TInterfacedObject, IBrakes)
  public
    function Brake(AForce: Double): IBrakes;
  end;
  
  TSensors = class(TInterfacedObject, ISensors)
  public
    function CheckBrakeFluid: Boolean;
    function CheckOil: Boolean;
    function CheckWater: Boolean;
  end;
  
  TDoors = class(TInterfacedObject, IDoors)
  public
    function Lock: IDoors;
    function Unlock: IDoors;
  end;
  
  TEngine = class(TInterfacedObject, IEngine)
  public
    procedure Start;
    procedure Stop;
    function Work: IEngine;
  end;
  
  TCar = class(TInterfacedObject, ICar)
  public
    procedure Run;
    function Brakes: IBrakes;
    function Sensors: ISensors;
    function Doors: IDoors;
    function Engine: IEngine;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Há várias possibilidade de implementação, mas a opção sugerida acima separa bem o comportamento de um carro através da composição de Objetos. No entanto, não há necessidade de especializar tudo. Por exemplo, o método &lt;code&gt;Run&lt;/code&gt; continua o mesmo; existe apenas uma Classe &lt;code&gt;TSensors&lt;/code&gt; para todos os sensores — seria muito melhor se tivéssemos uma Classe por sensor.&lt;/p&gt;

&lt;p&gt;O design deve ser o mais simples possível, porém correto, reutilizável (partes independentes) e testável (cada parte em separado).&lt;/p&gt;

&lt;p&gt;Na minha opinião, a &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt;, a reutilização e a testabilidade devem ser alguns dos maiores objetivos a serem seguidos no design de cada Classe.&lt;/p&gt;

&lt;p&gt;Essa foi uma maneira de implementar algo complexo de forma simples.&lt;/p&gt;

&lt;p&gt;Um outro padrão de desenvolvimento que podemos utilizar para implementarmos algo complexo é chamado de &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração de Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Imagine que você tenha diferentes modelos de motores. Utilizar &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança de Classes&lt;/a&gt; pode ser a primeira técnica que vem a sua mente, porém a Decoração de Objetos pode ser bem melhor. Utilizando essa técnica, podemos decorar Objetos em &lt;em&gt;runtime&lt;/em&gt; de acordo com os requisitos ou escolhas feita pelos usuários num determinado momento.&lt;/p&gt;

&lt;p&gt;Então, seguindo nosso exemplo, imagine um motor chamado X13 e uma versão com mais performance chamada X15 que possui um turbo compressor. Ao implementarmos essas Classes, gostaríamos de reutilizar as partes em comum. Sendo o X15 uma melhoria do X13, que tal &lt;em&gt;decorar&lt;/em&gt; o X13 em &lt;em&gt;runtime&lt;/em&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  Engine: IEngine;
begin
  Engine := 
    TX15Engine.New(
      0.6, // pressure
      TX13Engine.New()
    );
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo, a variável &lt;code&gt;Engine&lt;/code&gt; será, de certa forma, um Objeto &lt;em&gt;combinado&lt;/em&gt; de duas instâncias de Classes diferentes, porém complementares.&lt;/p&gt;

&lt;p&gt;Para implementarmos Objetos complexos, devemos analisar suas partes, de acordo com o nível de abstração requerido, e implementar cada uma delas, combinando-as entre si, para então termos a implementação de um Objeto maior e mais &lt;em&gt;complexo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“O todo é maior que a soma das partes”.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/objetos-complexos</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/objetos-complexos</guid>
      </item>
    
      <item>
        <title>O Procedimento Exit</title>
        <description>&lt;p&gt;Todos os programadores Pascal conhecem o procedimento &lt;code&gt;Exit()&lt;/code&gt; desde as primeiras versões dos compiladores. Mas será que todos sabem utilizá-lo corretamente?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-kev-seto-94686.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Kev Seto on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;O procedimento &lt;code&gt;Exit()&lt;/code&gt; é utilizado quando queremos sair de um escopo em execução. Esse escopo pode ser uma função, procedimento, método ou até mesmo o próprio programa.&lt;/p&gt;

&lt;p&gt;Vamos dizer que um programa console chame um procedimento &lt;code&gt;Execute&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  Writeln(&#39;1. Passing on this line...&#39;);
  Exit;
  Writeln(&#39;2. It will not pass here&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, somente a informação do primeiro &lt;code&gt;Writeln&lt;/code&gt; será mostrado no console.&lt;/p&gt;

&lt;p&gt;Ao sair de um escopo, o programa retorna imediatamente para o escopo anterior (outra função/procedimento/método ou o próprio programa). A única exceção a essa regra é quando há blocos &lt;code&gt;try-finally&lt;/code&gt;. Se &lt;code&gt;Exit()&lt;/code&gt; for chamado dentro de um bloco &lt;code&gt;try-finally&lt;/code&gt; o compilador irá executar o código dentro do &lt;code&gt;finally-end&lt;/code&gt; &lt;em&gt;antes&lt;/em&gt; de sair do escopo.&lt;/p&gt;

&lt;p&gt;Aqui está outro exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  try
    Writeln(&#39;1. Passing on this line...&#39;);
    Exit;
  finally
    Writeln(&#39;2. I am still here!&#39;);
  end;
  Writeln(&#39;3. It will not pass here&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os textos #1 e #2 serão mostrados no console. Mesmo que &lt;code&gt;Exit()&lt;/code&gt; tenha sido chamado antes da impressão do texto #2, ainda sim o código é executado devido ao &lt;code&gt;try-finally&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Outro exemplo de uso do &lt;code&gt;Exit()&lt;/code&gt; é quando fazemos validações. Se uma validação ou checagem não retornar verdadeiro, utilizamos o &lt;code&gt;Exit()&lt;/code&gt; para parar a execução do escopo atual.&lt;/p&gt;

&lt;p&gt;Suponha que queremos somar dois números inteiros, mas só queremos números maiores que zero:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;lt; 0) or (B &amp;lt; 0) then
    Exit;
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, o retorno da função &lt;code&gt;Sum&lt;/code&gt; é inicializado com um valor inválido e depois há uma validação para saber se os valores são menores que &lt;code&gt;0&lt;/code&gt;. Se o teste falhar, o programa irá retornar para o escopo anterior à chamada da função &lt;code&gt;Sum&lt;/code&gt; com o resultado inválido. Mas se o teste não falhar, o resultado da função será a soma de A e B.&lt;/p&gt;

&lt;p&gt;Há aqueles que são adeptos da programação estruturada e preferem não “quebrar” a execução do programa com uma “saída antecipada”, ou seja, não fazem uso do &lt;code&gt;Exit()&lt;/code&gt; por acreditarem que o código ficaria mais simples.&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  if (A &amp;gt; 0) and (B &amp;gt; 0) then
    Result := Format(&#39;The result is %d&#39;, [A + B]);
  else
    Result := &#39;Invalid result&#39;;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parece mais simples? Bem, nesse exemplo eu diria que sim. Porém para exemplos com mais condicionais, eu diria que não (vamos ver isso mais abaixo).&lt;/p&gt;

&lt;p&gt;E se quiséssemos dizer ao usuário que seus dados não estão corretos?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;gt; 0) then
  begin
    if (B &amp;gt; 0) then
      Result := Format(&#39;The result is %d&#39;, [A + B]);
    else
      Writeln(&#39;B should be greater than zero&#39;);
  end
  else
    Writeln(&#39;A should be greater than zero&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo não utilizamos &lt;code&gt;Exit()&lt;/code&gt; e eu acho que o código está bem confuso. Os testes estão “separados” do retorno de aviso para o usuário (&lt;code&gt;Writeln&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Kent Beck , Martin Fowler &lt;a href=&quot;https://en.wikipedia.org/wiki/Structured_programming#Early_exit&quot;&gt;afirmaram&lt;/a&gt; categoricamente que &lt;em&gt;“um ponto de saída não é realmente uma regra útil. A clareza é o princípio chave: se o método for mais claro com um ponto de saída, use um ponto de saída, caso contrário, não”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior com o uso de &lt;code&gt;Exit()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;lt; 0) then
  begin
    Writeln(&#39;A should be greater than zero&#39;);
    Exit;
  end;
  if (B &amp;lt; 0) then
  begin
    Writeln(&#39;B should be greater than zero&#39;);
    Exit;
  end;
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código ficou um pouco maior, é verdade, porém os testes e avisos para o usuário ficaram mais simples, na minha opinião. Você não precisa acompanhar todos os &lt;code&gt;if-else&lt;/code&gt; aninhados. A cada teste que falhar, o aviso está logo abaixo e o escopo será abortado com o uso do &lt;code&gt;Exit()&lt;/code&gt;. Se todos os testes não falharem, a função irá retornar a soma de A e B.&lt;/p&gt;

&lt;p&gt;No Delphi, a partir da &lt;a href=&quot;http://docs.embarcadero.com/products/rad_studio/delphiAndcpp2009/HelpUpdate2/EN/html/delphivclwin32/System_Exit.html&quot;&gt;versão 2009&lt;/a&gt;, o procedimento &lt;code&gt;Exit()&lt;/code&gt; ganhou uma melhoria: &lt;code&gt;Exit()&lt;/code&gt; pode ter um parâmetro especificando um resultado. O parâmetro deve ser do mesmo tipo que o resultado da função.&lt;/p&gt;

&lt;p&gt;O FPC também tem a &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/exit.html&quot;&gt;mesma definição&lt;/a&gt;, porém não sei quem implementou essa nova &lt;em&gt;feature&lt;/em&gt; primeiro.&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  if (A &amp;lt; 0) then
    Exit(&#39;A should be greater than zero&#39;);
  if (B &amp;lt; 0) then
    Exit(&#39;B should be greater than zero&#39;);
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/posts/simplicidade/&quot;&gt;Simples&lt;/a&gt; e limpo.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Exit()&lt;/code&gt; pode receber como parâmetro qualquer tipo de retorno, até mesmo instâncias de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;. Utilizando esse parâmetro, é como se ganhássemos o mesmo comportamento da palavra reservada &lt;code&gt;return&lt;/code&gt;, em Java. No entanto, &lt;code&gt;Exit()&lt;/code&gt; em conjunto com &lt;code&gt;Result&lt;/code&gt; nos dá ainda mais possibilidades de retorno para as funções.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/exit-proc</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/exit-proc</guid>
      </item>
    
      <item>
        <title>Pas2JS: Codificando em Pascal, Executando em JavaScript</title>
        <description>&lt;p&gt;A equipe do Free Pascal e Lazarus nos deram um grande presente de Final de Ano: Um Transpiler de Pascal para JavaScript.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-greg-rakozy-129733.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Greg Rakozy on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O uso do JavaScript é necessário para qualquer aplicação Web. Somos obrigados a utilizá-lo por quê (por enquanto) é a única linguagem que os &lt;em&gt;browsers&lt;/em&gt; entendem.&lt;/p&gt;

&lt;p&gt;Mas JavaScript não é fortemente tipado como Pascal e isso pode ser um grande problema quando codificamos aplicações maiores utilizando somente JavaScript.&lt;/p&gt;

&lt;p&gt;JavaScript pode ser &lt;em&gt;confuso&lt;/em&gt; e &lt;em&gt;ambíguo&lt;/em&gt;. Por isso muitos desenvolvedores &lt;em&gt;devem&lt;/em&gt; utilizar &lt;em&gt;frameworks&lt;/em&gt; que facilitam o desenvolvimento e padronizam a codificação.&lt;/p&gt;

&lt;p&gt;Codificar utilizando JavaScript &lt;em&gt;puro&lt;/em&gt; não é uma tarefa fácil.&lt;/p&gt;

&lt;p&gt;Então surgiram os &lt;a href=&quot;https://en.wikipedia.org/wiki/Source-to-source_compiler&quot;&gt;Transpilers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Um Transpiler é um compilador que, a partir de um código-fonte escrito em uma linguagem de programação como sua entrada, produz um código-fonte equivalente em outra linguagem de programação.&lt;/p&gt;

&lt;p&gt;Existem &lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS&quot;&gt;vários&lt;/a&gt; Transpilers para JavaScript a partir de várias linguagens de programação. O mais famoso deles, eu acredito, é a linguagem TypeScript da Microsoft.&lt;/p&gt;

&lt;p&gt;A linguagem Pascal está incluída nesse pacote de Transpilers, no entanto, além de existir poucos, eles são comerciais.&lt;/p&gt;

&lt;p&gt;Felizmente, agora temos uma opção gratuita e Open Source chamada &lt;strong&gt;Pas2JS&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;pas2js&quot;&gt;Pas2JS&lt;/h2&gt;

&lt;p&gt;Michael Van Canneyt (Free Pascal Team), Mattias Gaertner (Lazarus Team), e colaboradores, &lt;a href=&quot;http://lists.lazarus-ide.org/pipermail/lazarus/2017-December/233592.html&quot;&gt;lançaram oficialmente&lt;/a&gt; o compilador utilitário chamado &lt;a href=&quot;http://wiki.freepascal.org/pas2js&quot;&gt;Pas2JS&lt;/a&gt;, em 16 de Dezembro de 2017, na lista oficial do Free Pascal.&lt;/p&gt;

&lt;p&gt;O JavaScript gerado a partir de um código-fonte Pascal é utilizável no &lt;em&gt;browser&lt;/em&gt; ou até mesmo no Node.js.&lt;/p&gt;

&lt;p&gt;Ao invés de gerar um executável com seu código Pascal, um arquivo .js será gerado, compatível com seu &lt;em&gt;browser&lt;/em&gt;, sem a necessidade de haver um servidor de aplicação (CGI, FastCGI, ISAPI, etc) se o aplicativo não necessitar de dados externos.&lt;/p&gt;

&lt;p&gt;Como disse Michael no seu email de lançamento (tradução livre):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Isso torna o Free Pascal um ambiente de desenvolvimento completo para o desenvolvimento Web”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Na verdade, o desenvolvimento ainda não está (totalmente) completo. Funciona muito bem, porém ainda há melhorias a serem feitas, como pode ser visto &lt;a href=&quot;http://wiki.freepascal.org/pas2js#Other_not_implemented_features&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A sintaxe básica é a mesma do Delphi 7&lt;/strong&gt;, porém ainda não temos o suporte a Interfaces. Acredito que teremos isso em breve, no entanto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A RTL teve que ser reescrita&lt;/strong&gt;, gerando novas versões das Unidades padrão para que pudessem ser utilizadas perfeitamente na conversão de Pascal para JavaScript. A lista das unidades você pode ver &lt;a href=&quot;http://wiki.freepascal.org/pas2js#RTL&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O debugging pode ser feito diretamente no código Object Pascal&lt;/strong&gt;, dentro do &lt;em&gt;browser&lt;/em&gt;. Isso é possível por quê o Pas2JS emite um &lt;em&gt;“source map”&lt;/em&gt; para que o &lt;em&gt;browser&lt;/em&gt; exiba o código original em vez do código JavaScript, o que é muito útil para encontrar bugs no código original Pascal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lazarus já tem suporte para a sintaxe do Pas2JS&lt;/strong&gt;, então o &lt;em&gt;code completion&lt;/em&gt; irá funcionar (versão trunk).&lt;/p&gt;

&lt;p&gt;A integração completa do Pas2JS está sendo codificada no Lazarus e, futuramente, eles já falam em desenvolver pacotes de componentes para execução no &lt;em&gt;browser&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TMS Web componentes vai chegar no início de 2018&lt;/strong&gt;. São componentes visuais no bom estilo RAD para desenvolver aplicações Web utilizando &lt;code&gt;TForm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cito a TMS aqui por quê, no email do Michael, ele diz (tradução livre):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Em um futuro muito próximo, um importante fornecedor de componentes da Delphi anunciará um pacote completo para desenvolvimento web RAD no Delphi IDE.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu &lt;em&gt;acredito&lt;/em&gt; que ele estava falando da &lt;a href=&quot;https://www.tmssoftware.com/site/&quot;&gt;TMS&lt;/a&gt;, empresa conceituada que se dedica à fabricação de componentes e frameworks para Delphi e Lazarus.&lt;/p&gt;

&lt;p&gt;A alguns dias atrás os desenvolvedores do Brasil tiveram a chance de ver algumas palestras sobre Delphi e uma delas foi o anúncio da nova tecnologia da TMS para desenvolvimento Web, por Wagner Landgraf.&lt;/p&gt;

&lt;p&gt;Para quem acompanha os pré-anúncios do Pas2JS já algum tempo — pois ele está sendo desenvolvido ao longo de 10 anos — basta “ligar os pontos” para ter quase certeza que os componentes TMS Web utiliza a tecnologia Pas2JS ou, no mínimo, se inspirou nela.&lt;/p&gt;

&lt;p&gt;No entanto, na palestra do Wagner não há nenhuma menção ao Pas2JS.&lt;/p&gt;

&lt;p&gt;Se eu estou certo, ou seja, se a TMS Web realmente utiliza o Pas2JS no seu novo produto, eu considero uma &lt;em&gt;falha&lt;/em&gt; não mencionar quem criou o Transpiler.&lt;/p&gt;

&lt;p&gt;Não há nenhum problema em criar componentes para comercialização, no entanto é necessário dar o crédito a quem é devido.&lt;/p&gt;

&lt;p&gt;Entretanto, isso é apenas uma suposição pessoal. Se a TMS não utiliza/utilizou o Pas2JS, acredito que saberemos disso em breve.&lt;/p&gt;

&lt;p&gt;Mas, independentemente da TMS utilizar ou não o Pas2JS, fico ansioso para ver o lançamento oficial do novo &lt;em&gt;framework&lt;/em&gt;, visto que tais componentes irão funcionar também no Lazarus.&lt;/p&gt;

&lt;p&gt;Sendo a TMS &lt;em&gt;referência&lt;/em&gt; em componentes desde a primeira versão do Delphi, é de se esperar que esse será mais um grande sucesso.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;preview&lt;/em&gt; da tecnologia exposto na palestra foi excelente e motivador.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Para uma linguagem que muitos consideram “morta”, ter um Transpiler de Object Pascal para JavaScript é um grande impulso para por a linguagem (novamente) nos “trilhos do mercado”.&lt;/p&gt;

&lt;p&gt;Sabemos que hoje em dia muitas empresas optam por desenvolver soluções 100% online, via &lt;em&gt;browser&lt;/em&gt;, ao invés de aplicações Desktop.&lt;/p&gt;

&lt;p&gt;Com o Pas2JS será possível termos uma &lt;em&gt;única&lt;/em&gt; base de código Object Pascal — uma linguagem fortemente tipada, limpa e de fácil aprendizagem — onde poderemos utilizar todo o nosso conhecimento da linguagem, da RTL e componentes, para provermos aplicações 100% Web. Confiáveis, rápidas e de fácil manutenção.&lt;/p&gt;

&lt;p&gt;É esperar, pra ver.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/pas2js</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/pas2js</guid>
      </item>
    
      <item>
        <title>Mais Performance usando Argumentos &quot;const&quot; para Interfaces</title>
        <description>&lt;p&gt;Se você utiliza instâncias de Interfaces em todos os lugares e quer aumentar um pouco a performance do seu código, leia esse artigo.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-alex-holyoake-334209.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Alex Holyoake on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Em um código verdadeiramente Orientado a Objetos, as instâncias dos Objetos devem ser do tipo Interface em &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;todos os lugares&lt;/a&gt; do código.&lt;/p&gt;

&lt;p&gt;Além de prover um contrato entre os Objetos, as instâncias de Interfaces são auto-gerenciadas, ou seja, a memória é liberada automaticamente pelo compilador.&lt;/p&gt;

&lt;p&gt;No Free Pascal, no entanto, podemos ter instâncias de Interfaces que não são auto-gerenciadas. Essas interfaces utilizam o modelo &lt;a href=&quot;https://www.freepascal.org/docs-html/prog/progsu37.html&quot;&gt;CORBA&lt;/a&gt; com a directiva &lt;code&gt;{$interfaces corba}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Porém, o &lt;em&gt;default&lt;/em&gt; de uso de Interfaces é o modelo COM, com auto-gerenciamento de memória através de um contador interno de referências à instância.&lt;/p&gt;

&lt;p&gt;Esse auto-gerenciamento tem um custo computacional de execução, mas pode ser extremamente minimizado com apenas uma pequena alteração no código.&lt;/p&gt;

&lt;p&gt;Entretanto, para você entender como essa pequena alteração irá afetar a performance do seu código, antes você precisa saber como o compilador faz o auto-gerenciamento de memória de instâncias de Interfaces.&lt;/p&gt;

&lt;h2 id=&quot;metodos-especiais&quot;&gt;Métodos Especiais&lt;/h2&gt;

&lt;p&gt;Todo Objeto que implementa uma Interface COM — &lt;code&gt;IUnknown&lt;/code&gt; — deve implementar 3 Métodos especiais que não fazem parte da Interface.&lt;/p&gt;

&lt;p&gt;Funciona assim:&lt;/p&gt;

&lt;p&gt;Quando criamos uma instância do tipo Interface, o compilador irá chamar um método especial do Objeto chamado &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown._addref.html&quot;&gt;_AddRef&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse método irá aumentar uma contagem de referência, toda vez que uma nova variável receber a mesma instância do Objeto.&lt;/p&gt;

&lt;p&gt;Da mesma forma, toda vez que uma variável sair do escopo de execução, o compilador irá chamar o método &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown._release.html&quot;&gt;_Release&lt;/a&gt; para decrementar a contagem.&lt;/p&gt;

&lt;p&gt;Quando a contagem de referência — o atributo &lt;code&gt;FRefCount: LongInt&lt;/code&gt; — chegar a zero, o destrutor do Objeto será executado e a memória será liberada.&lt;/p&gt;

&lt;p&gt;Esse mecanismo é muito, muito mais simples do que ter um &lt;em&gt;garbage collector&lt;/em&gt; sendo executado em paralelo, como é feito em outras linguagens.&lt;/p&gt;

&lt;p&gt;Existe mais um terceiro e último método chamado &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown.queryinterface.html&quot;&gt;QueryInterface&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse método é utilizado quando fazemos &lt;a href=&quot;/posts/nao-utilize-casting/&quot;&gt;&lt;em&gt;casting&lt;/em&gt;&lt;/a&gt; do Objeto para Interface utilizando a estrutura &lt;code&gt;Intf := Obj as IMyInterface;&lt;/code&gt; ou quando utilizamos a função &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/sysutils/supports.html&quot;&gt;Supports&lt;/a&gt; para determinar se uma instância implementa ou não uma determinada Interface.&lt;/p&gt;

&lt;p&gt;Todas as Classes que implementam uma ou mais Interfaces, devem ter esses 3 métodos implementados.&lt;/p&gt;

&lt;p&gt;Esse é o motivo de herdarmos quase todas as nossas Classes de &lt;code&gt;TInterfacedObject&lt;/code&gt;, pois ela já contém a implementação destes métodos para lidar com a contagem de referência.&lt;/p&gt;

&lt;p&gt;Implementamos esses métodos apenas para o compilador e é possível sabermos o momento no qual o compilador irá chamá-los, sobrecarregando o código com execuções além da implementação padrão dos Métodos do Objeto.&lt;/p&gt;

&lt;p&gt;Então, se conseguirmos evitar tais chamadas, nosso código terá mais performance pois ciclos de CPU serão poupados.&lt;/p&gt;

&lt;h2 id=&quot;sobrecarga&quot;&gt;Sobrecarga&lt;/h2&gt;

&lt;p&gt;Devido as chamadas automáticas de &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; em toda atribuição e saída de escopo das variáveis, muitos desenvolvedores acham que essa é uma &lt;em&gt;grande&lt;/em&gt; sobrecarga para o código.&lt;/p&gt;

&lt;p&gt;Na Engenharia nada é grátis, havendo sempre prós e contras.&lt;/p&gt;

&lt;p&gt;Se por um lado temos o auto-gerenciamento de memória para instâncias de Interfaces, por outro temos essa sobrecarga do incremento e decremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;Além disso, toda vez que &lt;code&gt;_Release&lt;/code&gt; for chamado, haverá uma checagem para saber se a contagem chegou a zero para que o destrutor do Objeto também seja chamado.&lt;/p&gt;

&lt;p&gt;Eu acredito que essa é uma sobrecarga &lt;em&gt;mínima&lt;/em&gt;, considerando todas as &lt;em&gt;vantagens&lt;/em&gt; que temos ao utilizar instâncias de Interfaces.&lt;/p&gt;

&lt;p&gt;Mas nem todos os desenvolvedores pensam da mesma forma.&lt;/p&gt;

&lt;p&gt;De fato, existem algoritmos que não podem se dar o luxo de perder ciclos de CPU fazendo operações de infraestrutura da linguagem — incremento/decremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;Entretanto, a linguagem Object Pascal nos dá uma “saída” bastante elegante para a diminuição de toda essa sobrecarga.&lt;/p&gt;

&lt;h2 id=&quot;argumentos-const&quot;&gt;Argumentos “const”&lt;/h2&gt;

&lt;p&gt;Sempre que uma instância for passada por parâmetro a outro Objeto através de um argumento, haverá o incremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;A menos que você utilize Argumentos “const”.&lt;/p&gt;

&lt;p&gt;Vamos chamá-los de “&lt;em&gt;ConstArgs&lt;/em&gt;”, para encurtar.&lt;/p&gt;

&lt;p&gt;Aqui está a definição, em tradução livre, de &lt;a href=&quot;https://www.freepascal.org/docs-html/ref/refsu67.html&quot;&gt;const&lt;/a&gt; na documentação do Free Pascal:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Especificar um parâmetro como Constante está dando ao compilador uma dica de que o conteúdo do parâmetro não será alterado pela rotina chamada. Isso permite que o compilador execute otimizações que não poderia fazer de outra forma, e também para executar determinadas verificações no código dentro da rotina: ou seja, pode proibir atribuições ao parâmetro. Além disso, um parâmetro const não pode ser transmitido para outra função que requer um parâmetro variável: o compilador pode verificar isso também. O principal uso para isso é reduzir o tamanho da pilha, portanto, melhorar o desempenho e ainda manter a semântica de passagem por valor…”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eles não falam nada sobre utilizar “const” para argumentos do tipo Interface, no entanto eu posso lhe afirmar que utilizá-los irá aumentar a performance do seu código.&lt;/p&gt;

&lt;p&gt;O motivo é simples: &lt;em&gt;ConstArgs&lt;/em&gt; não executam &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Isso quer dizer que o incremento/decremento do atributo de contagem de referência não irão ocorrer.&lt;/p&gt;

&lt;p&gt;A checagem se o contador interno chegou a zero também não irá existir no ASSEMBLY final gerado pelo compilador.&lt;/p&gt;

&lt;p&gt;Vou demostrar isso, começando com a unidade base de todos os exemplos:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/d7583833ddaf07df796321c95ee8faa8.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A &lt;code&gt;Unit1&lt;/code&gt; contém uma Interface e uma Classe que a implementa.&lt;/p&gt;

&lt;p&gt;Os Métodos &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram sobrescritos para termos o controle do que ocorre dentro deles quando o compilador chamá-los.&lt;/p&gt;

&lt;p&gt;Então vamos criar o primeiro programa de teste que utiliza a &lt;code&gt;Unit1&lt;/code&gt;:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/ac9932e2b0e5a3525fdf05223051d5c9.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Esse é um programa &lt;em&gt;CLI&lt;/em&gt; (&lt;em&gt;command-line&lt;/em&gt;) bem simples.&lt;/p&gt;

&lt;p&gt;É necessário setar a utilização do &lt;a href=&quot;http://wiki.freepascal.org/heaptrc&quot;&gt;&lt;em&gt;heaptrc&lt;/em&gt;&lt;/a&gt; no Lazarus para mostrar os vazamentos de memória (se houver) no final da execução do programa.&lt;/p&gt;

&lt;p&gt;Então, após a execução, no meu laptop a saída foi essa:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
_AddRef called
RefCount is 1
_AddRef called
RefCount is 2
Acting...
_Release called
_Release called
RefCount is 0
Destroing...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
64 memory blocks freed     : 1593/1720
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A execução foi bem sucedida, e não contém vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Porém, veja que &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram, ambos, chamados 2 vezes cada. Isso ocorre por quê, ao criar a instância em &lt;code&gt;A&lt;/code&gt;, há o incremento e ao passar essa instância para &lt;code&gt;Execute&lt;/code&gt;, há um novo incremento da contagem.&lt;/p&gt;

&lt;p&gt;Agora apenas altere a assinatura do procedimento, adicionando &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute(const A: IAction);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute novamente.&lt;/p&gt;

&lt;p&gt;Esse é o resultado por aqui:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
_AddRef called
RefCount is 1
Acting...
_Release called
RefCount is 0
Destroing...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
64 memory blocks freed     : 1593/1720
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A mesma memória foi consumida, mas &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram chamados apenas 1 vez cada.&lt;/p&gt;

&lt;p&gt;Isso se traduz em &lt;em&gt;mais&lt;/em&gt; performance ou &lt;em&gt;menos&lt;/em&gt; sobrecarga, dependendo do seu ponto de vista.&lt;/p&gt;

&lt;p&gt;Imagine se esse mesmo procedimento fosse chamado 100 vezes. Sem o “const” haveria mais de 100 chamadas aos Métodos especiais.&lt;/p&gt;

&lt;p&gt;Mas, se é tão simples eliminar essa sobrecarga apenas especificando o tipo do argumento, por quê nem todos os desenvolvedores utilizam essa técnica?&lt;/p&gt;

&lt;p&gt;Talvez seja apenas falta de conhecimento ou talvez eles tenham lido sobre problemas obscuros de vazamento de memória com o uso de &lt;em&gt;ConstArgs&lt;/em&gt; e Interfaces.&lt;/p&gt;

&lt;h2 id=&quot;problemas&quot;&gt;Argumentos e Interfaces&lt;/h2&gt;

&lt;p&gt;Há alguns artigos na Internet dizendo que temos que ter &lt;a href=&quot;https://pascal.today/2016/12/16/take-care-of-const-and-interface-parameters/&quot;&gt;cuidado&lt;/a&gt; ao utilizarmos &lt;em&gt;ConstArgs&lt;/em&gt; em conjunto com instâncias de Interfaces.&lt;/p&gt;

&lt;p&gt;Sim, &lt;em&gt;devemos&lt;/em&gt; ter cuidado.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O código realmente pode ficar intrincado e vazamentos de memória podem ocorrer&lt;/strong&gt; em lugares onde tudo parece estar correto.&lt;/p&gt;

&lt;p&gt;Para demonstrar vamos a outro exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/979c82ffe9288ec129b5792cfef0d9b0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;É o mesmo programa anterior, porém agora a instância de &lt;code&gt;TAction&lt;/code&gt; é criada “inline”.&lt;/p&gt;

&lt;p&gt;Após executar, esse é o resultado por aqui:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
Acting...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
63 memory blocks freed     : 1577/1704
1 unfreed memory blocks : 16
True heap size : 229376 (80 used in System startup)
True free heap : 229200
Should be : 229216
Call trace for block $01872E88 size 16
  $004015C7  main,  line 14 of C:/temp/project1.lpr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que os Métodos especiais não foram executados e há um vazamento de memória, o que não é nada bom.&lt;/p&gt;

&lt;p&gt;Mas se você retirar o “const” do procedimento, o vazamento é corrigido.&lt;/p&gt;

&lt;p&gt;Se o argumento não for um &lt;em&gt;ConstArgs&lt;/em&gt; ele poderá incrementar a contagem e não haverá vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Por isso há o mito de que “não devemos utilizar &lt;em&gt;ConstArgs&lt;/em&gt; com Interfaces” ou que devemos evitar seu uso.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Felizmente a solução para toda essa complexidade é muito simples&lt;/strong&gt;, bastando utilizar uma técnica que eu publiquei a quase dois anos atrás, na qual eu chamo de &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Altere &lt;code&gt;TAction&lt;/code&gt; adicionando o Método &lt;code&gt;New&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TAction = class(TInterfacedObject, IAction)
public
  class function New: IAction;
  // ...
end;

implementation

class function TAction.New: IAction;
begin
  Result := Create;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Altere também o programa, dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
  Execute(TAction.New);
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute e veja o resultado você mesmo.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Se você criar suas instâncias utilizando &lt;code&gt;New&lt;/code&gt; — um método da Classe — ao invés de chamar diretamente os &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt;, eu lhe asseguro que você não terá problemas de vazamento de memória, se a utilizar corretamente.&lt;/p&gt;

&lt;p&gt;Vimos nesse artigo que uma simples mudança no código pode gerar um ganho considerável de performance.&lt;/p&gt;

&lt;p&gt;Utilizando &lt;em&gt;ConstArgs&lt;/em&gt; em conjunto com a técnica chamada &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;, você poderá deixar seu código mais rápido e sem vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Dec 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/argumentos-const</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/argumentos-const</guid>
      </item>
    
      <item>
        <title>Herança de Formulário é para Iniciantes</title>
        <description>&lt;p&gt;Depois que você aprendeu como funciona a Herança de Formulários, pode esquecê-la.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-ken-treloar-346065.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Ken Treloar on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No início da minha carreira, a muitos anos atrás, alguém me mostrou a Herança de Formulário no Delphi.&lt;/p&gt;

&lt;p&gt;Mesmo em &lt;em&gt;design time&lt;/em&gt;, dois Formulários herdados estavam “sincronizados”.&lt;/p&gt;

&lt;p&gt;Ao alterar um componente de lugar (&lt;em&gt;Top&lt;/em&gt; / &lt;em&gt;Left&lt;/em&gt;) no Formulário 1, automaticamente também era alterado no outro Formulário 2 devido a Herança entre eles.&lt;/p&gt;

&lt;p&gt;E na época eu pensei: UAU!&lt;/p&gt;

&lt;p&gt;Como era rápido fazer um Formulário (simplório) de CRUD. Basta herdar e setar algumas propriedades e sobrescrever alguns Métodos.&lt;/p&gt;

&lt;p&gt;Acredito que essa é uma das &lt;em&gt;features&lt;/em&gt; mais utilizadas hoje em dia.&lt;/p&gt;

&lt;p&gt;Mas, o que tem de errado com isso?&lt;/p&gt;

&lt;h2 id=&quot;problemas&quot;&gt;Problemas&lt;/h2&gt;

&lt;p&gt;Utilizar Herança de Formulário é bom apenas para os &lt;em&gt;iniciantes&lt;/em&gt; na programação Orientada a Objetos e para o uso &lt;em&gt;superficial&lt;/em&gt; do Delphi ou Lazarus.&lt;/p&gt;

&lt;p&gt;Pode ser considerado “Ok” para criar aplicações de exemplo, ensinar sobre &lt;del&gt;como não utilizar&lt;/del&gt; a Herança simplificada e… talvez, apenas isso.&lt;/p&gt;

&lt;p&gt;Para aplicações realmente importantes, sugiro esquecer a Herança de Formulário por completo.&lt;/p&gt;

&lt;p&gt;Enquanto a &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;Herança de Classes é um mal&lt;/a&gt; que pode ser gerenciado ou mesmo utilizado de forma mais &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/&quot;&gt;apropriada&lt;/a&gt;, a Herança de Formulário acaba com todos os conceitos da verdadeira &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; é perdido&lt;/strong&gt; quando utilizamos Herança de Formulários, pois o desenvolvedor precisa ter conhecimento do comportamento interno do formulário-pai afim de conseguir fazer algo de útil no formulário-filho.&lt;/p&gt;

&lt;p&gt;Muitas vezes encontramos formulários contendo apenas Métodos protegidos ou &lt;a href=&quot;/posts/metodos-privados/&quot;&gt;privados&lt;/a&gt; sem nenhum comportamento público; eles vem do formulário-pai. E isso é muito estranho. Por quê teríamos uma Classe (Form) que, a primeira vista, não tem nenhum comportamento para o mundo externo?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A ordem de execução dos Métodos protegidos&lt;/strong&gt; que devem ser sobrescritos, devem ser de conhecimento do desenvolvedor, mais uma vez quebrando o encapsulamento.&lt;/p&gt;

&lt;p&gt;É necessário visualizar o código do formulário-pai afim de saber onde e em que momento tais métodos abstratos e protegidos são utilizados.&lt;/p&gt;

&lt;p&gt;É comum ver métodos sobrescritos que não chamam o Método herdado, “matando” o comportamento padrão da Classe ancestral quando o Método não é abstrato.&lt;/p&gt;

&lt;p&gt;Pedaços de código serão duplicados pois estão em métodos não acessíveis nos formulários-filhos.&lt;/p&gt;

&lt;p&gt;Uma bagunça.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Componentes herdados não podem ser excluídos&lt;/strong&gt;, o que resulta em mais bagunça e “código espaguete”.&lt;/p&gt;

&lt;p&gt;Como não é possível excluir componentes em formulários-filho, o desenvolvedor tem que habilitar/desabilitar ou torná-los visível/não-visível. No entanto tais componentes continuarão a serem criados no formulário…&lt;/p&gt;

&lt;p&gt;Criar formulários com componentes que não serão utilizados é realmente um desperdício de memória RAM.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualquer alteração no formulário-pai irá refletir nos formulários-filhos&lt;/strong&gt;, e isso quer dizer que você pode quebrar o sistema inteiro com pequenas modificações.&lt;/p&gt;

&lt;p&gt;Você poderia argumentar que mesmo se não utilizasse Herança, mas sim Composição de Objetos, um Objeto que fosse reaproveitado por todo o sistema também poderia quebrá-lo caso algo fosse indevidamente alterado no seu código.&lt;/p&gt;

&lt;p&gt;Correto. Mas a grande diferença é que é muito mais fácil alterar um código de apenas uma Classe &lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/&quot;&gt;pequena&lt;/a&gt; e sem dependências externas ou heranças de Classes-filhas, do que um código de Formulário onde toda lógica está contido nele além de ter a preocupação se alguma alteração irá impactar negativamente nos nos formulários-filhos.&lt;/p&gt;

&lt;h2 id=&quot;solucoes&quot;&gt;Soluções&lt;/h2&gt;

&lt;p&gt;Vejamos então algumas opções para a completa substituição da Herança de Formulário, utilizando outras técnicas mais Orientadas a Objetos, &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e limpas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Composição e &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração&lt;/a&gt; de Objetos&lt;/strong&gt; são as opções mais simples e corretas para substituir praticamente qualquer tipo de Herança.&lt;/p&gt;

&lt;p&gt;Você pode criar Classes intermediárias ou &lt;a href=&quot;/posts/classes-adaptadoras/&quot;&gt;adaptadoras&lt;/a&gt; que se comunicam entre si para instanciar Formulários complexos.&lt;/p&gt;

&lt;p&gt;Com o uso de pequenas Classes utilizadas como “interface de acesso” aos Formulários, você consegue instanciá-los, desacoplá-los entre si, instanciar &lt;em&gt;Frames&lt;/em&gt;, ler e escrever dados em componentes. Tudo em &lt;em&gt;runtime&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O uso de &lt;em&gt;Frames&lt;/em&gt; é uma ótima opção&lt;/strong&gt; para o uso de composição visual, visto que são mini-formulários embutidos em outros Formulários.&lt;/p&gt;

&lt;p&gt;Pense em como são construídas as páginas de um website. Não há herança, apenas &lt;em&gt;includes&lt;/em&gt; de “pedaços de código”: &lt;em&gt;Header&lt;/em&gt;, &lt;em&gt;Footer&lt;/em&gt;, &lt;em&gt;JavaScript&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Você pode utilizar o mesmo pensamento para o uso de &lt;em&gt;Frames&lt;/em&gt;. Pode criar um &lt;em&gt;Frame&lt;/em&gt; apenas com os botões de CRUD; outro com &lt;em&gt;Grids&lt;/em&gt;; outro para o &lt;em&gt;footer&lt;/em&gt; de todo formulário.&lt;/p&gt;

&lt;p&gt;Eu utilizo &lt;em&gt;Frames&lt;/em&gt; até mesmo sem pensar na reutilização…&lt;/p&gt;

&lt;p&gt;Explico. Imagine um Formulário com algumas abas utilizando um &lt;a href=&quot;http://wiki.lazarus.freepascal.org/TPageControl&quot;&gt;TPageControl&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Bem, não podemos ter nomes de componentes iguais num único Formulário, ou seja, se você definiu que um &lt;code&gt;TEdit&lt;/code&gt; se chama &lt;code&gt;NameEdit&lt;/code&gt; na aba 1, você não pode nomear outro &lt;code&gt;TEdit&lt;/code&gt; com o mesmo nome na aba 2, pois ambos pertencem ao mesmo Formulário.&lt;/p&gt;

&lt;p&gt;Você precisa acrescentar mais prefixos/sufixos na &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/&quot;&gt;nomenclatura&lt;/a&gt; e isso torna o código mais verboso e confuso, além do fato de que seu Formulário terá que lidar com todos os componentes de uma só vez.&lt;/p&gt;

&lt;p&gt;Em meus projetos, uma aba pode conter a instância de um &lt;em&gt;Frame&lt;/em&gt;, caso haja ações diferentes em cada aba.&lt;/p&gt;

&lt;p&gt;Por exemplo, se eu precisar adicionar uma barra de botões (ações) na aba 2, então essa aba será um &lt;em&gt;Frame&lt;/em&gt; com sua própria implementação, componentes de nomenclatura simples e ações específicas.&lt;/p&gt;

&lt;p&gt;Dentro de um &lt;em&gt;Frame&lt;/em&gt; eu não preciso me preocupar em lidar com um único código inchado que lida com todos os &lt;em&gt;widgets&lt;/em&gt; dentro de um Formulário.&lt;/p&gt;

&lt;p&gt;E se um &lt;em&gt;Frame&lt;/em&gt; precisar notificar o Formulário principal, isso pode ser feito através de &lt;a href=&quot;/eventos-e-objetos&quot;&gt;Eventos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Criar Componentes no Delphi/Lazarus é tão fácil&lt;/strong&gt; que se você precisar utilizar muito um comportamento, pode ser uma boa ideia criar um novo componente e disponibilizá-lo na IDE.&lt;/p&gt;

&lt;p&gt;Já vi muito isso em empresas, onde existem componentes genéricos que podem ser utilizados por qualquer sistema, mas também componentes específicos por projeto.&lt;/p&gt;

&lt;p&gt;Entretanto, apesar de manter um padrão de uso de componentes por toda a equipe, pode ser difícil manter todas as IDE’s do Delphi atualizadas após um novo &lt;em&gt;release&lt;/em&gt; desses componentes — no Lazarus essa tarefa seria mais fácil devido sua “não-instalação” e componentes “registrados” em apenas 1 arquivo XML, no entanto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O objetivo do artigo não é depreciar desenvolvedores que ainda utilizam Herança de Formulários, mas sim apresentar técnicas muito mais eficazes de construção, visando a manutenibilidade do código no longo prazo.&lt;/p&gt;

&lt;p&gt;Eu mesmo ainda trabalho em alguns projetos totalmente baseado em Herança de Formulários. Nesses projetos eu sou &lt;em&gt;obrigado&lt;/em&gt; a utilizar herança pois todo o &lt;em&gt;framework&lt;/em&gt; funciona a partir de alguns formulários base. No entanto, esses projetos estão longe de ter um código ideal.&lt;/p&gt;

&lt;p&gt;Mantenha seus projetos atuais, mas repense o uso de Herança de Formulários em projetos futuros.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/heranca-de-formulario-e-para-iniciantes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/heranca-de-formulario-e-para-iniciantes</guid>
      </item>
    
      <item>
        <title>Eliminando Métodos Privados</title>
        <description>&lt;p&gt;A utilização de Métodos Privados é um erro comum no &lt;em&gt;design&lt;/em&gt; do código.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-james-sutton-187816.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by James Sutton on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“Existe um pensamento que diz que todo Método Privado deveria ser, na verdade, a implementação de outro Objeto”&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu escrevi esse texto acima em outro &lt;a href=&quot;/posts/metodos-privados/&quot;&gt;artigo&lt;/a&gt; aqui no blog… e eu acho que faz muito sentido.&lt;/p&gt;

&lt;p&gt;No entanto, o artigo tentou demonstrar que os Métodos Privados não representam um mal no código e que podemos conviver com eles pacificamente.&lt;/p&gt;

&lt;p&gt;É verdade que eles não representam um &lt;em&gt;grande&lt;/em&gt; mal ao projeto. Existem tantos outros males &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;piores&lt;/a&gt; para nos preocuparmos no dia-a-dia que não damos muita importância aos Métodos Privados.&lt;/p&gt;

&lt;p&gt;Eu mesmo venho utilizando-os em meus projetos à muitos anos — tanto que já escrevi um artigo defendendo-os.&lt;/p&gt;

&lt;p&gt;Mas, toda vez que eu codifico um Método Privado eu tenho a sensação de que alguma coisa está &lt;em&gt;errada&lt;/em&gt;, mesmo quando eles &lt;em&gt;facilitam&lt;/em&gt; a minha vida.&lt;/p&gt;

&lt;h2 id=&quot;metodos-privados&quot;&gt;Métodos Privados&lt;/h2&gt;

&lt;p&gt;Você provavelmente sabe que Métodos Privados são utilizados somente pela Classe na qual eles foram implementados e nenhum Objeto externo tem acesso à eles.&lt;/p&gt;

&lt;p&gt;Praticamente, toda linguagem que suporta o paradigma da &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt; tem uma sintaxe para a codificação de Métodos Privados.&lt;/p&gt;

&lt;p&gt;É de uso comum.&lt;/p&gt;

&lt;p&gt;Todos nós utilizamos, diariamente.&lt;/p&gt;

&lt;p&gt;Mas, em teoria, a interface de um Objeto — seus Métodos Públicos — deveria ser suficiente para ele exercer o trabalho que lhe foi designado.&lt;/p&gt;

&lt;p&gt;Se o trabalho é complexo e o Objeto necessitar de “ajuda”, ele deveria delegar à outros Objetos e &lt;em&gt;não&lt;/em&gt; tentar fazer tudo “sozinho” utilizando Métodos Privados.&lt;/p&gt;

&lt;p&gt;No entanto, as linguagens dão suporte para escrevê-los.&lt;/p&gt;

&lt;p&gt;As linguagens diferenciam Métodos privados, protegidos e públicos.&lt;/p&gt;

&lt;p&gt;Então, entendemos que era correto utilizá-los e estamos fazendo isso desde então.&lt;/p&gt;

&lt;p&gt;Entretanto, se por um lado os Métodos Privados não representam um grande mal, por outro eles também não são o &lt;em&gt;ideal&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;facilitadores&quot;&gt;Facilitadores&lt;/h2&gt;

&lt;p&gt;Métodos Privados são apenas &lt;em&gt;facilitadores&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Eles são utilizados do mesmo jeito que a maioria das pessoas utilizam, por exemplo, a fita &lt;a href=&quot;https://pt.wikipedia.org/wiki/Silver_Tape&quot;&gt;Silver Tape®&lt;/a&gt;, ou seja, como uma &lt;em&gt;solução alternativa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se algo quebrou no seu carro durante uma viagem (uma mangueira arrebentou, algo rachou, vazamentos, etc) e você não tem tempo para fazer um reparo perfeito ou as ferramentas apropriadas, você improvisa.&lt;/p&gt;

&lt;p&gt;Você pode utilizar uma fita para manter as coisas no lugar na esperança de que, no futuro, você possa fazer o reparo do jeito correto.&lt;/p&gt;

&lt;p&gt;Infelizmente podemos nos esquecer desses reparos temporários e seguir adiante, já que a “solução alternativa” continua mantendo tudo funcionando “perfeitamente” — como a mangueira de esguicho de água do para-brisa do meu carro que rachou e está com uma fita a mais de 2 anos.&lt;/p&gt;

&lt;p&gt;Um Método Privado é algo localizado e sem muita importância por que está encapsulado numa Classe e pode ser alterado a qualquer momento (em teoria) sem efeitos colaterais.&lt;/p&gt;

&lt;p&gt;Eu utilizo pouco o esguicho de água do para-brisa e mesmo assim ele continua funcionando mas, mesmo se parar de funcionar, não vai por minha vida em risco… teoricamente. Não haverá efeitos colaterais se eu fizer o conserto agora ou mais tarde.&lt;/p&gt;

&lt;p&gt;Nota: Não me entenda mal. Eu faço a manutenção do meu carro quase que religiosamente, mas a prioridade sempre será o motor, fluídos e suspensão.&lt;/p&gt;

&lt;p&gt;Projetos de Software também tem prioridades nos dizendo para não “perder tempo” codificando outras Classes, quando é mais &lt;em&gt;rápido&lt;/em&gt; codificar Métodos Privados e resolver o problema da maneira mais “fácil”.&lt;/p&gt;

&lt;p&gt;Entretanto, sabemos que “mais fácil” não combina com &lt;em&gt;sustentabilidade&lt;/em&gt; no longo prazo.&lt;/p&gt;

&lt;h2 id=&quot;motivos&quot;&gt;Motivos&lt;/h2&gt;

&lt;p&gt;Há 9 meses atrás houve uma &lt;a href=&quot;http://objectpascalprogramming.com/posts/metodos-privados/#comment-3127567762&quot;&gt;discussão&lt;/a&gt; na área de comentários do blog sobre utilizar ou não Métodos Privados.&lt;/p&gt;

&lt;p&gt;Num dos comentários eu escrevi:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Minha opinião é que, como são Privados, não há nenhum impacto direto no código. Sempre posso modificá-los a qualquer momento.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;E isso é, de fato, verdade.&lt;/p&gt;

&lt;p&gt;Se algo é privado a Classe, você pode modificá-lo sem haver impactos externos, na teoria. Faz parte do conceito de &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; de toda linguagem OO. Se é privado, somente a Classe tem acesso — sem levar em conta algo chamado &lt;em&gt;Reflexion&lt;/em&gt; ou RTTI.&lt;/p&gt;

&lt;p&gt;Então, quais seriam os motivos para deixar de utilizar Métodos Privados?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ao introduzir Métodos Privados, você pode estar codificando de forma procedural ao invés de Orientada a Objetos.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Você pode estar introduzindo &lt;em&gt;funções procedurais&lt;/em&gt; ao invés de Métodos que implementam o comportamento da &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidade&lt;/a&gt; representada.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/bbdc509810890ea5724a94a021f16791.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Na Classe acima, o método &lt;code&gt;CleanName&lt;/code&gt; é apenas uma &lt;em&gt;função utilitária&lt;/em&gt;. A função não pertence ao contexto representado por um &lt;code&gt;Employee&lt;/code&gt; e por isso eu não a considero como um Método do Objeto.&lt;/p&gt;

&lt;p&gt;Um &lt;code&gt;Employee&lt;/code&gt; não “limpa” o próprio nome.&lt;/p&gt;

&lt;p&gt;Essa é a tendência ao utilizarmos Métodos Privados: Adicionar funções utilitárias, por quê é fácil, conveniente e “ninguém está vendo”.&lt;/p&gt;

&lt;p&gt;Os nomes dessas funções também tem a tendência de serem &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/#metodos&quot;&gt;nomes compostos&lt;/a&gt; que é mais um &lt;em&gt;indício&lt;/em&gt; mostrando que a função pode pertencer a &lt;em&gt;outro&lt;/em&gt; contexto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Métodos Privados também podem gerar &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/&quot;&gt;duplicação de código&lt;/a&gt;, escondendo &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamentos&lt;/a&gt; que poderiam ser compartilhados entre os Objetos mas, como são privados, não podem reutilizados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Veja mais um exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/a303d0bf83930fcf580aee818ee23a52.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O Método &lt;code&gt;SplitName&lt;/code&gt; — também um função utilitária — acima poderia ser reutilizado por outra Classe que também encapsula uma instância de &lt;code&gt;IName&lt;/code&gt;. Mas aqui a Classe &lt;code&gt;TEmployeeName&lt;/code&gt; tem sua própria implementação privada, não havendo outra maneira de reutilizar o mesmo algoritmo fora da Classe.&lt;/p&gt;

&lt;p&gt;Em outras palavras, caso você precisasse utilizar o mesmo algoritmo implementado em &lt;code&gt;SplitName&lt;/code&gt;, você teria que fazer uma cópia.&lt;/p&gt;

&lt;p&gt;Acredito que estes podem ser bons motivos para eliminarmos os Métodos Privados dos nossos projetos desde o início ou quando for possível fazer a refatoração.&lt;/p&gt;

&lt;h2 id=&quot;eliminando&quot;&gt;Eliminando&lt;/h2&gt;

&lt;p&gt;Acredito que podemos remover quaisquer Métodos Privados utilizando apenas Classes.&lt;/p&gt;

&lt;p&gt;As Classes podem ser &lt;em&gt;públicas&lt;/em&gt; (disponível a todo o sistema) e/ou &lt;a href=&quot;/classes-aninhadas&quot;&gt;Aninhadas&lt;/a&gt; a outras Classes.&lt;/p&gt;

&lt;p&gt;Talvez os exemplos acima podem não ter convencido você.&lt;/p&gt;

&lt;p&gt;Você poderia dizer que haverá casos em que os Métodos Privados fazem, sim, parte do mesmo contexto e por isso deveriam &lt;em&gt;existir&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por exemplo.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/8afe1f70a803556a59513fb2dff36e21.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A Classe &lt;code&gt;THttpClient&lt;/code&gt; não está completa, mas a parte que falta é irrelevante.&lt;/p&gt;

&lt;p&gt;Veja que há o Método &lt;code&gt;Send&lt;/code&gt; que é utilizado em 2 outros Métodos: &lt;code&gt;Get&lt;/code&gt; e &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, é possível substituir o Método &lt;code&gt;Send&lt;/code&gt; por uma Classe?&lt;/p&gt;

&lt;p&gt;Com certeza.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/3cda576e9e13ac25ee5b4005a3b47a1a.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;E a vantagem de fazer isso é que deixamos a Classe mais simples e compacta, removendo o comportamento privado para uma nova Classe; agora podemos reutilizar o código externamente; se quisermos decorar &lt;code&gt;THttpProtocol&lt;/code&gt; com outras Classes como Log, por exemplo, também podemos.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Após muito ponderar, cheguei a conclusão que prover uma sintaxe para codificar Métodos Privados é um &lt;em&gt;erro&lt;/em&gt; no &lt;em&gt;design&lt;/em&gt; da linguagem. Não só em Object Pascal, mas também em Java, C# e tantas outras.&lt;/p&gt;

&lt;p&gt;Considere, então, que o uso de Métodos Privados foi o primeiro nível de aprendizado para sabermos dividir código dentro de uma Classe, entendê-los e saber como utilizá-los de forma consciente, &lt;em&gt;facilitando&lt;/em&gt; a transição da Programação Procedural para a Orientada a Objetos.&lt;/p&gt;

&lt;p&gt;Sabemos que particularidades da linguagem nos fazem criar Métodos Privados intencionalmente como, por exemplo, Métodos que executam &lt;a href=&quot;/eventos-e-objetos&quot;&gt;eventos&lt;/a&gt; — o Método Privado irá verificar se um evento foi ou não &lt;a href=&quot;/posts/getters-e-setters/#setters&quot;&gt;setado&lt;/a&gt; — e tudo bem se o método é apenas uma implementação de &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#infraestrutura&quot;&gt;infraestrutura&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lembre-se também que, ao criar mais Classes públicas, ao invés de Métodos Privados, haverá mais código para documentar. No entanto, você poderá manter essas Classes “escondidas” do usuário final utilizando o conceito de &lt;a href=&quot;/api-unit&quot;&gt;API Unit&lt;/a&gt;, declarando na API apenas as Classes que você “permite” utilizar.&lt;/p&gt;

&lt;p&gt;Um código final com um mínimo de Métodos Privados pode representar um bom sinal de &lt;em&gt;design&lt;/em&gt; do código, com Classes &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e elegantes.&lt;/p&gt;

&lt;p&gt;Então, não codifique Métodos Privados, a não ser que haja uma real necessidade para fazê-lo. Evite-os.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/eliminando-metodos-privados</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/eliminando-metodos-privados</guid>
      </item>
    
      <item>
        <title>Classes Aninhadas</title>
        <description>&lt;p&gt;As Classes Aninhadas reduzem o número de Classes públicas, melhoram o encapsulamento, o polimorfismo local e a legibilidade do código.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-iorni-321845.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by iorni on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A maneira mais fácil (preguiçosa e errada) de reaproveitar código é utilizando &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse é o início do aprendizado sobre &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Como muito mais tempo, aprendemos que a &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração&lt;/a&gt; e Composição de Objetos é o &lt;em&gt;melhor&lt;/em&gt; caminho para &lt;em&gt;adicionar&lt;/em&gt; e &lt;em&gt;reaproveitar&lt;/em&gt; comportamento, respectivamente.&lt;/p&gt;

&lt;p&gt;Classes Aninhadas tem tudo haver com Decoração e Composição.&lt;/p&gt;

&lt;p&gt;Nesse artigo você irá aprender como utilizar Classes Aninhadas para melhorar o encapsulamento e polimorfismo, acrescentando comportamento específico e localizado, sem o uso de &lt;em&gt;“Class Helpers”&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;classes-aninhadas&quot;&gt;Classes Aninhadas&lt;/h2&gt;

&lt;p&gt;A linguagem Object Pascal, apesar de ser bem antiga, está em constante desenvolvimento.&lt;/p&gt;

&lt;p&gt;Mas, eu sou avesso a grandes mudanças na linguagem. Em qualquer linguagem.&lt;/p&gt;

&lt;p&gt;Também não sou a favor de acrescentar novas &lt;em&gt;features&lt;/em&gt; apenas por quê existem em &lt;em&gt;outras&lt;/em&gt; linguagens.&lt;/p&gt;

&lt;p&gt;Quanto mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; for uma linguagem, mais fácil será o entendimento do código.&lt;/p&gt;

&lt;p&gt;Na minha opinião, ao invés de acrescentar novas &lt;em&gt;features&lt;/em&gt; numa linguagem, os desenvolvedores deviam trabalhar em novas &lt;em&gt;Libraries&lt;/em&gt; que resolvem problemas específicos.&lt;/p&gt;

&lt;p&gt;No entanto, algumas &lt;em&gt;features&lt;/em&gt; realmente podem fazer a diferença, ou seja, tornar o código melhor e mais simples.&lt;/p&gt;

&lt;p&gt;O conceito de Classes Aninhadas é simples: Permitir a declaração de Classes dentro de Classes. Sejam elas privadas ou públicas.&lt;/p&gt;

&lt;p&gt;Veja um exemplo da sintaxe:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/96820c816ffa3e1eb5296a330e3a1cef.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, para declarar uma Classe &lt;code&gt;TBar&lt;/code&gt;, foi necessário fazer a referência a Classe &lt;code&gt;TFoo&lt;/code&gt;, primeiramente.&lt;/p&gt;

&lt;p&gt;Então, &lt;code&gt;TBar&lt;/code&gt; é uma Classe Aninhada em &lt;code&gt;TFoo&lt;/code&gt; ou, em outras palavras, &lt;code&gt;TBar&lt;/code&gt; está encapsulada em &lt;code&gt;TFoo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Acredito que para o compilador, uma Classe Aninhada é apenas outra qualquer. Não há penalidades no código. A primeira Classe da hierarquia &lt;em&gt;não&lt;/em&gt; irá criar Objetos maiores devido as Classes Aninhadas.&lt;/p&gt;

&lt;p&gt;Para nós, desenvolvedores, é apenas um &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;&lt;em&gt;Syntactic sugar&lt;/em&gt;&lt;/a&gt; que parece não valer muito a pena prestar atenção.&lt;/p&gt;

&lt;p&gt;No entanto, para um &lt;em&gt;design&lt;/em&gt; realmente &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt;, esta é uma &lt;em&gt;feature&lt;/em&gt; que proporciona uma &lt;em&gt;grande&lt;/em&gt; melhoria no código.&lt;/p&gt;

&lt;h2 id=&quot;redescobrindo&quot;&gt;Redescobrindo&lt;/h2&gt;

&lt;p&gt;O fato é que não faz tanto tampo que eu descobri que a linguagem Object Pascal tem suporte a Classes Aninhadas. Bem, talvez eu já tenha lido sobre isso já faz alguns anos, mas a verdade é que eu nunca tinha utilizado tal recurso em sistemas reais.&lt;/p&gt;

&lt;p&gt;Há 3 semanas atrás, esse conceito retornou a minha mente após receber um e-mail relacionado a uma nova &lt;em&gt;issue&lt;/em&gt; num sistema privado.&lt;/p&gt;

&lt;p&gt;Eu tinha que fazer uma manutenção no código e um dos requisitos dizia que uma parte do sistema deveria se comportar de maneira ligeiramente diferente da condição atual, mas por um curto período de tempo.&lt;/p&gt;

&lt;p&gt;O motivo era que um segundo sistema estava sendo alterado e, enquanto essa tarefa não estivesse concluída, o primeiro sistema deveria se comportar de acordo com o requisito citado.&lt;/p&gt;

&lt;p&gt;Como o sistema é privado, o requisito real é irrelevante.&lt;/p&gt;

&lt;p&gt;Mas, para que você entenda como as Classes Aninhadas me ajudaram a implementar o requisito de forma simples, clássica e seguindo os &lt;a href=&quot;lista-vip/&quot;&gt;princípios&lt;/a&gt; da Orientação a Objetos, vou apresentar uma forma bem simplificada do que deveria ser alterado no código para a solução da tarefa.&lt;/p&gt;

&lt;h2 id=&quot;problema&quot;&gt;O Problema&lt;/h2&gt;

&lt;p&gt;Imagine que você tenha uma Unit com algumas Classes.&lt;/p&gt;

&lt;p&gt;Essas Classes utilizam outras Classes de outras Units.&lt;/p&gt;

&lt;p&gt;Para implementar o requisito, uma dessas Classes deveria ser alterada. No entanto, a alteração era relacionada com a Composição de outra Classe — na verdade eram outras Classes, no plural, mas vamos manter simples.&lt;/p&gt;

&lt;p&gt;Então temos o seguinte:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A Classe &lt;code&gt;TFoo&lt;/code&gt; é a que temos que alterar. No entanto ela trabalha com uma instância de &lt;code&gt;TBar&lt;/code&gt; internamente — novamente, por motivos de simplificação, vamos esquecer que a instância de &lt;code&gt;TBar&lt;/code&gt; deveria ser &lt;a href=&quot;/injecao-de-dependencia&quot;&gt;injetada&lt;/a&gt; no &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtor&lt;/a&gt; da Classe &lt;code&gt;TFoo&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;A interação entre as Classes &lt;code&gt;TFoo&lt;/code&gt; e &lt;code&gt;TBar&lt;/code&gt; era o que deveria ser alterado para a conclusão do requisito. No entanto, todas as outras Classes pertencentes a mesma Unit de &lt;code&gt;TFoo&lt;/code&gt; deveriam continuar com o mesmo comportamento atual. Em outras palavras, a Classe &lt;code&gt;TBar&lt;/code&gt; deveria ser alterada &lt;em&gt;apenas&lt;/em&gt; na implementação (local) de &lt;code&gt;TFoo&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Temos várias maneiras de implementar isso, é claro.&lt;/p&gt;

&lt;p&gt;Antes, vamos &lt;a href=&quot;/posts/nomeando-unidades/&quot;&gt;nomear&lt;/a&gt; algumas coisas para facilitar o entendimento:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Acme.Foos.Clss&lt;/code&gt; -&amp;gt; é a Unit onde a Classe &lt;code&gt;TFoo&lt;/code&gt; está declarada;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Acme.Bars.Clss&lt;/code&gt; -&amp;gt; é a Unit onde a Classe &lt;code&gt;TBar&lt;/code&gt; está declarada;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Então, para implementar o requisito, nós poderíamos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementar uma nova Classe na Sessão de Interface da &lt;code&gt;Acme.Bars.Clss&lt;/code&gt; chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Implementar uma nova Classe na Sessão de Interface da &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Criar uma nova Unit &lt;code&gt;Acme.Bars.Ex.Clss&lt;/code&gt; e implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Implementação da unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O caminho a ser escolhido é quase infinito, porém essas seriam as opções mais comuns, considerando que não queremos fazer uma refatoração muito grande no código. Será uma alteração temporária, lembra?&lt;/p&gt;

&lt;p&gt;Infelizmente, existem problemas de &lt;em&gt;design&lt;/em&gt; com todas as opções acima.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementar a nova Classe &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Interface de &lt;code&gt;Acme.Bars.Clss&lt;/code&gt; ou &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; irá disponibilizar a nova Classe para todo o sistema. Como é uma Classe temporária, ela não deveria estar disponível… não dessa forma.&lt;/li&gt;
  &lt;li&gt;Criar uma nova Unit &lt;code&gt;Acme.Bars.Ex.Clss&lt;/code&gt; é ainda pior, pois depois de algum tempo a Unit deverá ser removida, havendo mais alterações no código.&lt;/li&gt;
  &lt;li&gt;Por fim, implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Implementação da unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; seria a opção mais viável. No entanto não teria sido um código elegante, pois essa nova Classe seria criada para apenas para um caso específico mas elas estaria disponível para a Unit inteira. Também tem o fato de que a Classe &lt;em&gt;deve&lt;/em&gt; ter um nome diferente (&lt;code&gt;TBar&lt;/code&gt; vs &lt;code&gt;TBarEx&lt;/code&gt;) — esse é um dos motivos de adicionarmos prefixos ou sufixos estranhos — para não haver conflito com todas as instâncias de &lt;code&gt;TBar&lt;/code&gt; que continuam sendo utilizadas por toda a Unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt;. O ideal seria continuar utilizando a nomenclatura &lt;code&gt;TBar&lt;/code&gt;, de acordo com o domínio. Mas, infelizmente, a técnica de &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclaração de Classes&lt;/a&gt; não seria possível, pois só queremos uma &lt;code&gt;TBar&lt;/code&gt; diferente em apenas um lugar na Unit.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Eu não escolhi nenhuma das possíveis soluções acima.&lt;/p&gt;

&lt;h2 id=&quot;solucionando&quot;&gt;A Solução&lt;/h2&gt;

&lt;p&gt;Após pensar por alguns minutos sobre como resolver o requisito, o conceito de Classes Aninhadas retornou a minha mente como a melhor escolha.&lt;/p&gt;

&lt;p&gt;A solução é tão simples que você já a conhece. Está no início desse artigo!&lt;/p&gt;

&lt;p&gt;Vou apenas adicionar mais código para deixar a implementação mais contextualizada:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/b292e33439d9867b2c8c92d8caba4a96.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Agora, em todos os métodos de &lt;code&gt;TFoo&lt;/code&gt; que for preciso decorar instâncias de &lt;code&gt;IBar&lt;/code&gt;, uma Classe de &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nomenclatura&lt;/a&gt; simples e &lt;em&gt;local&lt;/em&gt; poderá ser utilizada sem haver conflito de nomes na Unit.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TFoo&lt;/code&gt; tem sua própria implementação privada de &lt;code&gt;TBar&lt;/code&gt;. Nenhum outro código no sistema poderá utilizar essa implementação.&lt;/p&gt;

&lt;p&gt;É uma solução &lt;em&gt;local&lt;/em&gt;, sem &lt;em&gt;workarounds&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Espero que os exemplos não tenham sido muito abstratos. A ideia foi mostrar o potencial dessa simples &lt;em&gt;feature&lt;/em&gt; sem deixar o artigo muito longo.&lt;/p&gt;

&lt;p&gt;É uma solução simples e bastante elegante. Totalmente de acordo com os princípios da Orientação a Objetos, encapsulamento e polimorfismo.&lt;/p&gt;

&lt;p&gt;A nomenclatura das Classes é simples, mantendo a legibilidade do código.&lt;/p&gt;

&lt;p&gt;A linguagem Object Pascal continua a me surpreender, mesmo após mais de 16 anos que a utilizo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/classes-aninhadas</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/classes-aninhadas</guid>
      </item>
    
      <item>
        <title>API Unit: Tudo num só lugar</title>
        <description>&lt;p&gt;Uma única técnica que resolve muitos problemas.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-nordwood-themes-166423.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by NordWood Themes on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Quando você utiliza uma Classe muitas vezes, já deve ter memorizado em qual Unit a Classe foi implementada.&lt;/p&gt;

&lt;p&gt;Mas e se &lt;em&gt;Library&lt;/em&gt; (Lib) que você está utilizando é nova ou foi completamente remodelada?&lt;/p&gt;

&lt;p&gt;E se você está tentando fazer um trabalho que nunca fez antes?&lt;/p&gt;

&lt;p&gt;Como saber as Classes existentes na Lib?&lt;/p&gt;

&lt;p&gt;Há basicamente 3 opções:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Abrir todas as Units da Lib e ler o código;&lt;/li&gt;
  &lt;li&gt;Ler a documentação, se houver;&lt;/li&gt;
  &lt;li&gt;Abrir apenas uma Unit que contenha todas as Interfaces e Classes;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Esse artigo é sobre a última opção, que eu chamo de “API Unit”.&lt;/p&gt;

&lt;h2 id=&quot;api-unit&quot;&gt;API Unit&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;API Unit&lt;/em&gt; é um conceito em fase de experimentação.&lt;/p&gt;

&lt;p&gt;A ideia é simples: Disponibilizar ao desenvolvedor, todas as Interfaces e Classes de &lt;em&gt;uso público&lt;/em&gt; em apenas 1 Unit.&lt;/p&gt;

&lt;p&gt;Não estou dizendo que deveríamos codificar &lt;em&gt;tudo&lt;/em&gt; num único arquivo. Isso seria insano. Mas se houvesse uma maneira de continuarmos codificando em módulos mas, ao mesmo tempo, termos tudo disponível para uso em apenas 1 única Unit, não acha que seria interessante?&lt;/p&gt;

&lt;p&gt;Já vi projetos onde os autores utilizavam arquivos &lt;code&gt;*.inc&lt;/code&gt; para ir montando a “verdadeira” Unit — o FPC e Lazarus utilizam essa técnica — mas eu acho confuso de administrar, além de dificultar a leitura do código.&lt;/p&gt;

&lt;p&gt;Não fui por esse caminho e continuei pensando…&lt;/p&gt;

&lt;p&gt;Então, tive uma ideia que chamei de &lt;em&gt;API Unit&lt;/em&gt;, meio que “por acaso”, após a publicação desse &lt;a href=&quot;/nomeando-classes-em-libraries&quot;&gt;artigo&lt;/a&gt;. Eu estava pensando em outras possibilidades para nomear Interfaces e Classes, algo que já havia explicado em outro artigo.&lt;/p&gt;

&lt;p&gt;Por quê?&lt;/p&gt;

&lt;p&gt;Bem, a técnica de nomenclatura que expliquei anteriormente continua válida, porém pode haver Libs mais complexas com &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nomes de Classes&lt;/a&gt; bem especializadas. Esses nomes tem a tendência de serem maiores e adicionar o nome da Lib como prefixo — conforme explicado no &lt;a href=&quot;/nomeando-classes-em-libraries&quot;&gt;artigo&lt;/a&gt; — deixando o nome da Classe ainda mais verboso.&lt;/p&gt;

&lt;p&gt;A linguagem Object Pascal não tem uma sintaxe para “renomear” uma Unit dentro do código. Algo &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; de se fazer em linguagens como Python, C# e Lua, por exemplo. Nessas linguagens, após o &lt;em&gt;“import”&lt;/em&gt; do arquivo, o desenvolvedor pode escolher um &lt;em&gt;alias&lt;/em&gt; para a “unidade”, ou seja, ele pode renomear dinamicamente o arquivo que irá conter as Interfaces, Classes e todo o resto.&lt;/p&gt;

&lt;p&gt;Eu mesmo já &lt;a href=&quot;http://wiki.freepascal.org/Namespaces#The_.22uses.22_clause&quot;&gt;solicitei&lt;/a&gt; essa &lt;em&gt;feature&lt;/em&gt; para os desenvolvedores do &lt;a href=&quot;https://freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt;, porém o pedido foi ignorado devido haver outras prioridades.&lt;/p&gt;

&lt;p&gt;Como isso não é possível (hoje), voltei para os meus pensamentos.&lt;/p&gt;

&lt;p&gt;Seria possível utilizar a nomenclatura mais simples (nomes curtos para Units, Interfaces e Classes) sem haver colisão de nomes?&lt;/p&gt;

&lt;p&gt;Meus requisitos foram:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Classes com nomes curtos e simples;&lt;/li&gt;
  &lt;li&gt;Havendo colisão de nomes entre Classes, a Unit seria utilizada como prefixo;&lt;/li&gt;
  &lt;li&gt;Units devem ter o nome mais curto possível, porém legível e sem ambiguidades;&lt;/li&gt;
  &lt;li&gt;O usuário da Lib deveria ter o controle da nomenclatura utilizada em seus sistemas;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Vamos analisar cada item:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Classes com nomes curtos e simples&lt;/strong&gt; deveria ser a norma utilizada em &lt;em&gt;todos&lt;/em&gt; os sistemas. Mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; de ler, mas fácil de entender.&lt;/p&gt;

&lt;p&gt;Ao invés de escrevermos &lt;code&gt;TAcCar&lt;/code&gt; ou &lt;code&gt;TAcmeCar&lt;/code&gt;, iríamos utilizar apenas &lt;code&gt;TCar&lt;/code&gt;. Mas, conforme explicado no artigo sobre nomenclatura, há grandes possibilidades de haver uma colisão de nomes caso duas ou mais unidades tenham utilizado o mesmo identificador &lt;code&gt;TCar&lt;/code&gt; e isso nos leva ao segundo requisito.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Havendo colisão de nomes entre Classes, a Unit seria utilizada como prefixo&lt;/strong&gt; e o problema estaria resolvido. No entanto, é muito verboso declarar um método assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TDriver.Drive(
  ACar: Acme.Interfaces.Cars.ICar): IDriver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O argumento &lt;code&gt;ACar&lt;/code&gt; é um tipo de Interface declarado em alguma Lib externa chamada &lt;code&gt;Acme&lt;/code&gt;. E foi preciso prefixar a Interface &lt;code&gt;ICar&lt;/code&gt; por que o seu projeto, hipoteticamente, também tem uma interface com o mesmo nome em outra Unit.&lt;/p&gt;

&lt;p&gt;Imagine agora esse mesmo método com mais 4 argumentos, sendo cada um deles prefixado com a Unit. O método ficaria muito mais verboso e, talvez, difícil de entender.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Units devem ter o nome mais curto possível, porém legível e sem ambiguidades&lt;/strong&gt; mas a linguagem não nos dá essa opção. Se fosse possível criar um &lt;em&gt;alias&lt;/em&gt; no Object Pascal poderíamos fazer isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  Acme.Interfaces.Cars.ICar as Acme;

function TDriver.Drive(ACar: Acme.ICar): IDriver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse ponto você pode estar pensando que voltamos a utilizar a mesma &lt;a href=&quot;/nomeando-classes-em-libraries&quot;&gt;técnica&lt;/a&gt; anterior, ou seja, o nome da Lib é o prefixo.&lt;/p&gt;

&lt;p&gt;Ora, afinal o identificador &lt;code&gt;Acme.ICar&lt;/code&gt; não é tão diferente de &lt;code&gt;IAcmeCar&lt;/code&gt;, não é?&lt;/p&gt;

&lt;p&gt;Sim, é verdade, porém com o uso (hipotético) de &lt;em&gt;alias&lt;/em&gt; é o usuário que tem o controle de qual nome utilizar como prefixo em todo o projeto. Algo que lhe dá liberdade, fazendo muita diferença.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O usuário da Lib deveria ter o controle da nomenclatura utilizada em seus sistemas&lt;/strong&gt; e não deixar que a Lib “imponha” um nome que, muitas vezes, é ambíguo, mal escolhido, confuso, verboso ou completamente sem sentido.&lt;/p&gt;

&lt;p&gt;É claro que identificadores fixos como &lt;code&gt;IAcmeCar&lt;/code&gt; podem ser &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclarados&lt;/a&gt;, porém se houver muitas Classes e Interfaces, poderia ser uma tarefa bem dispendiosa.&lt;/p&gt;

&lt;p&gt;Então, o uso de &lt;em&gt;alias&lt;/em&gt; na linguagem Object Pascal seria uma solução inovadora, porém não a temos.&lt;/p&gt;

&lt;p&gt;E é aí que entra a ideia da &lt;em&gt;API Unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se todos os identificadores estivessem declarados em apenas uma única Unit, representando toda a Lib, poderíamos simular um &lt;em&gt;alias&lt;/em&gt; utilizando um arquivo físico.&lt;/p&gt;

&lt;p&gt;Veja &lt;a href=&quot;https://github.com/mdbs99/james/blob/d63a1b93e246012ffc49fa6ea86ad644ceef12f5/src/james.api.pas#L24&quot;&gt;aqui&lt;/a&gt; um bom exemplo do que é uma &lt;em&gt;API Unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;No &lt;em&gt;link&lt;/em&gt; acima podemos ver que todas as Interfaces e Classes da Lib estão declaradas (apenas um &lt;em&gt;alias&lt;/em&gt; para os identificadores em outras Unit ) em apenas uma única Unit e isso nos dá &lt;em&gt;grandes&lt;/em&gt; possibilidades que irei explicar mais adiante.&lt;/p&gt;

&lt;p&gt;No entanto, sempre haverá vantagens de desvantagens.&lt;/p&gt;

&lt;h2 id=&quot;desvantagens&quot;&gt;Desvantagens&lt;/h2&gt;

&lt;p&gt;Vou começar pelas desvantagens, pois as vantagens são bem maiores.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Você irá deixar o código do desenvolvedor da Lib um pouquinho mais verboso&lt;/strong&gt; por que, para cada Interface ou Classe existente, você terá que declarar um &lt;em&gt;alias&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por exemplo, veja nesse &lt;a href=&quot;https://github.com/mdbs99/james/blob/d63a1b93e246012ffc49fa6ea86ad644ceef12f5/src/james.data.clss.pas#L34-L52&quot;&gt;link&lt;/a&gt; que a Classe &lt;code&gt;TDataStream&lt;/code&gt; tem um &lt;em&gt;alias&lt;/em&gt; declarado como &lt;code&gt;TDataStreamAlias = TDataStream;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A princípio, o identificador &lt;code&gt;TDataStreamAlias&lt;/code&gt; não faz sentido para a Unit na qual ele foi declarado, mas será importante para montarmos a &lt;em&gt;API Unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Todas as Interfaces e Classes para os usuários devem estar numa única Unit&lt;/strong&gt; e isso é meio chato e talvez um pouco trabalhoso de se fazer.&lt;/p&gt;

&lt;p&gt;O desenvolvedor terá um pequeno retrabalho adicionando as Interfaces e Classes de outras Unit  na Unit de API. O desenvolvedor poderia até esquecer de fazer isso. No entanto se a Lib possuir testes automatizados, não haverá esquecimento, pois os próprios testes irão utilizar apenas a &lt;em&gt;API Unit&lt;/em&gt; e para testar uma Classe ela deve estar declarada lá.&lt;/p&gt;

&lt;h2 id=&quot;vantagens&quot;&gt;Vantagens&lt;/h2&gt;

&lt;p&gt;Agora vamos falar um pouco sobre as vantagens em utilizarmos essa simples técnica.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Se toda a Lib pode ser utilizada através de apenas 1 Unit&lt;/strong&gt; você pode criar um &lt;em&gt;alias&lt;/em&gt; apenas renomeando o arquivo original.&lt;/p&gt;

&lt;p&gt;Por exemplo. Se a Lib Acme do exemplo acima tivesse uma &lt;em&gt;API Unit&lt;/em&gt; ela poderia se chamar &lt;code&gt;Acme.API.pas&lt;/code&gt;. Mas se você não gostou do nome, se ele ainda é verboso ou se você já tem uma Unit com esse nome no seu projeto, bastaria renomear a Unit para, digamos, &lt;code&gt;LibAcme.pas&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, qualquer colisão de nome entre Interfaces e Classes poderia ser resolvida apenas adicionando o “novo” nome da Lib como, por exemplo, &lt;code&gt;LibAcme.ICar&lt;/code&gt;. Simples, curto, fácil de entender e totalmente sob o controle do usuário da Lib.&lt;/p&gt;

&lt;p&gt;Se o desenvolvedor da Lib quiser ser ainda mais “legal” com o usuário, ele poderia criar um &lt;code&gt;.inc&lt;/code&gt; com todos os identificadores e declarar a &lt;code&gt;Acme.API &lt;/code&gt;assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit Acme.API;

{$include api.inc}

end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Então o usuário nem mesmo precisaria renomear o arquivo original. Bastaria criar um novo arquivo, por exemplo &lt;code&gt;LibAcme.pas&lt;/code&gt;, no mesmo diretório e incluir a &lt;code&gt;api.inc&lt;/code&gt; no corpo da nova Unit.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Como é fácil renomear a Unit que contém a API&lt;/strong&gt; o desenvolvedor não precisaria mais se preocupar em adicionar prefixos de 2~3 letras em Interfaces e Classes afim de diminuir a colisão de nomes nos projetos que utilizam a Lib. Qualquer nome simples pode ser utilizado, pois qualquer conflito será &lt;em&gt;fácil&lt;/em&gt; de resolver adicionando a Unit quando for necessário.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O usuário não precisa memorizar as Units da Lib&lt;/strong&gt; pois tudo está num único só lugar. Simples e conveniente.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O desenvolvedor da Lib poderia incluir mais Interfaces e Classes&lt;/strong&gt; porém apenas para o uso “privado” da Lib sem que o usuário precise saber da existência desses novos artefatos. O usuário já estaria acostumado a utilizar apenas uma única Unit, então ele não iria ter “acesso” a outros identificadores que não estão listados lá. É claro que ele ainda poderia utilizar as Units reais da Lib, porém isso poderia ser informado na documentação que isso seria considerado um &lt;em&gt;“hack”&lt;/em&gt; ou quebra de &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; e o usuário estaria por conta própria.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ao definir um &lt;em&gt;alias&lt;/em&gt; para cada Interface ou Classe&lt;/strong&gt; — exemplo &lt;code&gt;TDataStreamAlias&lt;/code&gt;— não seria necessário &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclarar&lt;/a&gt; os identificadores na API utilizando as Units reais como prefixo.&lt;/p&gt;

&lt;p&gt;Compare as duas opções abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit James.API;

type
  {1} TDataStream = TDataStreamAlias;
  {2} TDataStream = James.Data.Clss.TDataStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Com certeza a primeira linha e menos verbosa.&lt;/p&gt;

&lt;p&gt;Esse é o motivo de haver esses identificadores que são apenas &lt;em&gt;alias&lt;/em&gt;. Além de ser menos verboso, o desenvolvedor poderia mover a &lt;code&gt;TDataStream&lt;/code&gt; para outra Unit e não precisaria alterar a API.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quando a API começar a ficar grande demais&lt;/strong&gt; será um sinal — ou um “cheiro” — de que a Lib pode estar fazendo coisas demais. Então a &lt;em&gt;API Unit&lt;/em&gt; é, também, uma restrição. Mas isso é bom. &lt;a href=&quot;/posts/menos-e-mais/&quot;&gt;Menos é mais&lt;/a&gt;, lembre-se disso.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Esse artigo tentou demostrar que utilizando apenas uma única técnica simples e um pouco mais trabalho, é possível melhorar muito a qualidade do código, resolvendo problemas de escopo, nomenclatura e legibilidade.&lt;/p&gt;

&lt;p&gt;Estou utilizando &lt;em&gt;API Unit&lt;/em&gt; em alguns projetos privados e &lt;em&gt;Open Sources&lt;/em&gt; (&lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;aqui&lt;/a&gt;) e a legibilidade tem melhorado.&lt;/p&gt;

&lt;p&gt;Penso em utilizar o mesmo conceito para delimitar API’s (módulos) em grandes sistemas, mas a &lt;a href=&quot;/posts/interfaces-e-a-referencia-circular-entre-objetos/&quot;&gt;referência circular&lt;/a&gt; entre Units pode ser um problema. Então o design do projeto tem que levar isso em conta desde o início.&lt;/p&gt;

&lt;p&gt;Se vai valer a pena… o tempo dirá.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Oct 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/api-unit</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/api-unit</guid>
      </item>
    
  </channel>
</rss>
