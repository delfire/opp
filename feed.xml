<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Namespaces Inteligentes</title>
        <description>&lt;p&gt;Na minha opinião, a implementação atual de Namespaces no Delphi poderia ser muito mais inteligente, simples e sem ambiguidades.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-fervent-jan-121249.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Fervent Jan on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A linguagem Pascal foi criada com o conceito de Namespace desde o início chamado &lt;em&gt;Units&lt;/em&gt;. As Unidades agrupam os identificadores, variáveis, tipos, classes…tudo que faz parte de um mesmo contexto.&lt;/p&gt;

&lt;p&gt;No entanto, hoje em dia nós, desenvolvedores Object Pascal, ganhamos uma definição diferente para Unit e Namespace.&lt;/p&gt;

&lt;p&gt;Talvez, devido a influência de outras linguagens “mais modernas”, ter apenas Unidades não parece ser mais suficiente para a modularização de sistemas.&lt;/p&gt;

&lt;p&gt;Concordo que ainda há espaço para melhorias no conceito das Unidades, porém a implementação proposta pela Embarcadero é suficiente para, agora, dizermos que a linguagem foi atualizada e que Namespaces é uma evolução?&lt;/p&gt;

&lt;h1 id=&quot;atual&quot;&gt;Namespaces Atual&lt;/h1&gt;

&lt;p&gt;A partir do Delphi 2007~2009 a Embarcadero implementou o “novo” conceito chamado &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Using_Namespaces_with_Delphi&quot;&gt;Namespace&lt;/a&gt;, onde é possível termos nomes de Unidades pontilhadas, como já existem em algumas outras linguagens.&lt;/p&gt;

&lt;p&gt;Além da questão estética para termos &lt;a href=&quot;/posts/nomeando-unidades/&quot;&gt;nomes de arquivos&lt;/a&gt; mais legíveis, esse conceito permite que o compilador localize as Unidades declaradas no código não apenas por seu nome, mas também levando em consideração o Namespace (prefixo) da Unidade.&lt;/p&gt;

&lt;p&gt;Segundo a Embarcadero, um Namespace é um &lt;a href=&quot;/posts/datamodule-e-apenas-um-container/&quot;&gt;container&lt;/a&gt; de Unidades.&lt;/p&gt;

&lt;p&gt;Nesse &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Using_Namespaces_with_Delphi&quot;&gt;link&lt;/a&gt;
oficial diz que &lt;em&gt;“Namespaces fornece uma maneira de organizar identificadores e tipos, e são utilizados para desambiguar tipos com o mesmo nome”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas já temos isso com as Unidades então, qual é a grande atualização?&lt;/p&gt;

&lt;p&gt;O documento segue dizendo: &lt;em&gt;“Desde que eles são um container para Unidades Delphi, os Namespaces também podem ser utilizados para diferenciação de unidades com o mesmo nome, que residem em pacotes diferentes”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Aqui parece haver uma vantagem. O texto afirma que podemos ter pacotes distintos porém cada um deles contendo Unidades com o mesmo nome e mesmo assim poderíamos utilizar tais pacotes em um mesmo projeto — algo que não seria possível sem essa &lt;em&gt;feature&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Enquanto eu escrevo esse artigo, tomando uma xícara quente de café na Starbucks, não tenho disponível uma versão atual do Delphi para fazer esse teste, mas eu acredito que funcione desde que eu utilize o Namespace do Pacote para referenciar todas as Unidades dele no meu projeto.&lt;/p&gt;

&lt;p&gt;Meu entendimento é esse:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Existe um Pacote chamado &lt;code&gt;Acme.Xpto.MyPack&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Dentro desse pacote existe as Unidades &lt;code&gt;Foo.pas&lt;/code&gt; e &lt;code&gt;Bar.pas&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;No meu projeto eu desejo utilizar as Unidades do Pacote, então eu preciso declara-las como &lt;code&gt;Acme.Xpto.Foo&lt;/code&gt; e &lt;code&gt;Acme.Xpto.Bar&lt;/code&gt; respectivamente.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Se eu tenho que escrever as Unidades de forma totalmente qualificada, qual é a grande vantagem? Não seria mais simples todas as Unidades do Pacote já serem totalmente qualificadas?&lt;/p&gt;

&lt;p&gt;De fato, é possível não escrever os Namespaces, em alguns casos.&lt;/p&gt;

&lt;p&gt;É possível, por exemplo, declarar a Unidade &lt;code&gt;Dialogs&lt;/code&gt; no código do seu projeto mas a referência real será &lt;code&gt;Vcl.Dialogs&lt;/code&gt; ou &lt;code&gt;FMX.Dialogs&lt;/code&gt;, bastando definir um parâmetro para o compilador. Parece ser uma &lt;em&gt;feature&lt;/em&gt; interessante mas, e se eu quisesse utilizar ambas as Unidades no mesmo projeto, como o compilador iria saber qual &lt;code&gt;Dialogs&lt;/code&gt; utilizar? Será que uma das Unidades deveria ser totalmente qualificada enquanto a outra não? Se assim for, é uma solução &lt;em&gt;inconsistente&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Talvez, o Objetivo da implementação padrão serviu apenas aos interesses da Embarcadero para o uso da VCL/FMX ao invés de ser realmente uma nova &lt;em&gt;feature&lt;/em&gt; para o desenvolvedor.&lt;/p&gt;

&lt;p&gt;Namespaces, na minha opinião, deveriam ser implementados de outra forma.&lt;/p&gt;

&lt;h2 id=&quot;problema&quot;&gt;O Problema&lt;/h2&gt;

&lt;p&gt;Uma Unidade já agrupa, de forma inequívoca, um identificador. Sempre tivemos isso na linguagem Object Pascal mas muitos acham que esse conceito só apareceu em linguagens mais recentes.&lt;/p&gt;

&lt;p&gt;Porém, hoje em dia eu posso ver uma referência a &lt;code&gt;Dialogs&lt;/code&gt; no código e não ter certeza se é da VCL ou qualquer outra Lib que utiliza Namespaces. É necessário verificar as configurações do compilador.&lt;/p&gt;

&lt;p&gt;Olhar “só” o código não é mais suficiente.&lt;/p&gt;

&lt;p&gt;Outro problema existe com o uso de Libs externas. Não sabemos, previamente, quais nomes de Unidades serão utilizadas pelos programadores ao redor do mundo. Esse é o motivo pelo qual sempre utilizamos prefixos (2~3 letras) nos nomes da Unidades/Classes para simular um Namespace único.&lt;/p&gt;

&lt;p&gt;Incrivelmente, essa pratica tem sido suficiente para a maioria dos casos. Pelo menos, para a maioria dos projetos Open Source mais conhecidos como Zeos(Z), RX, Indy(Id), JEDI(Jc) ou Synopse mORMot(Syn). Parece haver um certo “cavalheirismo” entre programadores em não utilizar os prefixos “já em uso” na comunidade Open Source.&lt;/p&gt;

&lt;p&gt;No Java, eles resolveram esse problema de forma mais simples: Utilize a URL da empresa/projeto como um Namespace para cada projeto.&lt;/p&gt;

&lt;p&gt;E é só isso. Não há ambiguidades, pois não há URL iguais.&lt;/p&gt;

&lt;p&gt;Então, bastaria fazermos o mesmo em Object Pascal. O mesmo que a comunidade de Java fez. Basta utilizar o maior nome possível para uma Unidade. Não haverá ambiguidade. Não haverá conflito. Não é necessário implementar nada no compilador.&lt;/p&gt;

&lt;p&gt;Resolvido?&lt;/p&gt;

&lt;p&gt;Em teoria sim. No entanto a implementação atual do Namespaces clama em dizer que é muito mais quem um nome único (veremos mais sobre isso abaixo).&lt;/p&gt;

&lt;p&gt;Além disso, Object Pascal não é assim, tão verboso. Gostamos de nomes simples e de fácil memorização. Podemos programar utilizando um editor simples de texto. Em Java, por exemplo, é necessário haver uma IDE inteligente para ter o mínimo de eficiência na codificação, visto que a IDE incluí automaticamente as “unidades” que serão importadas, além de fazer uma tonelada de checagens.&lt;/p&gt;

&lt;p&gt;Bem, se vamos alterar ou melhorar o conceito de Unidades, por quê não fazer isso de forma inteligente, ainda mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, eficaz e sem os problemas de ambiguidades na utilização dos Namespaces atuais?&lt;/p&gt;

&lt;p&gt;Podemos sugerir algumas ideias.&lt;/p&gt;

&lt;h2 id=&quot;desejavel&quot;&gt;Namespaces Desejável&lt;/h2&gt;

&lt;p&gt;Então, qual seria o &lt;em&gt;nirvana&lt;/em&gt; da implementação de Namespaces no Delphi e Lazarus?&lt;/p&gt;

&lt;p&gt;Eu posso lhe dizer minhas ideias (atuais) e no fim veremos se você concorda.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespaces deveriam ser únicos e explícitos no código&lt;/strong&gt;, sem ambiguidades.&lt;/p&gt;

&lt;p&gt;É &lt;em&gt;errado&lt;/em&gt; e anti-Pascal ter uma Unidade que não está 100% explícita no código sobre o que ela representa ou se há ambiguidades sobre o que ela representa.&lt;/p&gt;

&lt;p&gt;Isso quer dizer que &lt;code&gt;Dialogs&lt;/code&gt; &lt;em&gt;não&lt;/em&gt; pode representar, ora &lt;code&gt;FMX.Dialogs&lt;/code&gt;, ora &lt;code&gt;Vcl.Dialogs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mesmo que eles possam ser configuráveis, eles deveriam ser únicos no código para não haver ambiguidades.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespaces deveriam ser dinâmicos&lt;/strong&gt;, porém explícitos no código.&lt;/p&gt;

&lt;p&gt;Ser dinâmico implica em configuração. Então, a ideia de definirmos Namespaces como argumentos do compilador é boa, porém sua implementação atual não foi bem executada.&lt;/p&gt;

&lt;p&gt;Sim, Namespaces deveriam ser definidos &lt;em&gt;por&lt;/em&gt; Pacote, porém o &lt;em&gt;erro&lt;/em&gt; é defini-los utilizando os nomes dos Pacotes.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;configuração&lt;/em&gt; deveria ser local.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Namespaces deveriam ser locais&lt;/strong&gt;, ou seja, cada projeto implementa os Namespaces de acordo com a nomenclatura que desejar.&lt;/p&gt;

&lt;p&gt;Na minha opinião, ao adicionar um Pacote ao meu projeto, eu poderia (ou deveria) definir um Namespace para ele. É o mesmo que dizer que todas as Unidades do Pacotes seriam “renomeadas” com o novo prefixo — muito similar com a solução atual — porém sem ambiguidades.&lt;/p&gt;

&lt;p&gt;Imagine 2 Pacotes: &lt;code&gt;FooPack&lt;/code&gt; e &lt;code&gt;BarPack&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Os desenvolvedores de ambos não deveriam se importar sobre Namespaces. Cada Pacote está bem definido em seus próprios contextos locais, sem se preocupar com o mundo afora. Não importa se os projetos que irão utilizá-los serão pequenos ou gigantescos com inúmeras dependências de vários outros Pacotes. Isso deveria ser irrelevante para os autores de Pacotes.&lt;/p&gt;

&lt;p&gt;Cabe a cada Projeto definir o Namespace para cada Pacote, se assim o desejar.&lt;/p&gt;

&lt;p&gt;Por exemplo, se ambos os Pacotes tem uma Unidade chamada &lt;code&gt;Utils&lt;/code&gt;, nos iríamos referenciá-las como &lt;code&gt;Foo.Utils&lt;/code&gt; e &lt;code&gt;Bar.Utils&lt;/code&gt; dentro do código do Projeto.&lt;/p&gt;

&lt;p&gt;Essa foram escolhas óbvias. Mas ou invés de &lt;code&gt;Foo.Utils&lt;/code&gt; e &lt;code&gt;Bar.Utils&lt;/code&gt; poderiam ser &lt;code&gt;FoPack.Utils&lt;/code&gt; e &lt;code&gt;BrPack.Utils&lt;/code&gt;, respectivamente. O mais importante aqui é que estas são &lt;em&gt;escolhas do Projeto&lt;/em&gt;, do usuário do Pacote, não daqueles que criaram os Pacotes.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;É necessário uma implementação mais moderna do conceito de Namespace, porém sem perder as características originais do Object Pascal.&lt;/p&gt;

&lt;p&gt;Tudo na linguagem é previamente declarado, exatamente para não haver ambiguidades. Unidades devem ser únicas em todo o projeto. Não importa se elas estão na VCL/LCL, RTL, Libs, etc. Não deveriam haver ambiguidades.&lt;/p&gt;

&lt;p&gt;Tudo é ou deveria ser explícito no código. Deixar o compilador decidir se um identificador corresponde a X ou a Y em tempo de execução, não me parece ser algo tão explícito.&lt;/p&gt;

&lt;p&gt;Finalmente, as ideias propostas nesse artigo tem a finalidade e o desejo de melhorar a linguagem Object Pascal e não depreciar as escolhas de &lt;em&gt;design&lt;/em&gt; dos desenvolvedores da linguagem e do compilador.&lt;/p&gt;

&lt;p&gt;Esses são meus pensamentos… Você concorda?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Feb 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/namespaces-inteligentes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/namespaces-inteligentes</guid>
      </item>
    
      <item>
        <title>Interfaces COM vs. CORBA</title>
        <description>&lt;p&gt;Existem dois tipos de Interfaces no Free Pascal definidos como COM e CORBA. No Delphi temos apenas o tipo COM. Mas será que existem vantagens ao utilizar o tipo CORBA?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-hermes-rivera-265372.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Hermes Rivera on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No Delphi, quando definimos que um Objeto é do tipo Interface, quer dizer que (por padrão) ele será a liberado automaticamente da memória pelo compilador quando a variável sair do escopo e sua &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#contador-de-referencias&quot;&gt;contagem de referência&lt;/a&gt; chegar a zero.&lt;/p&gt;

&lt;p&gt;Para utilizar essa &lt;em&gt;feature&lt;/em&gt;, basta implementar sua Classe herdando de &lt;code&gt;TInterfacedObject&lt;/code&gt;, afim de utilizar a implementação padrão para Interfaces COM.&lt;/p&gt;

&lt;p&gt;Se você não quiser utilizar &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;, terá que implementar os &lt;a href=&quot;/posts/interfaces-delegacao-problemas-solucoes/#contador-de-referencias&quot;&gt;3-métodos&lt;/a&gt; obrigatórios para toda Classe que implementa Interfaces COM e isso realmente pode parecer estranho para programadores que estão vindo de outras linguagens.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Por quê eu deveria implementar métodos que não estão definidos na Interface?”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Realmente, não parece fazer muito sentido.&lt;/p&gt;

&lt;h2 id=&quot;corba&quot;&gt;CORBA&lt;/h2&gt;

&lt;p&gt;No Free Pascal você tem uma escolha. Pode-se utilizar Interfaces COM ou CORBA. O primeiro tipo se comporta do mesmo jeito que no Delphi. Tem contagem de referência e liberação automática de memória, enquanto o tipo CORBA é exatamente o contrário. Esse tipo não tem contagem de referência e, por isso, não tem a ajuda do compilador para liberar a memória automaticamente. Cabe ao programador liberar os Objetos utilizando seus respectivos destrutores.&lt;/p&gt;

&lt;p&gt;Também não é possível liberar uma instância apenas atribuindo &lt;code&gt;nil&lt;/code&gt;. É necessário que se tenha a instância de uma Classe ou que a Interface tenha algum método que possa ser utilizado como destrutor, por exemplo, &lt;code&gt;Free&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IFoo = interface
    procedure Execute;
    procedure Free;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O tipo CORBA não exige do programador a implementação “obscura” de métodos de &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#infraestrutura&quot;&gt;infraestrutura&lt;/a&gt; além do que está declarado na Interface. Apenas os métodos das Interfaces devem ser implementados nas Classes. Essa é uma vantagem em relação ao tipo COM.&lt;/p&gt;

&lt;p&gt;Então, se você estiver desenvolvendo utilizando Free Pascal e não quer trabalhar com contagem de referência, utilizar CORBA pode ser uma boa opção.  Sua sintaxe e &lt;em&gt;design&lt;/em&gt; “limpos” não obrigam o programador a implementar os 3-métodos padrões de COM.&lt;/p&gt;

&lt;p&gt;Entretanto, lembre-se que todas as Interfaces dentro da mesma Unit terão o mesmo tipo, seja COM ou CORBA.&lt;/p&gt;

&lt;h2 id=&quot;com&quot;&gt;COM&lt;/h2&gt;

&lt;p&gt;Muitos programadores não gostam de utilizar o tipo COM devido aos problemas com referência de Objetos. Mesmo que a &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;solução&lt;/a&gt; seja simples para resolvê-los.&lt;/p&gt;

&lt;p&gt;Enquanto o tipo CORBA pode ter um &lt;em&gt;design&lt;/em&gt; mais simples, o tipo COM é mais &lt;em&gt;customizável&lt;/em&gt; pois pode ser implementado sem contagem de referência. Basta implementarmos os 3-métodos obrigatórios sem incrementar a contagem.&lt;/p&gt;

&lt;p&gt;Pessoalmente, sempre prefiro utilizar o tipo COM e a contagem de referência para a liberação automática dos objetos na memória. Entretanto, se eu quiser que apenas algumas Classes não tenham a contagem de referência, basta sobrescrever os métodos necessários para ter o mesmo comportamento das Classes que implementam Interfaces CORBA.&lt;/p&gt;

&lt;p&gt;Considero isso uma &lt;em&gt;grande&lt;/em&gt; vantagem!&lt;/p&gt;

&lt;p&gt;Por exemplo. Posso ter uma única Interface mas com implementações distintas em Classes diferentes, utilizando ou não a contagem de referência.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Minha conclusão é que o tipo COM é &lt;em&gt;melhor&lt;/em&gt; do que CORBA por quê podemos implementar os dois tipos de comportamentos (com ou sem contagem de referência), enquanto com CORBA implementamos apenas um comportamento.&lt;/p&gt;

&lt;p&gt;O comportamento deve estar nas Classes, não nas Interfaces ou diretivas de compilação.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/com-vs-corba</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/com-vs-corba</guid>
      </item>
    
      <item>
        <title>Versões Antigas dos Compiladores</title>
        <description>&lt;p&gt;A primeira versão do Delphi data de 1995, após o Turbo Pascal,enquanto o compilador Free Pascal é de 1993.&lt;/p&gt;

&lt;p&gt;Estamos em 2018 agora. Será que vale a pena manter seu código executando nas versões antigas do compilador?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-danielle-macinnes-222441.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Danielle MacInnes on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Talvez não valha a pena manter o código dos seus projetos funcionando nas versões antigas, uma vez que você tenha conseguido migrar todo o código-fonte para uma versão mais nova. No entanto, suas bibliotecas — especialmente as públicas, Open Source — poderiam (ou deveriam?) continuar compilando nas versões mais antigas dos compiladores.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O primeiro motivo&lt;/strong&gt; é bem simples. &lt;em&gt;Compatibilidade&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas por quê isso é importante?&lt;/p&gt;

&lt;p&gt;Trabalho profissionalmente com o Delphi desde sua versão 4 e um dos critérios que me fizeram continuar na ferramenta foi a retrocompatibilidade. Um código que executava na versão anterior, continuava executando na versão mais nova.&lt;/p&gt;

&lt;p&gt;Lembro das palestras e encontros proporcionados pela antiga Borland, onde o palestrante abria aquele “Projeto dos Peixinhos” feito no Delphi 1~2 e ele continuava compilando normalmente, sem alterações, na versão mais nova.&lt;/p&gt;

&lt;p&gt;É difícil ver esse nível de comprometimento com o usuário/desenvolvedor hoje em dia. Quantos frameworks a Microsoft já criou e matou na plataforma .NET? Temos que ficar correndo como “ratos” atrás do próximo “queijo sofisticado” para fazer o mesmo tipo de projeto que já estávamos fazendo a 20 anos atrás? Tenho certeza que não.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O segundo motivo&lt;/strong&gt; é proporcionar mais &lt;em&gt;opções&lt;/em&gt; de bibliotecas à comunidade Object Pascal.&lt;/p&gt;

&lt;p&gt;Hoje em dia a linguagem se tornou um (pequeno) nicho. Enquanto nascem “centenas” de frameworks JavaScript todos os dias, não vemos o mesmo empenho na comunidade Pascal. Então, é importante manter o código legado funcionando para manter os desenvolvedores fieis a linguagem. Senão eles irão procurar alternativas lá fora. Melhor ainda, seria se tivéssemos mais opções a escolher, no entanto.&lt;/p&gt;

&lt;p&gt;Eu já publiquei algumas bibliotecas Open Source a alguns anos, mas agora elas não existem mais. Não valiam a pena. Eram só “brinquedos”. Elas deveriam mesmo desaparecer. No entanto existem bibliotecas que fizeram e ainda fazem muita diferença no desenvolvimento hoje como a RX e JEDI. Acredito que essas bibliotecas não compilem utilizando versões antigas, no entanto elas foram atualizadas, o que já é um grande mérito para seus mantenedores.&lt;/p&gt;

&lt;p&gt;Existem ainda alguns &lt;em&gt;ninjas&lt;/em&gt; do Object Pascal que mantém uma &lt;em&gt;única&lt;/em&gt; base de código desde o Delphi 6 até o Delphi 10.2 Tokyo, compilando também no FPC 2.7.1/3.1.1 em diante. Me refiro ao framework &lt;a href=&quot;https://synopse.info/fossil/wiki?name=SQLite3+Framework&quot;&gt;mORMot&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mORMot é o estado-da-arte&lt;/strong&gt; dentre todos os projetos Object Pascal que conheço. Com uma &lt;em&gt;única&lt;/em&gt; base de código e sintaxe “old-school”, sem generics, sem classes anônimas, sem métodos anônimos, sem n.a.m.e.s.p.a.c.e.s, ou seja, “apenas” com Classes, Interfaces e funções, o autor Arnaud Bouchez e colaboradores foram capazes de criar e manter ao longo dos anos, um framework Client-Server ORM/ODM SOA MVC completo, quase sem dependências externas, com performance &lt;em&gt;superior&lt;/em&gt; as soluções &lt;em&gt;modernas&lt;/em&gt; como Node.js.&lt;/p&gt;

&lt;p&gt;Isso prova que &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt; e arquitetura bem feita são muito mais importantes que novas &lt;em&gt;features&lt;/em&gt; na linguagem, novos componentes, nova IDE…&lt;/p&gt;

&lt;p&gt;A alguns anos eu voltei a publicar projetos Open Source, com uma nova abordagem e profissionalismo. Mas quando vejo projetos como o mORMot, tenho a plena convicção do quanto eu ainda tenho que aprender.&lt;/p&gt;

&lt;p&gt;Hoje utilizo FPC/Lazarus mais do que Delphi. Comecei a migrar meus sistemas e bibliotecas privadas para a “plataforma concorrente” a alguns anos. Nessa época o Lazarus era um “brinquedo” mas, felizmente, continuei a utilizá-lo e hoje o Lazarus é tão bom quanto o Delphi — talvez melhor. No entanto, o &lt;em&gt;Delphi 7&lt;/em&gt; ainda faz parte do meu dia-a-dia. Então, vale a pena fazer bibliotecas para essa versão? Talvez.&lt;/p&gt;

&lt;p&gt;Saber que as mesmas bibliotecas que eu sempre utilizei foram sendo atualizadas ao londo de todos esses anos, é um conforto. Não precisarei reescrever meus sistemas… pelo menos enquanto mantermos a linguagem viva.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/versoes-antigas-dos-compiladores</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/versoes-antigas-dos-compiladores</guid>
      </item>
    
      <item>
        <title>Objetos Complexos</title>
        <description>&lt;p&gt;Um Objeto não é apenas uma instância de uma Classe. Ele pode conter instâncias (quase) infinitas de diferentes Classes combinadas.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-chuttersnap-378918.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by chuttersnap on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;No mundo real convivemos constantemente com Objetos (humanos, animais, plantas, coisas, etc) que possuem todo tipo de &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamento&lt;/a&gt; especializado. Alguns desses Objetos — talvez a maioria — fazem coisas demais, ou seja, eles agregam muitas funcionalidades num único “corpo”. Eles são &lt;em&gt;complexos&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Quando tentamos abstrair e implementar um &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Objeto ou Entidade&lt;/a&gt; no &lt;em&gt;software&lt;/em&gt;, utilizando uma linguagem de programação em conjunto com o paradigma da Orientação a Objetos, uma dúvida comum em quase todos os desenvolvedores iniciantes — ou mesmo experientes — é tentar identificar quais métodos irão ser implementados na Classe, baseado apenas no comportamento “final” do Objeto ou Entidade do mundo real.&lt;/p&gt;

&lt;p&gt;O comportamento final ao que me refiro é como vemos um Objeto e suas funcionalidades sem considerar as partes que os compõem. Vemos um Objeto como um &lt;em&gt;todo&lt;/em&gt; e não como uma soma das partes.&lt;/p&gt;

&lt;p&gt;Esse é um grande equívoco no desenvolvimento de software.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo. Como representamos um &lt;em&gt;Carro&lt;/em&gt; utilizando a &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;O primeiro passo seria determinar o nível de abstração dos comportamentos que precisamos implementar ou descartar. Em outras palavras, é necessário saber os requisitos do sistema para sabermos o que é realmente necessário.  Se a cor do carro é irrelevante para os requisitos do usuário dentro do &lt;em&gt;software&lt;/em&gt;, então não há necessidade de implementarmos. É necessário saber se a carroceria utiliza fibra de carbono ou alumínio? Se o carro é 4x4, sua velocidade máxima, quantidade de airbags, tipo de roda? Se nada disso for importante, descartamos. Então, o mais fácil a fazer é pensarmos no que é &lt;em&gt;necessário&lt;/em&gt;, pois é quase certo que qualquer Objeto implementado não irá representar uma entidade completamente, ou seja, com todo comportamento que a entidade possui no mundo real.&lt;/p&gt;

&lt;p&gt;Após termos o comportamento necessário já definido, o próximo passo é pensar na estrutura da Classe.&lt;/p&gt;

&lt;p&gt;É aqui, neste momento, que a grande maioria dos desenvolvedores utiliza o paradigma procedural, porém pensam que estão programando Orientado a Objetos apenas por quê estão utilizando Classes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TCar = class
  public
    procedure Run;
    procedure Brake;
    function CheckBrakeFluid: Boolean;
    function CheckOil: Boolean;
    function CheckWater: Boolean;
    procedure LockDoors;
    procedure UnlockDoors;
    procedure StartEngine;
    procedure StopEngine;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Classe acima mostra de forma simples os comportamentos necessários que foram solicitados, hipoteticamente, nos requisitos do usuário. Mas será esse é o design &lt;em&gt;correto&lt;/em&gt; para representar um carro dentro do &lt;em&gt;software&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Apesar das funcionalidades estarem bem evidentes e com &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/&quot;&gt;nomes de métodos&lt;/a&gt; bem “explicativos”, essa é uma implementação totalmente equivocada.&lt;/p&gt;

&lt;p&gt;Um carro não &lt;em&gt;corre&lt;/em&gt;. É o motor que gira e, através de mecanismos e engrenagens, passa energia para as rodas fazendo o carro se mover através do atrito dos pneus com o asfalto.&lt;/p&gt;

&lt;p&gt;Um carro não &lt;em&gt;freia&lt;/em&gt;. É o motorista que através de um pedal, em conjunto com cabos ou mesmo eletrônica, envia um comando às pinças de freio. Essas, em conjunto com os discos de freio, fazem o carro parar.&lt;/p&gt;

&lt;p&gt;Um carro não faz &lt;em&gt;checagens&lt;/em&gt; de fluídos. Existem sensores específicos para fazer essa leitura a cada segundo ou microssegundo.&lt;/p&gt;

&lt;p&gt;Fica claro aqui, que não devemos ver a entidade como um todo, mas sim pensar nas partes específicas que a compõe. No entanto, não devemos especializar demais para não complicarmos o modelo desnecessariamente.&lt;/p&gt;

&lt;p&gt;Vamos reescrever a Classe acima.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TBrakes = class(TInterfacedObject, IBrakes)
  public
    function Brake(AForce: Double): IBrakes;
  end;
  
  TSensors = class(TInterfacedObject, ISensors)
  public
    function CheckBrakeFluid: Boolean;
    function CheckOil: Boolean;
    function CheckWater: Boolean;
  end;
  
  TDoors = class(TInterfacedObject, IDoors)
  public
    function Lock: IDoors;
    function Unlock: IDoors;
  end;
  
  TEngine = class(TInterfacedObject, IEngine)
  public
    procedure Start;
    procedure Stop;
    function Work: IEngine;
  end;
  
  TCar = class(TInterfacedObject, ICar)
  public
    procedure Run;
    function Brakes: IBrakes;
    function Sensors: ISensors;
    function Doors: IDoors;
    function Engine: IEngine;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Há várias possibilidade de implementação, mas a opção sugerida acima separa bem o comportamento de um carro através da composição de Objetos. No entanto, não há necessidade de especializar tudo. Por exemplo, o método &lt;code&gt;Run&lt;/code&gt; continua o mesmo; existe apenas uma Classe &lt;code&gt;TSensors&lt;/code&gt; para todos os sensores — seria muito melhor se tivéssemos uma Classe por sensor.&lt;/p&gt;

&lt;p&gt;O design deve ser o mais simples possível, porém correto, reutilizável (partes independentes) e testável (cada parte em separado).&lt;/p&gt;

&lt;p&gt;Na minha opinião, a &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simplicidade&lt;/a&gt;, a reutilização e a testabilidade devem ser alguns dos maiores objetivos a serem seguidos no design de cada Classe.&lt;/p&gt;

&lt;p&gt;Essa foi uma maneira de implementar algo complexo de forma simples.&lt;/p&gt;

&lt;p&gt;Um outro padrão de desenvolvimento que podemos utilizar para implementarmos algo complexo é chamado de &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração de Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Imagine que você tenha diferentes modelos de motores. Utilizar &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança de Classes&lt;/a&gt; pode ser a primeira técnica que vem a sua mente, porém a Decoração de Objetos pode ser bem melhor. Utilizando essa técnica, podemos decorar Objetos em &lt;em&gt;runtime&lt;/em&gt; de acordo com os requisitos ou escolhas feita pelos usuários num determinado momento.&lt;/p&gt;

&lt;p&gt;Então, seguindo nosso exemplo, imagine um motor chamado X13 e uma versão com mais performance chamada X15 que possui um turbo compressor. Ao implementarmos essas Classes, gostaríamos de reutilizar as partes em comum. Sendo o X15 uma melhoria do X13, que tal &lt;em&gt;decorar&lt;/em&gt; o X13 em &lt;em&gt;runtime&lt;/em&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var
  Engine: IEngine;
begin
  Engine := 
    TX15Engine.New(
      0.6, // pressure
      TX13Engine.New()
    );
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo, a variável &lt;code&gt;Engine&lt;/code&gt; será, de certa forma, um Objeto &lt;em&gt;combinado&lt;/em&gt; de duas instâncias de Classes diferentes, porém complementares.&lt;/p&gt;

&lt;p&gt;Para implementarmos Objetos complexos, devemos analisar suas partes, de acordo com o nível de abstração requerido, e implementar cada uma delas, combinando-as entre si, para então termos a implementação de um Objeto maior e mais &lt;em&gt;complexo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“O todo é maior que a soma das partes”.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/objetos-complexos</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/objetos-complexos</guid>
      </item>
    
      <item>
        <title>O Procedimento Exit</title>
        <description>&lt;p&gt;Todos os programadores Pascal conhecem o procedimento &lt;code&gt;Exit()&lt;/code&gt; desde as primeiras versões dos compiladores. Mas será que todos sabem utilizá-lo corretamente?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-kev-seto-94686.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Kev Seto on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;O procedimento &lt;code&gt;Exit()&lt;/code&gt; é utilizado quando queremos sair de um escopo em execução. Esse escopo pode ser uma função, procedimento, método ou até mesmo o próprio programa.&lt;/p&gt;

&lt;p&gt;Vamos dizer que um programa console chame um procedimento &lt;code&gt;Execute&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  Writeln(&#39;1. Passing on this line...&#39;);
  Exit;
  Writeln(&#39;2. It will not pass here&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, somente a informação do primeiro &lt;code&gt;Writeln&lt;/code&gt; será mostrado no console.&lt;/p&gt;

&lt;p&gt;Ao sair de um escopo, o programa retorna imediatamente para o escopo anterior (outra função/procedimento/método ou o próprio programa). A única exceção a essa regra é quando há blocos &lt;code&gt;try-finally&lt;/code&gt;. Se &lt;code&gt;Exit()&lt;/code&gt; for chamado dentro de um bloco &lt;code&gt;try-finally&lt;/code&gt; o compilador irá executar o código dentro do &lt;code&gt;finally-end&lt;/code&gt; &lt;em&gt;antes&lt;/em&gt; de sair do escopo.&lt;/p&gt;

&lt;p&gt;Aqui está outro exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute;
begin
  try
    Writeln(&#39;1. Passing on this line...&#39;);
    Exit;
  finally
    Writeln(&#39;2. I am still here!&#39;);
  end;
  Writeln(&#39;3. It will not pass here&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Os textos #1 e #2 serão mostrados no console. Mesmo que &lt;code&gt;Exit()&lt;/code&gt; tenha sido chamado antes da impressão do texto #2, ainda sim o código é executado devido ao &lt;code&gt;try-finally&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Outro exemplo de uso do &lt;code&gt;Exit()&lt;/code&gt; é quando fazemos validações. Se uma validação ou checagem não retornar verdadeiro, utilizamos o &lt;code&gt;Exit()&lt;/code&gt; para parar a execução do escopo atual.&lt;/p&gt;

&lt;p&gt;Suponha que queremos somar dois números inteiros, mas só queremos números maiores que zero:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;lt; 0) or (B &amp;lt; 0) then
    Exit;
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, o retorno da função &lt;code&gt;Sum&lt;/code&gt; é inicializado com um valor inválido e depois há uma validação para saber se os valores são menores que &lt;code&gt;0&lt;/code&gt;. Se o teste falhar, o programa irá retornar para o escopo anterior à chamada da função &lt;code&gt;Sum&lt;/code&gt; com o resultado inválido. Mas se o teste não falhar, o resultado da função será a soma de A e B.&lt;/p&gt;

&lt;p&gt;Há aqueles que são adeptos da programação estruturada e preferem não “quebrar” a execução do programa com uma “saída antecipada”, ou seja, não fazem uso do &lt;code&gt;Exit()&lt;/code&gt; por acreditarem que o código ficaria mais simples.&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  if (A &amp;gt; 0) and (B &amp;gt; 0) then
    Result := Format(&#39;The result is %d&#39;, [A + B]);
  else
    Result := &#39;Invalid result&#39;;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parece mais simples? Bem, nesse exemplo eu diria que sim. Porém para exemplos com mais condicionais, eu diria que não (vamos ver isso mais abaixo).&lt;/p&gt;

&lt;p&gt;E se quiséssemos dizer ao usuário que seus dados não estão corretos?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;gt; 0) then
  begin
    if (B &amp;gt; 0) then
      Result := Format(&#39;The result is %d&#39;, [A + B]);
    else
      Writeln(&#39;B should be greater than zero&#39;);
  end
  else
    Writeln(&#39;A should be greater than zero&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo não utilizamos &lt;code&gt;Exit()&lt;/code&gt; e eu acho que o código está bem confuso. Os testes estão “separados” do retorno de aviso para o usuário (&lt;code&gt;Writeln&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Kent Beck , Martin Fowler &lt;a href=&quot;https://en.wikipedia.org/wiki/Structured_programming#Early_exit&quot;&gt;afirmaram&lt;/a&gt; categoricamente que &lt;em&gt;“um ponto de saída não é realmente uma regra útil. A clareza é o princípio chave: se o método for mais claro com um ponto de saída, use um ponto de saída, caso contrário, não”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior com o uso de &lt;code&gt;Exit()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  Result := &#39;Invalid result&#39;;
  if (A &amp;lt; 0) then
  begin
    Writeln(&#39;A should be greater than zero&#39;);
    Exit;
  end;
  if (B &amp;lt; 0) then
  begin
    Writeln(&#39;B should be greater than zero&#39;);
    Exit;
  end;
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código ficou um pouco maior, é verdade, porém os testes e avisos para o usuário ficaram mais simples, na minha opinião. Você não precisa acompanhar todos os &lt;code&gt;if-else&lt;/code&gt; aninhados. A cada teste que falhar, o aviso está logo abaixo e o escopo será abortado com o uso do &lt;code&gt;Exit()&lt;/code&gt;. Se todos os testes não falharem, a função irá retornar a soma de A e B.&lt;/p&gt;

&lt;p&gt;No Delphi, a partir da &lt;a href=&quot;http://docs.embarcadero.com/products/rad_studio/delphiAndcpp2009/HelpUpdate2/EN/html/delphivclwin32/System_Exit.html&quot;&gt;versão 2009&lt;/a&gt;, o procedimento &lt;code&gt;Exit()&lt;/code&gt; ganhou uma melhoria: &lt;code&gt;Exit()&lt;/code&gt; pode ter um parâmetro especificando um resultado. O parâmetro deve ser do mesmo tipo que o resultado da função.&lt;/p&gt;

&lt;p&gt;O FPC também tem a &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/exit.html&quot;&gt;mesma definição&lt;/a&gt;, porém não sei quem implementou essa nova &lt;em&gt;feature&lt;/em&gt; primeiro.&lt;/p&gt;

&lt;p&gt;Então vamos reescrever o exemplo anterior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Sum(A, B: Integer): string;
begin
  if (A &amp;lt; 0) then
    Exit(&#39;A should be greater than zero&#39;);
  if (B &amp;lt; 0) then
    Exit(&#39;B should be greater than zero&#39;);
  Result := Format(&#39;The result is %d&#39;, [A + B]);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/posts/simplicidade/&quot;&gt;Simples&lt;/a&gt; e limpo.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Exit()&lt;/code&gt; pode receber como parâmetro qualquer tipo de retorno, até mesmo instâncias de &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;. Utilizando esse parâmetro, é como se ganhássemos o mesmo comportamento da palavra reservada &lt;code&gt;return&lt;/code&gt;, em Java. No entanto, &lt;code&gt;Exit()&lt;/code&gt; em conjunto com &lt;code&gt;Result&lt;/code&gt; nos dá ainda mais possibilidades de retorno para as funções.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/exit-proc</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/exit-proc</guid>
      </item>
    
      <item>
        <title>Pas2JS: Codificando em Pascal, Executando em JavaScript</title>
        <description>&lt;p&gt;A equipe do Free Pascal e Lazarus nos deram um grande presente de Final de Ano: Um Transpiler de Pascal para JavaScript.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/photo-greg-rakozy-129733.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Greg Rakozy on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O uso do JavaScript é necessário para qualquer aplicação Web. Somos obrigados a utilizá-lo por quê (por enquanto) é a única linguagem que os &lt;em&gt;browsers&lt;/em&gt; entendem.&lt;/p&gt;

&lt;p&gt;Mas JavaScript não é fortemente tipado como Pascal e isso pode ser um grande problema quando codificamos aplicações maiores utilizando somente JavaScript.&lt;/p&gt;

&lt;p&gt;JavaScript pode ser &lt;em&gt;confuso&lt;/em&gt; e &lt;em&gt;ambíguo&lt;/em&gt;. Por isso muitos desenvolvedores &lt;em&gt;devem&lt;/em&gt; utilizar &lt;em&gt;frameworks&lt;/em&gt; que facilitam o desenvolvimento e padronizam a codificação.&lt;/p&gt;

&lt;p&gt;Codificar utilizando JavaScript &lt;em&gt;puro&lt;/em&gt; não é uma tarefa fácil.&lt;/p&gt;

&lt;p&gt;Então surgiram os &lt;a href=&quot;https://en.wikipedia.org/wiki/Source-to-source_compiler&quot;&gt;Transpilers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Um Transpiler é um compilador que, a partir de um código-fonte escrito em uma linguagem de programação como sua entrada, produz um código-fonte equivalente em outra linguagem de programação.&lt;/p&gt;

&lt;p&gt;Existem &lt;a href=&quot;https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS&quot;&gt;vários&lt;/a&gt; Transpilers para JavaScript a partir de várias linguagens de programação. O mais famoso deles, eu acredito, é a linguagem TypeScript da Microsoft.&lt;/p&gt;

&lt;p&gt;A linguagem Pascal está incluída nesse pacote de Transpilers, no entanto, além de existir poucos, eles são comerciais.&lt;/p&gt;

&lt;p&gt;Felizmente, agora temos uma opção gratuita e Open Source chamada &lt;strong&gt;Pas2JS&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;pas2js&quot;&gt;Pas2JS&lt;/h2&gt;

&lt;p&gt;Michael Van Canneyt (Free Pascal Team), Mattias Gaertner (Lazarus Team), e colaboradores, &lt;a href=&quot;http://lists.lazarus-ide.org/pipermail/lazarus/2017-December/233592.html&quot;&gt;lançaram oficialmente&lt;/a&gt; o compilador utilitário chamado &lt;a href=&quot;http://wiki.freepascal.org/pas2js&quot;&gt;Pas2JS&lt;/a&gt;, em 16 de Dezembro de 2017, na lista oficial do Free Pascal.&lt;/p&gt;

&lt;p&gt;O JavaScript gerado a partir de um código-fonte Pascal é utilizável no &lt;em&gt;browser&lt;/em&gt; ou até mesmo no Node.js.&lt;/p&gt;

&lt;p&gt;Ao invés de gerar um executável com seu código Pascal, um arquivo .js será gerado, compatível com seu &lt;em&gt;browser&lt;/em&gt;, sem a necessidade de haver um servidor de aplicação (CGI, FastCGI, ISAPI, etc) se o aplicativo não necessitar de dados externos.&lt;/p&gt;

&lt;p&gt;Como disse Michael no seu email de lançamento (tradução livre):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Isso torna o Free Pascal um ambiente de desenvolvimento completo para o desenvolvimento Web”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Na verdade, o desenvolvimento ainda não está (totalmente) completo. Funciona muito bem, porém ainda há melhorias a serem feitas, como pode ser visto &lt;a href=&quot;http://wiki.freepascal.org/pas2js#Other_not_implemented_features&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A sintaxe básica é a mesma do Delphi 7&lt;/strong&gt;, porém ainda não temos o suporte a Interfaces. Acredito que teremos isso em breve, no entanto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A RTL teve que ser reescrita&lt;/strong&gt;, gerando novas versões das Unidades padrão para que pudessem ser utilizadas perfeitamente na conversão de Pascal para JavaScript. A lista das unidades você pode ver &lt;a href=&quot;http://wiki.freepascal.org/pas2js#RTL&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O debugging pode ser feito diretamente no código Object Pascal&lt;/strong&gt;, dentro do &lt;em&gt;browser&lt;/em&gt;. Isso é possível por quê o Pas2JS emite um &lt;em&gt;“source map”&lt;/em&gt; para que o &lt;em&gt;browser&lt;/em&gt; exiba o código original em vez do código JavaScript, o que é muito útil para encontrar bugs no código original Pascal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lazarus já tem suporte para a sintaxe do Pas2JS&lt;/strong&gt;, então o &lt;em&gt;code completion&lt;/em&gt; irá funcionar (versão trunk).&lt;/p&gt;

&lt;p&gt;A integração completa do Pas2JS está sendo codificada no Lazarus e, futuramente, eles já falam em desenvolver pacotes de componentes para execução no &lt;em&gt;browser&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TMS Web componentes vai chegar no início de 2018&lt;/strong&gt;. São componentes visuais no bom estilo RAD para desenvolver aplicações Web utilizando &lt;code&gt;TForm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Cito a TMS aqui por quê, no email do Michael, ele diz (tradução livre):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Em um futuro muito próximo, um importante fornecedor de componentes da Delphi anunciará um pacote completo para desenvolvimento web RAD no Delphi IDE.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu &lt;em&gt;acredito&lt;/em&gt; que ele estava falando da &lt;a href=&quot;https://www.tmssoftware.com/site/&quot;&gt;TMS&lt;/a&gt;, empresa conceituada que se dedica à fabricação de componentes e frameworks para Delphi e Lazarus.&lt;/p&gt;

&lt;p&gt;A alguns dias atrás os desenvolvedores do Brasil tiveram a chance de ver algumas palestras sobre Delphi e uma delas foi o anúncio da nova tecnologia da TMS para desenvolvimento Web, por Wagner Landgraf.&lt;/p&gt;

&lt;p&gt;Para quem acompanha os pré-anúncios do Pas2JS já algum tempo — pois ele está sendo desenvolvido ao longo de 10 anos — basta “ligar os pontos” para ter quase certeza que os componentes TMS Web utiliza a tecnologia Pas2JS ou, no mínimo, se inspirou nela.&lt;/p&gt;

&lt;p&gt;No entanto, na palestra do Wagner não há nenhuma menção ao Pas2JS.&lt;/p&gt;

&lt;p&gt;Se eu estou certo, ou seja, se a TMS Web realmente utiliza o Pas2JS no seu novo produto, eu considero uma &lt;em&gt;falha&lt;/em&gt; não mencionar quem criou o Transpiler.&lt;/p&gt;

&lt;p&gt;Não há nenhum problema em criar componentes para comercialização, no entanto é necessário dar o crédito a quem é devido.&lt;/p&gt;

&lt;p&gt;Entretanto, isso é apenas uma suposição pessoal. Se a TMS não utiliza/utilizou o Pas2JS, acredito que saberemos disso em breve.&lt;/p&gt;

&lt;p&gt;Mas, independentemente da TMS utilizar ou não o Pas2JS, fico ansioso para ver o lançamento oficial do novo &lt;em&gt;framework&lt;/em&gt;, visto que tais componentes irão funcionar também no Lazarus.&lt;/p&gt;

&lt;p&gt;Sendo a TMS &lt;em&gt;referência&lt;/em&gt; em componentes desde a primeira versão do Delphi, é de se esperar que esse será mais um grande sucesso.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;preview&lt;/em&gt; da tecnologia exposto na palestra foi excelente e motivador.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Para uma linguagem que muitos consideram “morta”, ter um Transpiler de Object Pascal para JavaScript é um grande impulso para por a linguagem (novamente) nos “trilhos do mercado”.&lt;/p&gt;

&lt;p&gt;Sabemos que hoje em dia muitas empresas optam por desenvolver soluções 100% online, via &lt;em&gt;browser&lt;/em&gt;, ao invés de aplicações Desktop.&lt;/p&gt;

&lt;p&gt;Com o Pas2JS será possível termos uma &lt;em&gt;única&lt;/em&gt; base de código Object Pascal — uma linguagem fortemente tipada, limpa e de fácil aprendizagem — onde poderemos utilizar todo o nosso conhecimento da linguagem, da RTL e componentes, para provermos aplicações 100% Web. Confiáveis, rápidas e de fácil manutenção.&lt;/p&gt;

&lt;p&gt;É esperar, pra ver.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/pas2js</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/pas2js</guid>
      </item>
    
      <item>
        <title>Mais Performance usando Argumentos &quot;const&quot; para Interfaces</title>
        <description>&lt;p&gt;Se você utiliza instâncias de Interfaces em todos os lugares e quer aumentar um pouco a performance do seu código, leia esse artigo.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-alex-holyoake-334209.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Alex Holyoake on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Em um código verdadeiramente Orientado a Objetos, as instâncias dos Objetos devem ser do tipo Interface em &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;todos os lugares&lt;/a&gt; do código.&lt;/p&gt;

&lt;p&gt;Além de prover um contrato entre os Objetos, as instâncias de Interfaces são auto-gerenciadas, ou seja, a memória é liberada automaticamente pelo compilador.&lt;/p&gt;

&lt;p&gt;No Free Pascal, no entanto, podemos ter instâncias de Interfaces que não são auto-gerenciadas. Essas interfaces utilizam o modelo &lt;a href=&quot;https://www.freepascal.org/docs-html/prog/progsu37.html&quot;&gt;CORBA&lt;/a&gt; com a directiva &lt;code&gt;{$interfaces corba}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Porém, o &lt;em&gt;default&lt;/em&gt; de uso de Interfaces é o modelo COM, com auto-gerenciamento de memória através de um contador interno de referências à instância.&lt;/p&gt;

&lt;p&gt;Esse auto-gerenciamento tem um custo computacional de execução, mas pode ser extremamente minimizado com apenas uma pequena alteração no código.&lt;/p&gt;

&lt;p&gt;Entretanto, para você entender como essa pequena alteração irá afetar a performance do seu código, antes você precisa saber como o compilador faz o auto-gerenciamento de memória de instâncias de Interfaces.&lt;/p&gt;

&lt;h2 id=&quot;metodos-especiais&quot;&gt;Métodos Especiais&lt;/h2&gt;

&lt;p&gt;Todo Objeto que implementa uma Interface COM — &lt;code&gt;IUnknown&lt;/code&gt; — deve implementar 3 Métodos especiais que não fazem parte da Interface.&lt;/p&gt;

&lt;p&gt;Funciona assim:&lt;/p&gt;

&lt;p&gt;Quando criamos uma instância do tipo Interface, o compilador irá chamar um método especial do Objeto chamado &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown._addref.html&quot;&gt;_AddRef&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse método irá aumentar uma contagem de referência, toda vez que uma nova variável receber a mesma instância do Objeto.&lt;/p&gt;

&lt;p&gt;Da mesma forma, toda vez que uma variável sair do escopo de execução, o compilador irá chamar o método &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown._release.html&quot;&gt;_Release&lt;/a&gt; para decrementar a contagem.&lt;/p&gt;

&lt;p&gt;Quando a contagem de referência — o atributo &lt;code&gt;FRefCount: LongInt&lt;/code&gt; — chegar a zero, o destrutor do Objeto será executado e a memória será liberada.&lt;/p&gt;

&lt;p&gt;Esse mecanismo é muito, muito mais simples do que ter um &lt;em&gt;garbage collector&lt;/em&gt; sendo executado em paralelo, como é feito em outras linguagens.&lt;/p&gt;

&lt;p&gt;Existe mais um terceiro e último método chamado &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/system/iunknown.queryinterface.html&quot;&gt;QueryInterface&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse método é utilizado quando fazemos &lt;a href=&quot;/posts/nao-utilize-casting/&quot;&gt;&lt;em&gt;casting&lt;/em&gt;&lt;/a&gt; do Objeto para Interface utilizando a estrutura &lt;code&gt;Intf := Obj as IMyInterface;&lt;/code&gt; ou quando utilizamos a função &lt;a href=&quot;https://www.freepascal.org/docs-html/rtl/sysutils/supports.html&quot;&gt;Supports&lt;/a&gt; para determinar se uma instância implementa ou não uma determinada Interface.&lt;/p&gt;

&lt;p&gt;Todas as Classes que implementam uma ou mais Interfaces, devem ter esses 3 métodos implementados.&lt;/p&gt;

&lt;p&gt;Esse é o motivo de herdarmos quase todas as nossas Classes de &lt;code&gt;TInterfacedObject&lt;/code&gt;, pois ela já contém a implementação destes métodos para lidar com a contagem de referência.&lt;/p&gt;

&lt;p&gt;Implementamos esses métodos apenas para o compilador e é possível sabermos o momento no qual o compilador irá chamá-los, sobrecarregando o código com execuções além da implementação padrão dos Métodos do Objeto.&lt;/p&gt;

&lt;p&gt;Então, se conseguirmos evitar tais chamadas, nosso código terá mais performance pois ciclos de CPU serão poupados.&lt;/p&gt;

&lt;h2 id=&quot;sobrecarga&quot;&gt;Sobrecarga&lt;/h2&gt;

&lt;p&gt;Devido as chamadas automáticas de &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; em toda atribuição e saída de escopo das variáveis, muitos desenvolvedores acham que essa é uma &lt;em&gt;grande&lt;/em&gt; sobrecarga para o código.&lt;/p&gt;

&lt;p&gt;Na Engenharia nada é grátis, havendo sempre prós e contras.&lt;/p&gt;

&lt;p&gt;Se por um lado temos o auto-gerenciamento de memória para instâncias de Interfaces, por outro temos essa sobrecarga do incremento e decremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;Além disso, toda vez que &lt;code&gt;_Release&lt;/code&gt; for chamado, haverá uma checagem para saber se a contagem chegou a zero para que o destrutor do Objeto também seja chamado.&lt;/p&gt;

&lt;p&gt;Eu acredito que essa é uma sobrecarga &lt;em&gt;mínima&lt;/em&gt;, considerando todas as &lt;em&gt;vantagens&lt;/em&gt; que temos ao utilizar instâncias de Interfaces.&lt;/p&gt;

&lt;p&gt;Mas nem todos os desenvolvedores pensam da mesma forma.&lt;/p&gt;

&lt;p&gt;De fato, existem algoritmos que não podem se dar o luxo de perder ciclos de CPU fazendo operações de infraestrutura da linguagem — incremento/decremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;Entretanto, a linguagem Object Pascal nos dá uma “saída” bastante elegante para a diminuição de toda essa sobrecarga.&lt;/p&gt;

&lt;h2 id=&quot;argumentos-const&quot;&gt;Argumentos “const”&lt;/h2&gt;

&lt;p&gt;Sempre que uma instância for passada por parâmetro a outro Objeto através de um argumento, haverá o incremento da contagem de referência.&lt;/p&gt;

&lt;p&gt;A menos que você utilize Argumentos “const”.&lt;/p&gt;

&lt;p&gt;Vamos chamá-los de “&lt;em&gt;ConstArgs&lt;/em&gt;”, para encurtar.&lt;/p&gt;

&lt;p&gt;Aqui está a definição, em tradução livre, de &lt;a href=&quot;https://www.freepascal.org/docs-html/ref/refsu67.html&quot;&gt;const&lt;/a&gt; na documentação do Free Pascal:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Especificar um parâmetro como Constante está dando ao compilador uma dica de que o conteúdo do parâmetro não será alterado pela rotina chamada. Isso permite que o compilador execute otimizações que não poderia fazer de outra forma, e também para executar determinadas verificações no código dentro da rotina: ou seja, pode proibir atribuições ao parâmetro. Além disso, um parâmetro const não pode ser transmitido para outra função que requer um parâmetro variável: o compilador pode verificar isso também. O principal uso para isso é reduzir o tamanho da pilha, portanto, melhorar o desempenho e ainda manter a semântica de passagem por valor…”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Eles não falam nada sobre utilizar “const” para argumentos do tipo Interface, no entanto eu posso lhe afirmar que utilizá-los irá aumentar a performance do seu código.&lt;/p&gt;

&lt;p&gt;O motivo é simples: &lt;em&gt;ConstArgs&lt;/em&gt; não executam &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Isso quer dizer que o incremento/decremento do atributo de contagem de referência não irão ocorrer.&lt;/p&gt;

&lt;p&gt;A checagem se o contador interno chegou a zero também não irá existir no ASSEMBLY final gerado pelo compilador.&lt;/p&gt;

&lt;p&gt;Vou demostrar isso, começando com a unidade base de todos os exemplos:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/d7583833ddaf07df796321c95ee8faa8.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A &lt;code&gt;Unit1&lt;/code&gt; contém uma Interface e uma Classe que a implementa.&lt;/p&gt;

&lt;p&gt;Os Métodos &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram sobrescritos para termos o controle do que ocorre dentro deles quando o compilador chamá-los.&lt;/p&gt;

&lt;p&gt;Então vamos criar o primeiro programa de teste que utiliza a &lt;code&gt;Unit1&lt;/code&gt;:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/ac9932e2b0e5a3525fdf05223051d5c9.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Esse é um programa &lt;em&gt;CLI&lt;/em&gt; (&lt;em&gt;command-line&lt;/em&gt;) bem simples.&lt;/p&gt;

&lt;p&gt;É necessário setar a utilização do &lt;a href=&quot;http://wiki.freepascal.org/heaptrc&quot;&gt;&lt;em&gt;heaptrc&lt;/em&gt;&lt;/a&gt; no Lazarus para mostrar os vazamentos de memória (se houver) no final da execução do programa.&lt;/p&gt;

&lt;p&gt;Então, após a execução, no meu laptop a saída foi essa:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
_AddRef called
RefCount is 1
_AddRef called
RefCount is 2
Acting...
_Release called
_Release called
RefCount is 0
Destroing...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
64 memory blocks freed     : 1593/1720
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A execução foi bem sucedida, e não contém vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Porém, veja que &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram, ambos, chamados 2 vezes cada. Isso ocorre por quê, ao criar a instância em &lt;code&gt;A&lt;/code&gt;, há o incremento e ao passar essa instância para &lt;code&gt;Execute&lt;/code&gt;, há um novo incremento da contagem.&lt;/p&gt;

&lt;p&gt;Agora apenas altere a assinatura do procedimento, adicionando &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure Execute(const A: IAction);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute novamente.&lt;/p&gt;

&lt;p&gt;Esse é o resultado por aqui:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
_AddRef called
RefCount is 1
Acting...
_Release called
RefCount is 0
Destroing...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
64 memory blocks freed     : 1593/1720
0 unfreed memory blocks : 0
True heap size : 196608 (80 used in System startup)
True free heap : 196528
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A mesma memória foi consumida, mas &lt;code&gt;_AddRef&lt;/code&gt; e &lt;code&gt;_Release&lt;/code&gt; foram chamados apenas 1 vez cada.&lt;/p&gt;

&lt;p&gt;Isso se traduz em &lt;em&gt;mais&lt;/em&gt; performance ou &lt;em&gt;menos&lt;/em&gt; sobrecarga, dependendo do seu ponto de vista.&lt;/p&gt;

&lt;p&gt;Imagine se esse mesmo procedimento fosse chamado 100 vezes. Sem o “const” haveria mais de 100 chamadas aos Métodos especiais.&lt;/p&gt;

&lt;p&gt;Mas, se é tão simples eliminar essa sobrecarga apenas especificando o tipo do argumento, por quê nem todos os desenvolvedores utilizam essa técnica?&lt;/p&gt;

&lt;p&gt;Talvez seja apenas falta de conhecimento ou talvez eles tenham lido sobre problemas obscuros de vazamento de memória com o uso de &lt;em&gt;ConstArgs&lt;/em&gt; e Interfaces.&lt;/p&gt;

&lt;h2 id=&quot;problemas&quot;&gt;Argumentos e Interfaces&lt;/h2&gt;

&lt;p&gt;Há alguns artigos na Internet dizendo que temos que ter &lt;a href=&quot;https://pascal.today/2016/12/16/take-care-of-const-and-interface-parameters/&quot;&gt;cuidado&lt;/a&gt; ao utilizarmos &lt;em&gt;ConstArgs&lt;/em&gt; em conjunto com instâncias de Interfaces.&lt;/p&gt;

&lt;p&gt;Sim, &lt;em&gt;devemos&lt;/em&gt; ter cuidado.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O código realmente pode ficar intrincado e vazamentos de memória podem ocorrer&lt;/strong&gt; em lugares onde tudo parece estar correto.&lt;/p&gt;

&lt;p&gt;Para demonstrar vamos a outro exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/979c82ffe9288ec129b5792cfef0d9b0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;É o mesmo programa anterior, porém agora a instância de &lt;code&gt;TAction&lt;/code&gt; é criada “inline”.&lt;/p&gt;

&lt;p&gt;Após executar, esse é o resultado por aqui:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:\temp&amp;gt;project1.exe
Acting...
Heap dump by heaptrc unit
64 memory blocks allocated : 1593/1720
63 memory blocks freed     : 1577/1704
1 unfreed memory blocks : 16
True heap size : 229376 (80 used in System startup)
True free heap : 229200
Should be : 229216
Call trace for block $01872E88 size 16
  $004015C7  main,  line 14 of C:/temp/project1.lpr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que os Métodos especiais não foram executados e há um vazamento de memória, o que não é nada bom.&lt;/p&gt;

&lt;p&gt;Mas se você retirar o “const” do procedimento, o vazamento é corrigido.&lt;/p&gt;

&lt;p&gt;Se o argumento não for um &lt;em&gt;ConstArgs&lt;/em&gt; ele poderá incrementar a contagem e não haverá vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Por isso há o mito de que “não devemos utilizar &lt;em&gt;ConstArgs&lt;/em&gt; com Interfaces” ou que devemos evitar seu uso.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Felizmente a solução para toda essa complexidade é muito simples&lt;/strong&gt;, bastando utilizar uma técnica que eu publiquei a quase dois anos atrás, na qual eu chamo de &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Altere &lt;code&gt;TAction&lt;/code&gt; adicionando o Método &lt;code&gt;New&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TAction = class(TInterfacedObject, IAction)
public
  class function New: IAction;
  // ...
end;

implementation

class function TAction.New: IAction;
begin
  Result := Create;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Altere também o programa, dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
  Execute(TAction.New);
end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute e veja o resultado você mesmo.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Se você criar suas instâncias utilizando &lt;code&gt;New&lt;/code&gt; — um método da Classe — ao invés de chamar diretamente os &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt;, eu lhe asseguro que você não terá problemas de vazamento de memória, se a utilizar corretamente.&lt;/p&gt;

&lt;p&gt;Vimos nesse artigo que uma simples mudança no código pode gerar um ganho considerável de performance.&lt;/p&gt;

&lt;p&gt;Utilizando &lt;em&gt;ConstArgs&lt;/em&gt; em conjunto com a técnica chamada &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;, você poderá deixar seu código mais rápido e sem vazamentos de memória.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Dec 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/argumentos-const</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/argumentos-const</guid>
      </item>
    
      <item>
        <title>Herança de Formulário é para Iniciantes</title>
        <description>&lt;p&gt;Depois que você aprendeu como funciona a Herança de Formulários, pode esquecê-la.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-ken-treloar-346065.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Ken Treloar on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No início da minha carreira, a muitos anos atrás, alguém me mostrou a Herança de Formulário no Delphi.&lt;/p&gt;

&lt;p&gt;Mesmo em &lt;em&gt;design time&lt;/em&gt;, dois Formulários herdados estavam “sincronizados”.&lt;/p&gt;

&lt;p&gt;Ao alterar um componente de lugar (&lt;em&gt;Top&lt;/em&gt; / &lt;em&gt;Left&lt;/em&gt;) no Formulário 1, automaticamente também era alterado no outro Formulário 2 devido a Herança entre eles.&lt;/p&gt;

&lt;p&gt;E na época eu pensei: UAU!&lt;/p&gt;

&lt;p&gt;Como era rápido fazer um Formulário (simplório) de CRUD. Basta herdar e setar algumas propriedades e sobrescrever alguns Métodos.&lt;/p&gt;

&lt;p&gt;Acredito que essa é uma das &lt;em&gt;features&lt;/em&gt; mais utilizadas hoje em dia.&lt;/p&gt;

&lt;p&gt;Mas, o que tem de errado com isso?&lt;/p&gt;

&lt;h2 id=&quot;problemas&quot;&gt;Problemas&lt;/h2&gt;

&lt;p&gt;Utilizar Herança de Formulário é bom apenas para os &lt;em&gt;iniciantes&lt;/em&gt; na programação Orientada a Objetos e para o uso &lt;em&gt;superficial&lt;/em&gt; do Delphi ou Lazarus.&lt;/p&gt;

&lt;p&gt;Pode ser considerado “Ok” para criar aplicações de exemplo, ensinar sobre &lt;del&gt;como não utilizar&lt;/del&gt; a Herança simplificada e… talvez, apenas isso.&lt;/p&gt;

&lt;p&gt;Para aplicações realmente importantes, sugiro esquecer a Herança de Formulário por completo.&lt;/p&gt;

&lt;p&gt;Enquanto a &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;Herança de Classes é um mal&lt;/a&gt; que pode ser gerenciado ou mesmo utilizado de forma mais &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/&quot;&gt;apropriada&lt;/a&gt;, a Herança de Formulário acaba com todos os conceitos da verdadeira &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; é perdido&lt;/strong&gt; quando utilizamos Herança de Formulários, pois o desenvolvedor precisa ter conhecimento do comportamento interno do formulário-pai afim de conseguir fazer algo de útil no formulário-filho.&lt;/p&gt;

&lt;p&gt;Muitas vezes encontramos formulários contendo apenas Métodos protegidos ou &lt;a href=&quot;/posts/metodos-privados/&quot;&gt;privados&lt;/a&gt; sem nenhum comportamento público; eles vem do formulário-pai. E isso é muito estranho. Por quê teríamos uma Classe (Form) que, a primeira vista, não tem nenhum comportamento para o mundo externo?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A ordem de execução dos Métodos protegidos&lt;/strong&gt; que devem ser sobrescritos, devem ser de conhecimento do desenvolvedor, mais uma vez quebrando o encapsulamento.&lt;/p&gt;

&lt;p&gt;É necessário visualizar o código do formulário-pai afim de saber onde e em que momento tais métodos abstratos e protegidos são utilizados.&lt;/p&gt;

&lt;p&gt;É comum ver métodos sobrescritos que não chamam o Método herdado, “matando” o comportamento padrão da Classe ancestral quando o Método não é abstrato.&lt;/p&gt;

&lt;p&gt;Pedaços de código serão duplicados pois estão em métodos não acessíveis nos formulários-filhos.&lt;/p&gt;

&lt;p&gt;Uma bagunça.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Componentes herdados não podem ser excluídos&lt;/strong&gt;, o que resulta em mais bagunça e “código espaguete”.&lt;/p&gt;

&lt;p&gt;Como não é possível excluir componentes em formulários-filho, o desenvolvedor tem que habilitar/desabilitar ou torná-los visível/não-visível. No entanto tais componentes continuarão a serem criados no formulário…&lt;/p&gt;

&lt;p&gt;Criar formulários com componentes que não serão utilizados é realmente um desperdício de memória RAM.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Qualquer alteração no formulário-pai irá refletir nos formulários-filhos&lt;/strong&gt;, e isso quer dizer que você pode quebrar o sistema inteiro com pequenas modificações.&lt;/p&gt;

&lt;p&gt;Você poderia argumentar que mesmo se não utilizasse Herança, mas sim Composição de Objetos, um Objeto que fosse reaproveitado por todo o sistema também poderia quebrá-lo caso algo fosse indevidamente alterado no seu código.&lt;/p&gt;

&lt;p&gt;Correto. Mas a grande diferença é que é muito mais fácil alterar um código de apenas uma Classe &lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/&quot;&gt;pequena&lt;/a&gt; e sem dependências externas ou heranças de Classes-filhas, do que um código de Formulário onde toda lógica está contido nele além de ter a preocupação se alguma alteração irá impactar negativamente nos nos formulários-filhos.&lt;/p&gt;

&lt;h2 id=&quot;solucoes&quot;&gt;Soluções&lt;/h2&gt;

&lt;p&gt;Vejamos então algumas opções para a completa substituição da Herança de Formulário, utilizando outras técnicas mais Orientadas a Objetos, &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e limpas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Composição e &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração&lt;/a&gt; de Objetos&lt;/strong&gt; são as opções mais simples e corretas para substituir praticamente qualquer tipo de Herança.&lt;/p&gt;

&lt;p&gt;Você pode criar Classes intermediárias ou &lt;a href=&quot;/posts/classes-adaptadoras/&quot;&gt;adaptadoras&lt;/a&gt; que se comunicam entre si para instanciar Formulários complexos.&lt;/p&gt;

&lt;p&gt;Com o uso de pequenas Classes utilizadas como “interface de acesso” aos Formulários, você consegue instanciá-los, desacoplá-los entre si, instanciar &lt;em&gt;Frames&lt;/em&gt;, ler e escrever dados em componentes. Tudo em &lt;em&gt;runtime&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O uso de &lt;em&gt;Frames&lt;/em&gt; é uma ótima opção&lt;/strong&gt; para o uso de composição visual, visto que são mini-formulários embutidos em outros Formulários.&lt;/p&gt;

&lt;p&gt;Pense em como são construídas as páginas de um website. Não há herança, apenas &lt;em&gt;includes&lt;/em&gt; de “pedaços de código”: &lt;em&gt;Header&lt;/em&gt;, &lt;em&gt;Footer&lt;/em&gt;, &lt;em&gt;JavaScript&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Você pode utilizar o mesmo pensamento para o uso de &lt;em&gt;Frames&lt;/em&gt;. Pode criar um &lt;em&gt;Frame&lt;/em&gt; apenas com os botões de CRUD; outro com &lt;em&gt;Grids&lt;/em&gt;; outro para o &lt;em&gt;footer&lt;/em&gt; de todo formulário.&lt;/p&gt;

&lt;p&gt;Eu utilizo &lt;em&gt;Frames&lt;/em&gt; até mesmo sem pensar na reutilização…&lt;/p&gt;

&lt;p&gt;Explico. Imagine um Formulário com algumas abas utilizando um &lt;a href=&quot;http://wiki.lazarus.freepascal.org/TPageControl&quot;&gt;TPageControl&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Bem, não podemos ter nomes de componentes iguais num único Formulário, ou seja, se você definiu que um &lt;code&gt;TEdit&lt;/code&gt; se chama &lt;code&gt;NameEdit&lt;/code&gt; na aba 1, você não pode nomear outro &lt;code&gt;TEdit&lt;/code&gt; com o mesmo nome na aba 2, pois ambos pertencem ao mesmo Formulário.&lt;/p&gt;

&lt;p&gt;Você precisa acrescentar mais prefixos/sufixos na &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/&quot;&gt;nomenclatura&lt;/a&gt; e isso torna o código mais verboso e confuso, além do fato de que seu Formulário terá que lidar com todos os componentes de uma só vez.&lt;/p&gt;

&lt;p&gt;Em meus projetos, uma aba pode conter a instância de um &lt;em&gt;Frame&lt;/em&gt;, caso haja ações diferentes em cada aba.&lt;/p&gt;

&lt;p&gt;Por exemplo, se eu precisar adicionar uma barra de botões (ações) na aba 2, então essa aba será um &lt;em&gt;Frame&lt;/em&gt; com sua própria implementação, componentes de nomenclatura simples e ações específicas.&lt;/p&gt;

&lt;p&gt;Dentro de um &lt;em&gt;Frame&lt;/em&gt; eu não preciso me preocupar em lidar com um único código inchado que lida com todos os &lt;em&gt;widgets&lt;/em&gt; dentro de um Formulário.&lt;/p&gt;

&lt;p&gt;E se um &lt;em&gt;Frame&lt;/em&gt; precisar notificar o Formulário principal, isso pode ser feito através de &lt;a href=&quot;/eventos-e-objetos&quot;&gt;Eventos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Criar Componentes no Delphi/Lazarus é tão fácil&lt;/strong&gt; que se você precisar utilizar muito um comportamento, pode ser uma boa ideia criar um novo componente e disponibilizá-lo na IDE.&lt;/p&gt;

&lt;p&gt;Já vi muito isso em empresas, onde existem componentes genéricos que podem ser utilizados por qualquer sistema, mas também componentes específicos por projeto.&lt;/p&gt;

&lt;p&gt;Entretanto, apesar de manter um padrão de uso de componentes por toda a equipe, pode ser difícil manter todas as IDE’s do Delphi atualizadas após um novo &lt;em&gt;release&lt;/em&gt; desses componentes — no Lazarus essa tarefa seria mais fácil devido sua “não-instalação” e componentes “registrados” em apenas 1 arquivo XML, no entanto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O objetivo do artigo não é depreciar desenvolvedores que ainda utilizam Herança de Formulários, mas sim apresentar técnicas muito mais eficazes de construção, visando a manutenibilidade do código no longo prazo.&lt;/p&gt;

&lt;p&gt;Eu mesmo ainda trabalho em alguns projetos totalmente baseado em Herança de Formulários. Nesses projetos eu sou &lt;em&gt;obrigado&lt;/em&gt; a utilizar herança pois todo o &lt;em&gt;framework&lt;/em&gt; funciona a partir de alguns formulários base. No entanto, esses projetos estão longe de ter um código ideal.&lt;/p&gt;

&lt;p&gt;Mantenha seus projetos atuais, mas repense o uso de Herança de Formulários em projetos futuros.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/heranca-de-formulario-e-para-iniciantes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/heranca-de-formulario-e-para-iniciantes</guid>
      </item>
    
      <item>
        <title>Eliminando Métodos Privados</title>
        <description>&lt;p&gt;A utilização de Métodos Privados é um erro comum no &lt;em&gt;design&lt;/em&gt; do código.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-james-sutton-187816.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by James Sutton on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“Existe um pensamento que diz que todo Método Privado deveria ser, na verdade, a implementação de outro Objeto”&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu escrevi esse texto acima em outro &lt;a href=&quot;/posts/metodos-privados/&quot;&gt;artigo&lt;/a&gt; aqui no blog… e eu acho que faz muito sentido.&lt;/p&gt;

&lt;p&gt;No entanto, o artigo tentou demonstrar que os Métodos Privados não representam um mal no código e que podemos conviver com eles pacificamente.&lt;/p&gt;

&lt;p&gt;É verdade que eles não representam um &lt;em&gt;grande&lt;/em&gt; mal ao projeto. Existem tantos outros males &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;piores&lt;/a&gt; para nos preocuparmos no dia-a-dia que não damos muita importância aos Métodos Privados.&lt;/p&gt;

&lt;p&gt;Eu mesmo venho utilizando-os em meus projetos à muitos anos — tanto que já escrevi um artigo defendendo-os.&lt;/p&gt;

&lt;p&gt;Mas, toda vez que eu codifico um Método Privado eu tenho a sensação de que alguma coisa está &lt;em&gt;errada&lt;/em&gt;, mesmo quando eles &lt;em&gt;facilitam&lt;/em&gt; a minha vida.&lt;/p&gt;

&lt;h2 id=&quot;metodos-privados&quot;&gt;Métodos Privados&lt;/h2&gt;

&lt;p&gt;Você provavelmente sabe que Métodos Privados são utilizados somente pela Classe na qual eles foram implementados e nenhum Objeto externo tem acesso à eles.&lt;/p&gt;

&lt;p&gt;Praticamente, toda linguagem que suporta o paradigma da &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt; tem uma sintaxe para a codificação de Métodos Privados.&lt;/p&gt;

&lt;p&gt;É de uso comum.&lt;/p&gt;

&lt;p&gt;Todos nós utilizamos, diariamente.&lt;/p&gt;

&lt;p&gt;Mas, em teoria, a interface de um Objeto — seus Métodos Públicos — deveria ser suficiente para ele exercer o trabalho que lhe foi designado.&lt;/p&gt;

&lt;p&gt;Se o trabalho é complexo e o Objeto necessitar de “ajuda”, ele deveria delegar à outros Objetos e &lt;em&gt;não&lt;/em&gt; tentar fazer tudo “sozinho” utilizando Métodos Privados.&lt;/p&gt;

&lt;p&gt;No entanto, as linguagens dão suporte para escrevê-los.&lt;/p&gt;

&lt;p&gt;As linguagens diferenciam Métodos privados, protegidos e públicos.&lt;/p&gt;

&lt;p&gt;Então, entendemos que era correto utilizá-los e estamos fazendo isso desde então.&lt;/p&gt;

&lt;p&gt;Entretanto, se por um lado os Métodos Privados não representam um grande mal, por outro eles também não são o &lt;em&gt;ideal&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;facilitadores&quot;&gt;Facilitadores&lt;/h2&gt;

&lt;p&gt;Métodos Privados são apenas &lt;em&gt;facilitadores&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Eles são utilizados do mesmo jeito que a maioria das pessoas utilizam, por exemplo, a fita &lt;a href=&quot;https://pt.wikipedia.org/wiki/Silver_Tape&quot;&gt;Silver Tape®&lt;/a&gt;, ou seja, como uma &lt;em&gt;solução alternativa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se algo quebrou no seu carro durante uma viagem (uma mangueira arrebentou, algo rachou, vazamentos, etc) e você não tem tempo para fazer um reparo perfeito ou as ferramentas apropriadas, você improvisa.&lt;/p&gt;

&lt;p&gt;Você pode utilizar uma fita para manter as coisas no lugar na esperança de que, no futuro, você possa fazer o reparo do jeito correto.&lt;/p&gt;

&lt;p&gt;Infelizmente podemos nos esquecer desses reparos temporários e seguir adiante, já que a “solução alternativa” continua mantendo tudo funcionando “perfeitamente” — como a mangueira de esguicho de água do para-brisa do meu carro que rachou e está com uma fita a mais de 2 anos.&lt;/p&gt;

&lt;p&gt;Um Método Privado é algo localizado e sem muita importância por que está encapsulado numa Classe e pode ser alterado a qualquer momento (em teoria) sem efeitos colaterais.&lt;/p&gt;

&lt;p&gt;Eu utilizo pouco o esguicho de água do para-brisa e mesmo assim ele continua funcionando mas, mesmo se parar de funcionar, não vai por minha vida em risco… teoricamente. Não haverá efeitos colaterais se eu fizer o conserto agora ou mais tarde.&lt;/p&gt;

&lt;p&gt;Nota: Não me entenda mal. Eu faço a manutenção do meu carro quase que religiosamente, mas a prioridade sempre será o motor, fluídos e suspensão.&lt;/p&gt;

&lt;p&gt;Projetos de Software também tem prioridades nos dizendo para não “perder tempo” codificando outras Classes, quando é mais &lt;em&gt;rápido&lt;/em&gt; codificar Métodos Privados e resolver o problema da maneira mais “fácil”.&lt;/p&gt;

&lt;p&gt;Entretanto, sabemos que “mais fácil” não combina com &lt;em&gt;sustentabilidade&lt;/em&gt; no longo prazo.&lt;/p&gt;

&lt;h2 id=&quot;motivos&quot;&gt;Motivos&lt;/h2&gt;

&lt;p&gt;Há 9 meses atrás houve uma &lt;a href=&quot;http://objectpascalprogramming.com/posts/metodos-privados/#comment-3127567762&quot;&gt;discussão&lt;/a&gt; na área de comentários do blog sobre utilizar ou não Métodos Privados.&lt;/p&gt;

&lt;p&gt;Num dos comentários eu escrevi:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Minha opinião é que, como são Privados, não há nenhum impacto direto no código. Sempre posso modificá-los a qualquer momento.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;E isso é, de fato, verdade.&lt;/p&gt;

&lt;p&gt;Se algo é privado a Classe, você pode modificá-lo sem haver impactos externos, na teoria. Faz parte do conceito de &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; de toda linguagem OO. Se é privado, somente a Classe tem acesso — sem levar em conta algo chamado &lt;em&gt;Reflexion&lt;/em&gt; ou RTTI.&lt;/p&gt;

&lt;p&gt;Então, quais seriam os motivos para deixar de utilizar Métodos Privados?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ao introduzir Métodos Privados, você pode estar codificando de forma procedural ao invés de Orientada a Objetos.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Você pode estar introduzindo &lt;em&gt;funções procedurais&lt;/em&gt; ao invés de Métodos que implementam o comportamento da &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidade&lt;/a&gt; representada.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/bbdc509810890ea5724a94a021f16791.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Na Classe acima, o método &lt;code&gt;CleanName&lt;/code&gt; é apenas uma &lt;em&gt;função utilitária&lt;/em&gt;. A função não pertence ao contexto representado por um &lt;code&gt;Employee&lt;/code&gt; e por isso eu não a considero como um Método do Objeto.&lt;/p&gt;

&lt;p&gt;Um &lt;code&gt;Employee&lt;/code&gt; não “limpa” o próprio nome.&lt;/p&gt;

&lt;p&gt;Essa é a tendência ao utilizarmos Métodos Privados: Adicionar funções utilitárias, por quê é fácil, conveniente e “ninguém está vendo”.&lt;/p&gt;

&lt;p&gt;Os nomes dessas funções também tem a tendência de serem &lt;a href=&quot;/posts/nomeando-variaveis-e-metodos/#metodos&quot;&gt;nomes compostos&lt;/a&gt; que é mais um &lt;em&gt;indício&lt;/em&gt; mostrando que a função pode pertencer a &lt;em&gt;outro&lt;/em&gt; contexto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Métodos Privados também podem gerar &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/&quot;&gt;duplicação de código&lt;/a&gt;, escondendo &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamentos&lt;/a&gt; que poderiam ser compartilhados entre os Objetos mas, como são privados, não podem reutilizados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Veja mais um exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/a303d0bf83930fcf580aee818ee23a52.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O Método &lt;code&gt;SplitName&lt;/code&gt; — também um função utilitária — acima poderia ser reutilizado por outra Classe que também encapsula uma instância de &lt;code&gt;IName&lt;/code&gt;. Mas aqui a Classe &lt;code&gt;TEmployeeName&lt;/code&gt; tem sua própria implementação privada, não havendo outra maneira de reutilizar o mesmo algoritmo fora da Classe.&lt;/p&gt;

&lt;p&gt;Em outras palavras, caso você precisasse utilizar o mesmo algoritmo implementado em &lt;code&gt;SplitName&lt;/code&gt;, você teria que fazer uma cópia.&lt;/p&gt;

&lt;p&gt;Acredito que estes podem ser bons motivos para eliminarmos os Métodos Privados dos nossos projetos desde o início ou quando for possível fazer a refatoração.&lt;/p&gt;

&lt;h2 id=&quot;eliminando&quot;&gt;Eliminando&lt;/h2&gt;

&lt;p&gt;Acredito que podemos remover quaisquer Métodos Privados utilizando apenas Classes.&lt;/p&gt;

&lt;p&gt;As Classes podem ser &lt;em&gt;públicas&lt;/em&gt; (disponível a todo o sistema) e/ou &lt;a href=&quot;/classes-aninhadas&quot;&gt;Aninhadas&lt;/a&gt; a outras Classes.&lt;/p&gt;

&lt;p&gt;Talvez os exemplos acima podem não ter convencido você.&lt;/p&gt;

&lt;p&gt;Você poderia dizer que haverá casos em que os Métodos Privados fazem, sim, parte do mesmo contexto e por isso deveriam &lt;em&gt;existir&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por exemplo.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/8afe1f70a803556a59513fb2dff36e21.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;A Classe &lt;code&gt;THttpClient&lt;/code&gt; não está completa, mas a parte que falta é irrelevante.&lt;/p&gt;

&lt;p&gt;Veja que há o Método &lt;code&gt;Send&lt;/code&gt; que é utilizado em 2 outros Métodos: &lt;code&gt;Get&lt;/code&gt; e &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, é possível substituir o Método &lt;code&gt;Send&lt;/code&gt; por uma Classe?&lt;/p&gt;

&lt;p&gt;Com certeza.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/3cda576e9e13ac25ee5b4005a3b47a1a.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;E a vantagem de fazer isso é que deixamos a Classe mais simples e compacta, removendo o comportamento privado para uma nova Classe; agora podemos reutilizar o código externamente; se quisermos decorar &lt;code&gt;THttpProtocol&lt;/code&gt; com outras Classes como Log, por exemplo, também podemos.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Após muito ponderar, cheguei a conclusão que prover uma sintaxe para codificar Métodos Privados é um &lt;em&gt;erro&lt;/em&gt; no &lt;em&gt;design&lt;/em&gt; da linguagem. Não só em Object Pascal, mas também em Java, C# e tantas outras.&lt;/p&gt;

&lt;p&gt;Considere, então, que o uso de Métodos Privados foi o primeiro nível de aprendizado para sabermos dividir código dentro de uma Classe, entendê-los e saber como utilizá-los de forma consciente, &lt;em&gt;facilitando&lt;/em&gt; a transição da Programação Procedural para a Orientada a Objetos.&lt;/p&gt;

&lt;p&gt;Sabemos que particularidades da linguagem nos fazem criar Métodos Privados intencionalmente como, por exemplo, Métodos que executam &lt;a href=&quot;/eventos-e-objetos&quot;&gt;eventos&lt;/a&gt; — o Método Privado irá verificar se um evento foi ou não &lt;a href=&quot;/posts/getters-e-setters/#setters&quot;&gt;setado&lt;/a&gt; — e tudo bem se o método é apenas uma implementação de &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#infraestrutura&quot;&gt;infraestrutura&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lembre-se também que, ao criar mais Classes públicas, ao invés de Métodos Privados, haverá mais código para documentar. No entanto, você poderá manter essas Classes “escondidas” do usuário final utilizando o conceito de &lt;a href=&quot;/api-unit&quot;&gt;API Unit&lt;/a&gt;, declarando na API apenas as Classes que você “permite” utilizar.&lt;/p&gt;

&lt;p&gt;Um código final com um mínimo de Métodos Privados pode representar um bom sinal de &lt;em&gt;design&lt;/em&gt; do código, com Classes &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e elegantes.&lt;/p&gt;

&lt;p&gt;Então, não codifique Métodos Privados, a não ser que haja uma real necessidade para fazê-lo. Evite-os.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/eliminando-metodos-privados</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/eliminando-metodos-privados</guid>
      </item>
    
      <item>
        <title>Classes Aninhadas</title>
        <description>&lt;p&gt;As Classes Aninhadas reduzem o número de Classes públicas, melhoram o encapsulamento, o polimorfismo local e a legibilidade do código.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-iorni-321845.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by iorni on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A maneira mais fácil (preguiçosa e errada) de reaproveitar código é utilizando &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse é o início do aprendizado sobre &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Como muito mais tempo, aprendemos que a &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração&lt;/a&gt; e Composição de Objetos é o &lt;em&gt;melhor&lt;/em&gt; caminho para &lt;em&gt;adicionar&lt;/em&gt; e &lt;em&gt;reaproveitar&lt;/em&gt; comportamento, respectivamente.&lt;/p&gt;

&lt;p&gt;Classes Aninhadas tem tudo haver com Decoração e Composição.&lt;/p&gt;

&lt;p&gt;Nesse artigo você irá aprender como utilizar Classes Aninhadas para melhorar o encapsulamento e polimorfismo, acrescentando comportamento específico e localizado, sem o uso de &lt;em&gt;“Class Helpers”&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;classes-aninhadas&quot;&gt;Classes Aninhadas&lt;/h2&gt;

&lt;p&gt;A linguagem Object Pascal, apesar de ser bem antiga, está em constante desenvolvimento.&lt;/p&gt;

&lt;p&gt;Mas, eu sou avesso a grandes mudanças na linguagem. Em qualquer linguagem.&lt;/p&gt;

&lt;p&gt;Também não sou a favor de acrescentar novas &lt;em&gt;features&lt;/em&gt; apenas por quê existem em &lt;em&gt;outras&lt;/em&gt; linguagens.&lt;/p&gt;

&lt;p&gt;Quanto mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; for uma linguagem, mais fácil será o entendimento do código.&lt;/p&gt;

&lt;p&gt;Na minha opinião, ao invés de acrescentar novas &lt;em&gt;features&lt;/em&gt; numa linguagem, os desenvolvedores deviam trabalhar em novas &lt;em&gt;Libraries&lt;/em&gt; que resolvem problemas específicos.&lt;/p&gt;

&lt;p&gt;No entanto, algumas &lt;em&gt;features&lt;/em&gt; realmente podem fazer a diferença, ou seja, tornar o código melhor e mais simples.&lt;/p&gt;

&lt;p&gt;O conceito de Classes Aninhadas é simples: Permitir a declaração de Classes dentro de Classes. Sejam elas privadas ou públicas.&lt;/p&gt;

&lt;p&gt;Veja um exemplo da sintaxe:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/96820c816ffa3e1eb5296a330e3a1cef.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, para declarar uma Classe &lt;code&gt;TBar&lt;/code&gt;, foi necessário fazer a referência a Classe &lt;code&gt;TFoo&lt;/code&gt;, primeiramente.&lt;/p&gt;

&lt;p&gt;Então, &lt;code&gt;TBar&lt;/code&gt; é uma Classe Aninhada em &lt;code&gt;TFoo&lt;/code&gt; ou, em outras palavras, &lt;code&gt;TBar&lt;/code&gt; está encapsulada em &lt;code&gt;TFoo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Acredito que para o compilador, uma Classe Aninhada é apenas outra qualquer. Não há penalidades no código. A primeira Classe da hierarquia &lt;em&gt;não&lt;/em&gt; irá criar Objetos maiores devido as Classes Aninhadas.&lt;/p&gt;

&lt;p&gt;Para nós, desenvolvedores, é apenas um &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;&lt;em&gt;Syntactic sugar&lt;/em&gt;&lt;/a&gt; que parece não valer muito a pena prestar atenção.&lt;/p&gt;

&lt;p&gt;No entanto, para um &lt;em&gt;design&lt;/em&gt; realmente &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt;, esta é uma &lt;em&gt;feature&lt;/em&gt; que proporciona uma &lt;em&gt;grande&lt;/em&gt; melhoria no código.&lt;/p&gt;

&lt;h2 id=&quot;redescobrindo&quot;&gt;Redescobrindo&lt;/h2&gt;

&lt;p&gt;O fato é que não faz tanto tampo que eu descobri que a linguagem Object Pascal tem suporte a Classes Aninhadas. Bem, talvez eu já tenha lido sobre isso já faz alguns anos, mas a verdade é que eu nunca tinha utilizado tal recurso em sistemas reais.&lt;/p&gt;

&lt;p&gt;Há 3 semanas atrás, esse conceito retornou a minha mente após receber um e-mail relacionado a uma nova &lt;em&gt;issue&lt;/em&gt; num sistema privado.&lt;/p&gt;

&lt;p&gt;Eu tinha que fazer uma manutenção no código e um dos requisitos dizia que uma parte do sistema deveria se comportar de maneira ligeiramente diferente da condição atual, mas por um curto período de tempo.&lt;/p&gt;

&lt;p&gt;O motivo era que um segundo sistema estava sendo alterado e, enquanto essa tarefa não estivesse concluída, o primeiro sistema deveria se comportar de acordo com o requisito citado.&lt;/p&gt;

&lt;p&gt;Como o sistema é privado, o requisito real é irrelevante.&lt;/p&gt;

&lt;p&gt;Mas, para que você entenda como as Classes Aninhadas me ajudaram a implementar o requisito de forma simples, clássica e seguindo os &lt;a href=&quot;lista-vip/&quot;&gt;princípios&lt;/a&gt; da Orientação a Objetos, vou apresentar uma forma bem simplificada do que deveria ser alterado no código para a solução da tarefa.&lt;/p&gt;

&lt;h2 id=&quot;problema&quot;&gt;O Problema&lt;/h2&gt;

&lt;p&gt;Imagine que você tenha uma Unit com algumas Classes.&lt;/p&gt;

&lt;p&gt;Essas Classes utilizam outras Classes de outras Units.&lt;/p&gt;

&lt;p&gt;Para implementar o requisito, uma dessas Classes deveria ser alterada. No entanto, a alteração era relacionada com a Composição de outra Classe — na verdade eram outras Classes, no plural, mas vamos manter simples.&lt;/p&gt;

&lt;p&gt;Então temos o seguinte:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A Classe &lt;code&gt;TFoo&lt;/code&gt; é a que temos que alterar. No entanto ela trabalha com uma instância de &lt;code&gt;TBar&lt;/code&gt; internamente — novamente, por motivos de simplificação, vamos esquecer que a instância de &lt;code&gt;TBar&lt;/code&gt; deveria ser &lt;a href=&quot;/injecao-de-dependencia&quot;&gt;injetada&lt;/a&gt; no &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtor&lt;/a&gt; da Classe &lt;code&gt;TFoo&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;A interação entre as Classes &lt;code&gt;TFoo&lt;/code&gt; e &lt;code&gt;TBar&lt;/code&gt; era o que deveria ser alterado para a conclusão do requisito. No entanto, todas as outras Classes pertencentes a mesma Unit de &lt;code&gt;TFoo&lt;/code&gt; deveriam continuar com o mesmo comportamento atual. Em outras palavras, a Classe &lt;code&gt;TBar&lt;/code&gt; deveria ser alterada &lt;em&gt;apenas&lt;/em&gt; na implementação (local) de &lt;code&gt;TFoo&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Temos várias maneiras de implementar isso, é claro.&lt;/p&gt;

&lt;p&gt;Antes, vamos &lt;a href=&quot;/posts/nomeando-unidades/&quot;&gt;nomear&lt;/a&gt; algumas coisas para facilitar o entendimento:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Acme.Foos.Clss&lt;/code&gt; -&amp;gt; é a Unit onde a Classe &lt;code&gt;TFoo&lt;/code&gt; está declarada;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Acme.Bars.Clss&lt;/code&gt; -&amp;gt; é a Unit onde a Classe &lt;code&gt;TBar&lt;/code&gt; está declarada;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Então, para implementar o requisito, nós poderíamos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementar uma nova Classe na Sessão de Interface da &lt;code&gt;Acme.Bars.Clss&lt;/code&gt; chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Implementar uma nova Classe na Sessão de Interface da &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Criar uma nova Unit &lt;code&gt;Acme.Bars.Ex.Clss&lt;/code&gt; e implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Implementação da unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O caminho a ser escolhido é quase infinito, porém essas seriam as opções mais comuns, considerando que não queremos fazer uma refatoração muito grande no código. Será uma alteração temporária, lembra?&lt;/p&gt;

&lt;p&gt;Infelizmente, existem problemas de &lt;em&gt;design&lt;/em&gt; com todas as opções acima.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementar a nova Classe &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Interface de &lt;code&gt;Acme.Bars.Clss&lt;/code&gt; ou &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; irá disponibilizar a nova Classe para todo o sistema. Como é uma Classe temporária, ela não deveria estar disponível… não dessa forma.&lt;/li&gt;
  &lt;li&gt;Criar uma nova Unit &lt;code&gt;Acme.Bars.Ex.Clss&lt;/code&gt; é ainda pior, pois depois de algum tempo a Unit deverá ser removida, havendo mais alterações no código.&lt;/li&gt;
  &lt;li&gt;Por fim, implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Implementação da unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; seria a opção mais viável. No entanto não teria sido um código elegante, pois essa nova Classe seria criada para apenas para um caso específico mas elas estaria disponível para a Unit inteira. Também tem o fato de que a Classe &lt;em&gt;deve&lt;/em&gt; ter um nome diferente (&lt;code&gt;TBar&lt;/code&gt; vs &lt;code&gt;TBarEx&lt;/code&gt;) — esse é um dos motivos de adicionarmos prefixos ou sufixos estranhos — para não haver conflito com todas as instâncias de &lt;code&gt;TBar&lt;/code&gt; que continuam sendo utilizadas por toda a Unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt;. O ideal seria continuar utilizando a nomenclatura &lt;code&gt;TBar&lt;/code&gt;, de acordo com o domínio. Mas, infelizmente, a técnica de &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclaração de Classes&lt;/a&gt; não seria possível, pois só queremos uma &lt;code&gt;TBar&lt;/code&gt; diferente em apenas um lugar na Unit.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Eu não escolhi nenhuma das possíveis soluções acima.&lt;/p&gt;

&lt;h2 id=&quot;solucionando&quot;&gt;A Solução&lt;/h2&gt;

&lt;p&gt;Após pensar por alguns minutos sobre como resolver o requisito, o conceito de Classes Aninhadas retornou a minha mente como a melhor escolha.&lt;/p&gt;

&lt;p&gt;A solução é tão simples que você já a conhece. Está no início desse artigo!&lt;/p&gt;

&lt;p&gt;Vou apenas adicionar mais código para deixar a implementação mais contextualizada:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/b292e33439d9867b2c8c92d8caba4a96.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Agora, em todos os métodos de &lt;code&gt;TFoo&lt;/code&gt; que for preciso decorar instâncias de &lt;code&gt;IBar&lt;/code&gt;, uma Classe de &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nomenclatura&lt;/a&gt; simples e &lt;em&gt;local&lt;/em&gt; poderá ser utilizada sem haver conflito de nomes na Unit.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TFoo&lt;/code&gt; tem sua própria implementação privada de &lt;code&gt;TBar&lt;/code&gt;. Nenhum outro código no sistema poderá utilizar essa implementação.&lt;/p&gt;

&lt;p&gt;É uma solução &lt;em&gt;local&lt;/em&gt;, sem &lt;em&gt;workarounds&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Espero que os exemplos não tenham sido muito abstratos. A ideia foi mostrar o potencial dessa simples &lt;em&gt;feature&lt;/em&gt; sem deixar o artigo muito longo.&lt;/p&gt;

&lt;p&gt;É uma solução simples e bastante elegante. Totalmente de acordo com os princípios da Orientação a Objetos, encapsulamento e polimorfismo.&lt;/p&gt;

&lt;p&gt;A nomenclatura das Classes é simples, mantendo a legibilidade do código.&lt;/p&gt;

&lt;p&gt;A linguagem Object Pascal continua a me surpreender, mesmo após mais de 16 anos que a utilizo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/classes-aninhadas</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/classes-aninhadas</guid>
      </item>
    
  </channel>
</rss>
