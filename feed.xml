<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Linhas em Branco no Método é um Mal Cheiro no Código</title>
        <description>&lt;p&gt;Pular linhas dentro de um Método é um “mal cheiro”
no código. Significa que você está fazendo coisas 
demais num único Método.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1417309807426-472e833fa5d0.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O que significa mal cheiro no código?&lt;/p&gt;

&lt;p&gt;Um &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_smell&quot;&gt;mal cheiro&lt;/a&gt;,
se refere a qualquer sintoma no código-fonte 
de um programa que possivelmente indica um problema 
mais profundo.&lt;/p&gt;

&lt;p&gt;Eu já falei sobre isso
&lt;a href=&quot;/posts/pensando-em-objetos/#exemplo-1&quot;&gt;aqui&lt;/a&gt;
e nesse artigo vou abordar melhor esse assunto.&lt;/p&gt;

&lt;p&gt;Você irá entender porque não devemos utilizar 
linhas em branco dentro de Métodos.&lt;/p&gt;

&lt;h2 id=&quot;blocos-de-cdigo&quot;&gt;Blocos de Código&lt;/h2&gt;

&lt;p&gt;Por que muitos programadores ainda utilizam linhas em
branco dentro de Métodos?&lt;/p&gt;

&lt;p&gt;Simples. Eles estão separando o código de um Método
em blocos. E isso é, errado.&lt;/p&gt;

&lt;p&gt;Eu mesmo fiz isso por anos.&lt;/p&gt;

&lt;p&gt;Algumas vezes eu conseguia enxergar esse mal cheiro, então 
refatorava — criando outros Métodos — e seguia a vida.&lt;/p&gt;

&lt;p&gt;Mas na maioria das vezes eu pensava que estava “organizando o código”.
Tornando mais legível, mas “limpo”… não era verdade.&lt;/p&gt;

&lt;p&gt;Quando li esse
&lt;a href=&quot;http://www.yegor256.com/2014/11/03/empty-line-code-smell.html&quot;&gt;artigo&lt;/a&gt;
eu percebi que sempre houve algo de errado quando eu
utiliza linhas em branco.&lt;/p&gt;

&lt;p&gt;Quando existem linhas em branco dentro do Método,
significa que &lt;strong&gt;o Método está fazendo coisas demais&lt;/strong&gt;.
Um único grande procedimento, separado por com blocos 
de código…&lt;/p&gt;

&lt;p&gt;Desde então eu não codifico mais dessa forma.&lt;/p&gt;

&lt;h2 id=&quot;nao-seja-leviano&quot;&gt;Não basta retirar as Linhas em Branco&lt;/h2&gt;

&lt;p&gt;Você entendeu o problema e agora quer abrir seu editor
e começar a remover as linhas em branco… apenas remover
as linhas.&lt;/p&gt;

&lt;p&gt;Não seja leviano.&lt;/p&gt;

&lt;p&gt;Não basta abrir seu editor e começar a remover toda
linha em branco que encontrar dentro dos Métodos.&lt;/p&gt;

&lt;p&gt;Não!&lt;/p&gt;

&lt;p&gt;A linha em branco não é o problema em si. 
Ela só indica que há um problema.&lt;/p&gt;

&lt;p&gt;Apenas retirar essas linhas não vai sanar o problema.&lt;/p&gt;

&lt;p&gt;O que temos que fazer é &lt;strong&gt;refatorar&lt;/strong&gt; o código,
para depois removê-las.&lt;/p&gt;

&lt;h2 id=&quot;refatorando&quot;&gt;Refatorando&lt;/h2&gt;

&lt;p&gt;Se você realmente entendeu o conceito, não irá mais utilizar
linhas em branco dentro de Métodos de agora em diante.&lt;/p&gt;

&lt;p&gt;Certo?&lt;/p&gt;

&lt;p&gt;Mas você pode ir além. Você pode querer refatorar todo tipo
de código antigo ou fazer uma refatoração &lt;em&gt;on demand&lt;/em&gt;:
Refatorar apenas se encontrar Métodos com linhas em branco.&lt;/p&gt;

&lt;p&gt;Você pode seguir esses passos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Encontre um Método;&lt;/li&gt;
  &lt;li&gt;Verifique se há linhas em branco separando blocos;&lt;/li&gt;
  &lt;li&gt;Para cada bloco, extrair o código criando um novo Método;&lt;/li&gt;
  &lt;li&gt;Faça a chamada do novo Método no mesmo lugar que extraiu
  o código;&lt;/li&gt;
  &lt;li&gt;Repita o processo enquanto for necessário.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Parece besteira, mas não é.&lt;/p&gt;

&lt;p&gt;Escrever código qualquer um faz. Mas escrever um &lt;strong&gt;bom&lt;/strong&gt; código, 
no entanto, não é pra qualquer um. É necessário pensar no
longo prazo, no acoplamento, na coesão, no &lt;em&gt;design&lt;/em&gt;, deixar 
as coisas simples… é Engenharia, mas também Arte.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E a verdadeira Arte está nos detalhes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Sep 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/linhas-em-branco-no-metodo-e-mal-cheiro/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/linhas-em-branco-no-metodo-e-mal-cheiro/</guid>
      </item>
    
      <item>
        <title>A declaração WITH-DO é do Mal?</title>
        <description>&lt;p&gt;Muita gente odeia utilizar a construção WITH-DO do Pascal.
Dizem que é difícil de ler o código, introduz &lt;em&gt;bugs&lt;/em&gt;… 
esqueçam que WITH-DO existe! Eles dizem.&lt;/p&gt;

&lt;p&gt;Mas será que WITH-DO é mesmo do mal ou esses programadores é 
que não sabem utilizá-lo no momento certo?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-8bc72ed7.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Se você não sabe o que é WITH-DO, 
&lt;a href=&quot;http://www.freepascal.org/docs-html/ref/refsu63.html&quot;&gt;aqui&lt;/a&gt;
está uma boa explicação técnica.&lt;/p&gt;

&lt;p&gt;Então você define um &lt;strong&gt;bloco&lt;/strong&gt; ou &lt;strong&gt;contexto&lt;/strong&gt; e pode acessar os 
métodos e atributos de um Objeto sem a referência explícita à uma 
variável.&lt;/p&gt;

&lt;p&gt;A primeira vista parece que o objetivo é escrever menos e,
como bem sabemos, a maioria dos programadores são preguiçosos.&lt;/p&gt;

&lt;p&gt;Eu utilizo WITH-DO. Muito. E é claro, também quero escrever menos.&lt;/p&gt;

&lt;p&gt;Mas tento escrever menos da maneira correta. Não para poupar &lt;em&gt;bytes&lt;/em&gt;,
mas para deixar o código &lt;strong&gt;mais legível&lt;/strong&gt;, &lt;strong&gt;menos verboso&lt;/strong&gt; e 
&lt;strong&gt;menos acoplado&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ao longo de muitos anos utilizando WITH-DO eu posso contar 
nos dedos de apenas uma mão a quantidade de problemas que já 
tive ao utilizar essa construção, ou seja, acho que seu uso vale
a pena.&lt;/p&gt;

&lt;p&gt;Nesse artigo você aprenderá a utilizar a declaração WITH-DO.&lt;/p&gt;

&lt;h2 id=&quot;imperativo&quot;&gt;Imperativo&lt;/h2&gt;

&lt;p&gt;Creio que o &lt;strong&gt;mal&lt;/strong&gt; que WITH-DO nos traz é devido ao seu uso 100%
&lt;a href=&quot;https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa&quot;&gt;imperativo&lt;/a&gt;,
sem nenhum contexto determinando onde começa ou termina seu uso.&lt;/p&gt;

&lt;p&gt;Veja &lt;a href=&quot;http://forum.lazarus.freepascal.org/index.php?topic=32889.0&quot;&gt;aqui&lt;/a&gt; 
um exemplo de mal uso da declaração WITH-DO, postado no fórum 
do Lazarus.&lt;/p&gt;

&lt;p&gt;Vou replicar o código abaixo, caso o &lt;em&gt;link&lt;/em&gt; não esteja mais
disponível:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try
  btnOK.Enabled:=False;
  with datamodule.qryRegister do begin
    datamodule.connection.AutoCommit:=True;
    datamodule.connection.StartTransaction;
    SQL.Clear;
    SQL.Text:=
      &#39;INSERT INTO table VALUES (:name, :sex, :dateofbirth, :maritalstatus)&#39;;
    ParamByName(&#39;name&#39;).AsString:=teName.Text;
    ParamByName(&#39;sex&#39;).AsInteger:=cbSex.ItemIndex;
    ParamByName(&#39;dateofbirth&#39;).AsDate:=StrToDate(teDateOfBirth.Text);
    ParamByName(&#39;maritalstatus&#39;).AsInteger:=cbMaritalStatus.ItemIndex;          
    SQL.Clear;
    SQL.Text:=&#39;SELECT LAST_INSERT_ID() AS iddb FROM table&#39;;
    Open;
    idUser:=FieldByName(&#39;iddb&#39;).AsInteger;
    ExecSQL;
    Close;        
    try
      datamodule.connection.Commit;
      clearFields;
    except
      datamodule.connection.Rollback;
      ShowMessage(&#39;Error&#39;);
    end;
end; //with ends statement
except
  ShowMessage(&#39;Error: no connection to the database&#39;);
end;
bntOK.Enabled:=True;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O que é questionado nesse &lt;em&gt;post&lt;/em&gt; é irrelevante.&lt;/p&gt;

&lt;p&gt;Apenas analisem o código e vejam como o autor está utilizando
o WITH-DO:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Ele inicia uma transação;&lt;/li&gt;
  &lt;li&gt;Configura uma cláusula SQL;&lt;/li&gt;
  &lt;li&gt;Passa parâmetros;&lt;/li&gt;
  &lt;li&gt;Limpa a &lt;em&gt;query&lt;/em&gt;(?)&lt;/li&gt;
  &lt;li&gt;Executa a &lt;em&gt;query&lt;/em&gt;;&lt;/li&gt;
  &lt;li&gt;Commit… ClearFields…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;É um código totalmente procedural, imperativo e confuso!&lt;/p&gt;

&lt;p&gt;É muito difícil saber o que está sendo utilizado pelo 
WITH-DO e o que não está, concorda?&lt;/p&gt;

&lt;p&gt;Nesses casos, quando há ambiguidade entre métodos utilizados
pelo WITH-DO que não deveriam ser utilizados, alguns programadores
culpam o WITH-DO quando, na verdade, deveriam culpar a si mesmos
por escrever um código dessa maneira.&lt;/p&gt;

&lt;p&gt;Essa é uma maneira imperativa de codificação. Procedural.
Um código altamente acoplado que, realmente, não deveria utilizar
WITH-DO porque só piora as coisas.&lt;/p&gt;

&lt;h2 id=&quot;declarativo&quot;&gt;Declarativo&lt;/h2&gt;

&lt;p&gt;A codificação declarativa é utilizada nas linguagens funcionais.
Também é utilizada, por exemplo, quando codificamos SQL.&lt;/p&gt;

&lt;p&gt;Na codificação declarativa você define &lt;strong&gt;o que fazer&lt;/strong&gt;, mas não se
importa &lt;strong&gt;como será feito&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT * FROM Clients ORDER BY name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando escrevemos o código SQL acima, não nos preocupamos como o
SGBD irá trazer o resultado; quais índices; quais tuplas. Apenas
queremos o resultado o mais rápido possível.&lt;/p&gt;

&lt;p&gt;Assim deve ser a codificação 
&lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientada a Objetos&lt;/a&gt;,
onde os Objetos
&lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;pensam e tomam as próprias decisões&lt;/a&gt;,
sem que tenha um “controlador” informando &lt;strong&gt;como fazer&lt;/strong&gt; linha a linha.&lt;/p&gt;

&lt;p&gt;E o que isso tem haver com o uso do WITH-DO?&lt;/p&gt;

&lt;p&gt;Bem, o WITH-DO nos ajuda a transformar um código procedural em algo mais
declarativo, mais Orientado a Objetos.&lt;/p&gt;

&lt;p&gt;Um código mais Orientado a Objetos é mais &lt;strong&gt;legível&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Um código com menos declarações de variáveis, é menos &lt;strong&gt;verboso&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;E se você não declara variáveis de tipos específicos, automaticamente
seu código é &lt;strong&gt;menos acoplado&lt;/strong&gt;, com menos usos de Units para determinar
os tipos das variáveis.&lt;/p&gt;

&lt;p&gt;Vou lhe mostrar como.&lt;/p&gt;

&lt;p&gt;Vamos pegar o mesmo código procedural acima e reescrever utilizando
WITH-DO.&lt;/p&gt;

&lt;p&gt;Esse código será apenas &lt;strong&gt;um pouco mais&lt;/strong&gt; Orientado a Objetos, com
uma melhor legibilidade que o primeiro:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try
  btnOK.Enabled := False;
  with TDatabase.Instance.StartTransaction do
  try
    with 
      TQuery.New(
        &#39;INSERT INTO table VALUES (&#39; +
        &#39;  :name, :sex, :dateofbirth, :maritalstatus)&#39;
      )
    do
    begin
      Params
        .Add(&#39;name&#39;, ftString, teName.Text)
        .Add(&#39;sex&#39;, ftInteger, cbSex.ItemIndex)
        .Add(&#39;dateofbirth&#39;, ftDateTime, StrToDate(teDateOfBirth.Text))
        .Add(&#39;maritalstatus&#39;, ftInteger, cbMaritalStatus.ItemIndex)
      Execute;
    end;
    idUser := 
      TQuery.New(&#39;SELECT LAST_INSERT_ID() AS iddb FROM table&#39;)
        .Open
        .Field(&#39;iddb&#39;).AsInteger;
    Commit;
  except
    Rollback;
    raise;
  end;
except
  ShowMessage(&#39;Error: no connection to the database&#39;);
end;
bntOK.Enabled:=True;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;O código continua ruim, porém melhor.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Há muita coisa acontecendo num único método.&lt;/p&gt;

&lt;p&gt;Não deveríamos parar a refatoração agora.
Cada execução deveria estar num método a parte…&lt;/p&gt;

&lt;p&gt;No entanto o objetivo é mostrar o uso do WITH-DO e 
acho que dá pra ver a diferença, certo?&lt;/p&gt;

&lt;p&gt;Ao todo são apenas 2 declarações de WITH-DO. Cada declaração tem 
um &lt;strong&gt;contexto&lt;/strong&gt; bem definido por &lt;em&gt;TRY-EXCEPT&lt;/em&gt; ou &lt;em&gt;BEGIN-END&lt;/em&gt;. 
Não há ambiguidade.&lt;/p&gt;

&lt;p&gt;A declaração &lt;code&gt;TDatabase.Instance.StartTransaction&lt;/code&gt; irá retornar um
Objeto do tipo &lt;code&gt;ITransaction&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A declaração &lt;code&gt;TQuery.New&lt;/code&gt; irá retornar um Objeto do tipo &lt;code&gt;IQuery&lt;/code&gt;, 
através do &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Método New&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O código ficou mais legível.&lt;/p&gt;

&lt;p&gt;Não há declarações de variáveis.&lt;/p&gt;

&lt;p&gt;Não há variáveis globais como existe no código procedural — 
&lt;code&gt;datamodule.qryRegister&lt;/code&gt; é um Objeto global que, possivelmente, é 
reutilizado em toda a aplicação, sendo um &lt;em&gt;design&lt;/em&gt; muito errado, 
não &lt;em&gt;thread-safe&lt;/em&gt; e gerador de problemas.&lt;/p&gt;

&lt;h2 id=&quot;orientado-a-objetos&quot;&gt;Orientado a Objetos&lt;/h2&gt;

&lt;p&gt;A declaração WITH-DO nos ajuda a escrever um código mais simples e elegante.
Mas sejamos sinceros. Utilizamos WITH-DO para produzirmos código
procedural. E não tem nada de errado nisso, visto que é quase
impossível codificar 100% Orientado a Objetos em linguagens que
são imperativas.&lt;/p&gt;

&lt;p&gt;Uma vez que WITH-DO define uma variável implícita, o programador
pode chamar os &lt;strong&gt;métodos na sequência&lt;/strong&gt;, linha a linha.&lt;/p&gt;

&lt;p&gt;O uso de WITH-DO deixa o código melhor, mas se dá pra codificar
Orientado a Objetos, é o que devemos fazer.&lt;/p&gt;

&lt;p&gt;Então vou reescrever o código.&lt;/p&gt;

&lt;p&gt;Não há espaço aqui para a definição das Classes utilizadas
no exemplo.&lt;/p&gt;

&lt;p&gt;Qualquer dúvida, basta postar nos comentários.&lt;/p&gt;

&lt;p&gt;Abaixo um hipotético código &lt;strong&gt;declarativo&lt;/strong&gt; e &lt;strong&gt;Orientado a Objetos&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;btnOK.Enabled := False;
try
  idUser :=  
    TDatabase.Instance.Transaction(
      TTasks.New
        .Add(
          TQueryTask.New(
            &#39;INSERT INTO table VALUES (&#39; +
            &#39;  :name, :sex, :dateofbirth, :maritalstatus)&#39;,
            TDataParams.New
              .Add(&#39;name&#39;, ftString, teName.Text)
              .Add(&#39;sex&#39;, ftInteger, cbSex.ItemIndex)
              .Add(&#39;dateofbirth&#39;, ftDateTime, teDateOfBirth.Text)
              .Add(&#39;maritalstatus&#39;, ftInteger, cbMaritalStatus.ItemIndex)
          )
        )
        .Add(
          TQueryTask.New(&#39;SELECT LAST_INSERT_ID() AS iddb FROM table&#39;)            
        )
    )
    .Results
    .Get(&#39;iddb&#39;).AsInteger;
finally      
  bntOK.Enabled := True;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O que está ocorrendo aqui?&lt;/p&gt;

&lt;p&gt;Bem, temos &lt;code&gt;TQueryTask&lt;/code&gt; que implementa &lt;code&gt;ITask&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Temos uma lista de &lt;em&gt;tasks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A lista é passada para &lt;code&gt;Transaction&lt;/code&gt; que, internamente, irá executar
cada &lt;em&gt;task&lt;/em&gt; — chamando o método &lt;code&gt;Execute&lt;/code&gt; que não está explícito no
código — dentro de uma transação.&lt;/p&gt;

&lt;p&gt;Por fim &lt;code&gt;Transaction&lt;/code&gt; tem um método &lt;code&gt;Results&lt;/code&gt; que pode ser do tipo
&lt;code&gt;IDataParams&lt;/code&gt; e através de &lt;code&gt;Get&lt;/code&gt; é retornado um valor.&lt;/p&gt;

&lt;p&gt;O que acontece dentro desses Objetos é de responsabilidade deles.
O programador é apenas o &lt;strong&gt;orquestrador&lt;/strong&gt; dessa comunicação.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Na minha opinião WITH-DO pode e deve ser utilizado.&lt;/p&gt;

&lt;p&gt;Muita gente deseja cada vez mais &lt;em&gt;features&lt;/em&gt; para a linguagem
Object Pascal. Mas será que já sabemos utilizar, de forma eficaz,
tudo o que já temos nessa &lt;strong&gt;elegante linguagem&lt;/strong&gt; chamada Object Pascal?&lt;/p&gt;

&lt;p&gt;Até onde eu sei, essa &lt;em&gt;feature&lt;/em&gt; não existe em nenhuma outra linguagem.&lt;/p&gt;

&lt;p&gt;Apenas nós temos o WITH-DO!&lt;/p&gt;

&lt;p&gt;Mas será que sou o único que usa e aprecia essa &lt;em&gt;feature&lt;/em&gt;? :)&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Sep 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/a-declaracao-with-do-e-do-mal/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/a-declaracao-with-do-e-do-mal/</guid>
      </item>
    
      <item>
        <title>Procedural é fácil, Orientado a Objetos é difícil</title>
        <description>&lt;p&gt;Por que ainda temos discussões sobre a Programação Procedural ser mais fácil do que a Programação Orientada a Objetos? É claro que Programar no paradigma Procedural é mais fácil.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1470208564179-dd5b52a0d010.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Você olha para um código com 5 instâncias de Objetos, agumentos de Construtores, consumo de memória, polimorfismo e pensa:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eu poderia fazer a mesma coisa com 10 linhas de código Procedural.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A performance — você diria — poderia ser melhor, iria consumir menos memória e, claro, é muito mais fácil codificar.&lt;/p&gt;

&lt;p&gt;Eu concordo… em parte.&lt;/p&gt;

&lt;p&gt;Então por que escolher a &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Por que fazer da maneira “mais difícil”?&lt;/p&gt;

&lt;p&gt;Por que criar um &lt;a href=&quot;https://en.wikipedia.org/wiki/Overhead_(computing)&quot;&gt;&lt;em&gt;overhead&lt;/em&gt;&lt;/a&gt; “desnecessário”?&lt;/p&gt;

&lt;iframe src=&quot;https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Fobjectpascalprogramming%2Fposts%2F316968578655967&amp;amp;width=500&quot; width=&quot;500&quot; height=&quot;180&quot; style=&quot;border:none;overflow:hidden&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; allowtransparency=&quot;true&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Se pensarmos apenas no &lt;em&gt;overhead&lt;/em&gt; que traz a Orientação a Objetos, vamos então codificar nossos sistemas em apenas um único arquivo, usando &lt;em&gt;GO TO&lt;/em&gt; e código ASSEMBLY.&lt;/p&gt;

&lt;p&gt;Orientação a Objetos é sobre &lt;strong&gt;manutenabilidade&lt;/strong&gt; no longo prazo.&lt;/p&gt;

&lt;p&gt;É sobre não pensar como um controlador ou CPU, mas como &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidades&lt;/a&gt; auto-suficientes que &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;pensam e tomam decisões&lt;/a&gt; por conta própria.&lt;/p&gt;

&lt;p&gt;Não é sobre estar certo ou errado, fazer diagramas bonitos ou porque fica legal por no Currículo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Orientação a Objetos é sobre resolver um problema de forma sustentável.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Por isso escolhemos desenvolver seguindo esse paradigma.&lt;/p&gt;

&lt;p&gt;Em 1 hora é possível fazer muita coisa de forma Procedural, enquanto na Orientação a Objetos podemos ficar 1 hora apenas tentando identificar o melhor &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nome para uma Classe&lt;/a&gt;, quais são as &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidades&lt;/a&gt; que fazem parte do problema, quais os Contextos…&lt;/p&gt;

&lt;p&gt;E se eu lhe dissesse que podemos ficar “apenas” &lt;a href=&quot;/posts/pensando-em-objetos/&quot;&gt;pensando&lt;/a&gt; por 1 ou 2 semanas, sem escrever nenhuma linha de código?&lt;/p&gt;

&lt;p&gt;É verdade, acontece.&lt;/p&gt;

&lt;p&gt;Não adianta fazer um sistema rapidamente se seu código não é &lt;strong&gt;sustentável&lt;/strong&gt; no longo prazo.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Softwares&lt;/em&gt; sempre &lt;strong&gt;mudam&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Orientação a Objetos é sobre organização.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nós passamos a maior parte do tempo não codificando novas &lt;em&gt;features&lt;/em&gt;, mas sim lendo e tentando entender o código.&lt;/p&gt;

&lt;p&gt;De que adianta ter um código de execução mais rápida em 100 ms se daqui a um mês ninguém sabe como alterá-lo?&lt;/p&gt;

&lt;p&gt;Orientação a Objetos não é mais difícil de codificar, é apenas é mais trabalhoso.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mas vale a pena.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Por que no fim você irá trabalhar menos.&lt;/p&gt;

&lt;p&gt;Talvez com um pouco mais de código, é verdade, mas terá menos &lt;em&gt;bugs&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Menos &lt;em&gt;debugging&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Menos problemas.&lt;/p&gt;

&lt;p&gt;Orientação a Objetos agrega &lt;strong&gt;qualidade&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;E qualidade, é o que mais importa.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Sep 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/procedural-e-facil-orientado-a-objetos-e-dificil/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/procedural-e-facil-orientado-a-objetos-e-dificil/</guid>
      </item>
    
      <item>
        <title>Microservices com Delphi — Parte Final</title>
        <description>&lt;p&gt;Uma arquitetura que utiliza Microservices tem seus prós e contras como qualquer outra tecnologia. Será que essa arquitetura foi uma boa escolha para o projeto?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1454023989775-79520f04322c.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No &lt;a href=&quot;/posts/microservices-delphi-parte-3/&quot;&gt;artigo anterior&lt;/a&gt; eu lhe mostrei como codificar uma Classe de Negócio para fazer a comunicação com um Microservice utilizando todo o arcabouço apresentado na primeira parte dessa série.&lt;/p&gt;

&lt;p&gt;Nesse artigo você irá ver:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Tratamento de Exceções&lt;/strong&gt;: Quando algo dá errado nos Microservices ou na comunicação com eles;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Links&lt;/strong&gt;: Separei alguns artigos interessantes sobre o assunto;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;tratamento-de-excecoes&quot;&gt;Tratamento de Exceções&lt;/h2&gt;

&lt;p&gt;Todo &lt;em&gt;software&lt;/em&gt; precisa tratar erros e exceções, e é claro que estamos fazendo isso.&lt;/p&gt;

&lt;p&gt;Na Unit &lt;a href=&quot;/posts/microservices-delphi-parte-2/#unit-microservicesa&quot;&gt;AcmeMicroServiceA.pas&lt;/a&gt; o tratamento de exceções é feito no método &lt;code&gt;TMicroServiceClient.Send&lt;/code&gt;, verificando o &lt;code&gt;Code&lt;/code&gt; de retorno do protocolo HTTP.&lt;/p&gt;

&lt;p&gt;Se houver erro, definimos um protocolo privado que descreve como a mensagem para o &lt;em&gt;Client&lt;/em&gt; deve ser. Nada mais é do que um XML com &lt;em&gt;nodes&lt;/em&gt; específicos que descrevem o erro ou exceção.&lt;/p&gt;

&lt;p&gt;Abaixo o código modificado que trata erros e exceções. O código em produção é um pouco mais elaborado, no entanto acredito que com esse exemplo você irá entender como o tratamento ocorre no projeto real.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TMicroServiceClient.Send(
  const Content: string): IMicroServiceResponse;
begin
  with Response(Content) do
  begin
    Result := TMicroServiceResponse.New(
      Code,
      TXMLFactory.New(&#39;ISO-8859-1&#39;, Stream).Document
    );
    case Code of
      // BAD REQUEST
      400..499:
        raise EMicroService.Create(
          Result
            .XML
            .DocumentElement
            .ChildNodes[&#39;UserMessage&#39;].Text
        );
      // SERVER ERROR
      500..510:
        raise EMicroService.Create(
          Result
            .XML
            .DocumentElement
            .ChildNodes[&#39;DevMessage&#39;].Text
        );
    end;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repare que para cada tipo de erro/exceção, um &lt;em&gt;node&lt;/em&gt; (ou &lt;em&gt;nodes&lt;/em&gt;) específico é utilizado para obter a informação.&lt;/p&gt;

&lt;p&gt;No &lt;em&gt;Client&lt;/em&gt; Delphi, o &lt;code&gt;Code&lt;/code&gt; também é acessível através da Interface &lt;code&gt;IMicroServiceResponse&lt;/code&gt;, então o &lt;em&gt;Client&lt;/em&gt; pode tomar decisões específicas para casos que não gerem uma exceção.&lt;/p&gt;

&lt;p&gt;Veja &lt;a href=&quot;http://www.restapitutorial.com/httpstatuscodes.html&quot;&gt;aqui&lt;/a&gt; uma lista de &lt;em&gt;HTTP Status Codes&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;

&lt;p&gt;Separei alguns links interessantes de artigos e vídeos que serviram de inspiração para escrever essa série, assim como foram fontes de informações para o projeto.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.infoq.com/br/presentations/vantagens-e-desvantagens-de-uma-arquitetura-microservices&quot;&gt;Vantagens e desvantagens de uma arquitetura microservices: uma abordagem rica em exemplos&lt;/a&gt; é uma apresentação em vídeo de quase 1 hora que fala sobre os prós e contras em utilizar essa arquitetura. O autor fala sobre &lt;a href=&quot;http://www.martinfowler.com/bliki/StranglerApplication.html&quot;&gt;Strangler Application&lt;/a&gt; que é o mesmo princípio que estamos utilizando no projeto.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.infoq.com/br/articles/seven-uservices-antipatterns&quot;&gt;Sete antipadrões para microservices&lt;/a&gt; alerta sobre algumas coisas que devem ser evitadas, na opinião do autor, quando utilizamos a arquitetura de Microservices.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://medium.com/@mwhitt.w/preventing-tight-data-coupling-between-microservices-df30e1e24311#.wl6r7hcfz&quot;&gt;Preventing Tight Data Coupling Between Microservices&lt;/a&gt; é um artigo em Inglês interessante sobre acoplamento de dados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://medium.com/@skamille/microservices-real-architectural-patterns-68bd83bbb6cd#.hrsdvq3rj&quot;&gt;Microservices: Real Architectural Patterns&lt;/a&gt; é outro artigo em Inglês que fala sobre arquitetura e CRUD.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A escolha pela arquitetura de Microservices está sendo satisfatória.&lt;/p&gt;

&lt;p&gt;Microservices são como &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;instâncias de Objetos&lt;/a&gt; pela rede.&lt;/p&gt;

&lt;p&gt;Assim como Objetos, cada Microservice deve implementar apenas &lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/&quot;&gt;uma única responsabilidade&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Quando falamos sobre Microservices, WebServices, Multi-camadas, protocolos… tudo isso parece muito complicado. Mas se você souber como as coisas funcionam, poderá remover tudo que é &lt;strong&gt;desnecessário&lt;/strong&gt; para o &lt;strong&gt;seu negócio&lt;/strong&gt; e se concentrar apenas no &lt;strong&gt;essencial&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Você não precisa implementar &lt;strong&gt;tudo&lt;/strong&gt; o que dizem para implementar. Utilize tecnologias que fazem sentido para seu negócio e comece simples.&lt;/p&gt;

&lt;p&gt;A migração está longe de estar concluída. O sistema tem poucos meses, mas apenas poucos dias de trabalho &lt;em&gt;full time&lt;/em&gt; na codificação e integração dos Microservices.&lt;/p&gt;

&lt;p&gt;Por enquanto estamos indo bem.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Aug 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/microservices-delphi-parte-final/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/microservices-delphi-parte-final/</guid>
      </item>
    
      <item>
        <title>Microservices com Delphi — Parte 3</title>
        <description>&lt;p&gt;Podemos utilizar diretamente uma instância de &lt;code&gt;TMicroServiceClient&lt;/code&gt;, passar um XML como parâmetro e obter a resposta. Mas isso não seria o ideal. Devemos ter Classes de Negócio, com suas próprias Regras e entrada/saída de informações.&lt;/p&gt;

&lt;p&gt;Vamos codificar uma Classe de Negócio, que construa seu próprio XML e utilize, internamente, uma instância do &lt;em&gt;Client&lt;/em&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1448932223592-d1fc686e76ea.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No &lt;a href=&quot;/posts/microservices-delphi-parte-2/&quot;&gt;artigo anterior&lt;/a&gt; eu escrevi sobre o Módulo MicroService e Localização de Serviços.&lt;/p&gt;

&lt;p&gt;Nesse artigo você irá aprender a codificar uma Classe de Negócio que irá consumir um Microservice, utilizando o Módulo já apresentado ateriormente.&lt;/p&gt;

&lt;p&gt;Também aprenderá como transformar XML em dados tabulares para apresentá-los numa &lt;em&gt;Grid&lt;/em&gt;, por exemplo.&lt;/p&gt;

&lt;h2 id=&quot;classe-txmlfactory&quot;&gt;Classe TXMLFactory&lt;/h2&gt;

&lt;p&gt;Uma instância de &lt;code&gt;TXMLFactory&lt;/code&gt; é utilizada no &lt;em&gt;Client&lt;/em&gt;, especificamente no método &lt;code&gt;TMicroServiceClient.Send&lt;/code&gt;, que não foi abordada no artigo anterior.&lt;/p&gt;

&lt;p&gt;É uma Classe simples mas importante, utilizada tanto para montar tanto o XML de envio como o de retorno.&lt;/p&gt;

&lt;p&gt;O Delphi 7 não trabalha com &lt;em&gt;encode&lt;/em&gt; &lt;code&gt;UTF-8&lt;/code&gt; por padrão mas os Microservices em Java trabalham no formato &lt;code&gt;UTF-8&lt;/code&gt;. Então o &lt;em&gt;Client&lt;/em&gt; deve fazer todas as solicitações nesse formato.&lt;/p&gt;

&lt;p&gt;O resultado, no entanto, é convertido para &lt;code&gt;ISO-8859-1&lt;/code&gt; — que é o formato que estou utilizando no Delphi 7 — antes dos dados serem disponibilizados para o resto da aplicação.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TXMLFactory&lt;/code&gt; facilita o envio e retorno.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TXMLFactory = class(TInterfacedObject, IXMLFactory)
  private
    FEncoding: string;
    FStream: IDataStream;
  public
    constructor Create(const Encoding: string; Stream: IDataStream); reintroduce;
    class function New(const Encoding: string; Stream: IDataStream): IXMLFactory; overload;
    class function New(const Encoding: string): IXMLFactory; overload;
    class function New: IXMLFactory; overload;
    function Document: IXMLDocument;
  end;

{ TXMLFactory }

constructor TXMLFactory.Create(const Encoding: string; Stream: IDataStream);
begin
  inherited Create;
  FEncoding := Encoding;
  FStream := Stream;
end;

class function TXMLFactory.New(const Encoding: string;
  Stream: IDataStream): IXMLFactory;
begin
  Result := Create(Encoding, Stream);
end;

class function TXMLFactory.New(const Encoding: string): IXMLFactory;
begin
  Result := New(Encoding, TDataStream.New);
end;

class function TXMLFactory.New: IXMLFactory;
begin
  Result := New(&#39;UTF-8&#39;);
end;

function TXMLFactory.Document: IXMLDocument;
var
  Buf: TMemoryStream;
begin
  Result := TXMLDocument.Create(nil);
  Buf := TMemoryStream.Create;
  try
    Result.Options := [];
    Result.Active := True;
    Result.Version := &#39;1.0&#39;;
    if FStream.Size &amp;gt; 0 then
    begin
      FStream.Save(Buf);
      Result.LoadFromStream(Buf);
    end;
    Result.Encoding := FEncoding;
  finally
    Buf.Free;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;consumindo-um-servico&quot;&gt;Consumindo um Serviço&lt;/h2&gt;

&lt;p&gt;Nesse projeto eu defini que todo consumo de qualquer Microservice será feito através de Classes de Negócio. Então poderei ter o mesmo número de Classes correspondende ao número de Microservices ou até mais, pois uma Classe de Negócio poderia fazer uso de mais de um Microservice.&lt;/p&gt;

&lt;p&gt;Iremos implementar uma Classe de Negócio simples e hipotética, visto que não poderia disponibilizar o código real do sistema quando se trata do negócio da empresa.&lt;/p&gt;

&lt;p&gt;A Classe proposta é a &lt;code&gt;TFaturasService&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A instância dessa Classe irá receber um parâmetro do tipo &lt;code&gt;IDataUId&lt;/code&gt; — uma classe que encapsula um &lt;em&gt;GUID&lt;/em&gt; — para retornar os dados de uma Fatura.&lt;/p&gt;

&lt;p&gt;Segue sua implementação abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFaturasService = class(TInterfacedObject, IMicroServiceAction)
  private
    FUId: IDataUId;
  public
    constructor Create(UId: IDataUId); reintroduce;
    class function New(UId: IDataUId): IMicroServiceAction;
    function Act: IMicroServiceResponse;
  end;

{ TFaturasService }

constructor TFaturasService.Create(UId: IDataUId);
begin
  inherited Create;
  FUId := UId;
end;

class function TFaturasService.New(
  UId: IDataUId): IMicroServiceAction;
begin
  Result := Create(UId);
end;

function TFaturasService.Act: IMicroServiceResponse;

  function XML: IXMLDocument;
  begin
    Result := TXMLFactory.New.Document;
    with Result.AddChild(&#39;Params&#39;) do
    begin
      AddChild(&#39;uid&#39;).Text := FUId.AsString;
      AddChild(&#39;active&#39;).Text := &#39;True&#39;;
    end;
  end;

begin
  Result :=
    TMicroServiceClient.New(
      TMicroServiceParams.New(
        &#39;financ:faturas-service&#39;
      )
      .Find
    )
    .Send(XML)
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;passo-a-passo&quot;&gt;O código passo-a-passo&lt;/h3&gt;

&lt;p&gt;Vamos entender o código juntos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;TFaturasService&lt;/code&gt; é uma Classe de Negócio que implementa &lt;code&gt;IMicroServiceAction&lt;/code&gt; (veja &lt;a href=&quot;/posts/microservices-delphi-parte-2/#introducao&quot;&gt;aqui&lt;/a&gt;);&lt;/li&gt;
  &lt;li&gt;O Objeto &lt;code&gt;TXMLFactory&lt;/code&gt; é utilizado para gerar o XML de envio;&lt;/li&gt;
  &lt;li&gt;O Objeto &lt;code&gt;TMicroServiceParams&lt;/code&gt; localiza o serviço através do seu &lt;code&gt;name&lt;/code&gt; (único) e traz as informações em forma de parâmetros;&lt;/li&gt;
  &lt;li&gt;O Objeto &lt;code&gt;TMicroServiceClient&lt;/code&gt; envia o XML de envio e retorna uma instância de &lt;code&gt;IMicroServiceResponse&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;O objeto retornado contém um &lt;code&gt;XML: IXMLDocument&lt;/code&gt; que é a resposta do Microservice codificado em Java;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;E é isso.&lt;/p&gt;

&lt;p&gt;Uma implementação completa de um serviço.&lt;/p&gt;

&lt;p&gt;Se você esperava algo mais complexo, sinto decepcioná-lo, pois a implementação é tão simples quanto isso. :)&lt;/p&gt;

&lt;h3 id=&quot;utilizando-a-classe&quot;&gt;Utilizando a Classe de Negócio&lt;/h3&gt;

&lt;p&gt;Uma vez que a Classe de Negócio foi implementada, poderá ser utilizada em muitas partes do sistema sem haver duplicação de código; não precisará montar o mesmo XML em vários lugares; não precisará passar os mesmos parâmetros para o &lt;em&gt;Client&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Então, como utilizar a nova Classe no nosso código?&lt;/p&gt;

&lt;p&gt;Aqui está um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;procedure TForm1.FillData;
begin
  TXMLClientDataSetAdapter.New(
    FModule.FaturaClient,
    TFaturasService.New(FUId).Act.XML
  )
  .Adapt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No Delphi 7 utilizamos &lt;code&gt;TClientDataSet&lt;/code&gt; para manter os dados tabulares (linhas e colunas) em memória, exibir numa &lt;em&gt;Grid&lt;/em&gt; ou em qualquer outro &lt;em&gt;widget&lt;/em&gt;. Mas os dados dos Microservices vem no formato de XML. Esses dados precisam ser convertidos para um formato tabular.&lt;/p&gt;

&lt;p&gt;Para isso temos uma outra Classe responsável por fazer essa conversão da forma mais genérica possível.&lt;/p&gt;

&lt;p&gt;Essa Classe é a &lt;code&gt;TXMLClientDataSetAdapter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ela recebe 2 parâmetros:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Uma instância de um &lt;code&gt;TClientDataSet&lt;/code&gt;, que no exemplo está em um &lt;code&gt;TDataModule&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Uma instância de &lt;code&gt;IXMLDocument&lt;/code&gt;, que é obtido através da chamada &lt;code&gt;Act.XML&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Então executamos o método &lt;code&gt;Adapt&lt;/code&gt; e pronto, temos um XML convertido em dados tabulares.&lt;/p&gt;

&lt;p&gt;Será que o código da Classe &lt;code&gt;TXMLClientDataSetAdapter&lt;/code&gt; é complexo?&lt;/p&gt;

&lt;p&gt;Não. É tão simples quanto a implementação da Classe de Negócio.&lt;/p&gt;

&lt;p&gt;Veja a implementação do método &lt;code&gt;Adapt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TXMLClientDataSetAdapter.Adapt: IDataAdapter;
var
  I: Integer;
  Field: TField;
begin
  Result := Self;
  if not Assigned(FSource) then
    Exit;
  FDest.DisableControls;
  try
    while Assigned(FSource) do
    begin
      FDest.Append;
      for I := 0 to FSource.ChildNodes.Count -1 do
      begin
        with FSource.ChildNodes[I] do
        begin
          Field := FDest.FindField(NodeName);
          if Assigned(Field) and (Text &amp;lt;&amp;gt; &#39;&#39;) then
            Field.Value := Text;
        end;
      end;
      FSource := FSource.NextSibling;
    end;
  finally
    FDest.First;
    FDest.EnableControls;
  end;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ele adapta o XML para o formato tabular e no fim temos uma instância de &lt;code&gt;TClientDataSet&lt;/code&gt; com os dados provenientes do XML.&lt;/p&gt;

&lt;h2 id=&quot;ser-um-substituto-ao-datasnap&quot;&gt;Será um substituto ao &lt;em&gt;DataSnap&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;Eu ainda não terminei essa série, porém já recebi alguns e-mails de alguns leitores perguntando se é possível utilizar essa solução como um substituto ao &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Seattle/en/Developing_DataSnap_Applications&quot;&gt;&lt;em&gt;Delphi DataSnap&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Minha resposta é que o &lt;em&gt;DataSnap&lt;/em&gt; tem muito, muito código implementado com inúmeras facilidades para os desenvolvedores. Então não é um substituto — e mesmo se esse fosse o objetivo, estaríamos muito longe de concluí-lo.&lt;/p&gt;

&lt;p&gt;É melhor ou pior?&lt;/p&gt;

&lt;p&gt;Depende do tipo do projeto.&lt;/p&gt;

&lt;p&gt;Nesse projeto a versão do Delphi é a 7. A empresa não quer mais investir no Delphi e vai substituí-lo, aos poucos, por Java ou mesmo C#. Então não haveria motivos em utilizar &lt;em&gt;DataSnap&lt;/em&gt;, visto que a linguagem irá mudar no futuro.&lt;/p&gt;

&lt;h2 id=&quot;desvantagens-by-design&quot;&gt;Desvantagens &lt;em&gt;by design&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;É claro que há desvantagens na solução proposta. Sempre há desvantagens.&lt;/p&gt;

&lt;p&gt;Uma grande desvantagem é que novas informações não são, necessariamente, visíveis automaticamente quando há alterações nos Microservices.&lt;/p&gt;

&lt;p&gt;Por exemplo.&lt;/p&gt;

&lt;p&gt;Caso o Microservice acima enviasse uma nova informação chamada “status”, ela não iria aparecer automaticamente numa &lt;em&gt;Grid&lt;/em&gt; do Delphi. Esse campo teria que ser incluso, manualmente, no &lt;em&gt;ClientDataSet&lt;/em&gt; que fosse receber os dados.&lt;/p&gt;

&lt;p&gt;O que eu quero dizer é que a aplicação Delphi não se adapta automaticamente as mudanças dos Microservices. É possível fazer, porém exigiria muito mais tempo de desenvolvimento.&lt;/p&gt;

&lt;p&gt;A solução é simples porque estamos utilizando a premissa &lt;a href=&quot;https://en.wikipedia.org/wiki/Convention_over_configuration&quot;&gt;&lt;em&gt;Convention over configuration&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Se há dados, então eles estarão no formato XML;&lt;/li&gt;
  &lt;li&gt;Os &lt;em&gt;fields&lt;/em&gt; de um &lt;em&gt;ClientDataSet&lt;/em&gt; devem ter o mesmo nome dos &lt;em&gt;fields&lt;/em&gt; que são esperados nos Microservices e vice-versa;&lt;/li&gt;
  &lt;li&gt;Utilizamos os mesmos formatos para Data, Hora e Números decimais.&lt;/li&gt;
  &lt;li&gt;Etc.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Apesar de não vermos isso como desvantagens, não deixa de ler uma limitação.&lt;/p&gt;

&lt;h2 id=&quot;no-proximo-artigo&quot;&gt;No próximo artigo…&lt;/h2&gt;

&lt;p&gt;Você acabou de ver uma implementação simples, &lt;em&gt;“made in home”&lt;/em&gt;, para trabalhar com interoperabilidade entre sistemas distintos utilizando Microservices que nada mais são do que requisições HTTP enviando e recebendo XML.&lt;/p&gt;

&lt;p&gt;Finalizaremos essa série no &lt;a href=&quot;/posts/microservices-delphi-parte-final/&quot;&gt;próximo artigo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Aug 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/microservices-delphi-parte-3/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/microservices-delphi-parte-3/</guid>
      </item>
    
      <item>
        <title>Microservices com Delphi — Parte 2</title>
        <description>&lt;p&gt;Não basta apenas utilizar um Protocolo HTTP para fazer a comunicação com os Microservices. É necessário, também, codificar um Localizador de Microservices.&lt;/p&gt;

&lt;p&gt;Veja como um implementar um Localizador simples, utilizando um SGBD, e também a implementação de um &lt;em&gt;Client&lt;/em&gt; para fazer a comunicação com qualquer Microservice no nosso &lt;em&gt;framework&lt;/em&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1457305237443-44c3d5a30b89.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;No &lt;a href=&quot;/posts/microservices-delphi-parte-1/&quot;&gt;artigo anterior&lt;/a&gt; eu escrevi sobre o Projeto codificado em Delphi 7 que está sendo recodificado utilizando Microservices em Java.&lt;/p&gt;

&lt;p&gt;Nesse artigo irei falar sobre o Módulo Microservices, que possui todo o necessário para fazer a comunicação com os serviços.&lt;/p&gt;

&lt;h2 id=&quot;modulo-microservice&quot;&gt;Módulo MicroService&lt;/h2&gt;

&lt;p&gt;O Módulo MicroService é composto de apenas 4 simples Interfaces (até agora).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;IMicroServiceParams&lt;/strong&gt;: Representa um localizador de MicroService;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IMicroServiceResponse&lt;/strong&gt;: Representa um &lt;code&gt;Response&lt;/code&gt; após uma chamada a um MicroService;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IMicroServiceClient&lt;/strong&gt;: Representa o &lt;em&gt;Client&lt;/em&gt; para todos os Microservices;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IMicroServiceAction&lt;/strong&gt;: Representa uma Ação (irei falar sobre essa Interface em outro artigo).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unit-microservices&quot;&gt;Unit AcmeMicroServices.pas&lt;/h3&gt;

&lt;p&gt;Aqui está a implementação das Interfaces.&lt;/p&gt;

&lt;p&gt;Há algumas dependências que não estarão no escopo desses artigos, mas acredito que seja fácil abstrair as Classes ou Interfaces como, por exemplo, &lt;code&gt;IDataParams&lt;/code&gt; e &lt;code&gt;IXMLDocument&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  IMicroServiceParams = interface
    function Find: IDataParams;
  end;

  IMicroServiceResponse = interface
    function Code: Integer;
    function Empty: Boolean;
    function XML: IXMLDocument;
  end;

  IMicroServiceClient = interface
    function Send(const Content: string): IMicroServiceResponse; overload;
    function Send(XML: IXMLDocument): IMicroServiceResponse; overload;
  end;

  IMicroServiceAction = interface
    function Act: IMicroServiceResponse;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;localizando-servicos&quot;&gt;Localizando Serviços&lt;/h2&gt;

&lt;p&gt;Se sua aplicação utiliza apenas 3 ou 5 Microservices, não haveria necessidade de implementar um Localizador. Mas se sua aplicação lida com dezenas ou mais de Microservices, então é necessário haver um “índice” de Microservices.&lt;/p&gt;

&lt;p&gt;O índice está no SGBD, em apenas 1 tabela (atualmente), e a localização de qualquer serviço é feita através do seu &lt;em&gt;name&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Sim, é só isso.&lt;/p&gt;

&lt;p&gt;A tabela — vamos dar o nome de Micro_Services para esse artigo — possue algumas colunas.&lt;/p&gt;

&lt;p&gt;As mais relevantes são:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;[name]&lt;/strong&gt;: O nome do serviço. Esse nome deve ser único;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;[server]&lt;/strong&gt;: O IP do servidor onde o MicroService está hospedado;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;[path]&lt;/strong&gt;: O &lt;em&gt;path&lt;/em&gt; do serviço, exemplo: http://10.20.0.10/execute onde “/execute” é o &lt;em&gt;path&lt;/em&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;[port]&lt;/strong&gt;: A porta onde o serviço está hospedado, exemplo: http://10.20.0.10:8020/execute (8020 é a porta);&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;[encoding]&lt;/strong&gt;: Alguns serviços trabalham com &lt;em&gt;encode&lt;/em&gt; diferente de UTF-8;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;[verb]&lt;/strong&gt;: Existem serviços que utilizam GET outros POST, etc. Essa coluna informa qual verbo HTTP utilizar;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unit-microservicesa&quot;&gt;Unit AcmeMicroServiceA.pas&lt;/h3&gt;

&lt;p&gt;Essa &lt;em&gt;unit&lt;/em&gt; encapsula as Classes que implementam as Interfaces acima.&lt;/p&gt;

&lt;p&gt;A parte importante por aqui é o método &lt;code&gt;TMicroServiceClient.Response&lt;/code&gt;. Esse método utiliza o resultado de &lt;code&gt;TMicroServiceParams.Find&lt;/code&gt;, que é um localizador de serviços cadastrados, para montar uma requisição HTTP completa.&lt;/p&gt;

&lt;p&gt;Consegue ver a beleza do método &lt;code&gt;TMicroServiceClient.Response&lt;/code&gt; onde (quase) tudo são Objetos conversando e &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;tomando decisões&lt;/a&gt; entre si?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  EMicroService = class(Exception);

  TMicroServiceParams = class(TInterfacedObject, IMicroServiceParams)
  private
    FServiceName: string;
  public
    constructor Create(const ServiceName: string);
    class function New(const ServiceName: string): IMicroServiceParams;
    function Find: IDataParams; overload;
  end;

  TMicroServiceResponse = class(TInterfacedObject, IMicroServiceResponse)
  private
    FCode: Integer;
    FXML: IXMLDocument;
  public
    constructor Create(Code: Integer; XML: IXMLDocument);
    class function New(Code: Integer; XML: IXMLDocument): IMicroServiceResponse;
    function Code: Integer;
    function Empty: Boolean;
    function XML: IXMLDocument;
  end;

  TMicroServiceClient = class(TInterfacedObject, IMicroServiceClient)
  private
    FParams: IDataParams;
    function Response(const Content: string): IHttpResponse;
  public
    constructor Create(ServiceParams: IDataParams);
    class function New(ServiceParams: IDataParams): IMicroServiceClient;
    function Send(const Content: string): IMicroServiceResponse; overload;
    function Send(XML: IXMLDocument): IMicroServiceResponse; overload;
  end;

implementation

uses
  XMLIntf;

{ TMicroServiceParams }

constructor TMicroServiceParams.Create(const ServiceName: string);
begin
  inherited Create;
  FServiceName := ServiceName;
end;

class function TMicroServiceParams.New(const ServiceName: string): IMicroServiceParams;
begin
  Result := Create(ServiceName);
end;

function TMicroServiceParams.Find: IDataParams;
var 
  Q: ISQLQuery;
begin
  // Através de uma Query (instância Q), 
  // pesquisa pelo nome do serviço (FServiceName).
  // Utilizando os Fields, retornamos uma instância TDataParams.
  Result := TDataParams.New(Q.Fields);
end;

{ TMicroServiceResponse }

constructor TMicroServiceResponse.Create(Code: Integer; XML: IXMLDocument);
begin
  inherited Create;
  FCode := Code;
  FXML := XML;
end;

class function TMicroServiceResponse.New(Code: Integer; XML: IXMLDocument): IMicroServiceResponse;
begin
  Result := Create(Code, XML);
end;

function TMicroServiceResponse.Code: Integer;
begin
  Result := FCode;
end;

function TMicroServiceResponse.Empty: Boolean;
begin
  Result := (FCode = 204) or (FXML.ChildNodes.Count = 0);
end;

function TMicroServiceResponse.XML: IXMLDocument;
begin
  Result := FXML;
end;

{ TMicroServiceClient }

function TMicroServiceClient.Response(const Content: string): IHttpResponse;
begin
  try
    Result :=
      THttpClient.New(
        TWebURL.New(
          FParams.Param(&#39;server&#39;).AsString,
          FParams.Param(&#39;path&#39;).AsString,
          FParams.Param(&#39;port&#39;).AsInteger
        )
        .AsString,
        &#39;application/xml;charset=&#39; +
          FParams.Param(&#39;encoding&#39;).AsString,
        TDataStream.New(Content)
      )
      .Execute(FParams.Param(&#39;verb&#39;).AsString);
  except
    on E: Exception do
    begin
      raise EMicroService.Create(
        &#39;Service: &#39; + FParams.Param(&#39;name&#39;).AsString + #13 +
        &#39;Error: &#39; + E.Message
      );
    end;
  end;
end;

constructor TMicroServiceClient.Create(ServiceParams: IDataParams);
begin
  inherited Create;
  FParams := ServiceParams;
end;

class function TMicroServiceClient.New(ServiceParams: IDataParams): IMicroServiceClient;
begin
  Result := Create(ServiceParams);
end;

function TMicroServiceClient.Send(const Content: string): IMicroServiceResponse;
begin
  with Response(Content) do
  begin
    Result := TMicroServiceResponse.New(
      Code,
      TXMLFactory.New(&#39;ISO-8859-1&#39;, Stream).Document
    );
  end;
end;

function TMicroServiceClient.Send(XML: IXMLDocument): IMicroServiceResponse;
begin
  Result := Send(XML.XML.Text);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;no-proximo-artigo&quot;&gt;No próximo artigo…&lt;/h2&gt;

&lt;p&gt;Isso é código real, em produção!&lt;/p&gt;

&lt;p&gt;E onde está o Tratamento de Exceções, Classes de Negócio, etc?&lt;/p&gt;

&lt;p&gt;No &lt;a href=&quot;/posts/microservices-delphi-parte-3/&quot;&gt;próximo artigo&lt;/a&gt; você irá ver como construir uma &lt;strong&gt;Classe de Negócio&lt;/strong&gt; que faz uso de todo esse arcabouço.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Aug 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/microservices-delphi-parte-2/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/microservices-delphi-parte-2/</guid>
      </item>
    
      <item>
        <title>Microservices com Delphi — Parte 1</title>
        <description>&lt;p&gt;Imagine um grande Sistema ERP codificado em Delphi 7, com Regras de Negócio rigidamente codificadas para serem utilizadas somente numa aplicação Desktop.&lt;/p&gt;

&lt;p&gt;Se você tivesse que evoluir esse sistema para proporcionar uma interoperabilidade com outros Sistemas, versões Web ou mesmo simplificar sua manutenção, o que você faria?&lt;/p&gt;

&lt;p&gt;Minha resposta, Microservices.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1453230806017-56d81464b6c5.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Sistemas Web muitas vezes são preferíveis do que Sistemas Desktop. Não é necessária instalação, drivers, DLL’s… basta apontar seu browser para uma URL e começar a utilizar. Isso é um fato.&lt;/p&gt;

&lt;p&gt;Por outro lado Sistemas Desktop ainda são importantes. Proporcionam uma melhor experiência de UI para o usuário — mas UI Web estão melhorando a cada dia — com uma melhor performance e melhor integração com o Sistema Operacional.&lt;/p&gt;

&lt;p&gt;Não esqueçamos, também, das versões Mobile.&lt;/p&gt;

&lt;p&gt;A chave é criarmos uma API para disponibilizarmos as Regras de Negócio num único lugar, para que sejam utilizadas em qualquer versão do sistema ou mesmo qualquer dispositivo.&lt;/p&gt;

&lt;p&gt;Esse é o problema apresentado em um dos Projetos que estou envolvido.&lt;/p&gt;

&lt;p&gt;Um grande Projeto ERP que deverá ter muitas de suas funcionalidades exportadas, recodificadas e disponibilizadas para uso, seja pelo mesmo Sistema ERP, Web, Mobile ou mesmo outros Sistemas.&lt;/p&gt;

&lt;h2 id=&quot;microservices&quot;&gt;Microservices&lt;/h2&gt;

&lt;p&gt;O que são Microservices?&lt;/p&gt;

&lt;p&gt;Na &lt;a href=&quot;https://en.wikipedia.org/wiki/Microservices&quot;&gt;Wikipedia&lt;/a&gt; temos a seguinte definição:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Microservices são uma interpretação mais concreta e moderna de arquiteturas orientadas a serviços (SOA) usada para construir sistemas de software distribuídos.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A sigla SOA faz-nos lembrar logo de WebServices e o protocolo SOAP. Mas não estou me referindo a esta tecnologia.&lt;/p&gt;

&lt;p&gt;Microservices, na minha opinião, deve ser algo mais simples de construir e utilizar. Devem utilizar o padrão REST. Devem ser fácies de serem substituídos e reescritos em qualquer linguagem que possa interagir com requisições HTTP.&lt;/p&gt;

&lt;h2 id=&quot;o-projeto&quot;&gt;O Projeto&lt;/h2&gt;

&lt;p&gt;O ERP foi codificado em Delphi 7 e os Microservices — por determinação da empresa — será codificado em Java.&lt;/p&gt;

&lt;p&gt;O protocolo de comunicação é HTTP e REST.&lt;/p&gt;

&lt;p&gt;Os dados serão transportados utilizando XML, mas houveram argumentos em utilizar JSON. Bem, o Delphi 7 não tem uma &lt;em&gt;Lib&lt;/em&gt; padrão de JSON, mas tem uma &lt;em&gt;Lib&lt;/em&gt; padrão para interagir com XML, utilizando &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;, que funciona muito bem.&lt;/p&gt;

&lt;p&gt;Não irei comentar sobre o código em Java, pois é irrelevante. Esses artigos irão demonstrar como codificar a parte &lt;em&gt;Client&lt;/em&gt; e não a &lt;em&gt;Server&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Também não irei entrar em detalhes de cada Microservice, pois trata-se de código privado.&lt;/p&gt;

&lt;p&gt;Mas vou lhe apresentar a infra estrutura, a parte genérica do código que pode ser utilizado por qualquer outro software &lt;em&gt;Object Pascal&lt;/em&gt;. Qualquer outro detalhe mais específico desse projeto será omitido, por questões óbvias.&lt;/p&gt;

&lt;p&gt;Então, a perguta é:&lt;/p&gt;

&lt;p&gt;Como codificar uma API simples e Orientada a Objetos, para o compilador do Delphi 7, que possa ser utilizada em qualquer outro projeto Object Pascal?&lt;/p&gt;

&lt;p&gt;Vamos aos módulos.&lt;/p&gt;

&lt;h2 id=&quot;mdulo-web&quot;&gt;Módulo Web&lt;/h2&gt;

&lt;p&gt;Um sistema precisa ser &lt;a href=&quot;/posts/nomeando-unidades/&quot;&gt;modularizado&lt;/a&gt; o suficiente para haver o reaproveitamento de código em outros sistemas ou em outros módulos.&lt;/p&gt;

&lt;p&gt;Esse Módulo tem 2 &lt;em&gt;units&lt;/em&gt; de Classes que são relevantes para essa implementação.&lt;/p&gt;

&lt;h3 id=&quot;unit-weba&quot;&gt;Unit AcmeWebA.pas&lt;/h3&gt;

&lt;p&gt;Essa &lt;em&gt;unit&lt;/em&gt; encasula tudo que é genérico sobre Web.&lt;/p&gt;

&lt;p&gt;A Classe mais relevante é a &lt;code&gt;TWebURL&lt;/code&gt;, que será utilizada na solução.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TWebURL = class(TInterfacedObject, IWebURL)
  private
    FServer: string;
    FPathInfo: string;
    FPort: Integer;
  public
    constructor Create(const Server, PathInfo: string; 
      Port: Integer); reintroduce;
    class function New(const Server, PathInfo: string; 
      Port: Integer): IWebURL;
    function Server: string;
    function PathInfo: string;
    function Port: Integer;
    function AsString: string;
  end;

implementation

{ TWebURL }

constructor TWebURL.Create(const Server, PathInfo: string; 
  Port: Integer);
begin
  inherited Create;
  FServer := Server;
  FPathInfo := PathInfo;
  FPort := Port;
end;

class function TWebURL.New(const Server, PathInfo: string;
  Port: Integer): IWebURL;
begin
  Result := Create(Server, PathInfo, Port);
end;

function TWebURL.Server: string;
begin
  Result := FServer;
end;

function TWebURL.PathInfo: string;
begin
  Result := FPathInfo;
end;

function TWebURL.Port: Integer;
begin
  Result := FPort;
end;

function TWebURL.AsString: string;
begin
  Result := Format(
    &#39;http://%s:%d%s&#39;, [
      FServer, FPort, FPathInfo
    ]
  );
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;unit-webhttpa&quot;&gt;Unit AcmeWebHttpA.pas&lt;/h3&gt;

&lt;p&gt;Essa &lt;em&gt;unit&lt;/em&gt; encapsula o protocolo HTTP.&lt;/p&gt;

&lt;p&gt;A Classe mais relevante é a &lt;code&gt;THttpClient&lt;/code&gt;. Essa Classe ainda deve ser refatorada para utilizar instâncias de &lt;code&gt;TWebURL&lt;/code&gt; ao invés de URL’s do tipo &lt;code&gt;string&lt;/code&gt; — código real nunca é perfeito.&lt;/p&gt;

&lt;p&gt;Internamente é utilizada o &lt;em&gt;framework&lt;/em&gt; &lt;a href=&quot;http://synapse.ararat.cz/doku.php/download&quot;&gt;Synapse&lt;/a&gt; que implementa o protocolo HTTP. Quem já conhece esse &lt;em&gt;framework&lt;/em&gt; não terá dificuldade para entender o código. Se ainda não conhece, sugiro baixar seus fontes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  THttpResponse = class(TInterfacedObject, IHttpResponse)
  private
    FCode: Integer;
    FStream: IDataStream;
  public
    constructor Create(Code: Integer; 
      Stream: IDataStream); reintroduce;
    class function New(Code: Integer; 
      Stream: IDataStream): IHttpResponse; overload;
    function Code: Integer;
    function Stream: IDataStream;
  end;

  EHttpClient = class(Exception);

  THttpClient = class(TInterfacedObject, IHttpClient)
  private
    FURL: string;
    FMimeType: string;
    FStream: TStringStream;
    function Send(const Method: string): IHttpResponse;
  public
    constructor Create(const URL, MimeType: string; 
      Stream: IDataStream); reintroduce;
    class function New(const URL, MimeType: string; 
      Stream: IDataStream): IHttpClient; overload;
    class function New(const URL, MimeType: string; 
      Stream: TStream): IHttpClient; overload;
    class function New(const URL, MimeType: string): IHttpClient; overload;
    destructor Destroy; override;
    function Execute(const Verb: string): IHttpResponse;
    function Get: IHttpResponse;
    function Post: IHttpResponse;
  end;

implementation

uses
  // synapse
  httpsend, synacode, synautil, ssl_openssl;

{ THttpResponse }

constructor THttpResponse.Create(Code: Integer; 
  Stream: IDataStream);
begin
  inherited Create;
  FCode := Code;
  FStream := Stream;
end;

class function THttpResponse.New(Code: Integer;
  Stream: IDataStream): IHttpResponse;
begin
  Result := Create(Code, Stream);
end;

function THttpResponse.Code: Integer;
begin
  Result := FCode;
end;

function THttpResponse.Stream: IDataStream;
begin
  Result := FStream;
end;

{ THttpClient }

function THttpClient.Send(const Method: string): IHttpResponse;
var
  URL: string;
begin
  URL := FURL;
  with THTTPSend.Create do
  try
    try
      MimeType := FMimeType;
      if Method = &#39;GET&#39; then
        URL := URL + FStream.DataString
      else
        WriteStrToStream(Document, FStream.DataString);
      if not HTTPMethod(Method, URL) then
        raise Exception.Create(Sock.LastErrorDesc);
      Document.Position := soFromBeginning;
    except
      on E: Exception do
        raise EHttpClient.Create(
          E.Message +
          #13&#39;Method: &#39; + Method +
          #13&#39;Code: &#39; + IntToStr(ResultCode)
        );
    end;
  finally
    Result := THttpResponse.New(
      ResultCode, 
      TDataStream.New(Document)
    );
    Free;
  end;
end;

constructor THttpClient.Create(const URL, MimeType: string; 
  Stream: IDataStream);
begin
  inherited Create;
  FURL := URL;
  FMimeType := MimeType;
  FStream := TStringStream.Create(&#39;&#39;);
  Stream.Save(FStream);
end;

class function THttpClient.New(const URL, MimeType: string; 
  Stream: IDataStream): IHttpClient;
begin
  Result := Create(URL, MimeType, Stream);
end;

class function THttpClient.New(const URL, MimeType: string; 
  Stream: TStream): IHttpClient;
begin
  Result := New(URL, MimeType, TDataStream.New(Stream));
end;

class function THttpClient.New(const URL, MimeType: string): IHttpClient;
begin
  Result := New(URL, MimeType, TDataStream.New);
end;

destructor THttpClient.Destroy;
begin
  FStream.Free;
  inherited;
end;

function THttpClient.Execute(const Verb: string): IHttpResponse;
begin
  Result := Send(Verb);
end;

function THttpClient.Get: IHttpResponse;
begin
  Result := Execute(&#39;GET&#39;);
end;

function THttpClient.Post: IHttpResponse;
begin
  if FStream.Size = 0 then
    raise EHttpClient.Create(&#39;HTTP.Send: No data.&#39;);
  Result := Execute(&#39;POST&#39;);
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O mais importante na Classe &lt;code&gt;THttpClient&lt;/code&gt; é seu método &lt;code&gt;Send&lt;/code&gt;, mas não tem nada complicado.&lt;/p&gt;

&lt;p&gt;Veja essa parte:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if Method = &#39;GET&#39; then
  URL := URL + FStream.DataString
else
  WriteStrToStream(Document, FStream.DataString);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Caso o VERBO seja GET, então &lt;code&gt;FStream&lt;/code&gt; irá conter um PATH_INFO para complementar a URL. Do contrário, &lt;code&gt;FStream&lt;/code&gt; irá conter um BODY, ou seja, um XML de requisição com os parâmetros necessários para o Microservice.&lt;/p&gt;

&lt;h2 id=&quot;no-proximo-artigo&quot;&gt;No próximo artigo…&lt;/h2&gt;

&lt;p&gt;Até aqui nada de mais. Você viu apenas algumas Classes simples que encapsulam &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidades&lt;/a&gt; reais, utilizando Orientação a Objetos.&lt;/p&gt;

&lt;p&gt;No &lt;a href=&quot;/posts/microservices-delphi-parte-2/&quot;&gt;próximo artigo&lt;/a&gt; escrevo sobre o módulo &lt;code&gt;MicroService&lt;/code&gt; que contém todas as Classes que fazem a comunicação com os Microservices codificados em Java.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Aug 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/microservices-delphi-parte-1/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/microservices-delphi-parte-1/</guid>
      </item>
    
      <item>
        <title>Classes de Dados</title>
        <description>&lt;p&gt;Objetos são constituídos de Estado e Comportamento, enviam mensagens uns aos outros e devem representar Entidades reais de tudo que existe fora do Contexto do Software.&lt;/p&gt;

&lt;p&gt;E os Dados, onde estão os Dados?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1457904375453-3e1fc2fc76f4.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Tenho dito, por várias vezes, que um Objeto não deve ser visto ou utilizado como um &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/#objeto-nao-e-um-balde-de-funcoes-e-dados&quot;&gt;balde de dados e funções&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Objetos não são &lt;a href=&quot;/posts/datamodule-e-apenas-um-container/&quot;&gt;&lt;em&gt;containers&lt;/em&gt;&lt;/a&gt; de transporte de dados. Eles devem &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;representar uma Entidade&lt;/a&gt; fora do Contexto do Software. Não importa se a Entidade é um objeto, pessoa ou Dados.&lt;/p&gt;

&lt;p&gt;E o que são Dados?&lt;/p&gt;

&lt;p&gt;É difícil definir a diferença entre Dados e o Estado de um Objeto. Ambos, tecnicamente, podem ser considerados Dados. No entanto, eu acredito, há uma diferença teórica entre eles que muda nosso &lt;strong&gt;modo de pensar&lt;/strong&gt; quando estamos construindo um &lt;em&gt;software&lt;/em&gt; Orientado a Objetos.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dados também são representados por Objetos, pois eles também estão fora do Contexto do Software.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mas como um Objeto não deve ser um “balde de dados” e ao mesmo tempo deve representar Dados?&lt;/p&gt;

&lt;h2 id=&quot;dados-e-estado&quot;&gt;Dados e Estado&lt;/h2&gt;

&lt;p&gt;Tudo são Objetos.&lt;/p&gt;

&lt;p&gt;Tudo deve ser representado por Objetos.&lt;/p&gt;

&lt;p&gt;Não há diferenças, pensando em termos de Objetos, entre um &lt;strong&gt;Carro&lt;/strong&gt; e o &lt;strong&gt;número 9&lt;/strong&gt;, por exemplo. Ambos são Entidades que deveriam ser representados dentro do &lt;em&gt;software&lt;/em&gt; por Objetos.&lt;/p&gt;

&lt;p&gt;Mas a vida é difícil. Desenvolver &lt;em&gt;software&lt;/em&gt; Orientado a Objetos de forma &lt;em&gt;perfeita&lt;/em&gt; é quase impossível. Precisamos pensar na performance, na alocação de memória, uso de recursos, etc. E aí começa a confusão entre Dados e Estado.&lt;/p&gt;

&lt;p&gt;Vejamos. Se tenho uma Classe &lt;code&gt;TUrl&lt;/code&gt; com uma propriedade privada &lt;code&gt;FValue: string&lt;/code&gt;, a propriedade é um &lt;strong&gt;Dado&lt;/strong&gt; ou o &lt;strong&gt;Estado&lt;/strong&gt; do Objeto?&lt;/p&gt;

&lt;p&gt;Eu diria que representa o Estado do Objeto. A propriedade &lt;code&gt;FValue&lt;/code&gt; é a URL em forma de string.&lt;/p&gt;

&lt;p&gt;Mas como &lt;code&gt;string&lt;/code&gt; é um tipo primitivo (no Pascal), pensamos em termos de Dados e não de Estado do Objeto.&lt;/p&gt;

&lt;p&gt;Vejamos outro exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TFile = class(TInterfacedObject, IFile)
  private
    FPath: string;
    FName: string;
    FStream: IDataStream;
  public
    constructor Create(const Path, Name: string; 
      Stream: IDataStream);
    function Path: string;
    function Name: string;
    function Stream: IDataStream; 
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima, tem diferença entre Dados e Estado?&lt;/p&gt;

&lt;p&gt;Sim.&lt;/p&gt;

&lt;p&gt;Todas as 3 propriedades fazem parte do Estado do Objeto, no entanto a propriedade &lt;code&gt;FStream&lt;/code&gt; representa os Dados do arquivo que estão no HD do computador.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TFile&lt;/code&gt; faz uso da Composição de Objetos. Não olhamos para &lt;code&gt;TFile&lt;/code&gt; como um &lt;em&gt;container&lt;/em&gt; de &lt;em&gt;bytes&lt;/em&gt;, mas como um Objeto que representa um Arquivo no computador.&lt;/p&gt;

&lt;p&gt;Mas, se olharmos apenas para o Objeto &lt;code&gt;FStream&lt;/code&gt; dentro de &lt;code&gt;TFile&lt;/code&gt;, ele poderia ser implementado assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TDataStream = class sealed(TInterfacedObject, IDataStream)
  private
    FStream: TMemoryStream;
  public
    constructor Create(Stream: TStream);
    destructor Destroy; override;
    procedure Save(Stream: TStream); overload;
    procedure Save(const FileName: string); overload;
    function Size: Int64;
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora o Contexto mudou.&lt;/p&gt;

&lt;p&gt;A propriedade &lt;code&gt;FStream&lt;/code&gt; na Classe &lt;code&gt;TDataStream&lt;/code&gt; representa o Estado do Objeto e não Dados do Objeto. Essa Classe representa um &lt;em&gt;stream&lt;/em&gt; mas ela não sabe se o &lt;em&gt;stream&lt;/em&gt; é proveniente de um Arquivo ou de registros em uma Tabela.&lt;/p&gt;

&lt;p&gt;Estamos olhando para um novo Contexto e isso muda nossa percepção sobre o que é ou não Dados.&lt;/p&gt;

&lt;p&gt;Veja que internamente &lt;code&gt;TDataStream&lt;/code&gt; foi implementado utilizando um &lt;code&gt;TMemoryStream&lt;/code&gt; para “guardar” o &lt;em&gt;stream&lt;/em&gt; — mais uma vez utilizando Composição de Objetos — mas eu poderia optar por utilizar apenas &lt;em&gt;bytes&lt;/em&gt; e um ponteiro para a memória. Não importa. Isso tudo é privado e ninguém sabe o que acontece dentro de um Objeto. O importante é saber distinguir a diferença entre Dados e Estado do Objeto.&lt;/p&gt;

&lt;h2 id=&quot;dados-na-forma-de-objetos&quot;&gt;Dados na forma de Objetos&lt;/h2&gt;

&lt;p&gt;Classes de Dados são aquelas que geram Objetos que representam Dados.&lt;/p&gt;

&lt;p&gt;Nós utilizamos Dados na forma de Objetos a muito tempo.&lt;/p&gt;

&lt;p&gt;Uma Classe &lt;code&gt;TJsonObject&lt;/code&gt; representa um &lt;em&gt;stream&lt;/em&gt; de JSON, assim como uma Classe &lt;code&gt;TXmlDocument&lt;/code&gt; representa um &lt;em&gt;stream&lt;/em&gt; de XML.&lt;/p&gt;

&lt;p&gt;Se não tivéssemos essas Classes, teríamos que trabalhar os Dados no nível de &lt;em&gt;bytes&lt;/em&gt; e ponteiros na memória. Programação Procedural.&lt;/p&gt;

&lt;p&gt;Queremos utilizar Objetos, pois eles facilitam nossas vidas. Então encapsulamos arquivos, &lt;em&gt;streams&lt;/em&gt;, registros de Tabelas, etc em Classes que geram Objetos para manipular os Dados.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Não há problema se seu Objeto encapsula apenas Dados, contanto que esses Dados fazem parte da Entidade real que seu Objeto está representando.&lt;/p&gt;

&lt;p&gt;Entender a sutil diferença entre Dados e Estado do Objeto irá fazer você codificar Classes melhores.&lt;/p&gt;

&lt;p&gt;Você não irá mais pensar em definir uma única Classe que encapsula todos os Dados, mas sim Classes que representam Entidades, que utilizam a Composição de Objetos para Encapsular outros Objetos que, por fim, irão representar os Dados.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Aug 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/classes-de-dados/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/classes-de-dados/</guid>
      </item>
    
      <item>
        <title>Nomeando Variáveis e Métodos</title>
        <description>&lt;p&gt;A nomenclatura correta de Variáveis e Métodos simplifica e melhora o entendimento do código.&lt;/p&gt;

&lt;p&gt;Basicamente há uma única Regra para nomear ambos: &lt;strong&gt;Não utilize prefixos&lt;/strong&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-08208oju93773-4746gf33.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A regra de &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nomenclatura para Classes&lt;/a&gt; é sobre utilizar um prefixo (contexto) além do seu nome.&lt;/p&gt;

&lt;p&gt;A primeira regra de &lt;a href=&quot;/posts/nomeando-unidades/&quot;&gt;nomenclatura para Unidades&lt;/a&gt; é sobre utilizar prefixos.&lt;/p&gt;

&lt;p&gt;Ambas as regras falam sobre prefixos. O maior objetivo para os utilizarmos é evitar colisões de nomes. Unidades e Classes podem ser utilizadas globalmente em todo o projeto e por isso precisam ter nomes que minimizam ao máximo ambiguidades.&lt;/p&gt;

&lt;p&gt;No entanto, ao nomear Variáveis ou Métodos na programação &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientada a Objetos&lt;/a&gt;, você deve esquecer os prefixos.&lt;/p&gt;

&lt;p&gt;Prefixos de qualquer tipo, esqueça-os.&lt;/p&gt;

&lt;h2 id=&quot;variaveis&quot;&gt;Nomeando Variáveis&lt;/h2&gt;

&lt;p&gt;Acho que não preciso lembrá-lo que utilizar &lt;a href=&quot;/posts/singleton-e-um-anti-padrao/#variaveis-globais&quot;&gt;variáveis globais&lt;/a&gt; é um anti-padrão.&lt;/p&gt;

&lt;p&gt;Então toda variável é, ou deveria ser, local.&lt;/p&gt;

&lt;p&gt;Se variáveis são locais, não deveria haver colisões de nomes. Se não há colisões de nomes, por que utilizar prefixos?&lt;/p&gt;

&lt;p&gt;Mas o problema — você deve estar pensando — é que há colisões de nomes de variáveis até mesmo dentro de um único método. Pode não ser exatamente uma colisão de nome onde o compilador não conseguir ir adiante. Talvez haja só uma confusão de nomes, daquelas que você olha o código e pensa:&lt;/p&gt;

&lt;p&gt;“Essa é uma variável-atributo, uma variável local ou argumento do método?&lt;/p&gt;

&lt;p&gt;Acontece, certo?&lt;/p&gt;

&lt;p&gt;Bem, continue lendo.&lt;/p&gt;

&lt;h2 id=&quot;metodos&quot;&gt;Nomeando Métodos&lt;/h2&gt;

&lt;p&gt;Métodos de uma Classe definem a implementação de um &lt;a href=&quot;/posts/interfaces-em-todo-lugar/#interfaces-sao-contratos&quot;&gt;contrato&lt;/a&gt; de uma Interface.&lt;/p&gt;

&lt;p&gt;Toda Classe deveria implementar apenas uma &lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/#unica-responsabilidade&quot;&gt;única responsabilidade&lt;/a&gt;. Se a Classe tem apenas uma única responsabilidade, dificilmente você irá utilizar prefixos nos métodos.&lt;/p&gt;

&lt;p&gt;Veja nesse &lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/#implementacao-tradicional&quot;&gt;exemplo de código&lt;/a&gt; os métodos &lt;code&gt;SaveXxx&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A palavra &lt;code&gt;Save&lt;/code&gt; é um prefixo — nem sempre um nome composto será um prefixo, mas nesse caso ele é.&lt;/p&gt;

&lt;p&gt;Compare agora com a &lt;a href=&quot;/posts/classes-devem-implementar-apenas-uma-responsabilidade/#implementacao-oo&quot;&gt;versão&lt;/a&gt; Orientada a Objetos e verá que as Classes ficaram muito mais simples, utilizando nomes de métodos simples. Cada Classe só implementa apenas uma única responsabilidade. Por isso seus Métodos são simples e diretos.&lt;/p&gt;

&lt;p&gt;Consegue ver a diferença?&lt;/p&gt;

&lt;h2 id=&quot;o-que-esta-errado&quot;&gt;O que há de errado com Prefixos?&lt;/h2&gt;

&lt;p&gt;Os prefixos podem ser o mais diversos.&lt;/p&gt;

&lt;p&gt;Quando comecei a programar eu utilizava a &lt;a href=&quot;https://en.wikipedia.org/wiki/Hungarian_notation&quot;&gt;notação húngara&lt;/a&gt;. Também já utilizei outros prefixos, dependendo da empresa/projeto.&lt;/p&gt;

&lt;p&gt;Meu último “padrão pessoal de prefixo” foi utilizar um “l” (L minúsculo) para qualquer variável local…&lt;/p&gt;

&lt;p&gt;Nada disso era ou é necessário.&lt;/p&gt;

&lt;p&gt;Utilizamos prefixos em Métodos e Variáveis com o mesmo objetivo de quando nomeamos Classes e Unidades: evitar a colisão de nomes.&lt;/p&gt;

&lt;p&gt;É isso, não é?&lt;/p&gt;

&lt;p&gt;Bem, se você está fazendo isso — como eu mesmo fiz durante muito tempo — eu tenho que lhe dizer:&lt;/p&gt;

&lt;p&gt;Seu código &lt;strong&gt;não&lt;/strong&gt; tem um bom &lt;em&gt;design&lt;/em&gt;. Ele está acoplado e não está modularizado o sufiente.&lt;/p&gt;

&lt;p&gt;Se você está utilizando prefixos em Variáveis dentro de um método, quer dizer que seu Método está fazendo coisas demais. Você precisa identificar “quem é quem” dentro de um código possivelmente grande. Isso é errado. Refatore.&lt;/p&gt;

&lt;p&gt;Alias, aqui vai uma &lt;strong&gt;dica&lt;/strong&gt;: Refatore o Método que tiver utilizando mais de 5 variáveis.&lt;/p&gt;

&lt;p&gt;Se você está utilizando prefixos em Métodos, sua Classe está fazendo coisas demais. Esses Métodos com prefixos estão “gritando” à você que eles pertencem a outra Classe e que não deveriam estar ali! Isso é muito mais errado. Refatore imediatamente.&lt;/p&gt;

&lt;p&gt;Variáveis e Métodos devem ter o nome mais simples possível. Isso deveria ser um requisito de &lt;em&gt;design&lt;/em&gt;, uma restrição. Toda restrição impõe limites, que leva a regras, que leva a uma melhor organização de todo o código.&lt;/p&gt;

&lt;h2 id=&quot;argumentos-dos-metodos&quot;&gt;Argumentos dos Métodos&lt;/h2&gt;

&lt;p&gt;E para Argumentos dos Métodos, é necessário algum prefixo?&lt;/p&gt;

&lt;p&gt;Você continua não precisando de prefixos, mas Argumentos podem ter nomes mais verbosos a fim de facilitar o uso do Método, sem que o programador tenha que ler alguma documentação.&lt;/p&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; tem mais uma particularidade: Não é &lt;em&gt;case-sensitive&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por isso utilizamos prefixos como “T” para Classes, “I” para Interfaces, “P” para tipos ponteiro, etc. Nessa mesma linha de pensamento, alguns programadores utilizam o prefixo “A” para Argumentos.&lt;/p&gt;

&lt;p&gt;Não vejo problema nessa prática. No entanto se você codificar Classes e Métodos pequenos, talvez não será necessário utilizar nenhum prefixo nos argumentos, pois haverá pouco código para existência de conflitos de nomes.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Escolher bons nomes para Métodos e Variáveis é bem mais simples que escolher nomes para Unidades, Classes e Interfaces, mas ainda assim é uma arte.&lt;/p&gt;

&lt;p&gt;Novamente lhe digo que não existe o &lt;strong&gt;certo absoluto&lt;/strong&gt;. Talvez o padrão de nomenclatura que você já utiliza seja melhor pra você. Tudo bem. Mas o que tenho observado ao longo de alguns anos é que a minha “obrigação” de utilizar nomes mais simples deixa o código melhor. Não apenas por causa dos nomes em si, mas devido as Classes implementarem apena uma única responsabilidade, sendo os nomes uma espécie de métrica para verificar essa prática.&lt;/p&gt;

&lt;p&gt;Após anos de desenvolvimento, utilizando dezenas de padrões de nomenclatura em diversas empresas e projetos distintos, cheguei a conclusão que o “não-padrão” — sem prefixos e sem burocracia — é o melhor. É como estar organizado, sem organizar. Faz sentido?&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jul 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/nomeando-variaveis-e-metodos/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/nomeando-variaveis-e-metodos/</guid>
      </item>
    
      <item>
        <title>Nomeando Unidades</title>
        <description>&lt;p&gt;Acredito que todos os nomes de Unidades em um Projeto &lt;em&gt;Object Pascal&lt;/em&gt;, quiça em qualquer outra linguagem, deveriam ser hierárquicos do mais genérico para o mais específico.&lt;/p&gt;

&lt;p&gt;Neste artigo irei escrever sobre a lógica em utilizar uma nomenclatura hieraquizada para deixar seu projeto mais coeso e elegante.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/photo-1434030216411-0b793f4b4173.jpg&quot; alt=&quot;Imagem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Foi-se o tempo quando programávamos utilizando nomes de Unidades como: &lt;code&gt;uUtils&lt;/code&gt;, &lt;code&gt;uPerson&lt;/code&gt;, &lt;code&gt;frmClient&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;Em projetos pequenos tais nomes de Unidades ainda são utilizados (será?), mas essa nomenclatura não é nada profissional.&lt;/p&gt;

&lt;p&gt;Por quê?&lt;/p&gt;

&lt;p&gt;O motivo é que uma Unidade deve encapsular um Contexto &lt;strong&gt;bem definido&lt;/strong&gt;. Um Contexto pode ser genérico ou ser uma especialização.&lt;/p&gt;

&lt;p&gt;Um nome de Unidade como esses acima não transmitem um Contexto bem definido.&lt;/p&gt;

&lt;p&gt;Para que a idéia de Contexto fique clara, uma Unidade deve ter um nome sem ambiguidades.&lt;/p&gt;

&lt;p&gt;Veja esse exemplo de nomes de Unidades:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;frmClient&lt;/li&gt;
  &lt;li&gt;AcmeClientEditForm&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Qual dos nomes é mais claro, passando imediatamente a ideia do que essa Unidade faz?&lt;/p&gt;

&lt;p&gt;O item #2, é claro.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;Acme&lt;/code&gt; é o nome do Projeto ou nome da Empresa.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Client&lt;/code&gt; é o Contexto mais genérico.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Edit&lt;/code&gt; é o Contexto mais específico.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Form&lt;/code&gt; determina hierarquia da Classe ou o seu propósito.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A medida que um projeto cresce e novas Unidades são inseridas, colisões de nomes podem ocorrer. Ter bons nomes de Unidades no projeto fará muita diferença no longo prazo. Será mais fácil determinar o impacto de alguma alteração apenas olhando a hierarquia no nome da Unidade.&lt;/p&gt;

&lt;p&gt;Mas existem regras ou dicas para escolhermos bons nomes de Unidades?&lt;/p&gt;

&lt;p&gt;É o que iremos ver a seguir.&lt;/p&gt;

&lt;h2 id=&quot;regra-1-prefixos&quot;&gt;Regra 1: Prefixos&lt;/h2&gt;

&lt;p&gt;Um nome de Unidade hieraquizado nada mais é do que utilizar &lt;strong&gt;prefixos&lt;/strong&gt;. A cada prefixo adicionado, damos o nome de Contexto. O nome para cada Contexto ou prefixo utilizado vai depender de cada projeto.&lt;/p&gt;

&lt;p&gt;Um Contexto pode identificar uma tecnologia, protocolo, setor da empresa, entidade ou até mesmo um outro sistema.&lt;/p&gt;

&lt;p&gt;Para sistemas comerciais, o próprio usuário irá lhe dar os nomes desses Contextos. Os nomes dos setores na empresa serão o ponto de partida.&lt;/p&gt;

&lt;h2 id=&quot;regra-2-nome-do-projeto-ou-empresa&quot;&gt;Regra 2: Nome do Projeto ou Empresa&lt;/h2&gt;

&lt;p&gt;Toda Unidade deve ser precedida com o nome do Projeto ou nome da Empresa.&lt;/p&gt;

&lt;p&gt;Se teus projetos são feitos somente dentro de tua empresa para seu próprios clientes, basta utilizar o nome do Projeto como prefixo para todas as Unidades.&lt;/p&gt;

&lt;p&gt;Caso sua empresa faça &lt;em&gt;frameworks&lt;/em&gt; ou projetos OpenSource, ou seja, se o projeto terá um contexto mais global, é uma boa ideia utilizar o nome da Empresa como prefixo.&lt;/p&gt;

&lt;p&gt;Qual dos dois será utilizado dependerá do propósito geral do Projeto.&lt;/p&gt;

&lt;h2 id=&quot;regra-3-generico-para-especializado&quot;&gt;Regra 3: Genérico para o mais Especializado&lt;/h2&gt;

&lt;p&gt;O nome de uma Unidade deve ser hierarquizado do mais genérico para o mais especializado.&lt;/p&gt;

&lt;p&gt;No artigo sobre &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;Nomenclatura de Classes&lt;/a&gt; eu lhes dei um exemplo de nomenclatura (errada) para uma hipotética Classe do meu &lt;a href=&quot;https://github.com/mdbs99/aws&quot;&gt;Projeto AWS&lt;/a&gt; que foi &lt;code&gt;TAWSNetHTTPClient&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O nome de uma Classe não deve ser uma hierarquia.&lt;/p&gt;

&lt;p&gt;Classes nem deveriam fazer parte de uma &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;hieraquia de herança&lt;/a&gt; na maioria das vezes.&lt;/p&gt;

&lt;p&gt;A hierarquia deve estar no nome da Unidade.&lt;/p&gt;

&lt;p&gt;Então como ficariam os nomes, da Classe e da Unidade, considerando o exemplo acima?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Unidade: AWSNetHttpClient&lt;/li&gt;
  &lt;li&gt;Classe: THttpClient&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O &lt;code&gt;Http&lt;/code&gt; se repete no nome da Classe. O motivo é porque o nome da Classe deve ser constituído de &lt;strong&gt;Contexto + Nome&lt;/strong&gt;, conforme já explicado &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Outros exemplos de bons nomes para Unidades:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AcmeData&lt;/li&gt;
  &lt;li&gt;AcmeDataXml&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AcmeDataJson&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;AcmeReport&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AcmeReportRBuilder&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;AcmeWeb&lt;/li&gt;
  &lt;li&gt;AcmeWebHttp&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AcmeWebFtp&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;AcmeFinances&lt;/li&gt;
  &lt;li&gt;AcmeFinancesClient&lt;/li&gt;
  &lt;li&gt;AcmeFinancesClientReports&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;regra-4-interfaces-e-classes&quot;&gt;Regra 4: Interfaces numa Unidade, Classes noutra&lt;/h2&gt;

&lt;p&gt;Toda Classe deveria &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;implementar ao menos uma Interface&lt;/a&gt; e todo o Projeto deveria trabalhar com variáveis e argumentos do tipo Interface. Dessa forma um argumento poderia receber qualquer instância de Classe que implementa o tipo da Interface.&lt;/p&gt;

&lt;p&gt;Então temos que definir as Interfaces numa Unidade e suas implementações &lt;em&gt;default&lt;/em&gt; em outra Unidade. Caso o programador queira codificar sua própria implementação da Interface, ele só precisa adicionar no &lt;em&gt;uses&lt;/em&gt; apenas a Unidade que contém as Interfaces.&lt;/p&gt;

&lt;p&gt;Como nomear ambas as Unidades?&lt;/p&gt;

&lt;p&gt;Bem, eu utilizo uma nomenclatura que a princípio você não verá muita lógica, mas ficou como um costume pra mim. Talvez você pense numa nomenclatura melhor e nos diga na área de comentários.&lt;/p&gt;

&lt;p&gt;Vamos lá. Para Unidades sobre Finanças, por exemplo, eu teria o seguinte:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Unidade das Interfaces: AcmeFinances&lt;/li&gt;
  &lt;li&gt;Unidade das Classes: AcmeFinancesA&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Isso aí. Apenas a letra &lt;code&gt;A&lt;/code&gt; como sufixo.&lt;/p&gt;

&lt;p&gt;O motivo é que as Unidades são exibidas em ordem alfabética, então a Unidade de Interfaces virá antes da Unidade de Classes.&lt;/p&gt;

&lt;p&gt;Caso eu tenha outro sub prefixo que também começe com &lt;code&gt;A&lt;/code&gt;, exemplo &lt;code&gt;AcmeFinancesAction&lt;/code&gt;, ainda assim a ordem visual seria mantida, do mais genérico para o mais especializado.&lt;/p&gt;

&lt;h2 id=&quot;regra-5-unidade-especializada&quot;&gt;Regra 5: Uma Unidade especializada utiliza a mais genérica, nunca o contrário&lt;/h2&gt;

&lt;p&gt;Essa regra é clara, mas sempre é bom lembrar que uma Unidade genérica &lt;strong&gt;nunca&lt;/strong&gt; poderá ter um &lt;em&gt;uses&lt;/em&gt; para uma mais especializada dentro da mesma hierarquia.&lt;/p&gt;

&lt;p&gt;Veja o esquema abaixo:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;AcmeFinances&lt;/li&gt;
  &lt;li&gt;AcmeFinancesClient » uses AcmeFinances&lt;/li&gt;
  &lt;li&gt;AcmeFinancesClientReports » uses AcmeFinancesClient&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;regra-6-unidade-nao-pertence-ao-projeto&quot;&gt;Regra 6: Se uma Unidade está sendo utilizada em muitas outras hierarquias, ela não pertence ao Projeto&lt;/h2&gt;

&lt;p&gt;Se uma Unidade ou um pequeno conjunto delas, sempre aparecem no &lt;em&gt;uses&lt;/em&gt; de várias hierarquias diferentes, isso pode indicar que essa(s) Unidade(s) não fazem parte do &lt;em&gt;core&lt;/em&gt; do projeto devem ser refatoradas/extraídas para outro projeto ou &lt;em&gt;package&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se essas Unidades podem ser reaproveitadas em outros projetos por serem muito genéricas, é também outro grande indício para refatorar e extraí-las do projeto.&lt;/p&gt;

&lt;h2 id=&quot;bnus&quot;&gt;Bônus&lt;/h2&gt;

&lt;h3 id=&quot;unidades-pontilhadas&quot;&gt;Nomes de Unidades Pontilhadas&lt;/h3&gt;

&lt;p&gt;Hoje e dia o Delphi e FreePascal/Lazarus tem suporte para “Nomes de Unidades Pontilhadas”, ou seja, podemos nomear uma Unidade utilizando pontos que separam contextos. No Java sempre foi assim e o .NET fez igual.&lt;/p&gt;

&lt;p&gt;E em que isso muda as regras acima?&lt;/p&gt;

&lt;p&gt;Nada.&lt;/p&gt;

&lt;p&gt;Sem considerar os pontos, não há nenhuma diferença técnica ou de utilização para utilizar &lt;code&gt;Acme.Finances.Client.Reports&lt;/code&gt; ao invés de &lt;code&gt;AcmeFinancesClientReports&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A “vantagem” em utilizar “Nomes de Unidades Pontilhadas”, na minha opinião, é apenas visual.&lt;/p&gt;

&lt;p&gt;Veja um exemplo:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;AcmeWebHTTPClient&lt;/li&gt;
  &lt;li&gt;Acme.Web.HTTP.Client&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A opção #2 é mais &lt;em&gt;clean&lt;/em&gt; que a opção #1 devido ao Contexto &lt;code&gt;HTTP&lt;/code&gt; ter sido escrito em maiúsculo.&lt;/p&gt;

&lt;p&gt;Obs.: Já ouvi falar que o compilador do Delphi atualmente tem parâmetros que podem selecionar um &lt;em&gt;namespace&lt;/em&gt; específico para compilar Unidades específicas e isso pode ter haver com esse tipo de nomenclatura que utiliza pontos. Caso você saiba mais sobre isso, porfavor deixei seu comentário.&lt;/p&gt;

&lt;h3 id=&quot;abreviacoes-maiusculas&quot;&gt;Abreviações em Pascal-case ou tudo em maiúsculas&lt;/h3&gt;

&lt;p&gt;Qual nomenclatura utilizar para abreviações, por exemplo, &lt;code&gt;HTTP&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Sendo &lt;code&gt;HTTP&lt;/code&gt; uma abreviação de &lt;em&gt;Hypertext Transfer Protocol&lt;/em&gt;, o mais correto na escrita seria &lt;code&gt;HTTP&lt;/code&gt; e não &lt;code&gt;Http&lt;/code&gt;. Mas visualmente, quando uma abreviação faz parte do nome de uma Classe, fica mais elegante ou mais fácil de ler utilizando Pascal-case.&lt;/p&gt;

&lt;p&gt;Teoricamente &lt;code&gt;THttpClient&lt;/code&gt; é mais fácil de ler do que &lt;code&gt;THTTPClient&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Mas nesse quesito eu mesmo ainda não tomei uma decisão. Algumas vezes eu utilizo tudo em maiúsculo, outras vezes em Pascal-case. Ainda tenho um conflito interior entre o “certo na escrita” vs. “visual elegante”.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Escolher bons nomes para Unidades, Classes, Interfaces e métodos sempre será uma arte. Não existe o &lt;strong&gt;certo absoluto&lt;/strong&gt;. Cada projeto nos dará seus requisitos e os nomes irão aparecer.&lt;/p&gt;

&lt;p&gt;Essas Regras podem ajudar, mas cabe ao arquiteto ter bom senso, conhecer bem o domínio e pensar bem antes de nomear suas Unidades.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Jul 2016 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/posts/nomeando-unidades/</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/posts/nomeando-unidades/</guid>
      </item>
    
  </channel>
</rss>
