<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Git-work Project</title>
        <description>&lt;p&gt;Git-work são extensões minimalistas para Git, fornecendo operações de repositório de alto nível.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-zachary-nelson-192289.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Zachary Nelson on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Git&lt;/em&gt;&lt;/strong&gt;, segundo a &lt;a href=&quot;https://pt.wikipedia.org/wiki/Git&quot;&gt;Wikipedia&lt;/a&gt;,
é um sistema de controle de versão distribuído e um sistema de gerenciamento de código fonte, com ênfase em velocidade. O Git foi inicialmente projetado e desenvolvido por Linus Torvalds para o desenvolvimento do kernel Linux, mas foi adotado por muitos outros projetos.&lt;/p&gt;

&lt;p&gt;Ele é o padrão atual para o controle de versão de softwares. Não há nenhum outro concorrente que seja tão simples e eficaz.&lt;/p&gt;

&lt;p&gt;Apesar de ser um magnífico sistema, por muito tempo não havia um padrão definido em como trabalhar em equipe ou mesmo sozinho, ou seja, como enviar de forma eficiente uma alteração feita por você; como ser eficaz ao trabalhar com &lt;em&gt;branches&lt;/em&gt;; se devemos trabalhar diretamente no &lt;code&gt;master&lt;/code&gt; ou em &lt;em&gt;branches&lt;/em&gt; secundários; como iniciar uma alteração quando o projeto recebe uma &lt;em&gt;issue&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Hoje em dia temos um padrão chamado &lt;code&gt;git flow&lt;/code&gt;. Ele vem instalado nas últimas versões do Git e você pode configurá-lo digitando &lt;code&gt;git flow&lt;/code&gt; na linha-de-comando.&lt;/p&gt;

&lt;p&gt;No entanto, ainda que o &lt;code&gt;git flow&lt;/code&gt; não seja um padrão complicado de se utilizar, ele não nos deixa customizá-lo de forma simples num único lugar (são alguns arquivos &lt;em&gt;bash&lt;/em&gt; que devem ser editados), é verboso e não define um padrão para as mensagens dos &lt;em&gt;commits&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nesse artigo eu irei lhe apresentar o meu mais novo “&lt;em&gt;pet project&lt;/em&gt;” chamado &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt;, que é uma alternativa minimalista ao &lt;code&gt;git flow&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;git-work&quot;&gt;O que é Git-work&lt;/h2&gt;

&lt;p&gt;Assim como o &lt;code&gt;git flow&lt;/code&gt;, o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; é uma coleção de extensões para a linha-de-comando do Git.&lt;/p&gt;

&lt;p&gt;O nome escolhido é devido a semântica ao digitar os comandos como, por exemplo, &lt;code&gt;git work done&lt;/code&gt; para concluir uma &lt;code&gt;issue&lt;/code&gt;. Legal, não?&lt;/p&gt;

&lt;p&gt;É um projeto extremamente novo (apenas alguns dias) porém com um grande potencial, na minha humilde opinião.&lt;/p&gt;

&lt;p&gt;São extensões minimalistas para Git, fornecendo operações de repositório de alto nível além de padronizar, um &lt;em&gt;fluxo de trabalho&lt;/em&gt; com os &lt;em&gt;branches&lt;/em&gt;, que poderá ser totalmente customizável.&lt;/p&gt;

&lt;h2 id=&quot;motivacao&quot;&gt;Motivação&lt;/h2&gt;

&lt;p&gt;Eu tentei (tento) utilizar alguns &lt;em&gt;clients&lt;/em&gt; para Git como &lt;a href=&quot;https://desktop.github.com/&quot;&gt;Github Desktop&lt;/a&gt;, &lt;a href=&quot;http://www.syntevo.com/smartgit/&quot;&gt;SmartGit&lt;/a&gt; ou &lt;a href=&quot;https://www.gitkraken.com/&quot;&gt;GitKraken&lt;/a&gt;. Apesar desses e dezenas de outras IDE’s serem ótimos produtos, podem ter restrições de uso, além da curva de aprendizado para utilizá-los.&lt;/p&gt;

&lt;p&gt;Além disso, no meu caso, eu utilizo Git em alguns computadores e não posso me dar ao luxo de ter que ficar atualizando e reconfigurando IDE’s em todos esses computadores caso eu queria mudar meu modo de trabalho.&lt;/p&gt;

&lt;p&gt;Eu sou um cara &lt;em&gt;“old-school”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Gosto das coisas mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e manuais. Gosto de saber o que está acontecendo nos “bastidores” quando clico num botão. Gosto de aprender a utilizar algo reduzindo-o à sua interface mais básica.&lt;/p&gt;

&lt;p&gt;Então voltei para a linha-de-commando, onde posso fazer literalmente tudo com o Git. &lt;a href=&quot;/posts/menos-e-mais/&quot;&gt;Menos é mais&lt;/a&gt;, certo?&lt;/p&gt;

&lt;p&gt;Mas a linha-de-comando pode ser assutadora quando você não conhece os comandos. E, mesmo depois de aprendê-los, pode ser ineficaz se você tiver que fazer &lt;em&gt;tudo&lt;/em&gt; de forma manual.&lt;/p&gt;

&lt;p&gt;Então como eu poderia utilizar a linha-de-comando, mas automatizar os comandos mais utilizados e, ao mesmo tempo, definir um fluxo de trabalho padronizado?&lt;/p&gt;

&lt;p&gt;A ideia de construir o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; me ocorreu após uma tarde de intenso trabalho e uso do Git em um projeto particular.&lt;/p&gt;

&lt;p&gt;Trabalhei em algumas &lt;em&gt;issues&lt;/em&gt; »»»»»&lt;/p&gt;

&lt;h2 id=&quot;features&quot;&gt;Características&lt;/h2&gt;

&lt;p&gt;Inicialmente eu pensei em codificar o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; em &lt;em&gt;Object Pascal&lt;/em&gt;. Sério. Porém vi que o mais simples a fazer seria utilizar &lt;em&gt;Bash scripts&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O Git é bem integrado com &lt;em&gt;Bash&lt;/em&gt; então… Por quê não?&lt;/p&gt;

&lt;p&gt;Criei o projeto no Github, codifiquei as primeiras características e subi os fontes.&lt;/p&gt;

&lt;p&gt;Então meu amigo &lt;a href=&quot;https://github.com/fabriciofx/&quot;&gt;Fabrício Cabral&lt;/a&gt; se interessou pelo projeto e começou a trabalhar e melhorar o código.&lt;/p&gt;

&lt;p&gt;No momento da escrita desse artigo já temos algumas funcionalidades.&lt;/p&gt;

&lt;p&gt;Após “instalar”, digite &lt;code&gt;git work&lt;/code&gt; para ver os comandos:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/git-work-1.jpg&quot; alt=&quot;git-work&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Esses comandos ainda serão aperfeiçoados, pois estão em constante desenvolvimento.&lt;/p&gt;

&lt;h3 id=&quot;flow&quot;&gt;Fluxo de Trabalho&lt;/h3&gt;

&lt;p&gt;Após um usuário registrar a &lt;em&gt;issue&lt;/em&gt; #41 no seu sistema de &lt;em&gt;tickets&lt;/em&gt;, você inicia um fluxo:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Digite &lt;code&gt;git work issue 41&lt;/code&gt; para criar uma nova &lt;em&gt;branch&lt;/em&gt; com o nome &lt;code&gt;41&lt;/code&gt; a partir da &lt;code&gt;master&lt;/code&gt;, já com &lt;em&gt;checkout&lt;/em&gt; automático para o &lt;code&gt;41&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Enquanto você vai alterando os fontes, poderá digitar &lt;code&gt;git work commit &quot;mensagem&quot;&lt;/code&gt; para ir comitando seu trabalho;&lt;/li&gt;
  &lt;li&gt;Quando você tiver terminado o trabalho, digite &lt;code&gt;git work done&lt;/code&gt; para ir para o &lt;code&gt;master&lt;/code&gt; enquanto o sistema faz o &lt;em&gt;merge&lt;/em&gt; com a atual &lt;em&gt;branch&lt;/em&gt; &lt;code&gt;41&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Então você pode enviar suas alterações para o servidor digitando &lt;code&gt;git work push&lt;/code&gt; para enviar a &lt;em&gt;branch&lt;/em&gt; atual, que é a &lt;code&gt;master&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Quando tiver uma versão de &lt;em&gt;release&lt;/em&gt;, o comando &lt;code&gt;git work release 1.0&lt;/code&gt; poderá ser utilizado. O git-work irá criar uma nova &lt;em&gt;tag&lt;/em&gt; a partir da &lt;code&gt;master&lt;/code&gt; e enviar ao servidor.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pode não parecer muito agora. Os comandos são muito similares aos comandos do próprio Git, porém tudo ainda está em desenvolvimento.&lt;/p&gt;

&lt;p&gt;Os scripts irão verificar, na medida do possível, se você está utilizando os comandos certos, nos &lt;em&gt;branches&lt;/em&gt; corretos.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;branch&lt;/em&gt; padrão poderá ser &lt;a href=&quot;https://github.com/mdbs99/git-work/issues/9&quot;&gt;configurado&lt;/a&gt; (padrão &lt;code&gt;master&lt;/code&gt;) para que os comandos &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt; e &lt;code&gt;release&lt;/code&gt; saibam onde pegar os fontes atuais.&lt;/p&gt;

&lt;p&gt;As mensagens do &lt;code&gt;commit&lt;/code&gt; poderão ser &lt;a href=&quot;https://github.com/mdbs99/git-work/issues/8&quot;&gt;padronizadas&lt;/a&gt; com o número da &lt;em&gt;issue&lt;/em&gt; no início. Exemplo: &lt;em&gt;“#41 this fix…”.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;E se todos os (futuros) parâmetros customizáveis ainda não sejam suficientes para suas customizações, bastará você alterar apenas o &lt;a href=&quot;https://github.com/mdbs99/git-work/blob/master/git-work.sh&quot;&gt;único arquivo&lt;/a&gt; nesse projeto.&lt;/p&gt;

&lt;p&gt;Ainda há um grande caminho a percorrer.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Essa é apenas a versão &lt;code&gt;0.1&lt;/code&gt; desse projeto que só tem poucos dias de vida.&lt;/p&gt;

&lt;p&gt;Padronização, eficiência e simplicidade. Essa é a proposta desse projeto.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;https://github.com/mdbs99/git-work&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/git-work-project</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/git-work-project</guid>
      </item>
    
      <item>
        <title>Imutabilidade do Estado</title>
        <description>&lt;p&gt;Na Orientação a Objetos, um Objeto pode ser considerável Imutável mesmo que ele… mude.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-morgan-harper-nichols-157838.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Morgan Harper Nichols on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;O aprendizado de um conceito complexo, tende a ser melhor absorvido se dividirmos o conceito em pequenas partes.&lt;/p&gt;

&lt;p&gt;Por exemplo, quando começamos a aprender Inglês, nos é ensinado que, para nos referirmos a algo que ocorreu no passado, devemos utilizar os verbos no passado para fazer afirmações ou utilizamos o verbo modal &lt;em&gt;did&lt;/em&gt; ou &lt;em&gt;did not&lt;/em&gt; para fazermos perguntas ou negações. Esse é o tempo verbal &lt;em&gt;Simple Past&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo: &lt;em&gt;I saw this movie&lt;/em&gt; (tradução: eu vi esse filme).&lt;/p&gt;

&lt;p&gt;Então, quando você começa a estudar mais a língua, descobre que existe muitas outras maneiras de expressar algo que ocorreu no passado. Por exemplo, o uso do tempo verbal &lt;em&gt;Present Perfect&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Exemplo: &lt;em&gt;I have seen this movie&lt;/em&gt; (tradução: eu vi esse filme).&lt;/p&gt;

&lt;p&gt;Aqui vemos o uso do verbo modal &lt;em&gt;have&lt;/em&gt; e o uso do &lt;em&gt;Past Participle&lt;/em&gt; do verbo &lt;em&gt;to see&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ambas as frases dizem o mesmo quando traduzimos para o Português, porém a segunda frase pode ser considerada mais &lt;em&gt;correta&lt;/em&gt; do que a primeira — você só descobre isso depois que aprende o &lt;em&gt;Present Perfect&lt;/em&gt;.
Mas isso não é um blog de Inglês, vamos voltar para a Orientação a Objetos.&lt;/p&gt;

&lt;p&gt;Essa introdução é para lhe mostrar que primeiro devemos aprender um conceito na sua forma mais simples; depois aprimoramos.&lt;/p&gt;

&lt;h2 id=&quot;conceitos&quot;&gt;Conceitos da Imutabilidade&lt;/h2&gt;

&lt;p&gt;Quando você aprendeu sobre &lt;a href=&quot;/posts/objetos-imutaveis/&quot;&gt;Imutabilidade&lt;/a&gt; pode ter pensado que um Objeto é imutável se, depois de criado, nada é alterado dentro dele ou que o Objeto retorna sempre a mesma informação quando um método é chamado.&lt;/p&gt;

&lt;p&gt;Bem, não é tão simples assim.&lt;/p&gt;

&lt;p&gt;Diferentemente das linguagens funcionais, onde tudo é imutável por padrão, na Orientação a Objetos esse conceito pode ser mais amplo.&lt;/p&gt;

&lt;p&gt;Vamos ver alguns conceitos.&lt;/p&gt;

&lt;h3 id=&quot;ex1&quot;&gt;Conteúdo Externo&lt;/h3&gt;

&lt;p&gt;Uma classe que representa um arquivo pode ser imútável de duas maneiras:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/48237c902271b6f2c3a314d3b6f5b8c0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, o método &lt;code&gt;TFile.Stream: IDataStream&lt;/code&gt; sempre irá retornar o mesmo valor lido na primeira execução.&lt;/p&gt;

&lt;p&gt;O Objeto é imutável e &lt;em&gt;constante&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas, e se alterarmos o método confome abaixo, a classe continuaria sendo imutável?&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/0aea75fefaf8612d0bc84d5fc9ce85a0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Sim, com certeza.&lt;/p&gt;

&lt;p&gt;Apesar do retorno do método poder ser diferente em cada chamada — o conteúdo do arquivo pode ser alterado por outro processo — o Objeto continuaria sendo imutável pois seu &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado&lt;/a&gt; (&lt;code&gt;FFilePath&lt;/code&gt;) não foi alterado.&lt;/p&gt;

&lt;p&gt;Ele é imutável, porém &lt;em&gt;não&lt;/em&gt; é constante.&lt;/p&gt;

&lt;p&gt;O mesmo conceito se aplica para um conteúdo vindo de um Banco de Dados, site na Web, etc.&lt;/p&gt;

&lt;h3 id=&quot;ex2&quot;&gt;Conteúdo em Memória&lt;/h3&gt;

&lt;p&gt;Uma lista de Objetos é considerada mutável se adicionarmos itens após ela ter sido criada?&lt;/p&gt;

&lt;p&gt;Vejamos no código:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/af8769161d1b111128349b05b74bccb9.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Copyright (c) &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James Project&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TDataParams&lt;/code&gt; encapsula uma lista do tipo &lt;code&gt;TInterfaceList&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A cada inclusão de um novo item, é delegada à essa lista interna, a persistência em memória dos Objetos.&lt;/p&gt;

&lt;p&gt;Você acha que, assim, estamos alterando o Estado (&lt;code&gt;FList&lt;/code&gt;) do Objeto?&lt;/p&gt;

&lt;p&gt;Não estamos.&lt;/p&gt;

&lt;p&gt;O motivo é que não estamos redefinindo &lt;code&gt;FList&lt;/code&gt;. Não estamos recriando uma nova lista.&lt;/p&gt;

&lt;p&gt;Uma lista de itens está sendo criada em memória — blocos de memória — mas o endereço inicial de &lt;code&gt;FList&lt;/code&gt; continua intacto.&lt;/p&gt;

&lt;p&gt;Além disso, &lt;code&gt;FList&lt;/code&gt; é um &lt;a href=&quot;/atributos-primarios-secundarios#secundarios&quot;&gt;Atributo Secundário&lt;/a&gt;, então nós até poderíamos redefinir esse atributo sem estar em desacordo com o princípio. Mas, se a instância da lista fosse passada no construtor, então não poderíamos redefinir o Objeto, pois esse seria considerado como um &lt;a href=&quot;/atributos-primarios-secundarios#primarios&quot;&gt;Atributo Primário&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;estado&quot;&gt;Imutabilidade do Estado&lt;/h2&gt;

&lt;p&gt;Se mesmo após algumas mudanças internas ou externas ao Objeto, ele continua sendo considerado imutável, como saber se não estamos violando o princípio da Imutabilidade?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Simples&lt;/strong&gt;: Se o &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado do Objeto&lt;/a&gt;, ou seja, seus &lt;a href=&quot;/atributos-primarios-secundarios#primarios&quot;&gt;Atributos Primários&lt;/a&gt;, não for alterado/redefinindo, então ele é imutável.&lt;/p&gt;

&lt;p&gt;Uma vez que um atributo é instânciado, ele não poderá ter seu &lt;em&gt;endereço de memória&lt;/em&gt; alterado. Esses atributos serão inicializados no &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtor&lt;/a&gt; da classe e jamais poderão ser reinicializados.&lt;/p&gt;

&lt;p&gt;Seu Objeto deve ser &lt;em&gt;fiél&lt;/em&gt; aos argumentos passados no construtor da Classe, no entanto ele é &lt;em&gt;livre&lt;/em&gt; para trabalhar e responder o que quiser em seus métodos.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Imutabilidade, na Orientação a Objetos, não é só sobre as não-mudanças internas ou externas ao Objeto, mas sim sobre não alterar o Estado Primário do Objeto.&lt;/p&gt;

&lt;p&gt;Não confunda &lt;a href=&quot;/posts/classes-de-dados/&quot;&gt;dados&lt;/a&gt; com o Estado do Objeto.&lt;/p&gt;

&lt;p&gt;Infelizmente nenhum compilador &lt;em&gt;Object Pascal&lt;/em&gt; que eu conheça possui uma sintaxe para que essas regras não sejam quebradas. Java, por exemplo, tem atributos &lt;em&gt;final&lt;/em&gt; onde, uma vez inicializados, não podem ter seu endereço de memória substituído.&lt;/p&gt;

&lt;p&gt;Sven Barth, um integrante do FPC team, &lt;a href=&quot;http://lists.freepascal.org/pipermail/fpc-pascal/2017-July/051941.html&quot;&gt;me falou&lt;/a&gt; sobre um &lt;code&gt;{$modeswitch
finalfields}&lt;/code&gt; que foi implementado para a interoperabilidade do FPC para a JVM plataforma, porém ainda não disponível.&lt;/p&gt;

&lt;p&gt;Então temos que trabalhar apenas com o conceito ou utilizar ferramentas de verificação de código para que essa regra não seja quebrada.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/imutabilidade-do-estado</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/imutabilidade-do-estado</guid>
      </item>
    
      <item>
        <title>Diretivas de Compilação</title>
        <description>&lt;p&gt;Diretivas de Compilação podem lhe ajudar a tornar seu código &lt;em&gt;multi-plataform&lt;/em&gt; ou até mesmo &lt;em&gt;cross-compiled&lt;/em&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-mathyas-kurmann-102977.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Mathyas Kurmann on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.freepascal.org/docs-html/prog/progch1.html&quot;&gt;Diretivas de Compilação&lt;/a&gt; são comandos poderosos que o desenvolvedor pode utilizar para customizar a compilação.&lt;/p&gt;

&lt;p&gt;Essas Diretivas passam parâmetros para o compilador, informando os &lt;em&gt;argumentos&lt;/em&gt; da compilação, &lt;em&gt;como&lt;/em&gt; deve ser compilado e &lt;em&gt;o que&lt;/em&gt; deve ser compilado.&lt;/p&gt;

&lt;p&gt;Existem basicamente &lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Delphi_compiler_directives&quot;&gt;3 tipos&lt;/a&gt; de Diretivas de Compilação:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Switch directive&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Parameter directive&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Conditional compilation directive&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Os dois primeiros tipos alteram os parâmetros de compilação, enquanto o último altera o que o compilador irá executar.&lt;/p&gt;

&lt;p&gt;Nesse artigo iremos tratar do último tipo: &lt;em&gt;Condicionais&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;condicionais&quot;&gt;Condicionais&lt;/h2&gt;

&lt;p&gt;Apesar de serem comandos poderosos, &lt;em&gt;não&lt;/em&gt; devem ser utilizados levianamente.&lt;/p&gt;

&lt;p&gt;Com apenas alguns comandos condicionais, seu código &lt;a href=&quot;https://freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt; ou &lt;a href=&quot;https://www.embarcadero.com/products/delphi&quot;&gt;Delphi&lt;/a&gt; pode ser compilável em várias plataformas.&lt;/p&gt;

&lt;p&gt;Entretanto, a medida que vamos adicionando mais e mais diretivas, o código irá ficar mais complexo.&lt;/p&gt;

&lt;p&gt;Vejamos o exemplo abaixo:
&lt;script src=&quot;https://gist.github.com/mdbs99/dffca8326e924f4e036485a5674ea147.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;No código acima apenas a 1º e 3º chamada da função &lt;em&gt;Writeln&lt;/em&gt; serão executadas.&lt;/p&gt;

&lt;p&gt;Todas as diretivas e também a 2º chamada de &lt;em&gt;Writeln&lt;/em&gt; não irão fazer parte do executável final.&lt;/p&gt;

&lt;p&gt;Bem legal.&lt;/p&gt;

&lt;p&gt;Entretanto, veja que o código ficou bem “poluído” e também temos um &lt;a href=&quot;/posts/objetos-imutaveis/#acoplamento-temporal&quot;&gt;acoplamento temporal&lt;/a&gt;, pois as  constantes precisam ser definidas numa ordem específica.&lt;/p&gt;

&lt;p&gt;Diretivas e Definições de constantes que serão utilizadas em apenas numa única &lt;a href=&quot;/declarando-unidades&quot;&gt;Unidade&lt;/a&gt; pode até ser gerenciável, mas e se tivermos trabalhando com dezenas ou até centenas de Unidades que irão utilizar as mesmas diretivas e definições, ainda acha que essa abordagem é a melhor escolha para a arquitetura do seu projeto com a finalidade de construí-lo como &lt;em&gt;multi-plataform&lt;/em&gt; ou &lt;em&gt;cross-compiled&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Eu acho que &lt;em&gt;não&lt;/em&gt; e é por isso que no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt; estamos utilizando uma abordagem diferente.&lt;/p&gt;

&lt;h2 id=&quot;encapsulando&quot;&gt;Encapsulando Diretivas&lt;/h2&gt;

&lt;p&gt;No James estamos codificando num estilo que chamo de &lt;em&gt;Encapsulamento de Diretivas&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Um dos objetivos desse projeto é ser &lt;em&gt;cross-compiled&lt;/em&gt;, ou seja, ele irá compilar em Free Pascal e Delphi. No entanto não queremos que nem os usuários (desenvolvedores) ou os autores desse projeto se preocupem com diretivas de compilação.&lt;/p&gt;

&lt;p&gt;Atualmente não há diretivas condicionais no código de implementação dos métodos — com exceção da classe &lt;code&gt;TXMLComponent&lt;/code&gt; que deverá ser &lt;a href=&quot;https://github.com/mdbs99/james/issues/65&quot;&gt;refatorada&lt;/a&gt; em breve.&lt;/p&gt;

&lt;p&gt;O motivo dessa abordagem é que não queremos nos preocupar em  quebrar um código que é utilizado por 2 compiladores diferentes.&lt;/p&gt;

&lt;p&gt;Não utilizamos arquivos &lt;em&gt;“include”&lt;/em&gt; com pedaços de código.&lt;/p&gt;

&lt;p&gt;Não utilizamos definições globais de condicionais.&lt;/p&gt;

&lt;p&gt;Diretiva condicional é uma técnica &lt;em&gt;procedural&lt;/em&gt;. Não gostamos.&lt;/p&gt;

&lt;p&gt;Ao invés disso, utilizamos apenas &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;implementacao&quot;&gt;Implementação&lt;/h2&gt;

&lt;p&gt;Imagine uma Unidade que contenha classes para &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;representar&lt;/a&gt; a criptografia &lt;a href=&quot;https://en.wikipedia.org/wiki/MD5&quot;&gt;MD5&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No Free Pascal já temos uma Unidade &lt;code&gt;md5&lt;/code&gt; que tem funções que fazem esse trabalho — e é claro que temos que fazer Objetos para encapsular essas funções.&lt;/p&gt;

&lt;p&gt;No Delphi a Unidade que faz o mesmo trabalho é denominada &lt;code&gt;hash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Não queremos “reinventar a roda”. Queremos utilizar o que já está pronto em ambas as plataformas.&lt;/p&gt;

&lt;p&gt;Então, como fazer essa implementação sem utilizar diretivas condicionais no código de implementação ou arquivos de inclusão?&lt;/p&gt;

&lt;p&gt;Bem, no James temos a Unidade &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.crypto.md5.clss.pas&quot;&gt;James.Crypto.MD5.Clss&lt;/a&gt; com algumas classes que representam MD5.&lt;/p&gt;

&lt;p&gt;Essa é a única Unidade (até a data desse artigo) que os usuários devem utilizar para trabalhar com MD5.&lt;/p&gt;

&lt;p&gt;Nós, autores do projeto, poderíamos separar alguns desenvolvedores para trabalhar na implementação Free Pascal e outros para trabalhar na implementação Delphi, se assim o desejarmos, pois as implementações estão separadas em Unidades distintas.&lt;/p&gt;

&lt;p&gt;Primeiro criamos mais duas Unidades que serão utilizadas pela &lt;code&gt;James.Crypto.MD5.Clss&lt;/code&gt;:
Uma para Free Pascal e outra para o Delphi.&lt;/p&gt;

&lt;p&gt;São elas &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.crypto.md5.fpc.pas&quot;&gt;James.Crypto.MD5.FPC&lt;/a&gt; e &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.crypto.md5.delphi.pas&quot;&gt;James.Crypto.MD5.Delphi&lt;/a&gt;, respectivamente.&lt;/p&gt;

&lt;p&gt;Veja abaixo como implementamos isso:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/1bc867bb6303223496c44d221eae9044.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Ambas as Unidades possuem a definição da Classe &lt;code&gt;TMD5Hash&lt;/code&gt; (sim, mesmo nome em ambas). Então bastou criar um &lt;em&gt;alias&lt;/em&gt; (novamente, com o mesmo nome) direcionando &lt;code&gt;TMD5Hash&lt;/code&gt; para a classe correta (dependente da plataforma) e, &lt;em&gt;voilá!&lt;/em&gt;, temos uma Unidade “limpa” e sem condicionais na implementação dos métodos.&lt;/p&gt;

&lt;p&gt;Agora temos duas Classes distintas, em Unidades diferentes, que podem evoluir independentemente sem receio de quebrar o código entre plataformas.&lt;/p&gt;

&lt;p&gt;A clase &lt;code&gt;TMD5Stream&lt;/code&gt; não tem nenhuma diferença entre os compiladores, então é implementada diretamente na Unidade &lt;code&gt;James.Crypto.MD5.Clss&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Diretiva de Compilação é uma boa ferramenta para customização do código, porém deve ser utilizada com parcimônia.&lt;/p&gt;

&lt;p&gt;No código &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;Orientado a Objetos&lt;/a&gt;, dê preferência aos Objetos para resolver seus problemas.&lt;/p&gt;

&lt;p&gt;Para cada diretiva condicional que você queira adicionar no código de implementação, sugiro implementar um novo Objeto que encapsule a diretiva.&lt;/p&gt;

&lt;p&gt;Seu código ficará mais limpo e sustentável.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/diretivas-de-compilacao</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/diretivas-de-compilacao</guid>
      </item>
    
      <item>
        <title>Declarando Unidades</title>
        <description>&lt;p&gt;Determinar uma ordem para declarar as Unidades no código poderá facilitar a manutenção do código no futuro.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-annie-spratt-303942.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Quando você organiza suas coisas, tem a tendência de manter mais perto, mais fácil de utilizar ou pegar, todos os objetos que são mais utilizados no dia-a-dia, certo?&lt;/p&gt;

&lt;p&gt;Assim também deveria ser com as &lt;a href=&quot;http://castle-engine.io/modern_pascal_introduction.html#_units&quot;&gt;Unidades&lt;/a&gt; de um Projeto.&lt;/p&gt;

&lt;p&gt;A ordem em que aparecem as Unidades no código pode facilitar ou dificultar a manutenção.&lt;/p&gt;

&lt;p&gt;Nesse artigo irei lhe mostrar qual a ordem que utilizo ao declarar as Unidades no meus projetos.&lt;/p&gt;

&lt;h2 id=&quot;compilador&quot;&gt;Compilador&lt;/h2&gt;

&lt;p&gt;As Unidades, também conhecidas como módulos, compõe os projetos.&lt;/p&gt;

&lt;p&gt;Todo projeto deve ser dividido em Unidades lógicas e fazer essa divisão nem sempre é fácil, pois envolve um nível de pensamento abstrato e lógico.&lt;/p&gt;

&lt;p&gt;Após dividir as Unidades do projeto, também temos que nos preocupar com as Unidades de terceiros.&lt;/p&gt;

&lt;p&gt;Hoje em dia é quase mandatório utilizarmos &lt;em&gt;libs&lt;/em&gt; e &lt;em&gt;frameworks&lt;/em&gt; de terceiros. Na maioria das vezes são projetos &lt;em&gt;OpenSource&lt;/em&gt; como, por exemplo, o &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tais Unidades facilitam o nosso trabalho, pois já possuem artefatos prontos que agilizam muito a conclusão do projeto.&lt;/p&gt;

&lt;p&gt;Além dessas Unidades de terceiros, também temos as Unidades padrão da linguagem localizadas na &lt;em&gt;Run-time Library&lt;/em&gt; (RTL) ou VCL/LCL, possuindo muitas interfaces, classes, funções e artefatos prontos para uso.&lt;/p&gt;

&lt;p&gt;Então, qual ordem devemos declarar essas Unidades quando utilizamos em uma das nossas próprias Unidades?&lt;/p&gt;

&lt;p&gt;Aqui está a ordem que eu proponho:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyUnit;
uses
  // 1. fpc/lazarus/delphi units,
  // 2. 3rd units,
  // 3. my open source units,
  // 4. project units
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando o compilador começa a fazer o &lt;em&gt;parser&lt;/em&gt; do código do seu projeto e ele chega na &lt;code&gt;MyUnit&lt;/code&gt;, ele irá ler as Unidades na sequência na qual elas foram declaradas — pode haver alguma otimização, como leitura paralela, porém o que importa é o resultado final, no qual depende da ordem acima — e os identificadores (classes, interfaces, funções/procedimentos, variáveis e constantes) serão “armazenados em ordem” na qual eles foram declarados.&lt;/p&gt;

&lt;p&gt;Por isso eu proponho declarar, inicialmente, todas as Unidades que são padrão ao ambiente. Depois, todas as Unidades de terceiros como &lt;em&gt;libs&lt;/em&gt; e &lt;em&gt;frameworks&lt;/em&gt;. Então, todas as Unidades referentes a seus projetos públicos, sejam eles &lt;em&gt;OpenSource&lt;/em&gt; ou compartilhados dentro de setores de uma empresa. Finalmente, declaramos as Unidades do projeto em si, ou seja, no projeto no qual estamos trabalhando no momento.&lt;/p&gt;

&lt;p&gt;E por quê isso é importante?&lt;/p&gt;

&lt;p&gt;O motivo é porque o compilador precisa saber em qual Unidade um determinado artefato (classe, função, etc) está localizado.&lt;/p&gt;

&lt;p&gt;A regra é a seguinte:&lt;/p&gt;

&lt;p&gt;Se você tem 3 Unidades (&lt;code&gt;Unit1&lt;/code&gt;, &lt;code&gt;Unit2&lt;/code&gt; e &lt;code&gt;Unit3&lt;/code&gt;) e, em cada uma delas, tem uma classe com o nome &lt;code&gt;TFoo&lt;/code&gt;, o compilador irá “informar” ao seu código que &lt;code&gt;TFoo&lt;/code&gt; está localizada na última Unidade declarada.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  Unit1, Unit3, Unit2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reparem que eu inverti a ordem numérica. Primeiro é a 1, depois 3 e por último a 2.&lt;/p&gt;

&lt;p&gt;Onde está localizada a classe &lt;code&gt;TFoo&lt;/code&gt; quando você utilizá-la na sua Unidade, a &lt;code&gt;MyUnit&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;A resposta é: Na &lt;code&gt;Unit2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Motivo: Ela foi declarada por &lt;em&gt;último&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Imagine que o compilador vai montando, em memória, uma tabela de referência para todos os identificadores que ele encontra. Primeiro ele encontra &lt;code&gt;TFoo&lt;/code&gt; quando lê a &lt;code&gt;Unit1&lt;/code&gt;, depois encontra novamente quando lê a &lt;code&gt;Unit3&lt;/code&gt;. Nesse momento ele &lt;em&gt;substitui&lt;/em&gt; a referência que dizia que &lt;code&gt;TFoo&lt;/code&gt; está na &lt;code&gt;Unit1&lt;/code&gt;, pois agora está na &lt;code&gt;Unit3&lt;/code&gt;. Por fim, quando ele lê a &lt;code&gt;Unit2&lt;/code&gt; o identificador é reposicionado novamente.&lt;/p&gt;

&lt;p&gt;Se nessa mesma &lt;code&gt;MyUnit&lt;/code&gt; eu precisar utilizar &lt;code&gt;TFoo&lt;/code&gt; da &lt;code&gt;Unit1&lt;/code&gt;, eu sou obrigado a qualificar a classe com o nome da Unidade ao invés de apenas utilizar o identificador:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Foo := Unit1.TFoo.Create...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vocês podem ver outro exemplo &lt;a href=&quot;http://castle-engine.io/modern_pascal_introduction.html#_qualifying_identifiers_with_unit_name&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;secoes&quot;&gt;Seções&lt;/h2&gt;

&lt;p&gt;Na linguagem &lt;em&gt;Object Pascal&lt;/em&gt; temos dois lugares (seções) onde podemos declarar as Unidades que serão utilizadas.&lt;/p&gt;

&lt;p&gt;Podemos declarar na seção de interface ou na seção de implementação.&lt;/p&gt;

&lt;p&gt;Vale a pena declarar Unidades na seção de implementação?&lt;/p&gt;

&lt;p&gt;Na minha opinião sincera, não.&lt;/p&gt;

&lt;p&gt;Ao fazer isso, você terá 2 lugares para organizar a precedência da Unidades, ou seja, terá mais trabalho.&lt;/p&gt;

&lt;p&gt;Como a linguagem &lt;em&gt;Object Pascal&lt;/em&gt; não aceita &lt;a href=&quot;/posts/interfaces-e-a-referencia-circular-entre-objetos/&quot;&gt;referência circular&lt;/a&gt; entre Unidades, o motivo de haver opção para declarar Unidades na implementação é para permitir essa referência bi-direcional entre elas. No entanto, isso também indica um mal &lt;em&gt;design&lt;/em&gt; na divisão das Unidades do projeto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Definir a ordem de declaração das Unidades em cada Unidade de seu projeto pode ser de extrema importância para facilitar a manutenção e organização.&lt;/p&gt;

&lt;p&gt;Conforme você for adicionando novos identificadores, você terá a certeza que o compilador dará “prioridade” para uso dos identificadores do seu projeto, sem precisar prefixar com o nome da Unidade.&lt;/p&gt;

&lt;p&gt;Caso você adicione algum identificador e este entre em conflito com outra Unidade que possui o mesmo nome, basta prefixar esse identificador com o nome da Unidade, seja ela de terceiros ou do próprio ambiente. Entretando esse conflito não existirá nos identificadores das Unidades do seu projeto.&lt;/p&gt;

&lt;p&gt;Portanto deixe mais “próximo” do código as Unidades que pertencem ao projeto, ou seja, as Unidades que são mais utilizadas e mais “distantes” as Unidades auxiliares.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/declarando-unidades</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/declarando-unidades</guid>
      </item>
    
      <item>
        <title>James 2017-07</title>
        <description>&lt;p&gt;James é um projeto Open Source que será a base de todos os meus projetos Orientados a Objetos codificados em Object Pascal.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-hope-house-press-127593.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;james&quot;&gt;James&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;O que é?&lt;/strong&gt; &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James&lt;/a&gt; é uma coleção de classes e interfaces para projetos verdadeiramente orientados a objetos escritos em Object Pascal. Esta API está sendo escrita em Free Pascal e Lazarus. No entanto, torná-lo compatível com Delphi pode ser possível ou mesmo pode ser um objetivo (estamos dependendo de mais contribuidores para torná-lo possível).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Por quê?&lt;/strong&gt; Nós não queremos mais escrever o código procedural, nunca mais. Queremos escrever código elegante, limpo e sustentável usando a OOP.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Princípios&lt;/strong&gt;. O código possui alguns princípios de &lt;em&gt;design&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Totalmente baseado em interface&lt;/li&gt;
  &lt;li&gt;A memória é liberada automaticamente&lt;/li&gt;
  &lt;li&gt;Todos os métodos públicos são implementações de métodos de interface&lt;/li&gt;
  &lt;li&gt;Todos os métodos públicos retornam uma instância de interface ou tipo primitivo&lt;/li&gt;
  &lt;li&gt;Nenhum uso de NULL em argumentos ou retornos de métodos&lt;/li&gt;
  &lt;li&gt;Sem algoritmos nos construtores&lt;/li&gt;
  &lt;li&gt;Não há getters e setters&lt;/li&gt;
  &lt;li&gt;Sem &lt;em&gt;casting&lt;/em&gt; ou reflexão utilizando RTTI&lt;/li&gt;
  &lt;li&gt;Sem procedimentos e funções, apenas Objetos&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Mais informações&lt;/strong&gt;. Leia mais sobre o James &lt;a href=&quot;/posts/james/&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;/posts/james-e-testes-de-unidade/&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;como-contribuir&quot;&gt;Como contribuir?&lt;/h3&gt;

&lt;p&gt;Apenas faça um &lt;em&gt;fork&lt;/em&gt; do &lt;a href=&quot;https://github.com/mdbs99/james#fork-destination-box&quot;&gt;repositório&lt;/a&gt; e envie-nos um &lt;em&gt;Pull Request&lt;/em&gt; (PR).&lt;/p&gt;

&lt;p&gt;Cada PR precisa trabalhar apenas sobre uma única &lt;em&gt;issue&lt;/em&gt; ou em uma &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;única responsabilidade&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Por favor, nomeie seu PR usando o mesmo estilo de outros PR já &lt;a href=&quot;https://github.com/mdbs99/james/pulls?q=is%3Apr+is%3Aclosed&quot;&gt;finalizados&lt;/a&gt; neste projeto.&lt;/p&gt;

&lt;p&gt;Certifique-se de que o seu ramo seja construído sem quaisquer &lt;em&gt;warnings&lt;/em&gt;/problemas.&lt;/p&gt;

&lt;p&gt;Se você tiver dúvidas ou sugestões gerais, não hesite em enviar uma nova &lt;a href=&quot;https://github.com/mdbs99/james/issues/new&quot;&gt;Github issue&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;atualizacoes&quot;&gt;Atualizações&lt;/h3&gt;

&lt;p&gt;Ainda estamos em uma versão alfa muito precoce, a API pode e vai mudar com freqüência. Por favor, use isso por sua conta e risco, até liberarmos a versão 1.0.&lt;/p&gt;

&lt;p&gt;Algumas &lt;em&gt;unidades&lt;/em&gt; foram excluídas e outras foram criadas. Classes foram movidas e renomeadas.&lt;/p&gt;

&lt;p&gt;Vejamos abaixo as modificações mais recentes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/18&quot;&gt;PR #18&lt;/a&gt;: Só vamos utilizar caracteres ASCII para facilitar o uso no Delphi sem haver problemas de UNICODE (&lt;a href=&quot;https://www.mail-archive.com/lazarus@lists.lazarus-ide.org/msg02754.html&quot;&gt;veja mais&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/19&quot;&gt;PR #19&lt;/a&gt;: A classe &lt;code&gt;TStreamBase64&lt;/code&gt; não apenas foi renomeada para &lt;code&gt;TBase64Stream&lt;/code&gt;, como também está numa nova unidade chamada &lt;code&gt;james.format.base64.clss&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/20&quot;&gt;PR #20&lt;/a&gt;: A unidade &lt;code&gt;james.data.xml.clss&lt;/code&gt; foi renomeada para &lt;code&gt;james.format.xml.clss&lt;/code&gt; adicionando um novo prefixo &lt;code&gt;format&lt;/code&gt; que poderá ser utilizado por outros “formatos” como JSON, INI, etc.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/21&quot;&gt;PR #21&lt;/a&gt;: As unidades &lt;code&gt;james.files.*&lt;/code&gt; foram renomeadas para &lt;code&gt;james.io.*&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/23&quot;&gt;PR #23&lt;/a&gt;: Criada uma nova unidade &lt;code&gt;james.crypto.md5.clss&lt;/code&gt; que, além de adicionar um novo prefixo &lt;code&gt;crypto&lt;/code&gt; para outros tipos de criptografia, também contém classes relacionadas ao MD5.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mdbs99/james/pull/30&quot;&gt;PR #30&lt;/a&gt;: Adicionado as classes que implementam &lt;a href=&quot;/objetos-validadores#constraints&quot;&gt;Constraints&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A maioria das modificações são apenas estéticas ou apenas para melhorar a organização. No entanto são modificações necessárias para fazer o projeto crescer com saúde.&lt;/p&gt;

&lt;p&gt;Por enquanto é isso. Aguardo seus comentários aqui embaixo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/james-2017-07</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/james-2017-07</guid>
      </item>
    
      <item>
        <title>Objetos Validadores</title>
        <description>&lt;p&gt;Veja como fazer validações utilizando Objetos ao invés de utilizar programação procedural.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-scott-webb-59043.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Na Orientação a Objetos a codificação deve ser declarativa. Isso quer dizer que, num mundo ideal, iríamos criar os Objetos agrupando-os entre si e, com uma única &lt;a href=&quot;/posts/diga-me-algo-sobre-voce/#mensagens&quot;&gt;mensagem&lt;/a&gt;, o trabalho a ser realizado seria iniciado e cada Objeto iria realizar parte desse trabalho. Tudo em perfeita harmonia.&lt;/p&gt;

&lt;p&gt;No entanto, não vivemos num mundo ideal e problemas podem ocorrer.&lt;/p&gt;

&lt;p&gt;Se pudermos validar o &lt;em&gt;input&lt;/em&gt; dos dados no nosso sistema antes de iniciar um processo mais elaborado, isso tornaria o processamento menos custoso, menos demorado e menos propenso a erros.&lt;/p&gt;

&lt;p&gt;No entanto, se devemos codificar de forma declarativa, ou seja, sem condicionais que validem passo-a-passo o que está sendo processado — o &lt;em&gt;modus operandis&lt;/em&gt; da programação procedural — como seria possível fazer isso utilizando Objetos para deixar o código mais seguro e fazer um tratamento mais adequado para cada problema ou decisão, antes que uma exceção possa ocorrer?&lt;/p&gt;

&lt;h2 id=&quot;validacoes&quot;&gt;Validações&lt;/h2&gt;

&lt;p&gt;Imagine um Formulário onde há diversos campos para o usuário preencher antes de clicar em algum botão que irá fazer algo com os dados preenchidos nos &lt;em&gt;widgets&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Sempre temos que validar o &lt;em&gt;input&lt;/em&gt; antes de processá-lo, certo?&lt;/p&gt;

&lt;p&gt;Tenho trabalhado com desenvolvimento de &lt;em&gt;software&lt;/em&gt; a muitos anos. Grande parte desse tempo eu codifiquei a validação de campos utilizando o mesmo “padrão” que até hoje é utilizado, independentemente da linguagem utilizada.&lt;/p&gt;

&lt;p&gt;Vejamos como é esse padrão:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/1d990d474d0a15a7543c54c5c02b370a.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O exemplo acima é sobre um Formulário que contém alguns campos, dentre esses campos temos &lt;code&gt;Name&lt;/code&gt; e &lt;code&gt;Birthday&lt;/code&gt;. O primeiro é &lt;em&gt;string&lt;/em&gt; e não pode estar em branco. Já o segundo deveria ser uma data válida, então o código utiliza a função padrão &lt;code&gt;SysUtils.TryStrToDate&lt;/code&gt; que verifica se é uma data válida e retorna o valor na variável &lt;code&gt;MyDate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Quem nunca fez isso?&lt;/p&gt;

&lt;p&gt;Pois é.&lt;/p&gt;

&lt;p&gt;Há problemas demais com essa abordagem:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Não podemos reutilizar as validações. Em cada Formulário haverá uma possível cópia do mesmo código;&lt;/li&gt;
  &lt;li&gt;As variáveis locais podem aumentar consideravelmente caso haja mais testes que necessitem de variáveis;&lt;/li&gt;
  &lt;li&gt;O código é totalmente procedural;&lt;/li&gt;
  &lt;li&gt;Não posso utilizar as informações de aviso ao usuário em outra aplicação Web, por exemplo, visto que as &lt;em&gt;strings&lt;/em&gt; estão codificadas dentro de funções &lt;code&gt;ShowMessage&lt;/code&gt; (ou qualquer outra função de mensagem para Desktop);&lt;/li&gt;
  &lt;li&gt;O Formulário ficou complexo, visto que há muito código num único evento — e não adianta apenas criar vários métodos privados para cada teste, pois o Formulário irá continuar fazendo coisas demais.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Há variantes dessa abordagem acima, porém acredito que todos nós já vimos algo assim ou mesmo estamos codificando dessa maneira ainda hoje.&lt;/p&gt;

&lt;p&gt;O que podemos fazer para simplificar o código, obter a reutilização das validações e ainda codificar utilizando Orientação a Objetos?&lt;/p&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Constraints&lt;/em&gt; são Objetos que tem por função a validação de algum dado ou mesmo a validação de outro Objeto.&lt;/p&gt;

&lt;p&gt;Cada &lt;em&gt;constraint&lt;/em&gt; valida apenas 1 artefato. Assim podemos reutilizar a validação em muitos outros lugares.&lt;/p&gt;

&lt;p&gt;Vamos definir algumas &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt;:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/c668747123d651298e9f40d0e10af5b4.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Vamos entender cada Interface:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;[guids]&lt;/code&gt;: São necessários para &lt;em&gt;casting&lt;/em&gt; de Interfaces.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataInformation&lt;/code&gt;: Representa uma infomação.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataInformations&lt;/code&gt;: Representa uma lista de informações.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataResult&lt;/code&gt;: Representa um resultado de uma restrição.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataConstraint&lt;/code&gt;: Representa uma restrição.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;IDataConstraints&lt;/code&gt;: Representa uma lista de restrições.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Não estou utilizando &lt;em&gt;Generics&lt;/em&gt;. Apenas Classes que podem ser reescritas em praticamente qualquer versão do Lazarus ou Delphi.&lt;/p&gt;

&lt;p&gt;Bem simples.&lt;/p&gt;

&lt;p&gt;Agora veremos a implementação das Interfaces — por questões de breviedade, vou apresentar somente as assinaturas das Classes:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/b254ff882ce27ce9fa4e8219c63e3e96.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Essas são Classes utilizadas em projetos reais. &lt;del&gt;Em breve&lt;/del&gt; todo o código &lt;del&gt;estará&lt;/del&gt; já está disponível no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt;. Você poderá obter esse código acompanhando a &lt;a href=&quot;https://github.com/mdbs99/james/issues/17&quot;&gt;Issue #17&lt;/a&gt; do mesmo projeto.&lt;/p&gt;

&lt;p&gt;Na implementação acima não tem nenhuma Classe que implemente a Interface &lt;code&gt;IDataConstraint&lt;/code&gt;. O motivo disso é que você, programador, irá criar suas próprias &lt;em&gt;constraints&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo de como reescrever o código procedural do primeiro exemplo.&lt;/p&gt;

&lt;p&gt;Precisamos criar duas Classes que implementam &lt;code&gt;IDataConstraint&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Como só há apenas 1 método nessa Interface, e para não deixar esse artigo ainda maior, vou mostrar o código de apenas uma implementação:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/62040307d41fbc45c0f15605acc541b5.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O código acima mostra como seria a implementação para a &lt;em&gt;constraint&lt;/em&gt; &lt;code&gt;TNameConstraint&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O código está &lt;em&gt;procedural&lt;/em&gt; e ainda pode &lt;em&gt;melhorar&lt;/em&gt; muito. As variáveis locais poderiam ser retiradas, bastando adicionar mais um &lt;em&gt;overload&lt;/em&gt; do método &lt;code&gt;New&lt;/code&gt; na Classe &lt;code&gt;TDataResult&lt;/code&gt; — você consegue ver essa possibilidade? Conseguiria implementá-la?&lt;/p&gt;

&lt;p&gt;Abaixo o código de como utilizar todos esses Objetos em conjunto:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/5dc64c57916d86d01de561077d831aaf.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Se nas validações acima o nome estivesse &lt;em&gt;em branco&lt;/em&gt; mas a data de aniverário tivesse sido digitada &lt;em&gt;corretamente&lt;/em&gt; — o resultado do método &lt;code&gt;OK&lt;/code&gt; será verdadeiro se apenas todas as validações passarem no teste — o resultado do &lt;code&gt;ShowMessage&lt;/code&gt; poderia ser:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- Name: Name is empty
- Birthday: OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essa seria apenas uma versão da implementação de como mostrar as informações. Poderia haver muitos outros &lt;em&gt;decoradores&lt;/em&gt; para mostrar a informação em outros formatos como, por exemplo, HTML numa aplicação Web.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O código não está completo, mas acredito que posso ter aberto sua mente a novas possibilidades quando se trata de validações.&lt;/p&gt;

&lt;p&gt;O resultado final de &lt;code&gt;SaveButtonClick&lt;/code&gt;, mesmo utilizando a Classe &lt;code&gt;TDataConstraints&lt;/code&gt;, também não foi implementada complemente seguindo o paradigma da Orientação a Objetos — para deixar o código mais sucinto — pois tem um &lt;code&gt;IF&lt;/code&gt; lá que não deixa o código tão elegante quanto deveria, mas eu acho que dá para você visualizar as possibilidades de uso.&lt;/p&gt;

&lt;p&gt;A instância de &lt;code&gt;TDataConstraints&lt;/code&gt; e seus itens poderia ser utilizada em muitos outros lugares do código.&lt;/p&gt;

&lt;p&gt;A combinação de tais Objetos é virtualmente infinita e seu será o mesmo em &lt;em&gt;todo&lt;/em&gt; código.&lt;/p&gt;

&lt;p&gt;O código é &lt;em&gt;reutilizável&lt;/em&gt; em qualquer tipo de aplicação.&lt;/p&gt;

&lt;p&gt;Nenhuma informação ou mensagem ao usuário seria duplicada no código. Haverá apenas um &lt;em&gt;único&lt;/em&gt; lugar, uma única Classe, para fazer a manutenção de cada validação.&lt;/p&gt;

&lt;p&gt;E a exibição da mensagem poderia ser em qualquer formato, bastando utilizar outros Objetos &lt;em&gt;decoradores&lt;/em&gt; para ler as &lt;em&gt;informations&lt;/em&gt;, formatando como quiser.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Jul 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/objetos-validadores</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/objetos-validadores</guid>
      </item>
    
      <item>
        <title>Atributos Não Existem</title>
        <description>&lt;p&gt;E se eu lhe dissesse que Atributos não existem realmente?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-guillaume-bolduc-259596.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tive um &lt;em&gt;insight&lt;/em&gt; um dia desses:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Não existem Atributos, apenas Composição e Comportamento”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;O que chamamos de &lt;a href=&quot;/posts/menos-e-mais/#atributos&quot;&gt;Atributo&lt;/a&gt; é, na verdade, Composição de Objetos e &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;Comportamento&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Atributos &lt;em&gt;não&lt;/em&gt; existem. São virtuais, produtos de nossa imaginação ou apenas uma abstração da realidade.&lt;/p&gt;

&lt;p&gt;Veja as Cores, por exemplo.&lt;/p&gt;

&lt;p&gt;Não existe atributos de cor Amarelo, Vermelho ou Azul. São todos Objetos!&lt;/p&gt;

&lt;p&gt;O Amarelo é um Objeto numa composição &lt;em&gt;RGB&lt;/em&gt; e nosso olho processa essa composição interagindo com outro Objeto, a &lt;em&gt;Luz&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Assim “vemos” as cores.&lt;/p&gt;

&lt;p&gt;Quer outros exemplos?&lt;/p&gt;

&lt;p&gt;A quantidade de itens numa lista é determinada pelo comportamento do Objeto ao contar os itens da lista.&lt;/p&gt;

&lt;p&gt;A idade de uma pessoa é determinada pelo comportamento do Objeto ao contar o tempo.&lt;/p&gt;

&lt;p&gt;Não há nada de errado em continuarmos utilizando a palavra Atributo, mas não se esqueça que eles não existem. São apenas abstrações da realidade.&lt;/p&gt;

&lt;p&gt;Faz sentido?&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Jun 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/atributos-nao-existem</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/atributos-nao-existem</guid>
      </item>
    
      <item>
        <title>Mutabilidade Encapsulada</title>
        <description>&lt;p&gt;Um Objeto pode mudar internamente, mas permanecer imutável para o mundo exterior.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-ben-white-197668.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Uma das atribuições da Orientação a Objetos é &lt;em&gt;gerenciar&lt;/em&gt; a mutabilidade.&lt;/p&gt;

&lt;p&gt;Então foi criado o conceito de atributos privados, onde o acesso a esses atributos não seria permitido ou só seria permitido através de &lt;a href=&quot;/posts/getters-e-setters/&quot;&gt;métodos públicos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O gerenciamento da mutabilidade nos proporcionou um código mais seguro, melhorando a munutenabilidade.&lt;/p&gt;

&lt;p&gt;Entretanto, Objetos Mutáveis são os opostos dos &lt;a href=&quot;/posts/objetos-imutaveis/&quot;&gt;Objetos Imutáveis&lt;/a&gt;. Esses últimos são mais &lt;em&gt;simples&lt;/em&gt; de usar e ainda &lt;em&gt;mais seguros&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Mas nem sempre conseguimos — ou queremos — codificar um Objeto &lt;em&gt;completamente&lt;/em&gt; imutável. Seja por questão de performance, &lt;em&gt;design&lt;/em&gt; ou restrição tecnológica.&lt;/p&gt;

&lt;p&gt;Esse artigo irá lhe mostrar que podemos ter um Objeto &lt;em&gt;imutável&lt;/em&gt; para o mundo externo, mesmo ele sendo &lt;em&gt;mutável&lt;/em&gt; internamente.&lt;/p&gt;

&lt;h2 id=&quot;mutabilidade&quot;&gt;Mutabilidade&lt;/h2&gt;

&lt;p&gt;Na Orientação a Objetos, toda mutabilidade deve ser controlada.&lt;/p&gt;

&lt;p&gt;Nenhum atributo deve estar disponível para alteração de forma direta. Devemos, sempre, prover uma restrição com a máxima segurança aos atributos de um Objeto.&lt;/p&gt;

&lt;p&gt;A maioria das linguagens com suporte a Orientação a Objetos já faz isso por padrão. Basta declararmos os atributos como &lt;code&gt;private&lt;/code&gt; para que eles não sejam vistos fora do escopo do Objeto.&lt;/p&gt;

&lt;p&gt;Infelizmente, o uso das &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_(computer_programming)&quot;&gt;técnicas de reflexão&lt;/a&gt; acabaram com essa segurança, nos levando de volta aos tempos da programação procedural e variáveis globais, onde tudo está acessível a todos… mas, nesse artigo, vamos fingir que isso não existe. 
Voltemos aos atributos e a mutabilidade.&lt;/p&gt;

&lt;p&gt;Não me refiro aos atributos que fazem parte do &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado&lt;/a&gt; do Objeto, pois esses não deveriam ser violados.&lt;/p&gt;

&lt;p&gt;A mutabilidade estará em algo que chamo de &lt;a href=&quot;/atributos-primarios-secundarios#secundario&quot;&gt;atributos secundários&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esses tipo de atributo não faz parte do Estado do Objeto.
Então &lt;em&gt;ninguém&lt;/em&gt;, além do próprio Objeto, sabe de sua existência.&lt;/p&gt;

&lt;p&gt;Vejamos o mesmo exemplo do &lt;a href=&quot;/atributos-primarios-secundarios#secundario&quot;&gt;artigo anterior&lt;/a&gt;:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/48237c902271b6f2c3a314d3b6f5b8c0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O atributo &lt;code&gt;FStream&lt;/code&gt; não faz parte do Estado do Objeto. Esse atributo foi criado pensando na performance, ou seja, toda vez que o método &lt;code&gt;TFile.Stream&lt;/code&gt; for chamado, apenas na primeira vez o &lt;em&gt;stream&lt;/em&gt; do arquivo será lido em disco.&lt;/p&gt;

&lt;p&gt;É um atributo secundário.&lt;/p&gt;

&lt;p&gt;Mas algo muito importante deve ficar claro:
Poderíamos &lt;em&gt;remover&lt;/em&gt; esse atributo.&lt;/p&gt;

&lt;p&gt;Para o Objeto exercer seu &lt;a href=&quot;/posts/interfaces-em-todo-lugar/#interfaces-sao-contratos&quot;&gt;contrato&lt;/a&gt;, ele não é necessário!&lt;/p&gt;

&lt;p&gt;A implementação do Método poderia ser apenas isso:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/0aea75fefaf8612d0bc84d5fc9ce85a0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O Objeto continuaria funcionando, no entanto teríamos o “problema” da performance.&lt;/p&gt;

&lt;p&gt;Então o programador opta por implementar algo interno ao Objeto. Algo que pode ser alterado a qualquer momento, sem impacto na manutenção do código externo ao Objeto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Vimos que não há problemas em termos atributos secundários mutáveis dentro de Objetos — se o Objeto souber gerenciá-los corretamente.&lt;/p&gt;

&lt;p&gt;O que acontece dentro de um Objeto, é segredo do Objeto.&lt;/p&gt;

&lt;p&gt;Então seria vantagem criar tais atributos? Depende.&lt;/p&gt;

&lt;p&gt;Haverá casos que é mais simples criar algo interno ao Objeto. Mas outras vezes, não.&lt;/p&gt;

&lt;p&gt;Você irá decidir com base nas Regras de Negócio, performance, simplicidade, &lt;em&gt;design&lt;/em&gt; das Classes… e prazo de entrega do seu software.&lt;/p&gt;

&lt;p&gt;Felizmente, como são atributos privados, você pode alterar o código qualquer momento.&lt;/p&gt;

&lt;p&gt;Então, não pense tanto sobre isso.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Jun 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/mutabilidade-encapsulada</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/mutabilidade-encapsulada</guid>
      </item>
    
      <item>
        <title>Atributos Primários e Secundários</title>
        <description>&lt;p&gt;Um Objeto pode ter Atributos Primários e Secundários.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-tim-gouw-60216.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Os &lt;a href=&quot;/posts/menos-e-mais/#atributos&quot;&gt;atributos&lt;/a&gt; de um Objeto são a representação do seu conhecimento, ou seja, tudo que o Objeto &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsula&lt;/a&gt; é representado por atributos.&lt;/p&gt;

&lt;p&gt;Assim como uma Classe pode ter 2 tipos de &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt;, um Objeto pode ter 2 tipos de atributos: Primários e Secundários.&lt;/p&gt;

&lt;h2 id=&quot;primarios&quot;&gt;Primários&lt;/h2&gt;

&lt;p&gt;Atributos Primários são aqueles que fazem parte do &lt;a href=&quot;/estado-do-objeto&quot;&gt;Estado do Objeto&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;São os atributos inicializados pela Classe, passados ao Objeto através do construtor com a finalidade de representar uma &lt;a href=&quot;/posts/objetos-representam-entidades/#o-que-e-uma-entidade&quot;&gt;Entidade&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/5952c6f39810803d91b05a6f1c4b8766.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Na Classe &lt;code&gt;TFile&lt;/code&gt; acima, há apenas 1 argumento no construtor. Esse argumento será parte do Estado do Objeto e, portanto, irá inicializar um Atributo Primário chamado &lt;code&gt;FFilePath&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;secundario&quot;&gt;Secundários&lt;/h2&gt;

&lt;p&gt;Atributos Secundários são todos os atributos que não foram inicializados pelo construtor da Classe.&lt;/p&gt;

&lt;p&gt;São atributos de &lt;em&gt;suporte tecnológico&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/48237c902271b6f2c3a314d3b6f5b8c0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Nesse exemplo acima a Classe &lt;code&gt;TFile&lt;/code&gt; foi atualizada. Um novo atributo &lt;code&gt;FStream&lt;/code&gt; foi adicionado.&lt;/p&gt;

&lt;p&gt;Esse atributo não foi passado no construtor, então ele é um Atributo Secundário.&lt;/p&gt;

&lt;p&gt;O método &lt;code&gt;Stream&lt;/code&gt; irá retornar o &lt;em&gt;stream&lt;/em&gt; do arquivo, no entanto os dados do arquivo em disco serão lidos apenas na primeira execução, pois após inicializar o atributo &lt;code&gt;FStream&lt;/code&gt; ele não é mais atualizado.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TDataStream&lt;/code&gt; é irrelevante para o entendimento, mas veja que o &lt;em&gt;path&lt;/em&gt; do arquivo é passado. Então essa Classe irá ler o arquivo em disco e retornar uma instância de &lt;code&gt;IDataStream&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Atributos Primários são inicializados através do construtor da Classe e &lt;em&gt;devem&lt;/em&gt; ser &lt;a href=&quot;/posts/objetos-imutaveis/&quot;&gt;imutáveis&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Atributos Secundários podem ou não ser inicializados através do construtor da Classe, pois eles podem ser inicializados a qualquer momento e em qualquer lugar do Objeto.&lt;/p&gt;

&lt;p&gt;Tudo são atributos, mas saber essa diferença sutil entre Atributos Primários e Secundários é essencial para construírmos Classes melhores.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Jun 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/atributos-primarios-secundarios</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/atributos-primarios-secundarios</guid>
      </item>
    
      <item>
        <title>Estado do Objeto</title>
        <description>&lt;p&gt;Estado de um Objeto. Existem dois tipos. Entenda-os e torne-os invioláveis.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-tim-evans-88330.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Venho escrevendo sobre Orientação a Objetos e já falei  várias vezes sobre o &lt;em&gt;Estado de um Objeto&lt;/em&gt;, mas nunca havia explicado o que exatamente isso significa.&lt;/p&gt;

&lt;p&gt;Saber esse conceito é primordial para o entendimento da verdadeira Orientação a Objetos.&lt;/p&gt;

&lt;h2 id=&quot;estado&quot;&gt;O que é Estado&lt;/h2&gt;

&lt;p&gt;Todo Objeto é composto de Estado e Comportamento.&lt;/p&gt;

&lt;p&gt;Enquanto o comportamento é o que o Objeto &lt;em&gt;faz&lt;/em&gt;, Estado é o que o Objeto &lt;em&gt;sabe&lt;/em&gt; sobre a &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;Entidade&lt;/a&gt; que ele está representando dentro do &lt;em&gt;software&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Todo Objeto tem um Estado, mesmo que você não saiba sobre ele.&lt;/p&gt;

&lt;p&gt;Existem basicamente dois tipos de Estado.&lt;/p&gt;

&lt;h2 id=&quot;implicito&quot;&gt;Estado Implícito&lt;/h2&gt;

&lt;p&gt;Todo Objeto tem ou &lt;a href=&quot;/posts/objetos-sem-estado/&quot;&gt;deveria&lt;/a&gt; ter um Estado. No entanto existem casos especiais onde um Estado inicial não faz sentido &lt;em&gt;tecnicamente&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Um exemplo de um Objeto sem Estado inicial é uma Lista. Podemos inicializar a lista com um item, porém nem sempre esse será o caso. Na maioria das vezes queremos uma lista para depois ir adicionando itens. Então iniciamos a lista sem Estado aparente.&lt;/p&gt;

&lt;p&gt;Isso é fato se tivermos uma visão estritamente técnica. Mas quando essa lista for instânciada na memória do computador, seu Estado será inicializado. Em outras palavras, a área de memória que o Sistema Operacional concedeu ao Objeto será, também, o seu Estado.&lt;/p&gt;

&lt;p&gt;Pensando &lt;em&gt;filosoficamente&lt;/em&gt;, no
&lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtor&lt;/a&gt; de uma Classe Lista que é inicializada vazia, “sem estado”, seria passado o endereço de memória onde a lista iria residir na memória do computador. Porém construtores já fazem isso por padrão — encontram um endereço de memória disponível — então não há necessidade de sabermos endereços de memória e muito menos passá-los no construtor.&lt;/p&gt;

&lt;p&gt;Estados implícitos devem ser utilizados apenas para Objetos primários ou muito genéricos, como uma lista.&lt;/p&gt;

&lt;h2 id=&quot;explicito&quot;&gt;Estado Explícito&lt;/h2&gt;

&lt;p&gt;Argumentos nos &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt; de Classes mostram a intenção do desenvolvedor em instanciar um Objeto com um Estado Explícito.&lt;/p&gt;

&lt;p&gt;No entanto tais argumentos podem ou não fazer parte do Estado do Objeto que queremos inicializar.&lt;/p&gt;

&lt;p&gt;É o Objeto que irá decidir o que utilizar no seu Estado.&lt;/p&gt;

&lt;p&gt;Por exemplo. Numa Classe &lt;code&gt;TSalary&lt;/code&gt;, que representa um salário de alguém, é esperado um argumento no construtor do tipo &lt;code&gt;IMoney&lt;/code&gt;, que é uma &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interface&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TSalary&lt;/code&gt; poderia ter um outro construtor secundário com um argumento do tipo &lt;code&gt;string&lt;/code&gt;. Porém sabemos que um &lt;em&gt;TSalary&lt;/em&gt; não é uma &lt;em&gt;string&lt;/em&gt; e seu Estado não pode ser inicializado com um valor que não seja um &lt;code&gt;IMoney&lt;/code&gt;. Então porque esse construtor existe?&lt;/p&gt;

&lt;p&gt;Um exemplo de implementação desses construtores poderia ser assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// primary
construtor TSalary.Create(Value: IMoney);
begin
  FValue := Value;
end;

// secondary
construtor TSalary.Create(const Value: string);
begin
  Create(TStringAsMoney.New(Value));
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima o construtor secundário chama o primário com o argumento correto, do tipo &lt;code&gt;IMoney&lt;/code&gt;, porém outro Objeto é utilizado. O argumento &lt;code&gt;Value&lt;/code&gt; do tipo &lt;em&gt;string&lt;/em&gt; não faz parte do estado de &lt;code&gt;TSalary&lt;/code&gt; porém faz parte do estado de &lt;code&gt;TStringAsMoney&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Como eu disse antes, o Objeto que decide.&lt;/p&gt;

&lt;p&gt;Estados explícitos devem ser utilizados em todos os Objetos de alto nível e de regras de negócio.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;De todo esse papo técnico mas também filosófico, o que você nunca deve esquecer quando estiver construindo uma Classe é:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;O estado de um Objeto jamais deve ser violado.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Após o Objeto ser criado, seu Estado — implícito ou explícito — nunca poderia ser alterado, permanecendo intacto até o fim da sua vida.&lt;/p&gt;

&lt;p&gt;Se esse Estado for violado significa que seu Objeto não possui &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Um Objeto que não encapsula não pode ser considerado um Objeto. Chame-o de estrutura de dados.&lt;/p&gt;

&lt;p&gt;Objetos tem Estado, estruturas tem Dados.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Jun 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/estado-do-objeto</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/estado-do-objeto</guid>
      </item>
    
  </channel>
</rss>
