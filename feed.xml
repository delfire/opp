<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Pascal Programming</title>
    <description>Sacadas sobre Programação Orientada a Objetos e Object Pascal.
</description>
    <link>http://objectpascalprogramming.com/</link>
    <atom:link href="http://objectpascalprogramming.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Classes Aninhadas</title>
        <description>&lt;p&gt;As Classes Aninhadas reduzem o número de Classes públicas, melhoram o encapsulamento, o polimorfismo local e a legibilidade do código.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-iorni-321845.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by iorni on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A maneira mais fácil (preguiçosa e errada) de reaproveitar código é utilizando &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-1/&quot;&gt;herança&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse é o início do aprendizado sobre &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Como muito mais tempo, aprendemos que a &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;Decoração&lt;/a&gt; e Composição de Objetos é o &lt;em&gt;melhor&lt;/em&gt; caminho para &lt;em&gt;adicionar&lt;/em&gt; e &lt;em&gt;reaproveitar&lt;/em&gt; comportamento, respectivamente.&lt;/p&gt;

&lt;p&gt;Classes Aninhadas tem tudo haver com Decoração e Composição.&lt;/p&gt;

&lt;p&gt;Nesse artigo você irá aprender como utilizar Classes Aninhadas para melhorar o encapsulamento e polimorfismo, acrescentando comportamento específico e localizado, sem o uso de &lt;em&gt;“Class Helpers”&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;classes-aninhadas&quot;&gt;Classes Aninhadas&lt;/h2&gt;

&lt;p&gt;A linguagem Object Pascal, apesar de ser bem antiga, está em constante desenvolvimento.&lt;/p&gt;

&lt;p&gt;Mas, eu sou avesso a grandes mudanças na linguagem. Em qualquer linguagem.&lt;/p&gt;

&lt;p&gt;Também não sou a favor de acrescentar novas &lt;em&gt;features&lt;/em&gt; apenas por quê existem em &lt;em&gt;outras&lt;/em&gt; linguagens.&lt;/p&gt;

&lt;p&gt;Quanto mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; for uma linguagem, mais fácil será o entendimento do código.&lt;/p&gt;

&lt;p&gt;Na minha opinião, ao invés de acrescentar novas &lt;em&gt;features&lt;/em&gt; numa linguagem, os desenvolvedores deviam trabalhar em novas &lt;em&gt;Libraries&lt;/em&gt; que resolvem problemas específicos.&lt;/p&gt;

&lt;p&gt;No entanto, algumas &lt;em&gt;features&lt;/em&gt; realmente podem fazer a diferença, ou seja, tornar o código melhor e mais simples.&lt;/p&gt;

&lt;p&gt;O conceito de Classes Aninhadas é simples: Permitir a declaração de Classes dentro de Classes. Sejam elas privadas ou públicas.&lt;/p&gt;

&lt;p&gt;Veja um exemplo da sintaxe:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/96820c816ffa3e1eb5296a330e3a1cef.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No código acima, para declarar uma Classe &lt;code&gt;TBar&lt;/code&gt;, foi necessário fazer a referência a Classe &lt;code&gt;TFoo&lt;/code&gt;, primeiramente.&lt;/p&gt;

&lt;p&gt;Então, &lt;code&gt;TBar&lt;/code&gt; é uma Classe Aninhada em &lt;code&gt;TFoo&lt;/code&gt; ou, em outras palavras, &lt;code&gt;TBar&lt;/code&gt; está encapsulada em &lt;code&gt;TFoo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Acredito que para o compilador, uma Classe Aninhada é apenas outra qualquer. Não há penalidades no código. A primeira Classe da hierarquia &lt;em&gt;não&lt;/em&gt; irá criar Objetos maiores devido as Classes Aninhadas.&lt;/p&gt;

&lt;p&gt;Para nós, desenvolvedores, é apenas um &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;&lt;em&gt;Syntactic sugar&lt;/em&gt;&lt;/a&gt; que parece não valer muito a pena prestar atenção.&lt;/p&gt;

&lt;p&gt;No entanto, para um &lt;em&gt;design&lt;/em&gt; realmente &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt;, esta é uma &lt;em&gt;feature&lt;/em&gt; que proporciona uma &lt;em&gt;grande&lt;/em&gt; melhoria no código.&lt;/p&gt;

&lt;h2 id=&quot;redescobrindo&quot;&gt;Redescobrindo&lt;/h2&gt;

&lt;p&gt;O fato é que não faz tanto tampo que eu descobri que a linguagem Object Pascal tem suporte a Classes Aninhadas. Bem, talvez eu já tenha lido sobre isso já faz alguns anos, mas a verdade é que eu nunca tinha utilizado tal recurso em sistemas reais.&lt;/p&gt;

&lt;p&gt;Há 3 semanas atrás, esse conceito retornou a minha mente após receber um e-mail relacionado a uma nova &lt;em&gt;issue&lt;/em&gt; num sistema privado.&lt;/p&gt;

&lt;p&gt;Eu tinha que fazer uma manutenção no código e um dos requisitos dizia que uma parte do sistema deveria se comportar de maneira ligeiramente diferente da condição atual, mas por um curto período de tempo.&lt;/p&gt;

&lt;p&gt;O motivo era que um segundo sistema estava sendo alterado e, enquanto essa tarefa não estivesse concluída, o primeiro sistema deveria se comportar de acordo com o requisito citado.&lt;/p&gt;

&lt;p&gt;Como o sistema é privado, o requisito real é irrelevante.&lt;/p&gt;

&lt;p&gt;Mas, para que você entenda como as Classes Aninhadas me ajudaram a implementar o requisito de forma simples, clássica e seguindo os &lt;a href=&quot;lista-vip/&quot;&gt;princípios&lt;/a&gt; da Orientação a Objetos, vou apresentar uma forma bem simplificada do que deveria ser alterado no código para a solução da tarefa.&lt;/p&gt;

&lt;h2 id=&quot;problema&quot;&gt;O Problema&lt;/h2&gt;

&lt;p&gt;Imagine que você tenha uma Unit com algumas Classes.&lt;/p&gt;

&lt;p&gt;Essas Classes utilizam outras Classes de outras Units.&lt;/p&gt;

&lt;p&gt;Para implementar o requisito, uma dessas Classes deveria ser alterada. No entanto, a alteração era relacionada com a Composição de outra Classe — na verdade eram outras Classes, no plural, mas vamos manter simples.&lt;/p&gt;

&lt;p&gt;Então temos o seguinte:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A Classe &lt;code&gt;TFoo&lt;/code&gt; é a que temos que alterar. No entanto ela trabalha com uma instância de &lt;code&gt;TBar&lt;/code&gt; internamente — novamente, por motivos de simplificação, vamos esquecer que a instância de &lt;code&gt;TBar&lt;/code&gt; deveria ser &lt;a href=&quot;/injecao-de-dependencia&quot;&gt;injetada&lt;/a&gt; no &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtor&lt;/a&gt; da Classe &lt;code&gt;TFoo&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;A interação entre as Classes &lt;code&gt;TFoo&lt;/code&gt; e &lt;code&gt;TBar&lt;/code&gt; era o que deveria ser alterado para a conclusão do requisito. No entanto, todas as outras Classes pertencentes a mesma Unit de &lt;code&gt;TFoo&lt;/code&gt; deveriam continuar com o mesmo comportamento atual. Em outras palavras, a Classe &lt;code&gt;TBar&lt;/code&gt; deveria ser alterada &lt;em&gt;apenas&lt;/em&gt; na implementação (local) de &lt;code&gt;TFoo&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Temos várias maneiras de implementar isso, é claro.&lt;/p&gt;

&lt;p&gt;Antes, vamos &lt;a href=&quot;/posts/nomeando-unidades/&quot;&gt;nomear&lt;/a&gt; algumas coisas para facilitar o entendimento:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Acme.Foos.Clss&lt;/code&gt; -&amp;gt; é a Unit onde a Classe &lt;code&gt;TFoo&lt;/code&gt; está declarada;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Acme.Bars.Clss&lt;/code&gt; -&amp;gt; é a Unit onde a Classe &lt;code&gt;TBar&lt;/code&gt; está declarada;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Então, para implementar o requisito, nós poderíamos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementar uma nova Classe na Sessão de Interface da &lt;code&gt;Acme.Bars.Clss&lt;/code&gt; chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Implementar uma nova Classe na Sessão de Interface da &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Criar uma nova Unit &lt;code&gt;Acme.Bars.Ex.Clss&lt;/code&gt; e implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; ou;&lt;/li&gt;
  &lt;li&gt;Implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Implementação da unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O caminho a ser escolhido é quase infinito, porém essas seriam as opções mais comuns, considerando que não queremos fazer uma refatoração muito grande no código. Será uma alteração temporária, lembra?&lt;/p&gt;

&lt;p&gt;Infelizmente, existem problemas de &lt;em&gt;design&lt;/em&gt; com todas as opções acima.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Implementar a nova Classe &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Interface de &lt;code&gt;Acme.Bars.Clss&lt;/code&gt; ou &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; irá disponibilizar a nova Classe para todo o sistema. Como é uma Classe temporária, ela não deveria estar disponível… não dessa forma.&lt;/li&gt;
  &lt;li&gt;Criar uma nova Unit &lt;code&gt;Acme.Bars.Ex.Clss&lt;/code&gt; é ainda pior, pois depois de algum tempo a Unit deverá ser removida, havendo mais alterações no código.&lt;/li&gt;
  &lt;li&gt;Por fim, implementar uma nova Classe chamada &lt;code&gt;TBarEx&lt;/code&gt; na Sessão de Implementação da unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt; seria a opção mais viável. No entanto não teria sido um código elegante, pois essa nova Classe seria criada para apenas para um caso específico mas elas estaria disponível para a Unit inteira. Também tem o fato de que a Classe &lt;em&gt;deve&lt;/em&gt; ter um nome diferente (&lt;code&gt;TBar&lt;/code&gt; vs &lt;code&gt;TBarEx&lt;/code&gt;) — esse é um dos motivos de adicionarmos prefixos ou sufixos estranhos — para não haver conflito com todas as instâncias de &lt;code&gt;TBar&lt;/code&gt; que continuam sendo utilizadas por toda a Unit &lt;code&gt;Acme.Foos.Clss&lt;/code&gt;. O ideal seria continuar utilizando a nomenclatura &lt;code&gt;TBar&lt;/code&gt;, de acordo com o domínio. Mas, infelizmente, a técnica de &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclaração de Classes&lt;/a&gt; não seria possível, pois só queremos uma &lt;code&gt;TBar&lt;/code&gt; diferente em apenas um lugar na Unit.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Eu não escolhi nenhuma das possíveis soluções acima.&lt;/p&gt;

&lt;h2 id=&quot;solucionando&quot;&gt;A Solução&lt;/h2&gt;

&lt;p&gt;Após pensar por alguns minutos sobre como resolver o requisito, o conceito de Classes Aninhadas retornou a minha mente como a melhor escolha.&lt;/p&gt;

&lt;p&gt;A solução é tão simples que você já a conhece. Está no início desse artigo!&lt;/p&gt;

&lt;p&gt;Vou apenas adicionar mais código para deixar a implementação mais contextualizada:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/b292e33439d9867b2c8c92d8caba4a96.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Agora, em todos os métodos de &lt;code&gt;TFoo&lt;/code&gt; que for preciso decorar instâncias de &lt;code&gt;IBar&lt;/code&gt;, uma Classe de &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nomenclatura&lt;/a&gt; simples e &lt;em&gt;local&lt;/em&gt; poderá ser utilizada sem haver conflito de nomes na Unit.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TFoo&lt;/code&gt; tem sua própria implementação privada de &lt;code&gt;TBar&lt;/code&gt;. Nenhum outro código no sistema poderá utilizar essa implementação.&lt;/p&gt;

&lt;p&gt;É uma solução &lt;em&gt;local&lt;/em&gt;, sem &lt;em&gt;workarounds&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Espero que os exemplos não tenham sido muito abstratos. A ideia foi mostrar o potencial dessa simples &lt;em&gt;feature&lt;/em&gt; sem deixar o artigo muito longo.&lt;/p&gt;

&lt;p&gt;É uma solução simples e bastante elegante. Totalmente de acordo com os princípios da Orientação a Objetos, encapsulamento e polimorfismo.&lt;/p&gt;

&lt;p&gt;A nomenclatura das Classes é simples, mantendo a legibilidade do código.&lt;/p&gt;

&lt;p&gt;A linguagem Object Pascal continua a me surpreender, mesmo após mais de 16 anos que a utilizo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
        <link>http://objectpascalprogramming.com/classes-aninhadas</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/classes-aninhadas</guid>
      </item>
    
      <item>
        <title>API Unit: Tudo num só lugar</title>
        <description>&lt;p&gt;Uma única técnica que resolve muitos problemas.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-nordwood-themes-166423.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by NordWood Themes on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Quando você utiliza uma Classe muitas vezes, já deve ter memorizado em qual Unit a Classe foi implementada.&lt;/p&gt;

&lt;p&gt;Mas e se &lt;em&gt;Library&lt;/em&gt; (Lib) que você está utilizando é nova ou foi completamente remodelada?&lt;/p&gt;

&lt;p&gt;E se você está tentando fazer um trabalho que nunca fez antes?&lt;/p&gt;

&lt;p&gt;Como saber as Classes existentes na Lib?&lt;/p&gt;

&lt;p&gt;Há basicamente 3 opções:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Abrir todas as Units da Lib e ler o código;&lt;/li&gt;
  &lt;li&gt;Ler a documentação, se houver;&lt;/li&gt;
  &lt;li&gt;Abrir apenas uma Unit que contenha todas as Interfaces e Classes;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Esse artigo é sobre a última opção, que eu chamo de “API Unit”.&lt;/p&gt;

&lt;h2 id=&quot;api-unit&quot;&gt;API Unit&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;API Unit&lt;/em&gt; é um conceito em fase de experimentação.&lt;/p&gt;

&lt;p&gt;A ideia é simples: Disponibilizar ao desenvolvedor, todas as Interfaces e Classes de &lt;em&gt;uso público&lt;/em&gt; em apenas 1 Unit.&lt;/p&gt;

&lt;p&gt;Não estou dizendo que deveríamos codificar &lt;em&gt;tudo&lt;/em&gt; num único arquivo. Isso seria insano. Mas se houvesse uma maneira de continuarmos codificando em módulos mas, ao mesmo tempo, termos tudo disponível para uso em apenas 1 única Unit, não acha que seria interessante?&lt;/p&gt;

&lt;p&gt;Já vi projetos onde os autores utilizavam arquivos &lt;code&gt;*.inc&lt;/code&gt; para ir montando a “verdadeira” Unit — o FPC e Lazarus utilizam essa técnica — mas eu acho confuso de administrar, além de dificultar a leitura do código.&lt;/p&gt;

&lt;p&gt;Não fui por esse caminho e continuei pensando…&lt;/p&gt;

&lt;p&gt;Então, tive uma ideia que chamei de &lt;em&gt;API Unit&lt;/em&gt;, meio que “por acaso”, após a publicação desse &lt;a href=&quot;/nomeando-classes-em-libraries&quot;&gt;artigo&lt;/a&gt;. Eu estava pensando em outras possibilidades para nomear Interfaces e Classes, algo que já havia explicado em outro artigo.&lt;/p&gt;

&lt;p&gt;Por quê?&lt;/p&gt;

&lt;p&gt;Bem, a técnica de nomenclatura que expliquei anteriormente continua válida, porém pode haver Libs mais complexas com &lt;a href=&quot;/posts/nomeando-classes/&quot;&gt;nomes de Classes&lt;/a&gt; bem especializadas. Esses nomes tem a tendência de serem maiores e adicionar o nome da Lib como prefixo — conforme explicado no &lt;a href=&quot;/nomeando-classes-em-libraries&quot;&gt;artigo&lt;/a&gt; — deixando o nome da Classe ainda mais verboso.&lt;/p&gt;

&lt;p&gt;A linguagem Object Pascal não tem uma sintaxe para “renomear” uma Unit dentro do código. Algo &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; de se fazer em linguagens como Python, C# e Lua, por exemplo. Nessas linguagens, após o &lt;em&gt;“import”&lt;/em&gt; do arquivo, o desenvolvedor pode escolher um &lt;em&gt;alias&lt;/em&gt; para a “unidade”, ou seja, ele pode renomear dinamicamente o arquivo que irá conter as Interfaces, Classes e todo o resto.&lt;/p&gt;

&lt;p&gt;Eu mesmo já &lt;a href=&quot;http://wiki.freepascal.org/Namespaces#The_.22uses.22_clause&quot;&gt;solicitei&lt;/a&gt; essa &lt;em&gt;feature&lt;/em&gt; para os desenvolvedores do &lt;a href=&quot;https://freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt;, porém o pedido foi ignorado devido haver outras prioridades.&lt;/p&gt;

&lt;p&gt;Como isso não é possível (hoje), voltei para os meus pensamentos.&lt;/p&gt;

&lt;p&gt;Seria possível utilizar a nomenclatura mais simples (nomes curtos para Units, Interfaces e Classes) sem haver colisão de nomes?&lt;/p&gt;

&lt;p&gt;Meus requisitos foram:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Classes com nomes curtos e simples;&lt;/li&gt;
  &lt;li&gt;Havendo colisão de nomes entre Classes, a Unit seria utilizada como prefixo;&lt;/li&gt;
  &lt;li&gt;Units devem ter o nome mais curto possível, porém legível e sem ambiguidades;&lt;/li&gt;
  &lt;li&gt;O usuário da Lib deveria ter o controle da nomenclatura utilizada em seus sistemas;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Vamos analisar cada item:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Classes com nomes curtos e simples&lt;/strong&gt; deveria ser a norma utilizada em &lt;em&gt;todos&lt;/em&gt; os sistemas. Mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; de ler, mas fácil de entender.&lt;/p&gt;

&lt;p&gt;Ao invés de escrevermos &lt;code&gt;TAcCar&lt;/code&gt; ou &lt;code&gt;TAcmeCar&lt;/code&gt;, iríamos utilizar apenas &lt;code&gt;TCar&lt;/code&gt;. Mas, conforme explicado no artigo sobre nomenclatura, há grandes possibilidades de haver uma colisão de nomes caso duas ou mais unidades tenham utilizado o mesmo identificador &lt;code&gt;TCar&lt;/code&gt; e isso nos leva ao segundo requisito.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Havendo colisão de nomes entre Classes, a Unit seria utilizada como prefixo&lt;/strong&gt; e o problema estaria resolvido. No entanto, é muito verboso declarar um método assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TDriver.Drive(
  ACar: Acme.Interfaces.Cars.ICar): IDriver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O argumento &lt;code&gt;ACar&lt;/code&gt; é um tipo de Interface declarado em alguma Lib externa chamada &lt;code&gt;Acme&lt;/code&gt;. E foi preciso prefixar a Interface &lt;code&gt;ICar&lt;/code&gt; por que o seu projeto, hipoteticamente, também tem uma interface com o mesmo nome em outra Unit.&lt;/p&gt;

&lt;p&gt;Imagine agora esse mesmo método com mais 4 argumentos, sendo cada um deles prefixado com a Unit. O método ficaria muito mais verboso e, talvez, difícil de entender.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Units devem ter o nome mais curto possível, porém legível e sem ambiguidades&lt;/strong&gt; mas a linguagem não nos dá essa opção. Se fosse possível criar um &lt;em&gt;alias&lt;/em&gt; no Object Pascal poderíamos fazer isso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  Acme.Interfaces.Cars.ICar as Acme;

function TDriver.Drive(ACar: Acme.ICar): IDriver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse ponto você pode estar pensando que voltamos a utilizar a mesma &lt;a href=&quot;/nomeando-classes-em-libraries&quot;&gt;técnica&lt;/a&gt; anterior, ou seja, o nome da Lib é o prefixo.&lt;/p&gt;

&lt;p&gt;Ora, afinal o identificador &lt;code&gt;Acme.ICar&lt;/code&gt; não é tão diferente de &lt;code&gt;IAcmeCar&lt;/code&gt;, não é?&lt;/p&gt;

&lt;p&gt;Sim, é verdade, porém com o uso (hipotético) de &lt;em&gt;alias&lt;/em&gt; é o usuário que tem o controle de qual nome utilizar como prefixo em todo o projeto. Algo que lhe dá liberdade, fazendo muita diferença.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O usuário da Lib deveria ter o controle da nomenclatura utilizada em seus sistemas&lt;/strong&gt; e não deixar que a Lib “imponha” um nome que, muitas vezes, é ambíguo, mal escolhido, confuso, verboso ou completamente sem sentido.&lt;/p&gt;

&lt;p&gt;É claro que identificadores fixos como &lt;code&gt;IAcmeCar&lt;/code&gt; podem ser &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclarados&lt;/a&gt;, porém se houver muitas Classes e Interfaces, poderia ser uma tarefa bem dispendiosa.&lt;/p&gt;

&lt;p&gt;Então, o uso de &lt;em&gt;alias&lt;/em&gt; na linguagem Object Pascal seria uma solução inovadora, porém não a temos.&lt;/p&gt;

&lt;p&gt;E é aí que entra a ideia da &lt;em&gt;API Unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Se todos os identificadores estivessem declarados em apenas uma única Unit, representando toda a Lib, poderíamos simular um &lt;em&gt;alias&lt;/em&gt; utilizando um arquivo físico.&lt;/p&gt;

&lt;p&gt;Veja &lt;a href=&quot;https://github.com/mdbs99/james/blob/d63a1b93e246012ffc49fa6ea86ad644ceef12f5/src/james.api.pas#L24&quot;&gt;aqui&lt;/a&gt; um bom exemplo do que é uma &lt;em&gt;API Unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;No &lt;em&gt;link&lt;/em&gt; acima podemos ver que todas as Interfaces e Classes da Lib estão declaradas (apenas um &lt;em&gt;alias&lt;/em&gt; para os identificadores em outras Unit ) em apenas uma única Unit e isso nos dá &lt;em&gt;grandes&lt;/em&gt; possibilidades que irei explicar mais adiante.&lt;/p&gt;

&lt;p&gt;No entanto, sempre haverá vantagens de desvantagens.&lt;/p&gt;

&lt;h2 id=&quot;desvantagens&quot;&gt;Desvantagens&lt;/h2&gt;

&lt;p&gt;Vou começar pelas desvantagens, pois as vantagens são bem maiores.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Você irá deixar o código do desenvolvedor da Lib um pouquinho mais verboso&lt;/strong&gt; por que, para cada Interface ou Classe existente, você terá que declarar um &lt;em&gt;alias&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por exemplo, veja nesse &lt;a href=&quot;https://github.com/mdbs99/james/blob/d63a1b93e246012ffc49fa6ea86ad644ceef12f5/src/james.data.clss.pas#L34-L52&quot;&gt;link&lt;/a&gt; que a Classe &lt;code&gt;TDataStream&lt;/code&gt; tem um &lt;em&gt;alias&lt;/em&gt; declarado como &lt;code&gt;TDataStreamAlias = TDataStream;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A princípio, o identificador &lt;code&gt;TDataStreamAlias&lt;/code&gt; não faz sentido para a Unit na qual ele foi declarado, mas será importante para montarmos a &lt;em&gt;API Unit&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Todas as Interfaces e Classes para os usuários devem estar numa única Unit&lt;/strong&gt; e isso é meio chato e talvez um pouco trabalhoso de se fazer.&lt;/p&gt;

&lt;p&gt;O desenvolvedor terá um pequeno retrabalho adicionando as Interfaces e Classes de outras Unit  na Unit de API. O desenvolvedor poderia até esquecer de fazer isso. No entanto se a Lib possuir testes automatizados, não haverá esquecimento, pois os próprios testes irão utilizar apenas a &lt;em&gt;API Unit&lt;/em&gt; e para testar uma Classe ela deve estar declarada lá.&lt;/p&gt;

&lt;h2 id=&quot;vantagens&quot;&gt;Vantagens&lt;/h2&gt;

&lt;p&gt;Agora vamos falar um pouco sobre as vantagens em utilizarmos essa simples técnica.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Se toda a Lib pode ser utilizada através de apenas 1 Unit&lt;/strong&gt; você pode criar um &lt;em&gt;alias&lt;/em&gt; apenas renomeando o arquivo original.&lt;/p&gt;

&lt;p&gt;Por exemplo. Se a Lib Acme do exemplo acima tivesse uma &lt;em&gt;API Unit&lt;/em&gt; ela poderia se chamar &lt;code&gt;Acme.API.pas&lt;/code&gt;. Mas se você não gostou do nome, se ele ainda é verboso ou se você já tem uma Unit com esse nome no seu projeto, bastaria renomear a Unit para, digamos, &lt;code&gt;LibAcme.pas&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então, qualquer colisão de nome entre Interfaces e Classes poderia ser resolvida apenas adicionando o “novo” nome da Lib como, por exemplo, &lt;code&gt;LibAcme.ICar&lt;/code&gt;. Simples, curto, fácil de entender e totalmente sob o controle do usuário da Lib.&lt;/p&gt;

&lt;p&gt;Se o desenvolvedor da Lib quiser ser ainda mais “legal” com o usuário, ele poderia criar um &lt;code&gt;.inc&lt;/code&gt; com todos os identificadores e declarar a &lt;code&gt;Acme.API &lt;/code&gt;assim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit Acme.API;

{$include api.inc}

end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Então o usuário nem mesmo precisaria renomear o arquivo original. Bastaria criar um novo arquivo, por exemplo &lt;code&gt;LibAcme.pas&lt;/code&gt;, no mesmo diretório e incluir a &lt;code&gt;api.inc&lt;/code&gt; no corpo da nova Unit.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Como é fácil renomear a Unit que contém a API&lt;/strong&gt; o desenvolvedor não precisaria mais se preocupar em adicionar prefixos de 2~3 letras em Interfaces e Classes afim de diminuir a colisão de nomes nos projetos que utilizam a Lib. Qualquer nome simples pode ser utilizado, pois qualquer conflito será &lt;em&gt;fácil&lt;/em&gt; de resolver adicionando a Unit quando for necessário.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O usuário não precisa memorizar as Units da Lib&lt;/strong&gt; pois tudo está num único só lugar. Simples e conveniente.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O desenvolvedor da Lib poderia incluir mais Interfaces e Classes&lt;/strong&gt; porém apenas para o uso “privado” da Lib sem que o usuário precise saber da existência desses novos artefatos. O usuário já estaria acostumado a utilizar apenas uma única Unit, então ele não iria ter “acesso” a outros identificadores que não estão listados lá. É claro que ele ainda poderia utilizar as Units reais da Lib, porém isso poderia ser informado na documentação que isso seria considerado um &lt;em&gt;“hack”&lt;/em&gt; ou quebra de &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; e o usuário estaria por conta própria.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ao definir um &lt;em&gt;alias&lt;/em&gt; para cada Interface ou Classe&lt;/strong&gt; — exemplo &lt;code&gt;TDataStreamAlias&lt;/code&gt;— não seria necessário &lt;a href=&quot;/redeclarando-classes&quot;&gt;redeclarar&lt;/a&gt; os identificadores na API utilizando as Units reais como prefixo.&lt;/p&gt;

&lt;p&gt;Compare as duas opções abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit James.API;

type
  {1} TDataStream = TDataStreamAlias;
  {2} TDataStream = James.Data.Clss.TDataStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Com certeza a primeira linha e menos verbosa.&lt;/p&gt;

&lt;p&gt;Esse é o motivo de haver esses identificadores que são apenas &lt;em&gt;alias&lt;/em&gt;. Além de ser menos verboso, o desenvolvedor poderia mover a &lt;code&gt;TDataStream&lt;/code&gt; para outra Unit e não precisaria alterar a API.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quando a API começar a ficar grande demais&lt;/strong&gt; será um sinal — ou um “cheiro” — de que a Lib pode estar fazendo coisas demais. Então a &lt;em&gt;API Unit&lt;/em&gt; é, também, uma restrição. Mas isso é bom. &lt;a href=&quot;/posts/menos-e-mais/&quot;&gt;Menos é mais&lt;/a&gt;, lembre-se disso.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Esse artigo tentou demostrar que utilizando apenas uma única técnica simples e um pouco mais trabalho, é possível melhorar muito a qualidade do código, resolvendo problemas de escopo, nomenclatura e legibilidade.&lt;/p&gt;

&lt;p&gt;Estou utilizando &lt;em&gt;API Unit&lt;/em&gt; em alguns projetos privados e &lt;em&gt;Open Sources&lt;/em&gt; (&lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;aqui&lt;/a&gt;) e a legibilidade tem melhorado.&lt;/p&gt;

&lt;p&gt;Penso em utilizar o mesmo conceito para delimitar API’s (módulos) em grandes sistemas, mas a &lt;a href=&quot;/posts/interfaces-e-a-referencia-circular-entre-objetos/&quot;&gt;referência circular&lt;/a&gt; entre Units pode ser um problema. Então o design do projeto tem que levar isso em conta desde o início.&lt;/p&gt;

&lt;p&gt;Se vai valer a pena… o tempo dirá.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Oct 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/api-unit</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/api-unit</guid>
      </item>
    
      <item>
        <title>Injeção de Dependência sem XML, Atributos/Anotações ou Frameworks</title>
        <description>&lt;p&gt;É possível utilizar a Injeção de Dependência na Orientação Objetos sem depender de características específicas da linguagem, Arquivos XML, Atributos/Anotações ou &lt;em&gt;Frameworks&lt;/em&gt;?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-vadim-sherbakov-36.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Vadim Sherbakov on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Injeção de Dependência&lt;/a&gt; ou apenas DI (em Inglês: &lt;em&gt;“Dependency Injection”&lt;/em&gt;) pode ser um assunto bem controverso que ainda geram muitas dúvidas entre desenvolvedores.&lt;/p&gt;

&lt;p&gt;Será que DI é algo complexo que exige um &lt;em&gt;framework&lt;/em&gt; para gerenciar as dependências entre Classes de um &lt;em&gt;software&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;É necessário um arquivo XML para que o desenvolvedor possa configurar tais dependências?&lt;/p&gt;

&lt;p&gt;Talvez possamos utilizar Atributos/Anotações para facilitar essas configurações?&lt;/p&gt;

&lt;p&gt;Como podemos utilizar o conceito de &lt;a href=&quot;https://en.wikipedia.org/wiki/Inversion_of_control&quot;&gt;IoC&lt;/a&gt; sem um &lt;em&gt;framework&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;O mercado tem várias maneiras de “injetar” alguma coisa, porém eu lhe digo: Injeção de Dependência é apenas passagem de parâmetro entre Objetos.&lt;/p&gt;

&lt;h2 id=&quot;artefatos&quot;&gt;Artefatos&lt;/h2&gt;

&lt;p&gt;Qualquer sistema &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt; que faça algo de útil, terá dependências entre suas Classes ou Módulos.&lt;/p&gt;

&lt;p&gt;Um Módulo/Classe &lt;code&gt;A&lt;/code&gt; que usa &lt;code&gt;B&lt;/code&gt; que usa &lt;code&gt;C&lt;/code&gt; (&lt;code&gt;A-&amp;gt;B-&amp;gt;C&lt;/code&gt;) estão conectados entre si.&lt;/p&gt;

&lt;p&gt;Sempre devemos minimizar essas dependências afim de facilitarmos a manutenção do código, porém é impossível não tê-las.&lt;/p&gt;

&lt;p&gt;Mesmo assim, o mercado resolveu criar todo tipo de “artefatos” como &lt;em&gt;frameworks&lt;/em&gt;, atributos/anotações ou configurações em arquivos XML, para “facilitar” a comunicação entre os Objetos, tornando “transparente” para o desenvolvedor as dependências existentes entre as Classes.&lt;/p&gt;

&lt;p&gt;Na minha opinião, eles trouxeram mais problemas e &lt;em&gt;complexidade&lt;/em&gt; do que uma real solução.&lt;/p&gt;

&lt;p&gt;Pense bem:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Um &lt;em&gt;Framework&lt;/em&gt; para Injeção de Dependência, deixa seu código &lt;em&gt;dependente&lt;/em&gt; do próprio &lt;em&gt;framework&lt;/em&gt; que gerencia as dependências!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Os Atributos/Anotações que informam quais atributos do Objeto devem ser inicializados “magicamente” utilizando &lt;em&gt;reflection/RTTI&lt;/em&gt; ou utilizando &lt;a href=&quot;https://en.wikipedia.org/wiki/Service_locator_pattern&quot;&gt;&lt;em&gt;Services Locators&lt;/em&gt;&lt;/a&gt;, retiram do Objeto seus &lt;a href=&quot;/posts/construtores-da-classe-primario-secundarios/&quot;&gt;construtores&lt;/a&gt;, tornando-o &lt;em&gt;anêmico&lt;/em&gt; e &lt;em&gt;procedural&lt;/em&gt;, pois é preciso chamar &lt;a href=&quot;/posts/getters-e-setters/#setters&quot;&gt;&lt;em&gt;Setters&lt;/em&gt;&lt;/a&gt; para “configurar” o Objeto antes de fazer algo de útil com ele. Seu uso é totalmente desencorajado pois viola o &lt;a href=&quot;/posts/heranca-pode-ser-o-mal-da-orientacao-a-objetos-parte-2/#encapsulamento&quot;&gt;encapsulamento&lt;/a&gt; transformando o Objeto num &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/#objeto-nao-e-um-balde-de-funcoes-e-dados&quot;&gt;“saco de dados”&lt;/a&gt;, além de introduzir &lt;a href=&quot;http://blog.ploeh.dk/2011/05/24/DesignSmellTemporalCoupling/&quot;&gt;acoplamento temporal&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Arquivos XML de configuração que armazenam quais Classes serão utilizadas para instanciar tais &lt;a href=&quot;/posts/interfaces-em-todo-lugar/&quot;&gt;Interfaces&lt;/a&gt; é algo abominável: é estático, não segue o princípio &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY&lt;/a&gt;, e não tem checagem de sintaxe.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tais “soluções” criam, na verdade, outros problemas.&lt;/p&gt;

&lt;p&gt;Mas, e se fosse possível ter um código mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt;, sem XML, sem Atributos/Anotações ou mesmo sem &lt;em&gt;Frameworks&lt;/em&gt;, para trabalharmos com a Injeção de Dependência utilizando &lt;em&gt;somente&lt;/em&gt; Classes e Objetos, você iria continuar utilizando outros artefatos complexos?&lt;/p&gt;

&lt;p&gt;Vamos ver quais são os tipos de dependências mais utilizadas e então veremos se é possível termos soluções simples para cada uma delas.&lt;/p&gt;

&lt;h2 id=&quot;dependencia-por-construtor&quot;&gt;Dependência por Construtor&lt;/h2&gt;

&lt;p&gt;Dependência por Construtor é a maneira mais simples e eficaz de resolver dependências entre Objetos.&lt;/p&gt;

&lt;p&gt;Esse é o tipo de &lt;em&gt;dependência pura&lt;/em&gt; que é negligenciado por muitos desenvolvedores.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;THash.New(
  TFile.New(&#39;file.xml&#39;).Stream
).Calc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No exemplo acima a Classe &lt;code&gt;THash&lt;/code&gt; recebe um &lt;code&gt;Stream&lt;/code&gt; (dependência) no seu construtor. Obviamente o tipo do argumento é uma Interface (ex: &lt;code&gt;IStream&lt;/code&gt;) para que não haja uma dependência “física” entre as Classes.&lt;/p&gt;

&lt;p&gt;Não há &lt;em&gt;nenhum&lt;/em&gt; problema a ser solucionado aqui. Essa é a forma mais correta e eficaz para “injetar” uma dependência.&lt;/p&gt;

&lt;p&gt;Sempre tente utilizar construtores para passar as dependências para os Objetos. A única exigência é que os argumentos do construtor sejam do tipo Interface ao invés de Classes.&lt;/p&gt;

&lt;h2 id=&quot;dependencia-por-decoracao&quot;&gt;Dependência por Decoração&lt;/h2&gt;

&lt;p&gt;A utilização de bibliotecas (Libs) é muito útil para desenvolvermos mais rápido. Ao invés de criamos tudo que o software precisa, podemos delegar vários serviços às Libs especialistas no assunto. É como “contratar” consultores profissionais para cada especialidade.&lt;/p&gt;

&lt;p&gt;O “problema” é que essas Libs utilizam seus próprios Objetos. Bem, elas sabem o que fazem, porém há momentos que gostaríamos de “dizer” a essas Libs quais Objetos deveriam retornar em alguns momentos.&lt;/p&gt;

&lt;p&gt;Seria interessante se pudéssemos &lt;a href=&quot;/posts/decorator-pattern/&quot;&gt;decorar&lt;/a&gt; instâncias retornadas por Objetos pertencentes a Lib.&lt;/p&gt;

&lt;p&gt;Por exemplo. No código abaixo nós obtemos uma instância de um Objeto que representa um Atributo num arquivo XML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Attr := 
  TXMLPack.New(
    TFile.New(&#39;file.xml&#39;).Stream
  )
  .Node(&#39;/root&#39;)
  .Attrs
  .Item(&#39;id&#39;);
ShowMessage(Attr.Text);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que o desenvolvedor não tem controle sobre como a Lib irá instanciar esse Objeto internamente, pois primeiro &lt;code&gt;TXMLPack&lt;/code&gt; retorna outro Objeto em &lt;code&gt;Node()&lt;/code&gt; e então retorna uma lista &lt;code&gt;Attrs&lt;/code&gt; para então pesquisar e retornar a instância que queremos.&lt;/p&gt;

&lt;p&gt;É claro que podemos decorar qualquer instância retornada por qualquer Lib dentro do nosso próprio código, mas teríamos que fazer isso todas as vezes em todos os lugares.&lt;/p&gt;

&lt;p&gt;Por exemplo, se quiséssemos decorar instâncias de &lt;code&gt;TXMLAttribute&lt;/code&gt; (Lib) com a nossa Classe &lt;code&gt;TMyAttribute&lt;/code&gt;, teríamos que implementar dessa forma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node := TXMLPack.New(
  TFile.New(&#39;file.xml&#39;).Stream
)
.Node(&#39;/root&#39;);

// id attribute
IdAttr := 
  TMyAttribute.New(
    Node(&#39;/root&#39;).Attrs.Item(&#39;id&#39;)
  );

// name attribute
NameAttr := 
  TMyAttribute.New(
    Node(&#39;/root&#39;).Attrs.Item(&#39;name&#39;)
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja acima que foi preciso decorar cada instância (Atributos &lt;code&gt;id&lt;/code&gt; e &lt;code&gt;name&lt;/code&gt;) com a nossa Classe.&lt;/p&gt;

&lt;p&gt;Mas mesmo sendo um código &lt;em&gt;repetitivo&lt;/em&gt;, é &lt;em&gt;viável&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, se a Lib for desenvolvida para dar a opção ao desenvolvedor para decorar esses Objetos criados internamente, é provável que ela utilize o padrão &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_factory_pattern&quot;&gt;&lt;em&gt;Abstract Factory&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Essa seria uma opção simples para utilizar Injeção de Dependência de forma totalmente desacoplada e sem repetições.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ First we need to include a factory
  in some place of the code }
  
TXAttributeFactories.New
  .Add(
    // your own factory
    TMyAttributeFactory.New
  );

// ...  
  
{ Then, Lib&#39;s code will use these factories
  to decorate each new Attribute instance }
  
function TCAttributes.Item(AIndex: Integer): IXAttribute;
var
  A: TDOMNode;
begin
  A := FNode.Attributes.Item[AIndex];
  if not Assigned(A) then
    raise EXError.CreateFmt(
      &#39;Node not found on index %d.&#39;, [AIndex]
    );

  { At this point, factories instance will 
    find TMyAttributeFactory instance and it 
    will use to return a new instance, 
    wrapping TCAttribute instance }

  Result := 
    TXAttributeFactories.New
      .Decorate(
        TCAttribute.New(FNode, A)
      );
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código acima é do &lt;a href=&quot;https://github.com/mdbs99/xavier/blob/47240049ff594904a856320d0b6e4ed8c979529f/src/xavier.xml.fpc.pas#L179&quot;&gt;Projeto Xavier&lt;/a&gt;, porém a chamada à Classe &lt;code&gt;TXAttributeFactories&lt;/code&gt; é apenas uma simulação, exemplificando como a implementação poderia ser codificada.&lt;/p&gt;

&lt;p&gt;Veja que o método &lt;code&gt;Decorate(Attr: IXAttribute)&lt;/code&gt; recebe apenas uma instância já criada, ou seja, a fábrica não sabe como criar uma nova instância de &lt;code&gt;IXAttribute&lt;/code&gt;, ela apenas sabe como decorar uma instância já existente.&lt;/p&gt;

&lt;h2 id=&quot;dependencia-tardia&quot;&gt;Dependência Tardia&lt;/h2&gt;

&lt;p&gt;Chamo de dependência tardia quando um &lt;code&gt;Objeto A&lt;/code&gt; só precisa de uma instância &lt;code&gt;B&lt;/code&gt; num dado momento, dependendo de uma escolha do usuário ou evento externo. Em outras palavras, não sabemos se iremos precisar ou não da instância do &lt;code&gt;Objeto B&lt;/code&gt; quando estivermos compondo nossos Objetos para trabalhar numa determinada tarefa.&lt;/p&gt;

&lt;p&gt;Talvez esse tenha sido o grande problema que mais motivou a construção dos artefatos e &lt;em&gt;frameworks&lt;/em&gt; já citados.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo:&lt;/p&gt;

&lt;p&gt;Suponha que o &lt;code&gt;Objeto A&lt;/code&gt; receba uma conexão com um SGBD através de seu construtor e em um dos seus métodos é instanciado um &lt;code&gt;Objeto B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A instância de &lt;code&gt;B&lt;/code&gt; também precisa da conexão com o SGBD, então basta passarmos no construtor de &lt;code&gt;B&lt;/code&gt; a conexão já recebida no &lt;code&gt;Objeto A&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então &lt;code&gt;B&lt;/code&gt;, em um de seus métodos, instancia e retorna um &lt;code&gt;Objeto C&lt;/code&gt; e, nesse caso, &lt;code&gt;C&lt;/code&gt; não precisa de uma conexão. No seu construtor não há nenhum argumento desse tipo.&lt;/p&gt;

&lt;p&gt;O programa continua e agora essa instância de &lt;code&gt;C&lt;/code&gt; precisa instanciar um &lt;code&gt;Objeto D&lt;/code&gt;. Esse último Objeto, tem métodos que retornam outros Objetos, porém para instanciá-los uma conexão ao SGBD é necessária… mas nesse ponto não temos esse Objeto da conexão.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A (conection)
  B (conection)
    C ()
      D ()
        E (conection ?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse é o &lt;em&gt;grande&lt;/em&gt; problema.&lt;/p&gt;

&lt;p&gt;Onde o &lt;code&gt;Objeto D&lt;/code&gt; iria conseguir uma conexão ao SGBD para utilizar como argumento na criação de outros Objetos que necessitam de tal argumento?&lt;/p&gt;

&lt;p&gt;Nas linguagens Funcionais, existe o conceito de &lt;a href=&quot;https://pt.wikipedia.org/wiki/Currying&quot;&gt;Currying&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ao invés de termos funções que recebem N parâmetros, haverá funções com apenas 1 parâmetro que chamará outra função, e outra, e mais outra…&lt;/p&gt;

&lt;p&gt;Esse vídeo explica o conceito:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/ZasXwtTRkio&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;No entanto, pode ser um conceito difícil de entender pra quem é acostumando com linguagens imperativas.&lt;/p&gt;

&lt;p&gt;Bem, não temos &lt;em&gt;Currying&lt;/em&gt; nas linguagens Orientadas a Objetos, mas temos &lt;em&gt;Classes&lt;/em&gt; e Objetos.&lt;/p&gt;

&lt;p&gt;Então, utilizando apenas Classes e Objetos, como podemos fazer a Injeção de Dependência e obter argumentos onde e quando for preciso?&lt;/p&gt;

&lt;p&gt;A resposta é a mesma: &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_factory_pattern&quot;&gt;&lt;em&gt;Abstract Factory&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;No entanto, ao invés de apenas decorar uma instância, a fábrica iria criar uma nova do início.&lt;/p&gt;

&lt;p&gt;Essas fábricas teriam mais métodos, possivelmente métodos com as mesmas assinaturas dos construtores e &lt;a href=&quot;/posts/interfaces-e-o-metodo-estatico-new/&quot;&gt;Métodos New&lt;/a&gt; já existente na Classe original.&lt;/p&gt;

&lt;p&gt;No exemplo anterior, o método &lt;code&gt;Decorate(...)&lt;/code&gt; foi utilizado para decorar uma instância já existente. Aqui, sugiro utilizar a nomenclatura &lt;code&gt;Make(...)&lt;/code&gt; que irá criar uma nova instância.&lt;/p&gt;

&lt;p&gt;Esse tipo de fábrica seria muito mais utilizado em aplicações do que em Libs, no entanto.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Injeção de Dependência é &lt;a href=&quot;http://blog.ploeh.dk/2017/01/27/dependency-injection-is-passing-an-argument/&quot;&gt;passagem de parâmetro&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Vimos nesse artigo algumas possíveis opções para resolver os tipos de Dependência mais comuns.&lt;/p&gt;

&lt;p&gt;Vimos que não é necessário &lt;em&gt;frameworks&lt;/em&gt; complexos ou qualquer outro artefato além de Classes e Objetos simples para utilizarmos Injeção de Dependência na sua forma mais pura.&lt;/p&gt;

&lt;p&gt;Infelizmente o espaço de um único artigo não é suficiente para implementarmos uma solução completa.&lt;/p&gt;

&lt;p&gt;Seja simples. Utilize Classes e respeite seus Objetos sem quebrar o encapsulamento.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/injecao-de-dependencia</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/injecao-de-dependencia</guid>
      </item>
    
      <item>
        <title>Nomeando Classes em Libraries</title>
        <description>&lt;p&gt;Veja nesse artigo algumas ideias que você deveria considerar ao nomear suas Classes em projetos do tipo Library.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-marcel-strauss-334864.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Marcel Strauß on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Uma Library ou Lib, para encurtar, é definida na &lt;a href=&quot;https://en.wikipedia.org/wiki/Library_(computing)&quot;&gt;Wikipedia&lt;/a&gt; como “uma coleção de subprogramas utilizados no desenvolvimento de software”.&lt;/p&gt;

&lt;p&gt;Eu gosto mais da próxima definição: “Uma Lib é também uma coleção de implementações de &lt;a href=&quot;/posts/objetos-pensam-e-tomam-decisoes/&quot;&gt;comportamento&lt;/a&gt;”.&lt;/p&gt;

&lt;p&gt;Não pense numa Lib somente em termos de arquivos dll/so. Vamos aumentar esse conceito. Pense em Libs como dll/so, pacotes de software ou até mesmo um programa. Pense em termos de definição de comportamento especializado.&lt;/p&gt;

&lt;p&gt;Uma Lib é — ou deveria ser — um especialista em um assunto, dentro de um contexto bem definido.&lt;/p&gt;

&lt;p&gt;Eu diria que é (quase) a mesma definição do Objeto.&lt;/p&gt;

&lt;p&gt;No entanto, enquanto há Objetos tão simples com apenas um método, uma Lib parece mais como uma composição de muitos Objetos, trabalhando colaborativamente entre si, fazendo emergir um comportamento especializado.&lt;/p&gt;

&lt;p&gt;Os Objetos são como peças intercambiáveis. Podem ser simples ou complexos através do uso da composição.&lt;/p&gt;

&lt;p&gt;Uma Lib, eu acredito, é uma personificação de alguma entidade especializada.&lt;/p&gt;

&lt;p&gt;E toda entidade precisa ter um nome.&lt;/p&gt;

&lt;h2 id=&quot;lib&quot;&gt;Nomeando uma Lib&lt;/h2&gt;

&lt;p&gt;Há muitos anos eu já publicava alguns pequenos projetos no &lt;a href=&quot;https://sourceforge.net/&quot;&gt;SourceForge&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A maioria desses projetos eram pequenos pacotes de componentes para Delphi mas, apesar de ter tido alguns pouquíssimos colaboradores, tais projetos nunca foram relevantes para a comunidade.&lt;/p&gt;

&lt;p&gt;Bem, eu sabia quase nada sobre OpenSource e também não tinha muita experiência em desenvolvimento, então utilizei isso apenas como um aprendizado.&lt;/p&gt;

&lt;p&gt;Na época eu nomeava meus pacotes de componentes com nomes abstratos. Eles não representavam uma entidade especializada. Eram apenas arquivos agrupados num pacote. Um bom nome não era relevante naquela época — eu pensava.&lt;/p&gt;

&lt;p&gt;Anos se passaram.&lt;/p&gt;

&lt;p&gt;Então, eu aprendi mais sobre &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientação a Objetos&lt;/a&gt; e &lt;a href=&quot;https://en.wikipedia.org/wiki/Semantics&quot;&gt;semântica&lt;/a&gt; e como é importante utilizar bons nomes nos identificadores no código.&lt;/p&gt;

&lt;p&gt;Dizem que &lt;em&gt;nomear coisas e invalidar cache&lt;/em&gt; são as duas coisas mais difíceis de fazer na computação. E é verdade.&lt;/p&gt;

&lt;p&gt;Nomear coisas é difícil. Nunca fica perfeito. Escolhemos um nome pensando ser a melhor opção e daqui a duas horas estamos refatorando e renomeando…&lt;/p&gt;

&lt;p&gt;É quase uma &lt;em&gt;arte&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Muitas vezes demora mais tempo para descobrirmos que um nome não foi bem escolhido.&lt;/p&gt;

&lt;p&gt;Há pouco mais de 5 anos atrás eu publiquei um projeto OpenSource chamado &lt;a href=&quot;https://github.com/mdbs99/greyhound&quot;&gt;Greyhound&lt;/a&gt;, mas muitos não sabem qual o motivo da escolha desse nome.&lt;/p&gt;

&lt;p&gt;Aqui está a explicação: Enquanto a &lt;em&gt;Cheetah&lt;/em&gt; (símbolo do Free Pascal) é o animal terrestre mais rápido, &lt;em&gt;Greyhound&lt;/em&gt; é a raça mais rápida entre cães.&lt;/p&gt;

&lt;p&gt;E o que esse nome tem haver com um projeto que abstrai entidades de um Banco de Dados? — você pode estar pensando.&lt;/p&gt;

&lt;p&gt;É, concordo com você que esse nome não foi uma boa escolha.&lt;/p&gt;

&lt;p&gt;Mas ainda acho que é um nome bem interessante. Talvez para uma Lib que trabalhe com &lt;em&gt;stream&lt;/em&gt; de dados ou um novo sistema operacional. Talvez algo relacionado a velocidade? Não sei.&lt;/p&gt;

&lt;p&gt;Pode não ter sido a melhor escolha para o meu projeto, mas por causa dele eu passei a utilizar nomes cada vez mais comuns.&lt;/p&gt;

&lt;p&gt;Hoje em dia todos os meus projetos (privados) ganham nomes próprios comuns. Alguns desses nomes provocam sorrisos em reuniões sempre que são pronunciados. Não devido ao nome em si, mas devido a relação do nome com o sistema que ele representa.&lt;/p&gt;

&lt;p&gt;Eu também levei essa nomenclatura para o mundo OpenSource através das minhas Libs mais recentes: &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;James&lt;/a&gt; e &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;Xavier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Se esses são bons nomes ou não, você decide.&lt;/p&gt;

&lt;p&gt;O aprendizado aqui é que bons nomes podem fazer a diferença pois o nome não será utilizado apenas na URL do seu projeto, mas sim em (quase) todas as Classes.&lt;/p&gt;

&lt;h2 id=&quot;classes&quot;&gt;Nomeando Classes&lt;/h2&gt;

&lt;p&gt;Na época do SourceForge minhas Classes tinham minhas iniciais “MD” como prefixo ou qualquer outras “duas letras” abstratas.&lt;/p&gt;

&lt;p&gt;Prefixos. Vemos essa prática ainda hoje em dia para diminuir a colisão de nomes entre classes similares. Exemplo: &lt;code&gt;TAbStream&lt;/code&gt; vs &lt;code&gt;TCdStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Essa prática é visto até mesmo em grandes &lt;em&gt;frameworks&lt;/em&gt; e outros ecosistemas como Java e C#.&lt;/p&gt;

&lt;p&gt;Por quê?&lt;/p&gt;

&lt;p&gt;Bem, precisamos diferenciar a classe padrão &lt;code&gt;TStream&lt;/code&gt; da sua &lt;code&gt;TMyStream&lt;/code&gt;, por exemplo.&lt;/p&gt;

&lt;p&gt;Poderíamos utilizar a Unidade como prefixo, mas ninguém gosta de escrever o nome totalmente qualificado como &lt;code&gt;acme.streams.TStream&lt;/code&gt; sempre que tiver que usar a Classe &lt;code&gt;TStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Então o prefixo &lt;code&gt;My&lt;/code&gt;, nesse caso, faz diferença.&lt;/p&gt;

&lt;p&gt;No entanto, um grande problema é que não controlamos os prefixos que são utilizados em projetos ao redor do mundo. Eu quero dizer, por exemplo, que se você escolhe &lt;code&gt;Ab&lt;/code&gt; como prefixo de suas Classes, é bem possível que exista alguma outra Lib que já utiliza esse prefixo — e tem, chama-se &lt;a href=&quot;https://github.com/TurboPack/Abbrevia&quot;&gt;Abbrevia&lt;/a&gt; e eu a utilizo.&lt;/p&gt;

&lt;p&gt;O prefixo &lt;code&gt;Ab&lt;/code&gt; deixa os identificadores pequenos — o que é bom — porém a ambiguidade continua existindo, visto que, por serem apenas 2 letras, a probabilidade é que outro desenvolvedor já tenha escolhido esse mesmo prefixo.&lt;/p&gt;

&lt;p&gt;E esse não é o maior problema.&lt;/p&gt;

&lt;p&gt;É comum utilizarmos prefixos em grandes sistemas, compostos de muitos módulos, representando implementações diferentes para um mesmo conceito. Então se um desses prefixos for &lt;code&gt;Ab&lt;/code&gt; e já estiver sendo utilizado dentro de um grande sistema — imagine que esse prefixo faz todo o sentido para o sistema da empresa, podendo representar uma área, setor ou algo bem importante — a ambiguidade é ainda pior, visto que poderia confundir o desenvolvedor: “Essa é uma Classe da empresa ou da Lib?”.&lt;/p&gt;

&lt;p&gt;É claro que basta posicionarmos o mouse em cima do identificador para vermos um &lt;em&gt;hint&lt;/em&gt; com a informação de qual unidade ele pertence. Mas, e se você já utiliza o mesmo nome como &lt;code&gt;TAbStream&lt;/code&gt; (exemplo dado acima) dentro um grande sistema? Você muda o identificador que faz mais sentido para empresa para não conflitar com o identificador da Lib ou &lt;a href=&quot;/redeclarando-classes&quot;&gt;redefine&lt;/a&gt; todas as Classes da Lib?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Nomear coisas e invalidar cache são as duas tarefas mais difíceis na computação.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Acredito que muitos desenvolvedores nem sequer pensam nesses conflitos.&lt;/p&gt;

&lt;p&gt;“Ei! O código está funcionando, é o que importa”, eles dizem.&lt;/p&gt;

&lt;p&gt;Bem, existem bons profissionais, outros nem tanto.&lt;/p&gt;

&lt;p&gt;E como resolver esse impasse?&lt;/p&gt;

&lt;p&gt;Como ter identificadores curtos, porém com uma boa semântica?&lt;/p&gt;

&lt;p&gt;Como diminuir ou (quase) acabar com conflitos de nomenclatura?&lt;/p&gt;

&lt;p&gt;Minha única resposta é: Não use prefixos abstratos em Classes, use um &lt;em&gt;nome&lt;/em&gt; de verdade.&lt;/p&gt;

&lt;p&gt;O primeiro passo é escolher um bom nome: Simples, memorável e que represente um &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contexto&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;contextualizando&quot;&gt;Contextualizando&lt;/h2&gt;

&lt;p&gt;Um contexto encapsula uma possível implementação para um determinado problema.&lt;/p&gt;

&lt;p&gt;Ao invés de utilizar &lt;code&gt;TAbStream&lt;/code&gt;, você utilizaria &lt;code&gt;TAbbreviaStream&lt;/code&gt;, por exemplo — eu não sei se tal Classe realmente existe nessa Lib.&lt;/p&gt;

&lt;p&gt;Não parece muito, mas essa pequena alteração pode fazer uma grande diferença em médios a grandes sistemas.&lt;/p&gt;

&lt;p&gt;Ao invés de termos apenas 2 letras abstratas, temos um nome que identifica um contexto.&lt;/p&gt;

&lt;p&gt;Esse contexto é o mesmo que dizer: “Essa é a implementação de Abbrevia para representar um &lt;em&gt;Stream&lt;/em&gt;” — essa seria a “tradução” ao vermos a Classe &lt;code&gt;TAbbreviaStream&lt;/code&gt; declarada no código.&lt;/p&gt;

&lt;p&gt;É muito menos provável que outra Lib, com a mesma especialidade, utilize o mesmo nome. A probabilidade diminui ao utilizarmos mais letras, concorda?&lt;/p&gt;

&lt;p&gt;Além disso, é muito menos provável que você utilize nomes assim para representar contextos (área, setor ou algo bem importante) dentro de um sistema da empresa.&lt;/p&gt;

&lt;p&gt;Esse foi o tipo de refatoração que fiz a poucos dias no projeto &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;Xavier&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Uma Lib é um especialista em determinado assunto. Dar um nome memorável, apropriado e curto a sua Lib irá facilitar tanto a identificação das Classes quando o uso da mesma.&lt;/p&gt;

&lt;p&gt;Evite o uso de prefixos abstratos. Eles não eliminam a ambiguidade e podem tornar as coisas ainda mais confusas, caso você tenha outros pacotes que, por ventura, utilize o mesmo prefixo.&lt;/p&gt;

&lt;p&gt;Escolha nomes simples, de fácil memorização, curtos o suficiente, que tenham alguma relação ou que personifique a entidade especializada.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Oct 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/nomeando-classes-em-libraries</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/nomeando-classes-em-libraries</guid>
      </item>
    
      <item>
        <title>Versionando e Organizando seus Pacotes</title>
        <description>&lt;p&gt;O desenvolvimento de Pacotes reutilizáveis pode se tornar complicado quando cada projeto está utilizando diferentes versões do mesmo pacote.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-neonbrand-345038.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by NeONBRAND on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A modularização de sistemas é um conceito muito abrangente. Podemos modularizar um projeto desde o nível de arquivos (unidades) até o uso de WebServices e Microservices executando em servidores completamente distintos.&lt;/p&gt;

&lt;p&gt;Nesse meio, temos a modularização por Pacotes.&lt;/p&gt;

&lt;p&gt;Acredito que o uso de Pacotes seja o meio mais eficaz e simples para modularizar sistemas pequenos a médios.&lt;/p&gt;

&lt;p&gt;Até mesmo grandes sistemas podem (e devem) se beneficiar do uso de Pacotes, porém como a interoperabilidade com outras aplicações é quase mandatória em sistemas maiores, outras técnicas de modularização devem ser utilizadas em complemento.&lt;/p&gt;

&lt;p&gt;Mas essa eficácia tem um (baixo) custo que é &lt;del&gt;gastar&lt;/del&gt; investir parte do tempo do desenvolvimento na organização e versionamento desses Pacotes.&lt;/p&gt;

&lt;p&gt;Eu já escrevi sobre esse assunto &lt;a href=&quot;/posts/pacotes-e-versoes-no-lazarus/&quot;&gt;aqui&lt;/a&gt;, porém esse artigo é um aprimoramento sobre como versionar e consequentemente organizar seus Pacotes no &lt;a href=&quot;http://www.lazarus-ide.org/&quot;&gt;Lazarus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Talvez as ideias a seguir possam funcionar também no Delphi, mas eu não sei. Eu não encontrei nenhum artigo sobre como ter mais de uma versão de um mesmo (&lt;em&gt;runtime&lt;/em&gt;) Pacote no Delphi. Na verdade encontrei &lt;em&gt;workarounds&lt;/em&gt; estranhas como &lt;a href=&quot;https://stackoverflow.com/a/998096&quot;&gt;essa resposta&lt;/a&gt; no &lt;em&gt;StackOverflow&lt;/em&gt; sobre como instalar múltiplas versões.&lt;/p&gt;

&lt;h2 id=&quot;pacotes-registrados&quot;&gt;Pacotes Registrados&lt;/h2&gt;

&lt;p&gt;No Lazarus, todo Pacote &lt;em&gt;runtime&lt;/em&gt; é registrado automaticamente na IDE quando você o compila. Simples assim. Abra o Pacote. Compile. Pronto.&lt;/p&gt;

&lt;p&gt;Após o “registro” do Pacote, ele estará disponível para ser adicionado em qualquer projeto através da janela do &lt;em&gt;“Project Inspector -&amp;gt; Required Packages”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Essa funcionalidade é muito, muito útil para a modularização de qualquer projeto.&lt;/p&gt;

&lt;p&gt;Imagine você poder criar um Pacote a qualquer momento, adicionar algumas Unidades e tê-lo disponível para uso sem preocupações com &lt;em&gt;paths&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ao abrirmos a janela &lt;em&gt;Required Packages&lt;/em&gt;, todos os pacotes registrados aparecem numa &lt;em&gt;combo box&lt;/em&gt; com auto-completar ao digitar.&lt;/p&gt;

&lt;p&gt;Quase perfeito.&lt;/p&gt;

&lt;p&gt;No entanto, é comum um Pacote ser utilizado por mais de um projeto. Então, se modificarmos algo nesse Pacote compartilhado, talvez todos os projetos que o utilizam deverão sofrer alterações… o que pode ser um problema caso você tenha dezenas de projetos ou mais.&lt;/p&gt;

&lt;p&gt;Mas, e se tivermos múltiplas versões de um mesmo Pacote, sendo que cada projeto poderá escolher qual versão utilizar?&lt;/p&gt;

&lt;p&gt;Isso resolveria o problema.&lt;/p&gt;

&lt;h2 id=&quot;versionamento&quot;&gt;Versionamento&lt;/h2&gt;

&lt;p&gt;Quando desenvolvemos um Pacote, na maioria das vezes, temos 2 objetivos primários: Modularização e  Compartilhamento.&lt;/p&gt;

&lt;p&gt;Modularizar o sistema em pequenas partes mais gerenciáveis, encapsulando contextos menores e bem definidos, facilita o desenvolvimento e a manutenção de todo o sistema. A modularização por Pacotes já nos dá um grande benefício.&lt;/p&gt;

&lt;p&gt;No entanto, acredito que a principal razão para a maioria dos desenvolvedores criarem pacotes é devido ao compartilhamento de Unidades entre projetos. Esse é um pensamento lógico e razoável. Mas se algo é compartilhado entre mais de um projeto, como ter o controle de qualidade ao fazer uma mudança no código do Pacote que é utilizado em muitos lugares?&lt;/p&gt;

&lt;p&gt;Por exemplo, se você alterar a interface de uma Classe, acrescentar mais um método numa Interface, remover algo que não é mais necessário, etc, como saber quais projetos serão afetados?&lt;/p&gt;

&lt;p&gt;Não há como saber.&lt;/p&gt;

&lt;p&gt;Então você segue em frente e faz as alterações necessárias no seu Pacote e também no seu projeto atual, sem pensar nos projetos mais antigos.&lt;/p&gt;

&lt;p&gt;Poderia haver outros projetos que utilizam o mesmo Pacote e que, ao tentar compilá-los futuramente, eles não irão compilar e você teria que lembrar o que fez anteriormente e ir alterando cada parte do projeto para torná-lo compatível com a nova versão do Pacote, novamente.&lt;/p&gt;

&lt;p&gt;É claro, você terá que fazer isso em algum momento. O problema é que abrimos projetos antigos, na maioria das vezes, apenas para acrescentar ou consertar algo. E o que em teoria seria uma tarefa simples, poderia demorar horas ou dias apenas por que você, primeiro, terá que compatibilizar o código do projeto com o código do seu Pacote recém alterado.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;solução&lt;/em&gt; é o versionamento dos Pacotes.&lt;/p&gt;

&lt;p&gt;Todo Pacote (compartilhado entre projetos) deve ser versionado. Isso quer dizer que você terá que ter N diretórios do mesmo Pacote, ou seja, cada diretório irá tratar de uma específica versão do Pacote. A versão é definida pelos números Mínimo e Máximo para cada versão do Pacote.&lt;/p&gt;

&lt;p&gt;Tendo essas versões definidas, basta &lt;a href=&quot;http://wiki.freepascal.org/Lazarus_Packages#Using_minimum.2C_maximum_version&quot;&gt;escolhermos&lt;/a&gt; uma versão mínima para cada projeto quando o Pacote for incluído como uma dependência.&lt;/p&gt;

&lt;p&gt;As versões de dependência do(s) Pacote(s), que ficam gravadas nos arquivos do projeto, é tudo que o Lazarus precisa saber para carregar a versão correta quando um projeto for aberto na IDE.&lt;/p&gt;

&lt;p&gt;E, &lt;em&gt;voilá&lt;/em&gt;! Você não precisa mas alterar todos os projetos que utilizam determinado Pacote. Você pode evoluir a versão mais atual, mas mantendo as versões antigas totalmente funcionais. Então, ao abrir projetos antigos, você só iria fazer modificações para utilizar a versão do Pacote mais atual se, e somente se, fosse estritamente necessário. Do contrário, continue trabalhando com a versão antiga que o projeto já utilizava anteriormente, pois ela não deixou de funcionar.&lt;/p&gt;

&lt;p&gt;Perfeito agora?&lt;/p&gt;

&lt;h2 id=&quot;solucao&quot;&gt;Fluxo, Organização e Desenvolvimento&lt;/h2&gt;

&lt;p&gt;Se quisermos ter um sistema simples, eficaz e organizado, precisamos dedicar algum tempo à sua manutenção ao invés de somente codificar as &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#regras-de-negocio&quot;&gt;Regras de Negócio&lt;/a&gt; do projeto.&lt;/p&gt;

&lt;p&gt;Ao criamos esses Pacotes, precisamos definir um fluxo de trabalho para que tudo dê certo não só agora, mas principalmente no longo prazo.&lt;/p&gt;

&lt;p&gt;Hoje em dia, com o acesso quase irrestrito a informação, qualquer programador iniciante consegue criar um pequeno ou médio sistema totalmente funcional. Mas o que separa programadores iniciantes dos verdadeiros profissionais, é a arquitetura bem estruturada dos projetos, Pacotes, e todo o resto… no longo prazo.&lt;/p&gt;

&lt;h3 id=&quot;passo-a-passo&quot;&gt;Passo a Passo&lt;/h3&gt;

&lt;p&gt;Essa é a maneira que utilizo para organizar meus Pacotes ou Libs:&lt;/p&gt;

&lt;p&gt;A primeira coisa a fazer, é criar o diretório do Pacote e depois um subdiretório para o primeiro &lt;em&gt;release&lt;/em&gt; — normalmente a versão 1.0.&lt;/p&gt;

&lt;p&gt;Diferentemente do que eu disse &lt;a href=&quot;/posts/pacotes-e-versoes-no-lazarus/#preferencial&quot;&gt;aqui&lt;/a&gt; sobre a nomenclatura, considere nomear os diretórios de Pacotes com o número da versão correspondente — para projetos, no entanto, a nomenclatura sugerida continua válida — mas isso não faz diferença para o compilador, sendo apenas uma questão de organização visual.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yourpack
  |
  1.0
    |
    bin  : todos os arquivos binários e libs
    |
    pkg  : pacotes e configurações
    |
    src  : fontes de produção
    |
    test : fontes de testes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Segundo, você irá trabalhar nos fontes do seu Pacote. Irá criar Unidades, implementar testes, projeto com os testes, etc. Não esqueça de definir a versão atual real, por exemplo, 0.8 (lembre-se que ainda não chegamos na versão 1.0.&lt;/p&gt;

&lt;p&gt;Então, digamos que ele já pode ser utilizado em algum dos seus projetos, mesmo que a versão atual não seja a 1.0.&lt;/p&gt;

&lt;p&gt;Terceiro, você vai adicionar ao seu projeto uma nova dependência para o seu pacote, mas ao adicioná-lo no projeto, irá definir a versão &lt;em&gt;mínima&lt;/em&gt; de uso que, atualmente, é a 0.8.&lt;/p&gt;

&lt;p&gt;A versão &lt;em&gt;máxima&lt;/em&gt; de uso é opcional (nesse caso) pois mesmo que você atualize a versão do Pacote para, digamos 0.9.2, seu projeto continuará funcionando pois apenas a versão mínima foi definida.&lt;/p&gt;

&lt;p&gt;O Lazarus procura os Pacotes pelo seu nome, versão e &lt;em&gt;path&lt;/em&gt;, no arquivo &lt;code&gt;packagesfiles.xml&lt;/code&gt;, que é gerenciado pela IDE.&lt;/p&gt;

&lt;p&gt;Então, ambos os projetos (seu projeto e o Pacote) vão sendo atualizados, até que você resolve publicar a versão 1.0 do Pacote — determinado pelo mesmo nome do diretório.&lt;/p&gt;

&lt;p&gt;Nesse momento, você irá fazer um cópia do diretório &lt;code&gt;/1.0&lt;/code&gt; para gerar um novo diretório, por exemplo o &lt;code&gt;/2.0&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yourpack
  |
  2.0
    |
    bin  : todos os arquivos binários e libs
    |
    doc  : toda a documentação
    |
    pkg  : pacotes e configurações
    |
    src  : fontes de produção
    |
    test : fontes de testes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja que, hipoteticamente, somente na versão 2.0 foi criado um diretório &lt;code&gt;/doc&lt;/code&gt; com a documentação do projeto. Está evoluindo…&lt;/p&gt;

&lt;p&gt;A partir do diretório 2.0 você irá continuar seu trabalho com as próximas versões: 1.1, 1.2… até chegar na 2.0 quando o ciclo recomeça.&lt;/p&gt;

&lt;p&gt;No meio desse ciclo, imagine que seu cliente, dono do primeiro projeto de exemplo, abre um &lt;em&gt;ticket&lt;/em&gt;  relatando um problema. Você então abre o antigo projeto e “magicamente” a IDE faz o &lt;em&gt;load&lt;/em&gt; da versão correta do Pacote, ou seja, a versão 1.0 que esse projeto ainda utiliza. Você não precisa compatibilizar esse projeto com a versão 2.0 do seu Pacote agora. Você pode (deve) fazer isso mais tarde, pois a prioridade agora é resolver o &lt;em&gt;ticket&lt;/em&gt; do seu cliente.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Na conclusão do &lt;a href=&quot;/posts/pacotes-e-versoes-no-lazarus/&quot;&gt;artigo&lt;/a&gt; anterior sobre esse assunto, eu disse que &lt;a href=&quot;http://wiki.freepascal.org/Lazarus_Packages#Different_versions_of_a_package&quot;&gt;marcava&lt;/a&gt; as dependências como &lt;em&gt;preferencial&lt;/em&gt; — opção que utiliza o &lt;em&gt;path&lt;/em&gt; do pacote, não a versão. Porém, percebi que utilizando o fluxo descrito acima eu teria &lt;em&gt;liberdade&lt;/em&gt; na configuração das dependências do meu projeto. O &lt;em&gt;path&lt;/em&gt; seria gerenciado pela IDE e para utilizar novas versões dos Pacotes bastaria mudar os números mínimo e máximo.&lt;/p&gt;

&lt;p&gt;Para a maioria dos desenvolvedores, Pacotes são sinônimos de Componentes instalados na IDE. Mas eles são muito mais que isso.&lt;/p&gt;

&lt;p&gt;A modularização de sistemas utilizando Pacotes sempre foi muito negligenciada e espero que esse artigo tenha aberto seus olhos.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Sep 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/versionando-e-organizando-seus-pacotes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/versionando-e-organizando-seus-pacotes</guid>
      </item>
    
      <item>
        <title>Xavier Package</title>
        <description>&lt;p&gt;Xavier é uma biblioteca leve, Orientada a Objetos, para trabalhar com XML.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-xavier.jpg&quot; alt=&quot;Unsplash image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Hoje em dia, todas as bibliotecas XML são muito complexas. Cada classe pode ter tantos métodos que pode ser muito difícil utilizá-las e compreendê-las. Essas implementações são muito procedurais também.&lt;/p&gt;

&lt;p&gt;Que tal se tivéssemos uma &lt;em&gt;Library&lt;/em&gt; leve, &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientada a Objetos&lt;/a&gt;, que trabalha com XML e que compila em &lt;a href=&quot;https://freepascal.org/&quot;&gt;&lt;em&gt;Free Pascal&lt;/em&gt;&lt;/a&gt; e &lt;a href=&quot;https://www.embarcadero.com/products/delphi&quot;&gt;&lt;em&gt;Delphi&lt;/em&gt;&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Hoje quero apresentar a você o meu mais novo projeto.&lt;/p&gt;

&lt;h2 id=&quot;xavier&quot;&gt;Xavier&lt;/h2&gt;

&lt;p&gt;Eu não trabalhava no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt; já fazia mais ou menos um mês. Além da falta de tempo — os projetos dos clientes são prioridade, certo? — &lt;del&gt;temos&lt;/del&gt; tínhamos uma &lt;a href=&quot;https://github.com/mdbs99/james/issues/65&quot;&gt;&lt;em&gt;issue&lt;/em&gt;&lt;/a&gt; que não nos deixava prosseguir.&lt;/p&gt;

&lt;p&gt;Estávamos tentando compatibilizar o código com o &lt;em&gt;Delphi&lt;/em&gt;, porém a parte que trata de XML é um tanto complicado.&lt;/p&gt;

&lt;p&gt;O maior problema é que o &lt;em&gt;Free Pascal&lt;/em&gt; não tem a mesma implementação do &lt;em&gt;Delphi&lt;/em&gt; para leitura e escrita de &lt;em&gt;streams&lt;/em&gt; e arquivos XML.&lt;/p&gt;

&lt;p&gt;No &lt;em&gt;Free Pascal&lt;/em&gt; a implementação é baseada apenas em Classes, enquanto no &lt;em&gt;Delphi&lt;/em&gt; a implementação é baseada em Interfaces — ponto para o &lt;em&gt;Delphi&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Os desenvolvedores do &lt;em&gt;Free Pascal&lt;/em&gt; sempre tentam compatibilizar suas implementações com o &lt;em&gt;Delphi&lt;/em&gt; porém, ao que parece, a implementação de XML no &lt;em&gt;Free Pascal&lt;/em&gt; foi feita &lt;em&gt;antes&lt;/em&gt; da implementação do &lt;em&gt;Delphi&lt;/em&gt; e eles escolheram fazer tudo apenas com Classes.&lt;/p&gt;

&lt;p&gt;A maioria das &lt;em&gt;libs&lt;/em&gt; que são compativeis entre ambos os compiladores utilizam-se de &lt;a href=&quot;/diretivas-de-compilacao&quot;&gt;diretivas de compilação&lt;/a&gt; para que seus códigos funcionem. Essa técnica, apesar de muito útil, pode transformar seu código em “espaguete” rapidamente.&lt;/p&gt;

&lt;p&gt;Veja esse exemplo de como salvar um &lt;code&gt;TXMLDocument&lt;/code&gt; em &lt;em&gt;stream&lt;/em&gt;, no compilador &lt;em&gt;Free Pascal&lt;/em&gt; e &lt;em&gt;Delphi&lt;/em&gt;, utilizando diretivas:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/c630eb809a9d030917af1efcd7e453d6.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;E que tal isso?&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/mdbs99/96e6f11f9a2184e4e9e932202751b9d0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Meio bizarro, improdutivo e confuso, não?&lt;/p&gt;

&lt;p&gt;Quero escrever código mais elegante, limpo e sustentável usando a Orientação a Objetos e, infelizmente, as opções &lt;em&gt;Open Source&lt;/em&gt; atuais não foram suficientes, considerando meus critérios pessoais.&lt;/p&gt;

&lt;p&gt;Então, criei o &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;Xavier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O principal objetivo do Xavier é substituir o código procedural comum em nossos projetos, que podem ter tantas condicionais e variáveis, num código mais declarativo e Orientado a Objetos, para trabalhar mais facilmente com o XML, sem diretivas de compilação no código final.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A implementação do Xavier ainda está no início mas todo o código disponível hoje está funcionando, com cobertura de testes automatizados.&lt;/p&gt;

&lt;p&gt;Eu escrevi o código em apenas algumas horas. Ainda há muito o que fazer.&lt;/p&gt;

&lt;p&gt;Estou fazendo minha parte…&lt;/p&gt;

&lt;p&gt;E você, que tal fazer um &lt;a href=&quot;https://github.com/mdbs99/xavier#fork-destination-box&quot;&gt;&lt;em&gt;fork&lt;/em&gt;&lt;/a&gt; do projeto e colaborar?&lt;/p&gt;

&lt;p&gt;Link do projeto &lt;a href=&quot;https://github.com/mdbs99/xavier&quot;&gt;https://github.com/mdbs99/xavier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 18 Sep 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/xavier-package</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/xavier-package</guid>
      </item>
    
      <item>
        <title>Inter-process Communication</title>
        <description>&lt;p&gt;Gostaria de modularizar seus sistemas &lt;em&gt;Object Pascal&lt;/em&gt; em pequenos executáveis mas não sabe como?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-climate-kic-350836.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Climate KIC on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Muitos sistemas começam simples. Uma dúzia de tabelas, alguns cadastros, um formulário de &lt;em&gt;login&lt;/em&gt; e poucas &lt;a href=&quot;/posts/codigo-duplicado-talvez-nao/#regras-de-negocio&quot;&gt;Regras de Negócio&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Com o tempo é necessário ter alguns relatórios, mais cadastros, mais tabelas e muito mais Regras de Negócio.&lt;/p&gt;

&lt;p&gt;A complexidade vai aumentando cada vez mais. O que antes era simples, agora é um “monstro” monolítico.&lt;/p&gt;

&lt;p&gt;Essa história parece familiar?&lt;/p&gt;

&lt;p&gt;Isso já aconteceu comigo — mais de uma vez — e talvez esteja acontecendo com você agora mesmo.&lt;/p&gt;

&lt;p&gt;Hoje vou lhe apresentar uma técnica (antiga) para modularizar seus sistemas, facilitando a manutenção e, possivelmente, diminuir a complexidade do código.&lt;/p&gt;

&lt;p&gt;Esse artigo irá focar numa dessas técnicas chamada &lt;a href=&quot;https://en.wikipedia.org/wiki/Inter-process_communication&quot;&gt;Inter-process Communication&lt;/a&gt; ou IPC.&lt;/p&gt;

&lt;h2 id=&quot;ipc&quot;&gt;IPC&lt;/h2&gt;

&lt;p&gt;Um sistema pode ser modularizado de várias maneiras. Podemos utilizar algumas técnicas como DLL’s, &lt;a href=&quot;/posts/pacotes-e-versoes-no-lazarus/&quot;&gt;&lt;em&gt;Packages&lt;/em&gt;&lt;/a&gt;, WebServices, &lt;a href=&quot;/posts/microservices-delphi-parte-1/&quot;&gt;Microservices&lt;/a&gt; e algumas outras.&lt;/p&gt;

&lt;p&gt;O IPC permite que dois processos (executáveis) distintos se comuniquem entre si através de mensagens que são gerenciadas pelo sistema operacional.&lt;/p&gt;

&lt;p&gt;Essa técnica é muito utilizada por sistemas operacionais de microkernel como, por exemplo, o sistema operacional &lt;a href=&quot;http://www.minix3.org/&quot;&gt;MINIX3&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O objetivo principal é diminuir o número de funcionalidades de um executável monolítico, utilizando um &lt;em&gt;design&lt;/em&gt; mas modular, onde haverá uma comunicação entre processos colaborativos ao invés de haver um único processo que faz tudo.&lt;/p&gt;

&lt;p&gt;A comunicação por IPC é do tipo cliente/servidor, sendo que cada processo pode ser tanto um como outro ao mesmo tempo.&lt;/p&gt;

&lt;p&gt;Então, imagine projetar um sistema onde seus módulos seriam divididos em vários executáveis. Um módulo com as Regras de Negócio, outro de Relatórios para disponibilizá-los tanto na Web quanto no Desktop, outro para &lt;em&gt;login&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Alguns destes módulos seriam executados na mesma máquina e, portanto, seria mais vantajoso se esses executáveis se comunicassem através de mensagens gerenciadas pelo Sistema Operacional ao invés de utilizar uma nova camada de protocolos (REST, SOAP, etc). Para esses casos, podemos utilizar o IPC.&lt;/p&gt;

&lt;p&gt;Mas como implementá-lo?&lt;/p&gt;

&lt;h2 id=&quot;simpleipc&quot;&gt;SimpleIPC&lt;/h2&gt;

&lt;p&gt;No compilador &lt;a href=&quot;https://freepascal.org/&quot;&gt;&lt;em&gt;Free Pascal&lt;/em&gt;&lt;/a&gt; existe um &lt;em&gt;package&lt;/em&gt; chamado &lt;a href=&quot;https://svn.freepascal.org/svn/fpc/branches/fixes_3_0/packages/fcl-process/&quot;&gt;fcl-process&lt;/a&gt; que implementa o IPC.&lt;/p&gt;

&lt;p&gt;Essa implementação foi codificada numa única Unidade chamada &lt;code&gt;simpleipc.pp&lt;/code&gt; e é &lt;em&gt;cross-platform&lt;/em&gt;, ou seja, um único código que funciona em sistemas &lt;em&gt;Unix-like&lt;/em&gt; e &lt;em&gt;Windows&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O próprio &lt;a href=&quot;http://www.lazarus-ide.org/&quot;&gt;&lt;em&gt;Lazarus&lt;/em&gt;&lt;/a&gt; utiliza o &lt;em&gt;SimpleIPC&lt;/em&gt; para fazer a &lt;a href=&quot;http://wiki.freepascal.org/Help_protocol&quot;&gt;comunicação&lt;/a&gt; entre a IDE e o &lt;em&gt;Help Viewer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Basicamente são duas classes principais a saber:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A classe &lt;a href=&quot;http://lazarus-ccr.sourceforge.net/docs/fcl/simpleipc/tsimpleipcclient.html&quot;&gt;&lt;code&gt;TSimpleIPCClient&lt;/code&gt;&lt;/a&gt; implementa o envio das mensagens&lt;/li&gt;
  &lt;li&gt;A classe &lt;a href=&quot;http://lazarus-ccr.sourceforge.net/docs/fcl/simpleipc/tsimpleipcserver.html&quot;&gt;&lt;code&gt;TSimpleIPCServer&lt;/code&gt;&lt;/a&gt; implementa o recebimento das mensagens&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Exemplos de uso de ambas as Classes podem ser visto nos &lt;em&gt;demos&lt;/em&gt; disponibilizados no próprio &lt;em&gt;package&lt;/em&gt;, &lt;a href=&quot;https://svn.freepascal.org/svn/fpc/branches/fixes_3_0/packages/fcl-process/examples/&quot;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;alternativas&quot;&gt;Alternativas&lt;/h2&gt;

&lt;p&gt;Para aqueles que não utilizam &lt;em&gt;Free Pascal&lt;/em&gt;, existe a opção de utilizar a implementação do &lt;em&gt;SimpleIPC&lt;/em&gt; no formato de DLL.&lt;/p&gt;

&lt;p&gt;O projeto &lt;a href=&quot;http://wiki.lazarus.freepascal.org/SimpleIPC_Library&quot;&gt;&lt;em&gt;SimpleIPC Library&lt;/em&gt;&lt;/a&gt; encapsula a implementação do &lt;em&gt;Free Pascal&lt;/em&gt; numa DLL que pode ser utilizada por praticamente qualquer linguagem.&lt;/p&gt;

&lt;p&gt;O código é bastante procedural — padrão em DLL’s — porém pode ser uma alternativa rápida para começar a utilizar essa técnica ao invés de implentá-la do zero.&lt;/p&gt;

&lt;p&gt;Considere que mesmo que sua linguagem já implemente tal padrão, talvez ele não seja compatível com outras linguagens. Nesses casos o uso de uma DLL padrão pode fazer sentido.&lt;/p&gt;

&lt;p&gt;No Windows o IPC pode ser “traduzido” como uma &lt;em&gt;Windows Message&lt;/em&gt; do tipo &lt;code&gt;WM_COPYDATA&lt;/code&gt;. Sabemos que é relativamente fácil trabalhar com mensagens do Windows no &lt;em&gt;Object Pascal&lt;/em&gt;  então, se o desenvolvimento for apenas para a plataforma Windows, talvez seja mais simples utilizar mensagens do tipo &lt;code&gt;WM_COPYDATA&lt;/code&gt;. Esses links &lt;a href=&quot;https://www.thoughtco.com/send-information-between-applications-1058476&quot;&gt;aqui&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/7257719/wm-copydata-string-not-appearing-in-target-application&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;https://stackoverflow.com/questions/7540706/wm-copydata-with-and-without-quotes-yields-different-results&quot;&gt;aqui&lt;/a&gt;, podem ajudar.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Nos anos 60 já existiam tais técnicas de modularização. No entanto, ainda hoje, continuamos a desenvolver softwares monolíticos, pesados e de difícil manutenção.&lt;/p&gt;

&lt;p&gt;Como visto nesse artigo, utilizar o IPC pode facilitar a manutenção do código, pois cada subprojeto (executável) iria lidar apenas com poucos &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contextos&lt;/a&gt;, possivelmente diminuindo a complexidade.&lt;/p&gt;

&lt;p&gt;Cada subprojeto poderia evoluir e ser utilizado independentemente.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Sep 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/ipc</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/ipc</guid>
      </item>
    
      <item>
        <title>Porquê eu escolhi Delphi e então, Object Pascal</title>
        <description>&lt;p&gt;Essa é minha contribuição aos artigos na Internet com a &lt;em&gt;hastag&lt;/em&gt; &lt;a href=&quot;https://www.google.com.br/search?q=%23WhyIChooseDelphi&quot;&gt;#WhyIChooseDelphi&lt;/a&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-kace-rodriguez-75513.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Kace Rodriguez on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;inicio&quot;&gt;Quando tudo começou&lt;/h2&gt;

&lt;p&gt;Minha história com &lt;em&gt;Object Pascal&lt;/em&gt; começa em 1999 quando comecei a estudar programação de computadores.&lt;/p&gt;

&lt;p&gt;Havia um curso chamado Programação de Computadores com “Novas” Tecnologias ministrado na PUC-RJ.&lt;/p&gt;

&lt;p&gt;Lá eu aprendi bastante sobre algoritmos, SGBD’s e linguagens de programação como COBOL, C/C++, Pascal, Java, Visual Basic e &lt;a href=&quot;https://www.embarcadero.com/products/delphi&quot;&gt;Delphi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Através dos convênios da PUC com outras empresas, consegui meu primeiro emprego como estagiário numa &lt;em&gt;software house&lt;/em&gt; chamada &lt;em&gt;Fuzion Engenharia de Software&lt;/em&gt; em meados do ano 2000.&lt;/p&gt;

&lt;h2 id=&quot;delphi&quot;&gt;Um caminho diferente&lt;/h2&gt;

&lt;p&gt;Na &lt;em&gt;Fuzion&lt;/em&gt; utilizáva-mos Delphi, Visual Basic e pouca coisa em Java. No entanto, a maioria dos projetos eram desenvolvidos em Delphi.&lt;/p&gt;

&lt;p&gt;Na PUC éramos referência no desenvolvimento &lt;a href=&quot;/posts/o-que-e-orientacao-a-objetos/&quot;&gt;Orientado a Objetos&lt;/a&gt;. Veja, em Delphi, não em Java.&lt;/p&gt;

&lt;p&gt;Quando eu entrei na empresa a versão era Delphi 4. Alguns bugs, alguns problemas… mas então veio a tão aclamada versão 5 e a produtividade era sem igual.&lt;/p&gt;

&lt;p&gt;Tínhamos desenvolvido nossa própria metodologia e ferramentas que geravam código automaticamente e eu já tinha um cargo de Desenvolvedor Pleno.&lt;/p&gt;

&lt;p&gt;Nunca utilizamos &lt;em&gt;DB-aware components&lt;/em&gt;, pois tudo era feito através de camadas e Objetos. Esse era um dos motivos para ser tão difícil contratar mais desenvolvedores, pois aqueles que vinham fazer uma prova depois da entrevista, não sabiam como mostrar informações num &lt;em&gt;Form&lt;/em&gt; com “Mestre/Detalhe” e outros &lt;em&gt;widgets&lt;/em&gt;, sem utizar componentes &lt;em&gt;DB-aware&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Essa sempre foi a beleza do Delphi: Você pode utilizar o paradigma que quiser e conseguir um excelente resultado no final.&lt;/p&gt;

&lt;p&gt;Na Fuzion trilhávamos um caminho diferente. Delphi era um dos nossos segredos de performance e eficácia. E tivemos sucesso… enquanto durou.&lt;/p&gt;

&lt;h2 id=&quot;mudando&quot;&gt;A mudança de ambiente&lt;/h2&gt;

&lt;p&gt;Eu abri minha própria empresa em 2003 para trabalhar como consultor alocado em outras empresas.&lt;/p&gt;

&lt;p&gt;Eu já havia mudado de empresa umas duas vezes até estar na atual, onde já trabalho por quase 13 anos.&lt;/p&gt;

&lt;p&gt;Lá também utilizamos Delphi, a versão 7. Na época que entrei nesta empresa, o Delphi ainda dominava o mercado quando se tratava de aplicações Desktop.&lt;/p&gt;

&lt;p&gt;Por volta de 2006 (se não me engano) a Borland estava vendendo o Delphi. Eu acompanhei, com tristeza, o Delphi ser vendido entre as empresas.&lt;/p&gt;

&lt;p&gt;Eu adorava a Borland, a ponto de querer trabalhar pra ela, e Delphi sempre foi a minha escolha, mas eu achava que tinha que seguir em frente, já que agora o caminho parecia incerto.&lt;/p&gt;

&lt;p&gt;Apesar de na época estar num emprego relativamente estável, eu tinha meus próprios clientes. Eu utilizei Delphi para fazer todos os seus &lt;em&gt;softwares&lt;/em&gt; e, como não tinha certeza se o Delphi iria sobreviver, comecei a pensar em migrar para outra linguagem, outro ambiente.&lt;/p&gt;

&lt;p&gt;Apenas em 2010 eu comecei a pensar em outras possibilidades, quando soube um um projeto que “voltou das cinzas”, hoje conhecido como Lazarus.&lt;/p&gt;

&lt;h2 id=&quot;lazarus&quot;&gt;Migrando para Lazarus&lt;/h2&gt;

&lt;p&gt;Eu comecei a utilizar &lt;a href=&quot;http://www.lazarus-ide.org/&quot;&gt;Lazarus&lt;/a&gt; e quase desisti. Comparado com o Delphi, na época, Lazarus era muito inferior.&lt;/p&gt;

&lt;p&gt;Muitos bugs, pouca produtividade e muita diferença entre ambientes. Apesar de ambos utilizarem a mesma linguagem.&lt;/p&gt;

&lt;p&gt;Felizmente eu consegui superar os problemas. Hoje o ambiente Lazarus é bem estável e completo e me sinto “em casa” como eu me sentia na época do Delphi 5~7.&lt;/p&gt;

&lt;p&gt;Então consegui migrar muitos projetos de Delphi para Lazarus e outros parmaneceram nas versões antigas de Delphi — e vão muito bem, obrigado.&lt;/p&gt;

&lt;p&gt;Apesar de ainda haver problemas, hoje em dia a história parece ser outra. Cada vez mais vejo pessoas reclamando de &lt;em&gt;bugs&lt;/em&gt; no Delphi e, em comparação, vejo cada vez mais elogios ao Lazarus e ao compilador &lt;a href=&quot;https://freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hoje em dia tenho aplicações Desktop e Web, construídas em Free Pascal e Lazarus, rodando em servidores Windows IIS utilizando &lt;a href=&quot;https://www.iis.net/downloads/microsoft/fastcgi-for-iis&quot;&gt;FastCGI&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nada mal, considerando que tais &lt;em&gt;softwares&lt;/em&gt; foram desenvolvidos utilizando ferramentas gratuitas e livres, não é?&lt;/p&gt;

&lt;p&gt;Free Pascal e Lazarus são ferramentas desenvolvidas apenas nas horas vagas por alguns programadores motivados e apaixonados por &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;motivos&quot;&gt;Simplicidade, Performance e Lucro&lt;/h2&gt;

&lt;p&gt;Hoje em dia existem tantas linguagens e ambientes que alguns programadores continuam querendo saber meus motivos em continuar utilizando &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bem, eu publiquei um vídeo que explica meus principais motivos.&lt;/p&gt;

&lt;div style=&quot;position:relative;height:0;padding-bottom:56.25%&quot;&gt;&lt;iframe src=&quot;https://www.youtube.com/embed/iayMGRIRwjY?ecver=2&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; style=&quot;position:absolute;width:100%;height:100%;left:0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;p&gt;E enquanto esses motivos forem válidos, irei continuar utilizando a linguagem &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;hoje&quot;&gt;Object Pascal hoje em dia&lt;/h2&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; é relevante hoje em dia? Bem, depende de como você vê o mundo.&lt;/p&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt;, pra mim, é como um carro esportivo antigo, como essa imagem do &lt;em&gt;Porsche&lt;/em&gt; aí em cima.&lt;/p&gt;

&lt;p&gt;Esse &lt;em&gt;Porsche&lt;/em&gt; — ou quase qualquer outro esportivo antigo —  é simples, manual e puro. Você precisa saber o que está fazendo a todo momento. Não há computadores e sensores para lhe ajudar. Não há muita segurança como &lt;em&gt;airbags&lt;/em&gt;. Você tem que fazer mais força para “domá-lo”. Quase tudo é manual e “barulhento”. Você precisa entender de subesterço e sobre-esterço, se quiser dirigir de forma mais agressiva ao entrar numa curva. Enfim, você precisa saber muita coisa se quiser ter a verdadeira experiência de dirigir.&lt;/p&gt;

&lt;p&gt;Mas no fim do dia, após passar algumas horas atrás do volante, você se sente realizado. Você sabe exatamente o que fez. Você entende como as coisas funcionam nos seus mínimos detalhes. Você estava integrado ao ambiente. Você era apenas um com seu &lt;em&gt;Porsche&lt;/em&gt;. Homem e máquina.&lt;/p&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; é como um clássico esportivo que nunca sai de moda.&lt;/p&gt;

&lt;p&gt;Hoje temos cada vez mais IDE’s e linguagens “inteligentes” que podem mudar a cada nova versão. Esquecem do passado e “inventam” novas maneiras de fazer a mesma coisa que já fazíamos antes. Essas IDE’s nos dão &lt;em&gt;“airbags”&lt;/em&gt;, “segurança” e todo tipo de “artefato” para ajudar no desenvolvimento, mas no fim o desenvolvedor não sabe exatamente o que está fazendo. Ele apenas memorizou quais “botões apertar no painel” e se algo não sai conforme o esperado, sempre haverá a Internet para responder suas dúvidas, certo?&lt;/p&gt;

&lt;p&gt;Vejo desenvolvedores correndo atrás do último lançamento da IDE, &lt;em&gt;Lib&lt;/em&gt; ou compilador, apenas para constatarem que deverão modificar seu código que antes funcionava.&lt;/p&gt;

&lt;p&gt;A última versão do compilador adiciou tais e tais &lt;em&gt;features&lt;/em&gt; e todos querem utilizar, no entanto a maioria não sabe separar um &lt;em&gt;software&lt;/em&gt; em módulos reutilizáveis!&lt;/p&gt;

&lt;p&gt;Então, pra mim, &lt;em&gt;Object Pascal&lt;/em&gt; continua muito relevante. Gosto de “ter trabalho” ao construir meus &lt;em&gt;softwares&lt;/em&gt;, pois gosto do sentimento de ter construído algo por minhas próprias mãos sem ser obrigado a seguir as “regras de desenvolvimento” que algumas empresas consideram ideal.&lt;/p&gt;

&lt;p&gt;Não quero depender de outras empresas e de seus produtos privados, que podem mudar a qualquer momento, para que eu possa entregar valor aos meus clientes. A confiança que eu tinha na antiga Borland se foi… até que me provem o contrário. Hoje eu quero ser livre.&lt;/p&gt;

&lt;p&gt;Liberdade, é disso que se trata.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Eu gosto de imaginar um mundo onde o Delphi fosse disponibilizado de graça, doado ao time do Free Pascal e Lazarus.&lt;/p&gt;

&lt;p&gt;Gosto de pensar numa união de forças entre o &lt;em&gt;Open Source&lt;/em&gt; e a magnífica IDE, Delphi, que sempre ajudou o desenvolvedor (experiente ou não) da melhor forma possível.&lt;/p&gt;

&lt;p&gt;Gosto de pensar num mundo onde iríamos dar um passo pra trás e ver a beleza e a simplicidade da linguagem &lt;em&gt;Object Pascal&lt;/em&gt;, linguagem essa que foi e ainda é inspiração para várias outras.&lt;/p&gt;

&lt;p&gt;Eu &lt;em&gt;escolhi&lt;/em&gt; Delphi no passado e construí minha carreira com a ajuda dele.&lt;/p&gt;

&lt;p&gt;Delphi continua sendo uma ótima escolha para aqueles que sabem aproveitá-lo.&lt;/p&gt;

&lt;p&gt;Eu não o abandonei. Tiraram ele de mim devido a burocracia e altos custos. Mas ele continua no meu coração.&lt;/p&gt;

&lt;p&gt;Minha &lt;em&gt;hastag&lt;/em&gt; hoje — infelizmente ou não — não é mais &lt;strong&gt;#WhyIChooseDelphi&lt;/strong&gt;, mas sim &lt;strong&gt;#WhyIChoseDelphi&lt;/strong&gt; (uma letra faz diferença).&lt;/p&gt;

&lt;p&gt;Felizmente tem algo que nunca mudou: A linguagem &lt;em&gt;Object Pascal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/porque-eu-escolhi-delphi-e-object-pascal</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/porque-eu-escolhi-delphi-e-object-pascal</guid>
      </item>
    
      <item>
        <title>Redefinindo Classes</title>
        <description>&lt;p&gt;A redeclaração de Classes é um método prático para minimizar a colisão de nomes entre Classes, mesmo utilizando identificadores curtos.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-mpumelelo-macu-283883.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Mpumelelo Macu on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;A linguagem &lt;em&gt;Object Pascal&lt;/em&gt; tem uma &lt;em&gt;feature&lt;/em&gt; muito útil que, acredito, não é muito utilizada pelos desenvolvedores.&lt;/p&gt;

&lt;p&gt;Não sei se há um nome específico pra isso, mas eu a chamo de &lt;em&gt;Redefinição de Classes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Na verdade essa &lt;em&gt;feature&lt;/em&gt; pode ser utilizada para redeclarar Classes, Constantes e até mesmo Funções.&lt;/p&gt;

&lt;p&gt;Porém, na Orientação a Objetos, basicamente só utilizamos Classes. Então esqueça o resto e vamos nos concentrar nelas.&lt;/p&gt;

&lt;p&gt;Vamos ver algumas técnicas que podem ser aplicadas utilizando tal conceito.&lt;/p&gt;

&lt;h2 id=&quot;renomeando&quot;&gt;Renomeando&lt;/h2&gt;

&lt;p&gt;Imagine que você quer utilizar uma classe de alguma &lt;em&gt;Lib&lt;/em&gt;, mas essa Classe tem o mesmo nome — exemplo &lt;code&gt;TSmartMemory&lt;/code&gt;— de uma de suas Classes que você já utiliza por todo o seu código. O que fazer?&lt;/p&gt;

&lt;p&gt;A primeira opção é nunca utilizar ambas as Classes numa mesma Unidade. Mas talvez você não tenha essa sorte.&lt;/p&gt;

&lt;p&gt;A segunda opção é prefixar uma das Classes com o nome da Unidade — muito comum ver isso em projetos Java — por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uses
  LibMemory,
  MyMemory;

begin
  M := TSmartMemory.New;  // your class
  L := LibMemory.TSmartMemory.Create;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A terceira opção, que eu utilizo na maioria das vezes, é &lt;em&gt;“renomear”&lt;/em&gt; a Classe da &lt;em&gt;Lib&lt;/em&gt; para uma nomenclatura que não colide com a nomenclatura já utilizada no meu projeto. Vejamos um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyMemory;

uses
  LibMemory;

type
  // TSmartMemory from LibMemory
  TLibStartMemory = TSmartMemory; 

  // my new class
  TSmartMemory = class
    // ...
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse exemplo ambas as Classes estão declaradas na mesma Unidade existente no projeto — a &lt;code&gt;MyMemory&lt;/code&gt; — e o projeto poderá utilizar ambas as Classes sem colisão de nomenclatura.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin
  M := TSmartMemory.New;
  L := TLibSmartMemory.Create;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Utilizando essa técnica evitamos o conflito de nomes, o que é muito útil.&lt;/p&gt;

&lt;p&gt;Ao invés de utilizarmos o nome real da Classe, podemos lhe dar um &lt;em&gt;apelido&lt;/em&gt;. O código fica mais limpo, simples e com identificadores curtos, pois não temos a necessidade de utilizar a Unidade como prefixo.&lt;/p&gt;

&lt;p&gt;A linguagem C# &lt;a href=&quot;https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/using-directive&quot;&gt;tem algo muito parecido&lt;/a&gt; o que me faz pensar de onde será que o principal arquiteto da linguagem C# tirou essa ideia.&lt;/p&gt;

&lt;h2 id=&quot;visibilidade&quot;&gt;Visibilidade&lt;/h2&gt;

&lt;p&gt;Muitas vezes precisamos utilizar uma composição de diferentes Classes para resolver um problema.&lt;/p&gt;

&lt;p&gt;Mas se cada uma dessas Classes tiver sido declarada numa Unidade diferente, precisaremos declarar todas essas Unidades, para ter acesso a cada uma dessas Classes.&lt;/p&gt;

&lt;p&gt;Por exemplo. Precisamos da &lt;code&gt;TClass1&lt;/code&gt;, &lt;code&gt;TClass2&lt;/code&gt; e &lt;code&gt;TClass3&lt;/code&gt;. Cada uma delas em Unidades diferentes, &lt;code&gt;Unit1&lt;/code&gt;, &lt;code&gt;Unit2&lt;/code&gt; e &lt;code&gt;Unit3&lt;/code&gt;, respectivamente.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyUnit;

uses
  Unit1, Unit2, Unit3;  
  
begin
  TClass3.New(
    TClass2.New(
      TClass1.New
    )
  )
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se precisarmos utilizar essa composição em muitos lugares do código, teremos sempre que lembrar em quais Unidades essas Classes estão.&lt;/p&gt;

&lt;p&gt;Outra opção é dar visibilidade às Classes, redeclarando todas elas numa única Unidade, por exemplo &lt;code&gt;Unit123&lt;/code&gt;, para que possamos utilizá-las de forma mais simples, porém ainda mantendo cada implementação em Unidades diferentes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit Unit123;

uses
  Unit1, Unit2, Unit3;

type
  TClass1 = Unit1.TClass1;
  TClass2 = Unit2.TClass2;
  TClass3 = Unit3.TClass3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora, basta utilizarmos a &lt;code&gt;Unit123&lt;/code&gt; no código para ter acesso a todas as 3 Classes que anteriormente só poderiam ser acessadas em Unidades distintas.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit UnitTest;

uses
  Unit123;  
  
begin
  TClass3.New(
    TClass2.New(
      TClass1.New
    )
  )
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta técnica é bastante útil para simplificar uma API, fornecendo aos desenvolvedores somente algumas poucas Classes para uso em contextos bem específicos.&lt;/p&gt;

&lt;h2 id=&quot;heranca&quot;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Há momentos que queremos utilizar &lt;a href=&quot;/posts/como-utilizar-heranca-apropriadamente/&quot;&gt;Herança de Classes&lt;/a&gt; — mesmo sendo a Composição de Objetos a melhor escolha — porém gostaríamos de utilizar o mesmo nome da Classe ancestral.&lt;/p&gt;

&lt;p&gt;Vamos imaginar que estamos desenvolvendo um software e que em uma de suas Unidades tem uma Classe que &lt;a href=&quot;/posts/objetos-representam-entidades/&quot;&gt;representa&lt;/a&gt; um arquivo PDF. Nomeamos essa Classe como &lt;code&gt;TPDFFile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;No entanto sabemos que poderá haver dezenas ou centenas de &lt;em&gt;Libs&lt;/em&gt; que já trabalham com PDF. Então vamos chamar uma dessas &lt;em&gt;Libs&lt;/em&gt; de &lt;em&gt;“PDFLib”&lt;/em&gt;, apenas como exemplo.&lt;/p&gt;

&lt;p&gt;Na &lt;em&gt;PDFLib&lt;/em&gt; temos uma Classe chamada &lt;code&gt;TPDFFile&lt;/code&gt; que é exatamente o mesmo nome que já decidimos que será utilizada no nosso software, mas o arquiteto do projeto diz que nossa Classe deve herdar de &lt;code&gt;PDFLib.TPDFFile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Acho que você já sabe a resposta:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyPDFUnit;

uses
  PDFLib;

type
  TPDFFile = class(PDFLib.TPDFFile)
    // more methods
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prefixando a Classe da &lt;em&gt;Lib&lt;/em&gt; podemos identificá-la de forma diferente da nossa Classe declarada na mesma Unidade.&lt;/p&gt;

&lt;p&gt;A Classe &lt;code&gt;TPDFFile&lt;/code&gt; é agora uma extensão de &lt;code&gt;PDFLib.TPDFFile&lt;/code&gt; que pertence a uma &lt;em&gt;Lib&lt;/em&gt; externa. Mas para todo o restante do código no projeto, só existirá a Classe &lt;code&gt;MyPDFUnit.TPDFFile&lt;/code&gt; que representa um PDF.&lt;/p&gt;

&lt;h2 id=&quot;estendendo&quot;&gt;Estendendo&lt;/h2&gt;

&lt;p&gt;A técnica que vou mostrar agora já era utilizada antes mesmo de haver a sintaxe para &lt;em&gt;Classes Helpers&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por exemplo, imagine que você queira incluir novas propriedades ou métodos na Classe &lt;code&gt;TEdit&lt;/code&gt;. O primeiro pensamento é utilizar herança para criar um novo componente. No entanto você não quer substituir cada &lt;code&gt;TEdit&lt;/code&gt; em todos os &lt;code&gt;TForm&lt;/code&gt; já existentes no projeto. Então, o que fazer?&lt;/p&gt;

&lt;p&gt;A resposta continua sendo utilizar Herança. Mas há um truque ou &lt;em&gt;hack&lt;/em&gt; que irei mostrar na técnica a seguir. Mas gostaria de lembrar que isso deve ser utilizado com muita parcimônia. Eu só utilizei essa técnica pouquíssimas vezes e somente para Classes que representam &lt;em&gt;widgets&lt;/em&gt;, ou seja, Classes de componentes que são utilizadas em Formulários.&lt;/p&gt;

&lt;p&gt;Para extender um &lt;code&gt;TEdit&lt;/code&gt; sem criar uma nova Classe e sem ter que alterar os Formulários, basta utilizar a mesma técnica acima:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyStdCtrls;

type
  TEdit = class(StdCtrls.TEdit) // or Vcl.StdCtrls.TEdit
    // more methods and properties
  end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Você não precisa alterar os &lt;em&gt;widgets&lt;/em&gt; nos Formulários. A renderização do &lt;em&gt;design&lt;/em&gt; do Formulário irá funcionar utilizando os recursos (*.lfm | *.dfm) corretamente.&lt;/p&gt;

&lt;p&gt;Porém há um truque que você não pode esquecer: Em cada um desses Formulários você precisará &lt;a href=&quot;/declarando-unidades&quot;&gt;declarar&lt;/a&gt; sua Unidade &lt;strong&gt;depois&lt;/strong&gt; da Unidade &lt;code&gt;StdCtrls&lt;/code&gt; real.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unit MyForm1;

uses
  StdCtrls, MyStdCtrls;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse &lt;em&gt;hack&lt;/em&gt; é necessário para que o compilador ache a declaração da sua Unidade antes de encontrá-la na &lt;code&gt;StdCtrls&lt;/code&gt; padrão.&lt;/p&gt;

&lt;p&gt;Por isso é tão importante ter uma &lt;a href=&quot;/declarando-unidades&quot;&gt;ordem&lt;/a&gt; na declaração das Unidades.&lt;/p&gt;

&lt;h2 id=&quot;opcional&quot;&gt;Nomenclatura Opcional&lt;/h2&gt;

&lt;p&gt;Essa técnica pode ser considerada o oposto da primeira mostrada nesse artigo, ou seja, ao invés de você “renomear” uma Classe pertencente a outra &lt;em&gt;Lib&lt;/em&gt;, você irá dar ao desenvolvedor opções de nomenclatura para o uso das suas Classes.&lt;/p&gt;

&lt;p&gt;Imagine que você codificou um &lt;em&gt;package&lt;/em&gt; com algumas Classes. Nesse &lt;em&gt;package&lt;/em&gt; você gosta de utilizar nomes simples como &lt;code&gt;TStream&lt;/code&gt;, &lt;code&gt;TMemoryStream&lt;/code&gt;, &lt;code&gt;TString&lt;/code&gt;, &lt;code&gt;TInteger&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;Veja que já temos alguns possíveis “problemas” aqui. Vejamos:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;As Classes &lt;code&gt;TStream&lt;/code&gt; e &lt;code&gt;TMemoryStream&lt;/code&gt; já existem no FPC|Delphi e por isso poderá haver colisão de nomes quando os desenvolvedores forem utilizar seu &lt;em&gt;package&lt;/em&gt;, pois é bem provável que eles já estejam utilizando tais Classes padrão em seus projetos;&lt;/li&gt;
  &lt;li&gt;As Classes &lt;code&gt;TString&lt;/code&gt; e &lt;code&gt;TInteger&lt;/code&gt; são Classes com nomes muito simples ou genéricos e, novamente, é provável que alguma outra &lt;em&gt;Lib&lt;/em&gt; ou mesmo os próprios projetos desses desenvolvedores já utilizem tais nomes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O problema aqui é o nome &lt;em&gt;limpo&lt;/em&gt; e &lt;em&gt;curto&lt;/em&gt;. Ao mesmo tempo que esses nomes são &lt;em&gt;perfeitos&lt;/em&gt;, eles tem o grande potencial de gerar o problema da colisão de nomenclatura.&lt;/p&gt;

&lt;p&gt;Mas quando você está criando seu &lt;em&gt;package&lt;/em&gt;, você tem que abstrair o mundo externo. O &lt;a href=&quot;/posts/delegacao-de-implementacao-de-interfaces/#contextos&quot;&gt;contexto&lt;/a&gt; do &lt;em&gt;package&lt;/em&gt; que deve influenciar a nomenclatura das Classes e não o mundo externo que, talvez, irá utilizá-lo!&lt;/p&gt;

&lt;p&gt;Eu “lutei” contra esse problema por muito anos. Antes de “descobrir” essa técnica, eu prefixava minhas Classes com 1, 2 ou 3 letras — esse parece ser o padrão utilizado por todos os desenvolvedores de componentes do mercado — porém você pode descobrir com o tempo que “seu prefixo” escolhido para suas Classes já foi utilizado em outra &lt;em&gt;Lib&lt;/em&gt; de terceiros.&lt;/p&gt;

&lt;p&gt;Imagine você ter que utilizar nomes verbosos como &lt;code&gt;TXyzMemoryStream&lt;/code&gt; por todo o seu código para, então, descobrir que &lt;code&gt;Xyz&lt;/code&gt; já é o prefixo utilizado por uma grande “fazedora de componentes” do mercado.&lt;/p&gt;

&lt;p&gt;Então eu descobri que a linguagem &lt;em&gt;Object Pascal&lt;/em&gt; já tinha uma resposta e eu poderia ter o melhor dos dois mundos. Eu poderia utilizar nomes simples, compactos e limpos dentro do meu contexto (&lt;em&gt;package&lt;/em&gt;, projeto, &lt;em&gt;lib&lt;/em&gt;) mas dar aos potenciais usuários|desenvolvedores um nome mais verboso, porém com menor possibilidade de haver colisão de nomes, se assim eu desejasse.&lt;/p&gt;

&lt;p&gt;Vejamos um exemplo. Uma das Classes do &lt;a href=&quot;https://github.com/mdbs99/james/blob/master/src/james.data.clss.pas&quot;&gt;James&lt;/a&gt; tem o nome &lt;code&gt;TDataStream&lt;/code&gt;. Esse nome já evita a colisão com &lt;code&gt;TStream&lt;/code&gt; que é basicamente o que essa Classe representa, porém o “prefixo” &lt;code&gt;Data&lt;/code&gt; não foi utilizado para minimizar a colisão de nomenclatura, mas sim devido a sua semântica.&lt;/p&gt;

&lt;p&gt;Mas digamos que agora o Lazarus e/ou Delphi implementaram uma Classe de uso geral chamada… &lt;code&gt;TDataStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Eu deveria mudar o nome dessa Classe no &lt;a href=&quot;https://github.com/mdbs99/james&quot;&gt;Projeto James&lt;/a&gt; e em todos os meus projetos que já utilizam essa nomenclatura? É claro que não!&lt;/p&gt;

&lt;p&gt;Eu só iria dar a opção para os (novos) desenvolvedores utizarem outra nomenclatura para a mesma Classe, desse jeito:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type
  TDataStream = class sealed(TInterfacedObject, IDataStream)
  // some methods
  end;
  
  TJamesDataStream = TDataStream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O código agora tem 2 possibilidades de uso de nomenclatura para a mesma Classe!&lt;/p&gt;

&lt;p&gt;Você pode continuar utilizando &lt;code&gt;TDataStream&lt;/code&gt; por todo o seu código, desde que mantenha a &lt;a href=&quot;/declarando-unidades&quot;&gt;ordem de declaração&lt;/a&gt; das Unidades, ou pode utilizar a nova opção &lt;code&gt;TJamesDataStream&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;E se mesmo assim ainda houver colisão de nomenclatura, aí caberá ao desenvolvedor utilizar a primeira técnica desse artigo.&lt;/p&gt;

&lt;p&gt;Dessa forma ambos os lados (desenvolvedores de &lt;em&gt;packages&lt;/em&gt; e usuários de &lt;em&gt;packages&lt;/em&gt;) estão &lt;em&gt;livres&lt;/em&gt; para utilizarem os nomes que quiserem em suas Classes.&lt;/p&gt;

&lt;p&gt;A única exceção, até onde eu sei, são os componentes que são instalados na IDE. Ambas as IDE’s (Lazarus e Delphi) não deixam instalar componentes com o mesmo nome, mesmo estando em &lt;em&gt;packages&lt;/em&gt; distintos. No entanto, na minha opinião, isso é um erro de &lt;em&gt;design&lt;/em&gt; das IDE’s. Ambas deveriam permitir a instalação e, ao utilizarmos tais componentes, bastaria a IDE declarar os &lt;em&gt;fields&lt;/em&gt; no Formulário utilizando a nomenclatura totalmente qualificada, como &lt;code&gt;Edit1: StdCtrls.TEdit;&lt;/code&gt; e tudo iria funcionar.&lt;/p&gt;

&lt;p&gt;Eu fiz essa &lt;a href=&quot;http://lists.lazarus-ide.org/pipermail/lazarus/2011-January/123929.html&quot;&gt;proposta&lt;/a&gt; na lista oficial do Lazarus em Janeiro/2011, porém ainda sem previsão, prioridade ou interesse.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A redeclaração ou renomeação de Classes (e constantes, funções, etc) é uma técnica que existe quase desde os primórdios da linguagem, mas que a grande maioria dos desenvolvedores não utiliza, seja por desconhecimento, inabilidade ou mesmo falta de interesse.&lt;/p&gt;

&lt;p&gt;É um conceito &lt;em&gt;antigo&lt;/em&gt;, mas que nos proporciona várias técnicas e possibilidades para codificar melhor &lt;em&gt;hoje&lt;/em&gt;, conforme demonstrado nesse artigo.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/redeclarando-classes</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/redeclarando-classes</guid>
      </item>
    
      <item>
        <title>Git-work Project</title>
        <description>&lt;p&gt;Git-work são extensões minimalistas para Git, fornecendo operações de repositório de alto nível.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/photo-zachary-nelson-192289.jpg&quot; alt=&quot;Unsplash image&quot; /&gt; 
&lt;span style=&quot;font-family: &#39;Bebas Neue&#39;; font-size: 0.7em;&quot;&gt;Photo by Zachary Nelson on Unsplash&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducao&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Git&lt;/em&gt;&lt;/strong&gt;, segundo a &lt;a href=&quot;https://pt.wikipedia.org/wiki/Git&quot;&gt;Wikipedia&lt;/a&gt;,
é um sistema de controle de versão distribuído e um sistema de gerenciamento de código fonte, com ênfase em velocidade. O Git foi inicialmente projetado e desenvolvido por Linus Torvalds para o desenvolvimento do kernel Linux, mas foi adotado por muitos outros projetos.&lt;/p&gt;

&lt;p&gt;Ele é o padrão atual para o controle de versão de softwares. Não há nenhum outro concorrente que seja tão simples e eficaz.&lt;/p&gt;

&lt;p&gt;Apesar de ser um magnífico sistema, por muito tempo não havia um padrão definido em como trabalhar em equipe ou mesmo sozinho, ou seja, como enviar de forma eficiente uma alteração feita por você; como ser eficaz ao trabalhar com &lt;em&gt;branches&lt;/em&gt;; se devemos trabalhar diretamente no &lt;code&gt;master&lt;/code&gt; ou em &lt;em&gt;branches&lt;/em&gt; secundários; como iniciar uma alteração quando o projeto recebe uma &lt;em&gt;issue&lt;/em&gt;, etc.&lt;/p&gt;

&lt;p&gt;Hoje em dia temos um padrão chamado &lt;code&gt;git flow&lt;/code&gt;. Ele vem instalado nas últimas versões do Git e você pode configurá-lo digitando &lt;code&gt;git flow&lt;/code&gt; na linha-de-comando.&lt;/p&gt;

&lt;p&gt;No entanto, ainda que o &lt;code&gt;git flow&lt;/code&gt; não seja um padrão complicado de se utilizar, ele não nos deixa customizá-lo de forma simples num único lugar (são alguns arquivos &lt;em&gt;bash&lt;/em&gt; que devem ser editados), é verboso e não define um padrão para as mensagens dos &lt;em&gt;commits&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nesse artigo eu irei lhe apresentar o meu mais novo “&lt;em&gt;pet project&lt;/em&gt;” chamado &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt;, que é uma alternativa minimalista ao &lt;code&gt;git flow&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;git-work&quot;&gt;O que é Git-work&lt;/h2&gt;

&lt;p&gt;Assim como o &lt;code&gt;git flow&lt;/code&gt;, o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; é uma coleção de extensões para a linha-de-comando do Git.&lt;/p&gt;

&lt;p&gt;O nome escolhido é devido a semântica ao digitar os comandos como, por exemplo, &lt;code&gt;git work done&lt;/code&gt; para concluir uma &lt;code&gt;issue&lt;/code&gt;. Legal, não?&lt;/p&gt;

&lt;p&gt;É um projeto extremamente novo (apenas alguns dias) porém com um grande potencial, na minha humilde opinião.&lt;/p&gt;

&lt;p&gt;São extensões minimalistas para Git, fornecendo operações de repositório de alto nível além de padronizar, um &lt;em&gt;fluxo de trabalho&lt;/em&gt; com os &lt;em&gt;branches&lt;/em&gt;, que poderá ser totalmente customizável.&lt;/p&gt;

&lt;h2 id=&quot;motivacao&quot;&gt;Motivação&lt;/h2&gt;

&lt;p&gt;Eu tentei (tento) utilizar alguns &lt;em&gt;clients&lt;/em&gt; para Git como &lt;a href=&quot;https://desktop.github.com/&quot;&gt;Github Desktop&lt;/a&gt;, &lt;a href=&quot;http://www.syntevo.com/smartgit/&quot;&gt;SmartGit&lt;/a&gt; ou &lt;a href=&quot;https://www.gitkraken.com/&quot;&gt;GitKraken&lt;/a&gt;. Apesar desses e dezenas de outras IDE’s serem ótimos produtos, podem ter restrições de uso, além da curva de aprendizado para utilizá-los.&lt;/p&gt;

&lt;p&gt;Além disso, no meu caso, eu utilizo Git em alguns computadores e não posso me dar ao luxo de ter que ficar atualizando e reconfigurando IDE’s em todos esses computadores caso eu queria mudar meu modo de trabalho.&lt;/p&gt;

&lt;p&gt;Eu sou um cara &lt;em&gt;“old-school”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Gosto das coisas mais &lt;a href=&quot;/posts/simplicidade/&quot;&gt;simples&lt;/a&gt; e manuais. Gosto de saber o que está acontecendo nos “bastidores” quando clico num botão. Gosto de aprender a utilizar algo reduzindo-o à sua interface mais básica.&lt;/p&gt;

&lt;p&gt;Então voltei para a linha-de-commando, onde posso fazer literalmente tudo com o Git. &lt;a href=&quot;/posts/menos-e-mais/&quot;&gt;Menos é mais&lt;/a&gt;, certo?&lt;/p&gt;

&lt;p&gt;Mas a linha-de-comando pode ser assutadora quando você não conhece os comandos. E, mesmo depois de aprendê-los, pode ser ineficaz se você tiver que fazer &lt;em&gt;tudo&lt;/em&gt; de forma manual.&lt;/p&gt;

&lt;p&gt;Então como eu poderia utilizar a linha-de-comando, mas automatizar os comandos mais utilizados e, ao mesmo tempo, definir um fluxo de trabalho padronizado?&lt;/p&gt;

&lt;p&gt;A ideia de construir o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; me ocorreu após uma tarde de intenso trabalho e uso do Git em um projeto particular.&lt;/p&gt;

&lt;p&gt;Trabalhei em algumas &lt;em&gt;issues&lt;/em&gt; e foi bastante ineficaz ter que ficar indo e vindo entre os &lt;em&gt;branches&lt;/em&gt; para fazer a mesclagem além de ter que ficar digitando comandos que poderiam ser automatizados.&lt;/p&gt;

&lt;p&gt;Além disso, não ter um fluxo de trabalho pré-determinado me fazia perder tempo para identificar o próximo passo.&lt;/p&gt;

&lt;p&gt;Então nasceu o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;features&quot;&gt;Características&lt;/h2&gt;

&lt;p&gt;Inicialmente eu pensei em codificar o &lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;&lt;strong&gt;git-work&lt;/strong&gt;&lt;/a&gt; em &lt;em&gt;Object Pascal&lt;/em&gt;. Sério. Porém vi que o mais simples a fazer seria utilizar &lt;em&gt;Bash scripts&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O Git é bem integrado com &lt;em&gt;Bash&lt;/em&gt; então… Por quê não?&lt;/p&gt;

&lt;p&gt;Criei o projeto no Github, codifiquei as primeiras características e subi os fontes.&lt;/p&gt;

&lt;p&gt;Então meu amigo &lt;a href=&quot;https://github.com/fabriciofx/&quot;&gt;Fabrício Cabral&lt;/a&gt; se interessou pelo projeto e começou a trabalhar e melhorar o código.&lt;/p&gt;

&lt;p&gt;No momento da escrita desse artigo já temos algumas funcionalidades.&lt;/p&gt;

&lt;p&gt;Após “instalar”, digite &lt;code&gt;git work&lt;/code&gt; para ver os comandos:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/git-work-1.jpg&quot; alt=&quot;git-work&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Esses comandos ainda serão aperfeiçoados, pois estão em constante desenvolvimento.&lt;/p&gt;

&lt;h3 id=&quot;flow&quot;&gt;Fluxo de Trabalho&lt;/h3&gt;

&lt;p&gt;Após um usuário registrar a &lt;em&gt;issue&lt;/em&gt; #41 no seu sistema de &lt;em&gt;tickets&lt;/em&gt;, você inicia um fluxo:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Digite &lt;code&gt;git work issue 41&lt;/code&gt; para criar uma nova &lt;em&gt;branch&lt;/em&gt; com o nome &lt;code&gt;41&lt;/code&gt; a partir da &lt;code&gt;master&lt;/code&gt;, já com &lt;em&gt;checkout&lt;/em&gt; automático para o &lt;code&gt;41&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Enquanto você vai alterando os fontes, poderá digitar &lt;code&gt;git work commit &quot;mensagem&quot;&lt;/code&gt; para ir comitando seu trabalho;&lt;/li&gt;
  &lt;li&gt;Quando você tiver terminado o trabalho, digite &lt;code&gt;git work done&lt;/code&gt; para ir para o &lt;code&gt;master&lt;/code&gt; enquanto o sistema faz o &lt;em&gt;merge&lt;/em&gt; com a atual &lt;em&gt;branch&lt;/em&gt; &lt;code&gt;41&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Então você pode enviar suas alterações para o servidor digitando &lt;code&gt;git work push&lt;/code&gt; para enviar a &lt;em&gt;branch&lt;/em&gt; atual, que é a &lt;code&gt;master&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Quando tiver uma versão de &lt;em&gt;release&lt;/em&gt;, o comando &lt;code&gt;git work release 1.0&lt;/code&gt; poderá ser utilizado. O git-work irá criar uma nova &lt;em&gt;tag&lt;/em&gt; a partir da &lt;code&gt;master&lt;/code&gt; e enviar ao servidor.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pode não parecer muito agora. Os comandos são muito similares aos comandos do próprio Git, porém tudo ainda está em desenvolvimento.&lt;/p&gt;

&lt;p&gt;Os scripts irão verificar, na medida do possível, se você está utilizando os comandos certos, nos &lt;em&gt;branches&lt;/em&gt; corretos.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;branch&lt;/em&gt; padrão poderá ser &lt;a href=&quot;https://github.com/mdbs99/git-work/issues/9&quot;&gt;configurado&lt;/a&gt; (padrão &lt;code&gt;master&lt;/code&gt;) para que os comandos &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt; e &lt;code&gt;release&lt;/code&gt; saibam onde pegar os fontes atuais.&lt;/p&gt;

&lt;p&gt;As mensagens do &lt;code&gt;commit&lt;/code&gt; poderão ser &lt;a href=&quot;https://github.com/mdbs99/git-work/issues/8&quot;&gt;padronizadas&lt;/a&gt; com o número da &lt;em&gt;issue&lt;/em&gt; no início. Exemplo: &lt;em&gt;“#41 this fix…”.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;E se todos os (futuros) parâmetros customizáveis ainda não sejam suficientes para suas customizações, bastará você alterar apenas o &lt;a href=&quot;https://github.com/mdbs99/git-work/blob/master/git-work.sh&quot;&gt;único arquivo&lt;/a&gt; nesse projeto.&lt;/p&gt;

&lt;p&gt;Ainda há um grande caminho a percorrer.&lt;/p&gt;

&lt;h2 id=&quot;conclusao&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Essa é apenas a versão &lt;code&gt;0.1&lt;/code&gt; desse projeto que só tem poucos dias de vida.&lt;/p&gt;

&lt;p&gt;Padronização, eficiência e simplicidade. Essa é a proposta desse projeto.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mdbs99/git-work&quot;&gt;https://github.com/mdbs99/git-work&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Até logo.&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Aug 2017 00:00:00 +0100</pubDate>
        <link>http://objectpascalprogramming.com/git-work-project</link>
        <guid isPermaLink="true">http://objectpascalprogramming.com/git-work-project</guid>
      </item>
    
  </channel>
</rss>
